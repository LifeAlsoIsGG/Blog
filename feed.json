{
  "version": "https://jsonfeed.org/version/1.1",
  "title": "Draco's Blog",
  "home_page_url": "https://vuepress-theme-hope-demo.mrhope.site/",
  "feed_url": "https://vuepress-theme-hope-demo.mrhope.site/feed.json",
  "description": "美丽新世界",
  "author": {
    "name": "Draco"
  },
  "items": [
    {
      "title": "About",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/about/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/about/",
      "content_html": "<h2 id=\"about\"> About</h2>\n<p>这里是我的博客和笔记Wiki，通过<code>Vuepress</code>搭建在<code>Github Pages</code>上</p>\n<p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/about/about.jpg\" alt=\"about\" /></p>\n",
      "image": "https://blog-1300186248.cos.ap-shanghai.myqcloud.com/about/about.jpg",
      "date_published": "2022-03-06T10:17:18.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": []
    },
    {
      "title": "算法",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/dataStructure&algorithm/Algorithm/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/dataStructure&algorithm/Algorithm/",
      "content_html": "<h2 id=\"动态规划和贪心算法的区别\"> 动态规划和贪心算法的区别</h2>\n<p>相同点</p>\n<ul>\n<li>动态规划和贪心算法都是一种递推算法</li>\n<li>均有局部最优解来推导全局最优解</li>\n</ul>\n<p>不同点</p>\n<ul>\n<li>贪心算法中，作出的每步贪心决策都无法改变，因为贪心策略是由上一步的最优解推导下一步的最优解，而上一部之前的最优解则不作保留。</li>\n<li>可以知道贪心法正确的条件是：每一步的最优解一定包含上一步的最优解。</li>\n<li>全局最优解中一定包含某个局部最优解，但不一定包含前一个局部最优解，因此需要记录之前的所有最优解</li>\n<li>动态规划的关键是状态转移方程，即如何由以求出的局部最优解来推导全局最优解</li>\n<li>边界条件：即最简单的，可以直接得出的局部最优解</li>\n</ul>\n",
      "date_published": "2020-08-30T18:04:39.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": []
    },
    {
      "title": "数据结构&算法题目合集",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/dataStructure&algorithm/DataStructure&algorithm_question/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/dataStructure&algorithm/DataStructure&algorithm_question/",
      "content_html": "<h1 id=\"_1-通用操作\"> 1. 通用操作</h1>\n<h2 id=\"_1-1-输入类\"> 1.1 输入类</h2>\n<h3 id=\"_1-1-1-利用字符串输入不定长int数组-逗号隔开\"> 1.1.1 利用字符串输入不定长int数组，逗号隔开</h3>\n<p>输入时用<code>','</code>隔开</p>\n<div><pre><code>        <span>Scanner</span> input <span>=</span> <span>new</span> <span>Scanner</span><span>(</span><span>System</span><span>.</span>in<span>)</span><span>;</span>\n        <span>String</span> str <span>=</span> input<span>.</span><span>nextLine</span><span>(</span><span>)</span><span>.</span><span>toString</span><span>(</span><span>)</span><span>;</span>\n        <span>String</span><span>[</span><span>]</span> arr  <span>=</span> str<span>.</span><span>split</span><span>(</span><span>\",\"</span><span>)</span><span>;</span>\n        <span>int</span><span>[</span><span>]</span> nums <span>=</span> <span>new</span> <span>int</span><span>[</span>arr<span>.</span>length<span>]</span><span>;</span>\n        <span>for</span><span>(</span><span>int</span> j <span>=</span> <span>0</span><span>;</span> j<span>&lt;</span>nums<span>.</span>length<span>;</span>j<span>++</span><span>)</span> <span>{</span>\n            nums<span>[</span>j<span>]</span> <span>=</span> <span>Integer</span><span>.</span><span>parseInt</span><span>(</span>arr<span>[</span>j<span>]</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>int</span> repeat <span>=</span> <span>0</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Arrays</span><span>.</span><span>toString</span><span>(</span>nums<span>)</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id=\"_1-1-2-输入定长二维数组字符\"> 1.1.2 输入定长二维数组字符</h3>\n<div><pre><code><span>Scanner</span> in<span>=</span><span>new</span> <span>Scanner</span><span>(</span><span>System</span><span>.</span>in<span>)</span><span>;</span>\n        <span>int</span> m<span>=</span>in<span>.</span><span>nextInt</span><span>(</span><span>)</span><span>;</span>\n        <span>int</span> n<span>=</span>in<span>.</span><span>nextInt</span><span>(</span><span>)</span><span>;</span>\n        in<span>.</span><span>nextLine</span><span>(</span><span>)</span><span>;</span>\n        <span>char</span><span>[</span><span>]</span><span>[</span><span>]</span> arr <span>=</span> <span>new</span> <span>char</span><span>[</span>m<span>]</span><span>[</span>n<span>]</span><span>;</span>\n\n        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span>m <span>;</span> i<span>++</span><span>)</span> <span>{</span>\n            <span>String</span> s <span>=</span> in<span>.</span><span>nextLine</span><span>(</span><span>)</span><span>.</span><span>toString</span><span>(</span><span>)</span><span>;</span>\n            <span>for</span> <span>(</span><span>int</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span>n <span>;</span> j<span>++</span><span>)</span> <span>{</span>\n                arr<span>[</span>i<span>]</span><span>[</span>j<span>]</span><span>=</span>s<span>.</span><span>charAt</span><span>(</span>j<span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n\n        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> m<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n            <span>for</span> <span>(</span><span>int</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> n<span>;</span> j<span>++</span><span>)</span> <span>{</span>\n                <span>System</span><span>.</span>out<span>.</span><span>print</span><span>(</span>arr<span>[</span>i<span>]</span><span>[</span>j<span>]</span><span>)</span><span>;</span>\n            <span>}</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><h3 id=\"_1-1-3-输入定长二维字符串\"> 1.1.3 输入定长二维字符串</h3>\n<div><pre><code>        <span>Scanner</span> in<span>=</span><span>new</span> <span>Scanner</span><span>(</span><span>System</span><span>.</span>in<span>)</span><span>;</span>\n        <span>int</span> m<span>=</span>in<span>.</span><span>nextInt</span><span>(</span><span>)</span><span>;</span>\n        <span>int</span> n<span>=</span>in<span>.</span><span>nextInt</span><span>(</span><span>)</span><span>;</span>\n        in<span>.</span><span>nextLine</span><span>(</span><span>)</span><span>;</span><span>//此行用来做缓冲ENTER按键</span>\n        <span>String</span><span>[</span><span>]</span><span>[</span><span>]</span> arr <span>=</span> <span>new</span> <span>String</span><span>[</span>m<span>]</span><span>[</span>n<span>]</span><span>;</span>\n\n        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span>m <span>;</span> i<span>++</span><span>)</span> <span>{</span>\n            <span>for</span> <span>(</span><span>int</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span>n <span>;</span> j<span>++</span><span>)</span> <span>{</span>\n\n                arr<span>[</span>i<span>]</span><span>[</span>j<span>]</span><span>=</span>in<span>.</span><span>nextLine</span><span>(</span><span>)</span><span>;</span>\n                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"arr[i][j] : \"</span> <span>+</span> arr<span>[</span>i<span>]</span><span>[</span>j<span>]</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n\n        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> m<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n            <span>for</span> <span>(</span><span>int</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> n<span>;</span> j<span>++</span><span>)</span> <span>{</span>\n                <span>System</span><span>.</span>out<span>.</span><span>print</span><span>(</span>arr<span>[</span>i<span>]</span><span>[</span>j<span>]</span><span>)</span><span>;</span>\n            <span>}</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><h2 id=\"_1-2-将两个整数数组合并之后按照升序排序-并打印输出到控制台-注意不要去重\"> 1.2 将两个整数数组合并之后按照升序排序,并打印输出到控制台,注意不要去重</h2>\n<div><pre><code><span>public</span> <span>class</span> 合并数组按照升序排序 <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>int</span> a<span>[</span><span>]</span> <span>=</span> <span>{</span><span>1</span><span>,</span><span>3</span><span>,</span><span>5</span><span>,</span><span>7</span><span>}</span><span>;</span>\n        <span>int</span> b<span>[</span><span>]</span> <span>=</span> <span>{</span><span>2</span><span>,</span><span>4</span><span>,</span><span>5</span><span>,</span><span>8</span><span>}</span><span>;</span>\n        <span>int</span> c<span>[</span><span>]</span> <span>=</span> <span>new</span> <span>int</span><span>[</span>a<span>.</span>length <span>+</span> b<span>.</span>length<span>]</span><span>;</span>\n        <span>int</span> i <span>=</span><span>0</span><span>,</span> j <span>=</span> <span>0</span> <span>,</span> k <span>=</span> <span>0</span><span>;</span>\n        <span>while</span><span>(</span>i <span>&lt;</span> a<span>.</span>length <span>&amp;&amp;</span> j <span>&lt;</span> b<span>.</span>length<span>)</span><span>{</span>\n            <span>if</span><span>(</span>a<span>[</span>i<span>]</span> <span>&lt;</span> b<span>[</span>j<span>]</span><span>)</span> <span>{</span>\n                c<span>[</span>k<span>++</span><span>]</span> <span>=</span> a<span>[</span>i<span>++</span><span>]</span><span>;</span>\n            <span>}</span><span>else</span><span>{</span>\n                c<span>[</span>k<span>++</span><span>]</span> <span>=</span> b<span>[</span>j<span>++</span><span>]</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n        <span>while</span> <span>(</span>i <span>&lt;</span> a<span>.</span>length<span>)</span> <span>{</span>\n            c<span>[</span>k<span>++</span><span>]</span> <span>=</span> a<span>[</span>i<span>++</span><span>]</span><span>;</span>\n        <span>}</span>\n        <span>while</span> <span>(</span>j <span>&lt;</span> b<span>.</span>length<span>)</span> <span>{</span>\n            c<span>[</span>k<span>++</span><span>]</span> <span>=</span> b<span>[</span>j<span>++</span><span>]</span><span>;</span>\n        <span>}</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Arrays</span><span>.</span><span>toString</span><span>(</span>c<span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><h2 id=\"_1-3-给定一个数组-设计一个既高效又公平的方法随机打乱这个数组。\"> 1.3 给定一个数组，设计一个既高效又公平的方法随机打乱这个数组。</h2>\n<h2 id=\"_1-4-如何判断素数\"> 1.4 如何判断素数</h2>\n<div><pre><code>    <span>public</span> <span>static</span> <span>boolean</span> <span>primeNumber</span><span>(</span><span>int</span> i<span>)</span><span>{</span>\n        <span>int</span> s <span>=</span> <span>(</span><span>int</span><span>)</span> <span>Math</span><span>.</span><span>sqrt</span><span>(</span>i<span>)</span><span>;</span>\n        <span>int</span> j <span>=</span> <span>0</span><span>;</span>\n        <span>for</span> <span>(</span>j <span>=</span> <span>2</span><span>;</span> j <span>&lt;=</span> s<span>;</span> j<span>++</span><span>)</span> <span>{</span>\n            <span>if</span><span>(</span>i <span>%</span> j <span>==</span> <span>0</span><span>)</span><span>{</span>\n                <span>break</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n        <span>if</span><span>(</span>j <span>></span> s<span>)</span><span>{</span>\n            <span>return</span> <span>true</span><span>;</span>\n        <span>}</span>\n        <span>return</span> <span>false</span><span>;</span>\n    <span>}</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>primeNumber</span><span>(</span><span>19</span><span>)</span><span>)</span><span>;</span>\n\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h2 id=\"_1-5-数位和计算\"> 1.5 数位和计算</h2>\n<p>通过转换为String再一一相加</p>\n<div><pre><code><span>long</span> i <span>=</span> <span>1111111111111111L</span><span>;</span>\n<span>String</span> s <span>=</span> <span>String</span><span>.</span><span>valueOf</span><span>(</span>i<span>)</span><span>;</span>\n<span>int</span> sum <span>=</span> <span>0</span><span>;</span>\n<span>for</span> <span>(</span><span>int</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> s<span>.</span><span>length</span><span>(</span><span>)</span><span>;</span> j<span>++</span><span>)</span> <span>{</span>\n sum <span>+=</span> s<span>.</span><span>charAt</span><span>(</span>j<span>)</span> <span>-</span> <span>'0'</span><span>;</span>\n<span>}</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>sum<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>循环求余</p>\n<div><pre><code><span>int</span> j <span>=</span> <span>11111</span><span>;</span>\n<span>int</span> sum2 <span>=</span> <span>0</span><span>;</span>\n<span>while</span> <span>(</span>j <span>!=</span> <span>0</span><span>)</span><span>{</span>\n sum2 <span>+=</span> j <span>%</span> <span>10</span><span>;</span>\n j <span>=</span> j <span>/</span> <span>10</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h1 id=\"_2-leetcode\"> 2. Leetcode</h1>\n<p>参考</p>\n<blockquote>\n<ul>\n<li>https://krahets.gitee.io/views/sword-for-offer/2020-05-20-sword-for-offer-00.html</li>\n</ul>\n</blockquote>\n<h2 id=\"_05-最长回文子串\"> <a href=\"https://leetcode-cn.com/problems/longest-palindromic-substring/\" target=\"_blank\" rel=\"noopener noreferrer\">05. 最长回文子串</a></h2>\n<p>当 <code>s.length() &lt; 2</code> 时直接返回</p>\n<h3 id=\"暴力法\"> 暴力法</h3>\n<p>直接计算每个子字符串是否为回文数，是的话就将此子字符串长度与 <code>maxLen</code> 比较，如果大于 <code>maxLen</code> ，就覆盖 <code>maxLen</code> 并覆盖起始位置 <code>begin</code> ，最后的时候返回 <code>s.subString(begin , begin + maxLen)</code> 即可</p>\n<div><pre><code>    <span>/*暴力法，遍历所有子串*/</span>\n    <span>public</span> <span>static</span> <span>String</span> <span>longestPalindrome</span><span>(</span><span>String</span> s<span>)</span><span>{</span>\n        <span>int</span> len <span>=</span> s<span>.</span><span>length</span><span>(</span><span>)</span><span>;</span>\n        <span>if</span><span>(</span>len <span>&lt;</span> <span>2</span><span>)</span><span>{</span>\n            <span>return</span> s<span>;</span>\n        <span>}</span>\n        <span>int</span> maxLen <span>=</span> <span>1</span><span>;</span>\n        <span>int</span> begin <span>=</span> <span>0</span><span>;</span>\n        <span>char</span><span>[</span><span>]</span> chars <span>=</span> s<span>.</span><span>toCharArray</span><span>(</span><span>)</span><span>;</span>\n        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> len <span>-</span> <span>1</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>\n            <span>for</span> <span>(</span><span>int</span> j <span>=</span> i <span>+</span> <span>1</span><span>;</span> j <span>&lt;</span> len<span>;</span> j<span>++</span><span>)</span> <span>{</span>\n                <span>if</span><span>(</span>j <span>-</span> i <span>+</span> <span>1</span> <span>></span> maxLen <span>&amp;&amp;</span> <span>validPalindrome</span><span>(</span>chars<span>,</span> i <span>,</span>j<span>)</span><span>)</span><span>{</span>\n                    maxLen <span>=</span> j <span>-</span> i <span>+</span> <span>1</span><span>;</span>\n                    begin <span>=</span> i<span>;</span>\n                <span>}</span>\n            <span>}</span>\n        <span>}</span>\n        <span>return</span> s<span>.</span><span>substring</span><span>(</span>begin<span>,</span> begin <span>+</span> maxLen<span>)</span><span>;</span>\n    <span>}</span>\n    <span>public</span> <span>static</span> <span>boolean</span> <span>validPalindrome</span><span>(</span><span>char</span><span>[</span><span>]</span> chars <span>,</span> <span>int</span> left <span>,</span> <span>int</span> right<span>)</span><span>{</span>\n        <span>while</span> <span>(</span>left <span>&lt;</span> right<span>)</span><span>{</span>\n            <span>if</span><span>(</span>chars<span>[</span>left<span>]</span> <span>!=</span> chars<span>[</span>right<span>]</span><span>)</span><span>{</span>\n                <span>return</span> <span>false</span><span>;</span>\n            <span>}</span>\n            left<span>++</span><span>;</span>\n            right<span>--</span><span>;</span>\n        <span>}</span>\n        <span>return</span> <span>true</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><h3 id=\"中心扩展\"> 中心扩展</h3>\n<p>遍历字符串，并以每个字符为中心比较左右两个字符是否相等，边界条件为 <code>left &gt;=0 &amp;&amp; right &lt; s.length() &amp;&amp; s.charAt(left) == s.charAt(right)</code> 。但是分两种情况</p>\n<ul>\n<li>以一个字符为中心扩展</li>\n<li>以两个字符为中心扩展</li>\n</ul>\n<p>在每一次循环时比较上述两个长度的最大值，再与 <code>maxLen</code> 比较，大于则赋值给 <code>maxLen</code> 并赋值 <code>begin</code> 索引</p>\n<div><pre><code>    <span>/*中心扩展*/</span>\n    <span>public</span> <span>static</span> <span>String</span> <span>longestPalindrome_expandCenter</span><span>(</span><span>String</span> s<span>)</span><span>{</span>\n        <span>int</span> maxLen <span>=</span> <span>0</span><span>;</span>\n        <span>int</span> begin <span>=</span> <span>0</span><span>;</span>\n        <span>if</span><span>(</span>s<span>.</span><span>length</span><span>(</span><span>)</span> <span>&lt;</span> <span>2</span><span>)</span><span>{</span>\n            <span>return</span> s<span>;</span>\n        <span>}</span>\n        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> s<span>.</span><span>length</span><span>(</span><span>)</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>\n          \n            <span>int</span> len <span>=</span> <span>Math</span><span>.</span><span>max</span><span>(</span><span>expandAroundCenter</span><span>(</span>s <span>,</span> i <span>,</span> i<span>)</span><span>,</span><span>expandAroundCenter</span><span>(</span>s <span>,</span> i <span>,</span> i <span>+</span> <span>1</span><span>)</span><span>)</span><span>;</span>\n            <span>if</span><span>(</span>len <span>></span> maxLen<span>)</span><span>{</span>\n                begin <span>=</span> i <span>-</span> <span>(</span>len <span>-</span> <span>1</span><span>)</span><span>/</span><span>2</span><span>;</span><span>//赋值给索引begin</span>\n                maxLen <span>=</span> len<span>;</span><span>//赋值给回文串最大长度</span>\n            <span>}</span>\n        <span>}</span>\n        <span>return</span> s<span>.</span><span>substring</span><span>(</span>begin<span>,</span> begin <span>+</span> maxLen<span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>static</span> <span>int</span> <span>expandAroundCenter</span><span>(</span><span>String</span> s <span>,</span> <span>int</span> left <span>,</span> <span>int</span> right<span>)</span><span>{</span>\n        <span>while</span> <span>(</span>left <span>>=</span><span>0</span> <span>&amp;&amp;</span> right <span>&lt;</span> s<span>.</span><span>length</span><span>(</span><span>)</span> <span>&amp;&amp;</span> s<span>.</span><span>charAt</span><span>(</span>left<span>)</span> <span>==</span> s<span>.</span><span>charAt</span><span>(</span>right<span>)</span><span>)</span><span>{</span>\n            left<span>--</span><span>;</span>\n            right<span>++</span><span>;</span>\n        <span>}</span>\n        <span>return</span> right <span>-</span> left <span>-</span> <span>1</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><p>参考</p>\n<blockquote>\n<ul>\n<li><a href=\"https://krahets.gitee.io/views/sword-for-offer/2020-05-20-sword-for-offer-00.html\" target=\"_blank\" rel=\"noopener noreferrer\">「 剑指 OFFER 系列题解 」 扬帆，起航</a></li>\n</ul>\n</blockquote>\n<h2 id=\"_03-剑指-offer-03-数组中重复的数字\"> <a href=\"https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/\" target=\"_blank\" rel=\"noopener noreferrer\">03. 剑指 Offer 03. 数组中重复的数字</a></h2>\n<p><code>HashSet去重</code></p>\n<p><img src=\"./images/DataStructure&algorithm_question/SwordOffer03.jpg\" alt=\"剑指offer-03-数组中重复的数字\" /></p>\n<h3 id=\"第一种-使用hastset去重-遍历添加时如果返回为false则说明重复则直接返回此数\"> 第一种：使用HastSet去重，遍历添加时如果返回为<code>false</code>则说明重复则直接返回此数</h3>\n<div><pre><code>    <span>public</span> <span>static</span> <span>int</span> <span>findRepeatNumber</span><span>(</span><span>)</span> <span>{</span>\n        <span>HashSet</span><span><span>&lt;</span><span>Integer</span><span>></span></span> dic <span>=</span> <span>new</span> <span>HashSet</span><span><span>&lt;</span><span>Integer</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n        <span>int</span><span>[</span><span>]</span> nums <span>=</span> <span>{</span><span>1</span><span>,</span><span>2</span><span>,</span><span>2</span><span>,</span><span>4</span><span>}</span><span>;</span>\n        <span>int</span> repeat <span>=</span> <span>0</span><span>;</span>\n        <span>for</span><span>(</span><span>int</span> num <span>:</span> nums<span>)</span><span>{</span>\n            <span>if</span><span>(</span> <span>!</span>dic<span>.</span><span>add</span><span>(</span>num<span>)</span><span>)</span><span>{</span>\n                repeat <span>=</span> num<span>;</span>\n                <span>break</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n        <span>return</span> repeat<span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h3 id=\"第二种-由于指定了里面的数范围为0-n-1-可以用遍历添加到另一个数组-另一个数组下标为数组中的数-值为出现的次数-当次数大于2则返回\"> 第二种：由于指定了里面的数范围为0 ~ n-1，可以用遍历添加到另一个数组，另一个数组下标为数组中的数，值为出现的次数，当次数大于2则返回</h3>\n<div><pre><code> <span>int</span><span>[</span><span>]</span> nums <span>=</span> <span>{</span><span>1</span><span>,</span><span>2</span><span>,</span><span>2</span><span>,</span><span>3</span><span>}</span><span>;</span>\n        <span>int</span><span>[</span><span>]</span> nums_2 <span>=</span> <span>new</span> <span>int</span><span>[</span>nums<span>.</span>length<span>]</span><span>;</span>\n        <span>int</span> repeat <span>=</span> <span>-</span><span>1</span><span>;</span>\n        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> nums<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n            <span>if</span><span>(</span><span>++</span>nums_2<span>[</span>nums<span>[</span>i<span>]</span><span>]</span> <span>></span> <span>1</span><span>)</span><span>{</span>\n                repeat <span>=</span> nums<span>[</span>i<span>]</span><span>;</span>\n              \t<span>break</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n        <span>return</span> repeat<span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h2 id=\"_04-剑指-offer-04-二维数组中的查找\"> <a href=\"https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/submissions/\" target=\"_blank\" rel=\"noopener noreferrer\">04. 剑指 Offer 04. 二维数组中的查找</a></h2>\n<p><code>标志位法</code> <code>线性查找</code></p>\n<p><img src=\"./images/DataStructure&algorithm_question/SwordOffer04.jpg\" alt=\"\" /></p>\n<h3 id=\"线性查找\"> 线性查找</h3>\n<p>​\t\t由于给定的二维数组具备每行从左到右递增以及每列从上到下递增的特点，当访问到一个元素时，可以排除数组中的部分元素。</p>\n<p>从二维数组的右上角开始查找。如果当前元素等于目标值，则返回 true。如果当前元素大于目标值，则移到左边一列。如果当前元素小于目标值，则移到下边一行。</p>\n<p>可以证明这种方法不会错过目标值。如果当前元素大于目标值，说明当前元素的下边的所有元素都一定大于目标值，因此往下查找不可能找到目标值，往左查找可能找到目标值。如果当前元素小于目标值，说明当前元素的左边的所有元素都一定小于目标值，因此往左查找不可能找到目标值，往下查找可能找到目标值。</p>\n<ul>\n<li>\n<p>若数组为空，返回 false</p>\n</li>\n<li>\n<p>初始化行下标为 0，列下标为二维数组的列数减 1</p>\n</li>\n<li>\n<p>重复下列步骤，直到行下标或列下标超出边界</p>\n</li>\n<li>\n<p>获得当前下标位置的元素 num</p>\n<blockquote>\n<ul>\n<li>如果 num 和 target 相等，返回 true</li>\n<li>如果 num 大于 target，列下标减 1</li>\n<li>如果 num 小于 target，行下标加 1</li>\n</ul>\n</blockquote>\n</li>\n<li>\n<p>循环体执行完毕仍未找到元素等于 target ，说明不存在这样的元素，返回false</p>\n</li>\n</ul>\n<div><pre><code><span>class</span> <span>Solution</span> <span>{</span>\n    <span>public</span> <span>boolean</span> <span>findNumberIn2DArray</span><span>(</span><span>int</span><span>[</span><span>]</span><span>[</span><span>]</span> matrix<span>,</span> <span>int</span> target<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>matrix <span>==</span> <span>null</span> <span>||</span> matrix<span>.</span>length <span>==</span> <span>0</span> <span>||</span> matrix<span>[</span><span>0</span><span>]</span><span>.</span>length <span>==</span> <span>0</span><span>)</span> <span>{</span>\n            <span>return</span> <span>false</span><span>;</span>\n        <span>}</span>\n        <span>int</span> rows <span>=</span> matrix<span>.</span>length<span>,</span> columns <span>=</span> matrix<span>[</span><span>0</span><span>]</span><span>.</span>length<span>;</span>\n        <span>int</span> row <span>=</span> <span>0</span><span>,</span> column <span>=</span> columns <span>-</span> <span>1</span><span>;</span>\n        <span>while</span> <span>(</span>row <span>&lt;</span> rows <span>&amp;&amp;</span> column <span>>=</span> <span>0</span><span>)</span> <span>{</span>\n            <span>int</span> num <span>=</span> matrix<span>[</span>row<span>]</span><span>[</span>column<span>]</span><span>;</span>\n            <span>if</span> <span>(</span>num <span>==</span> target<span>)</span> <span>{</span>\n                <span>return</span> <span>true</span><span>;</span>\n            <span>}</span> <span>else</span> <span>if</span> <span>(</span>num <span>></span> target<span>)</span> <span>{</span>\n                column<span>--</span><span>;</span>\n            <span>}</span> <span>else</span> <span>{</span>\n                row<span>++</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n        <span>return</span> <span>false</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><h2 id=\"_05-剑指-offer-05-替换空格\"> <a href=\"https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/\" target=\"_blank\" rel=\"noopener noreferrer\">05. 剑指 Offer 05. 替换空格</a></h2>\n<p><code>字符串拼接</code> <code>StringBuilder</code></p>\n<div><pre><code><span>class</span> <span>Solution</span> <span>{</span>\n    <span>public</span> <span>String</span> <span>replaceSpace</span><span>(</span><span>String</span> s<span>)</span> <span>{</span>\n        <span>StringBuilder</span> res <span>=</span> <span>new</span> <span>StringBuilder</span><span>(</span><span>)</span><span>;</span>\n        <span>for</span><span>(</span><span>Character</span> c <span>:</span> s<span>.</span><span>toCharArray</span><span>(</span><span>)</span><span>)</span>\n        <span>{</span>\n            <span>if</span><span>(</span>c <span>==</span> <span>' '</span><span>)</span> res<span>.</span><span>append</span><span>(</span><span>\"%20\"</span><span>)</span><span>;</span>\n            <span>else</span> res<span>.</span><span>append</span><span>(</span>c<span>)</span><span>;</span>\n        <span>}</span>\n        <span>return</span> res<span>.</span><span>toString</span><span>(</span><span>)</span><span>;</span>\n\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h2 id=\"_06-剑指-offer-06-从尾到头打印链表\"> <a href=\"https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/\" target=\"_blank\" rel=\"noopener noreferrer\">06. 剑指 Offer 06. 从尾到头打印链表</a></h2>\n<p><code>栈</code> <code>遍历链表</code></p>\n<h3 id=\"第一种-先算出数量再遍历赋值直到head-next-null\"> 第一种：先算出数量再遍历赋值直到head.next == null</h3>\n<div><pre><code>    <span>public</span> <span>int</span><span>[</span><span>]</span> <span>reversePrint</span><span>(</span><span>ListNode</span> head<span>)</span> <span>{</span>\n       <span>//先获取链表长度，创建对应长度数组</span>\n        <span>ListNode</span> currNode <span>=</span> head<span>;</span>\n        <span>int</span> len <span>=</span> <span>0</span><span>;</span>\n        <span>while</span><span>(</span>currNode <span>!=</span> <span>null</span><span>)</span><span>{</span>\n            len <span>++</span><span>;</span>\n            currNode <span>=</span> currNode<span>.</span>next<span>;</span>\n        <span>}</span>\n        <span>int</span><span>[</span><span>]</span> result <span>=</span> <span>new</span> <span>int</span><span>[</span>len<span>]</span><span>;</span>\n        \n        <span>//再次遍历链表，将值倒序填充至结果数组</span>\n        currNode <span>=</span> head<span>;</span>\n        <span>while</span><span>(</span>currNode <span>!=</span> <span>null</span><span>)</span><span>{</span>\n            result<span>[</span>len <span>-</span> <span>1</span><span>]</span> <span>=</span> currNode<span>.</span>val<span>;</span>\n            len <span>--</span><span>;</span>\n            currNode <span>=</span> currNode<span>.</span>next<span>;</span>\n        <span>}</span>\n        <span>return</span> result<span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h3 id=\"第二种-使用栈\"> 第二种：使用栈</h3>\n<div><pre><code><span>/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */</span>\n<span>class</span> <span>Solution</span> <span>{</span>\n    <span>public</span> <span>int</span><span>[</span><span>]</span> <span>reversePrint</span><span>(</span><span>ListNode</span> head<span>)</span> <span>{</span>\n        <span>Stack</span><span><span>&lt;</span><span>ListNode</span><span>></span></span> stack <span>=</span> <span>new</span> <span>Stack</span><span><span>&lt;</span><span>ListNode</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n        <span>ListNode</span> temp <span>=</span> head<span>;</span>\n        <span>while</span> <span>(</span>temp <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n            stack<span>.</span><span>push</span><span>(</span>temp<span>)</span><span>;</span>\n            temp <span>=</span> temp<span>.</span>next<span>;</span>\n        <span>}</span>\n        <span>int</span> size <span>=</span> stack<span>.</span><span>size</span><span>(</span><span>)</span><span>;</span>\n        <span>int</span><span>[</span><span>]</span> print <span>=</span> <span>new</span> <span>int</span><span>[</span>size<span>]</span><span>;</span>\n        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> size<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n            print<span>[</span>i<span>]</span> <span>=</span> stack<span>.</span><span>pop</span><span>(</span><span>)</span><span>.</span>val<span>;</span>\n        <span>}</span>\n        <span>return</span> print<span>;</span>\n    <span>}</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><h3 id=\"第三种-使用集合等遍历逆序添加\"> 第三种：使用集合等遍历逆序添加</h3>\n<h2 id=\"_07-剑指-offer-07-重建二叉树\"> <a href=\"https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/\" target=\"_blank\" rel=\"noopener noreferrer\">07. 剑指 Offer 07. 重建二叉树</a></h2>\n<p><code>递归法</code> <code>二叉树</code> <code>分治思想</code></p>\n<p><img src=\"./images/DataStructure&algorithm_question/rebuild_binary-tree.jpg\" alt=\"重建二叉树\" /></p>\n<div><pre><code><span>class</span> <span>Solution</span> <span>{</span>\n    <span>HashMap</span><span><span>&lt;</span><span>Integer</span><span>,</span> <span>Integer</span><span>></span></span> dic <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n    <span>int</span><span>[</span><span>]</span> po<span>;</span>\n    <span>public</span> <span>TreeNode</span> <span>buildTree</span><span>(</span><span>int</span><span>[</span><span>]</span> preorder<span>,</span> <span>int</span><span>[</span><span>]</span> inorder<span>)</span> <span>{</span>\n        po <span>=</span> preorder<span>;</span>\n        <span>for</span><span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> inorder<span>.</span>length<span>;</span> i<span>++</span><span>)</span> \n            dic<span>.</span><span>put</span><span>(</span>inorder<span>[</span>i<span>]</span><span>,</span> i<span>)</span><span>;</span>\n        <span>return</span> <span>recur</span><span>(</span><span>0</span><span>,</span> <span>0</span><span>,</span> inorder<span>.</span>length <span>-</span> <span>1</span><span>)</span><span>;</span>\n    <span>}</span>\n    <span>TreeNode</span> <span>recur</span><span>(</span><span>int</span> pre_root<span>,</span> <span>int</span> in_left<span>,</span> <span>int</span> in_right<span>)</span> <span>{</span>\n        <span>if</span><span>(</span>in_left <span>></span> in_right<span>)</span> <span>return</span> <span>null</span><span>;</span>\n        <span>TreeNode</span> root <span>=</span> <span>new</span> <span>TreeNode</span><span>(</span>po<span>[</span>pre_root<span>]</span><span>)</span><span>;</span>\n        <span>int</span> i <span>=</span> dic<span>.</span><span>get</span><span>(</span>po<span>[</span>pre_root<span>]</span><span>)</span><span>;</span>\n        root<span>.</span>left <span>=</span> <span>recur</span><span>(</span>pre_root <span>+</span> <span>1</span><span>,</span> in_left<span>,</span> i <span>-</span> <span>1</span><span>)</span><span>;</span>\n        root<span>.</span>right <span>=</span> <span>recur</span><span>(</span>pre_root <span>+</span> i <span>-</span> in_left <span>+</span> <span>1</span><span>,</span> i <span>+</span> <span>1</span><span>,</span> in_right<span>)</span><span>;</span>\n        <span>return</span> root<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h2 id=\"_09-剑指-offer-09-用两个栈实现队列\"> <a href=\"https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/\" target=\"_blank\" rel=\"noopener noreferrer\">09. 剑指 Offer 09. 用两个栈实现队列</a></h2>\n<p><code>栈</code> <code>队列</code></p>\n<p>使用两个栈，一个栈(A)负责进，一个栈(B)负责出，根据方法有两种情况：</p>\n<p>入队<code>appendTail</code></p>\n<p>直接将元素压入第一个栈A中，此时第一个栈栈底即为队列第一个元素</p>\n<p>出队<code>deleteHead</code></p>\n<p>在执行出队时我们将A栈中的元素出队到B栈中，A栈在<code>pop</code>前栈底为头结点，栈顶为尾结点，将A栈中元素出栈后<code>push</code>进B中，此时A栈为空，B栈中栈顶元素为队列的头结点，栈底元素为队列的尾结点。在后续出栈中有三种情况：</p>\n<ul>\n<li>B栈不为空，则出栈<code>push</code></li>\n<li>B栈为空，A栈不为空，将A栈元素都<code>pop</code>然后<code>push</code>到B栈中，B栈再出栈</li>\n<li>B栈为空，A栈为空，此时没有结点，则直接返回-1</li>\n</ul>\n<p>集合框架不采用Stack是因为被Stack继承于Vector，存在着大量的Synchronized而弃用，使用LinkedList可以模拟，比如<code>addFirst</code>和<code>addLast</code>，<code>removeFirst</code>和<code>removeLast</code></p>\n<div><pre><code><span>class</span> <span>CQueue</span> <span>{</span>\n    <span>static</span> <span>LinkedList</span><span><span>&lt;</span><span>Integer</span><span>></span></span> <span>A</span><span>,</span><span>B</span><span>;</span>\n\n    <span>public</span> <span>CQueue</span><span>(</span><span>)</span> <span>{</span>\n        <span>A</span> <span>=</span> <span>new</span> <span>LinkedList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n        <span>B</span> <span>=</span> <span>new</span> <span>LinkedList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n\n    <span>}</span>\n    \n    <span>public</span> <span>void</span> <span>appendTail</span><span>(</span><span>int</span> value<span>)</span> <span>{</span>\n        <span>A</span><span>.</span><span>addLast</span><span>(</span>value<span>)</span><span>;</span>\n\n    <span>}</span>\n    \n    <span>public</span> <span>int</span> <span>deleteHead</span><span>(</span><span>)</span> <span>{</span>\n        <span>if</span><span>(</span><span>!</span><span>B</span><span>.</span><span>isEmpty</span><span>(</span><span>)</span><span>)</span><span>{</span>\n            <span>return</span> <span>B</span><span>.</span><span>removeLast</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>if</span><span>(</span><span>A</span><span>.</span><span>isEmpty</span><span>(</span><span>)</span><span>)</span><span>{</span>\n            <span>return</span> <span>-</span><span>1</span><span>;</span>\n        <span>}</span>\n        <span>while</span> <span>(</span><span>!</span><span>A</span><span>.</span><span>isEmpty</span><span>(</span><span>)</span><span>)</span><span>{</span>\n            <span>B</span><span>.</span><span>addLast</span><span>(</span><span>A</span><span>.</span><span>removeLast</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>return</span> <span>B</span><span>.</span><span>removeLast</span><span>(</span><span>)</span><span>;</span>\n\n    <span>}</span>\n<span>}</span>\n\n<span>/**\n * Your CQueue object will be instantiated and called as such:\n * CQueue obj = new CQueue();\n * obj.appendTail(value);\n * int param_2 = obj.deleteHead();\n */</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br></div></div><h2 id=\"_10-剑指-offer-10-ii-青蛙跳台阶问题\"> <a href=\"https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/\" target=\"_blank\" rel=\"noopener noreferrer\">10. 剑指 Offer 10- II. 青蛙跳台阶问题</a></h2>\n<p><code>Fibonacci</code></p>\n<div><pre><code><span>class</span> <span>Solution</span> <span>{</span>\n    <span>public</span> <span>int</span> <span>numWays</span><span>(</span><span>int</span> n<span>)</span> <span>{</span>\n        <span>int</span> a <span>=</span> <span>0</span> <span>,</span> b <span>=</span> <span>1</span> <span>,</span> sum <span>=</span> <span>0</span><span>;</span>\n        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> n<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n            sum <span>=</span> <span>(</span>a <span>+</span> b<span>)</span> <span>%</span> <span>1000000007</span><span>;</span>\n            a <span>=</span> b<span>;</span>\n            b <span>=</span> sum<span>;</span>\n        <span>}</span>\n        <span>return</span> sum<span>;</span>\n\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h2 id=\"_11-剑指-offer-11-旋转数组的最小数字\"> <a href=\"https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/\" target=\"_blank\" rel=\"noopener noreferrer\">11. 剑指 Offer 11. 旋转数组的最小数字</a></h2>\n<p><code>二分法</code></p>\n<p>整体思路使用二分法。根据题意可以知道，先设旋转点下标为 <code>x</code>，左侧为<code>left</code>，右侧为<code>right</code> ，此数组的特性有</p>\n<blockquote>\n<ul>\n<li>由于是递增排序后的旋转数组，那么左边数组的最小值 <code>&gt;=</code> 右边数组的最大值</li>\n<li>旋转后的数组一定有右边数组，可以没有左边数组，例如<code>[1,2,3,4,5]</code>会被认为是<code>[1,2,3,4,5]</code>旋转5次后的数组，所以这就决定了<code>numbers[mid]</code>应该与<code>numbers[right]</code>进行对比而不是<code>numbers[left]</code>，因为<code>right</code>一定指向右边数组，而<code>left</code>不一定，下方会详细说明</li>\n</ul>\n</blockquote>\n<p>让<code>numbers[mid]</code>与<code>numbers[right]</code>对比，使用二分法依然有三种情况</p>\n<blockquote>\n<ul>\n<li>\n<p><code>numbers[mid] &gt; numbers[right]</code>:由于right指向最右边即右边数组的最大值，当大于右边数组的最大值时，说明<code>numbers[mid]</code>左侧数组，此时将<code>left</code>指向<code>mid + 1</code>，因为<code>numbers[mid]</code>在左侧数组，可以直接摒弃</p>\n</li>\n<li>\n<p><code>numbers[mid] &lt; numbers[right]</code>：由于左边数组的最小值 <code>&gt;=</code> 右边数组的最大值，所以<code>numbers[mid]</code>必定在右侧数组，如果此旋转后的数组全是右侧数组，没有左侧数组，也可成立适用。此时缩小范围，将<code>right</code>指向<code>mid</code>，是因为<code>mid</code>还在右侧数组，不能摒弃，例如<code>[3,1,3]</code>，在比较后，<code>right</code>为<code>0</code>，二旋转点是1，显然不符合。</p>\n</li>\n<li>\n<p><code>numbers[mid] == numbers[right]</code>：这时候无法确定<code>mid</code>在哪边，执行 <code>right = right - 1</code>缩小判断范围</p>\n<blockquote>\n<ul>\n<li>\n<p>当<code>[2,2,2,1,2]</code>时，<code>mid</code>在左侧数组，可以发现区间<code>[left,mid]</code>值和<code>right</code>相等，由于 <code>左排序数组 任一元素 &gt;= 右排序数组 任一元素</code>,可以知道，<code>numbers[旋转点] &lt;= (numbers[right] == numbers[mid])</code>,</p>\n<blockquote>\n<ul>\n<li>\n<p>若 <code>numbers[旋转点] &lt; numbers[right]</code>:那么执行 <code>right = right - 1</code>后，旋转点依然在<code>[left,right]</code>中</p>\n</li>\n<li>\n<p>若 <code>numbers[旋转点] == numbers[right]</code>：此时有两种情况关于下标</p>\n<blockquote>\n<ul>\n<li>当 <code>right &gt; 旋转点</code> ： 易得执行right = right - 1后旋转点 仍在<code>[left,right]</code>区间内。</li>\n<li>当<code>right == 旋转点</code>：例如<code>[1,1,1,2,3,1]</code>，虽然丢失了旋转点索引 <code>x = 5</code>，但最终返回值仍正确（最终返回的 numbers[0] 等于旋转点值 numbers[5] ），这是因为：之后的二分循环一直在执行<code>right = mid</code>，而区间<code>[left,mid]</code> 内的元素值一定都等于旋转点值 <code>numbers[旋转点]</code></li>\n</ul>\n</blockquote>\n</li>\n</ul>\n</blockquote>\n</li>\n<li>\n<p>当<code>[2,3,2,2,2]</code>时，<code>mid</code>在右侧数组，可以发现区间<code>[mid,right]</code>的值相等,此时执行 <code>right = right - 1</code>,依然是可以求出旋转点的值，只是抛弃一个重复值，毕竟都相同</p>\n</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n</blockquote>\n<p><strong>总结：</strong> 此方法可以保证返回值 <code>numbers[left]</code> 等于旋转点值 <code>numbers[旋转点]</code> ；但在少数特例下left点不是旋转点，只要求返回 “旋转点的值” ，因此本方法可行。</p>\n<div><pre><code>    <span>public</span> <span>static</span> <span>int</span> <span>findMin</span><span>(</span><span>int</span><span>[</span><span>]</span> numbers<span>)</span><span>{</span>\n        <span>if</span> <span>(</span>numbers<span>.</span>length <span>==</span> <span>0</span><span>)</span> <span>{</span>\n            <span>return</span> <span>-</span><span>1</span><span>;</span>\n        <span>}</span>\n        <span>int</span> left <span>=</span> <span>0</span> <span>,</span> right <span>=</span> numbers<span>.</span>length <span>-</span> <span>1</span> <span>,</span> mid<span>;</span>\n        <span>while</span> <span>(</span>left <span>&lt;</span> right<span>)</span><span>{</span>\n            mid <span>=</span> left <span>+</span> <span>(</span>right <span>-</span> left<span>)</span> <span>/</span> <span>2</span><span>;</span>\n            <span>if</span><span>(</span>numbers<span>[</span>mid<span>]</span> <span>></span> numbers<span>[</span>right<span>]</span><span>)</span><span>{</span>\n                left <span>=</span> mid <span>+</span> <span>1</span><span>;</span>\n            <span>}</span><span>else</span> <span>if</span><span>(</span>numbers<span>[</span>mid<span>]</span> <span>&lt;</span> numbers<span>[</span>right<span>]</span><span>)</span><span>{</span>\n                right <span>=</span> mid<span>;</span>\n            <span>}</span><span>else</span> <span>if</span><span>(</span>numbers<span>[</span>mid<span>]</span> <span>==</span> numbers<span>[</span>right<span>]</span><span>)</span><span>{</span>\n                right <span>-=</span> <span>1</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n        <span>return</span> numbers<span>[</span>left<span>]</span><span>;</span>\n\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h2 id=\"_12-剑指-offer-12-矩阵中的路径\"> <a href=\"https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/\" target=\"_blank\" rel=\"noopener noreferrer\">12. 剑指 Offer 12. 矩阵中的路径</a></h2>\n<p><code>DFS</code> <code>剪枝</code></p>\n<div><pre><code><span>class</span> <span>Solution</span> <span>{</span>\n    <span>public</span> <span>boolean</span> <span>exist</span><span>(</span><span>char</span><span>[</span><span>]</span><span>[</span><span>]</span> board<span>,</span> <span>String</span> word<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>board<span>.</span>length <span>==</span> <span>0</span> <span>||</span> word<span>.</span><span>length</span><span>(</span><span>)</span> <span>==</span> <span>0</span><span>)</span><span>{</span>\n            <span>return</span> <span>false</span><span>;</span>\n        <span>}</span>\n        <span>char</span><span>[</span><span>]</span> words <span>=</span> word<span>.</span><span>toCharArray</span><span>(</span><span>)</span><span>;</span>\n        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> board<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n            <span>for</span> <span>(</span><span>int</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> board<span>[</span><span>0</span><span>]</span><span>.</span>length<span>;</span> j<span>++</span><span>)</span> <span>{</span>\n                <span>if</span><span>(</span><span>dfs</span><span>(</span>board<span>,</span> words<span>,</span> i<span>,</span> j<span>,</span> <span>0</span><span>)</span><span>)</span><span>{</span>\n                    <span>return</span> <span>true</span><span>;</span>\n                <span>}</span>\n            <span>}</span>\n        <span>}</span>\n        <span>return</span> <span>false</span><span>;</span>\n\n    <span>}</span>\n\n        <span>public</span> <span>static</span> <span>boolean</span> <span>dfs</span><span>(</span><span>char</span><span>[</span><span>]</span><span>[</span><span>]</span> board<span>,</span> <span>char</span><span>[</span><span>]</span> words <span>,</span> <span>int</span> i <span>,</span> <span>int</span> j <span>,</span> <span>int</span> k<span>)</span><span>{</span>\n        <span>/*当一维下标i越界（往下移动时）或小于0（往左移动时），或\n        当二维下标j越界（往右移动时）或小于0（向上移动时），或\n        board[i][j] != words[k]，不匹配时，\n        返回false*/</span>\n        <span>if</span><span>(</span><span>(</span>i <span>>=</span> board<span>.</span>length <span>||</span> i <span>&lt;</span> <span>0</span><span>)</span> <span>||</span> <span>(</span>j <span>>=</span> board<span>[</span><span>0</span><span>]</span><span>.</span>length <span>||</span>j <span>&lt;</span> <span>0</span><span>)</span> <span>||</span> board<span>[</span>i<span>]</span><span>[</span>j<span>]</span> <span>!=</span> words<span>[</span>k<span>]</span><span>)</span><span>{</span>\n            <span>return</span> <span>false</span><span>;</span>\n        <span>}</span>\n        <span>/*这里也是终止条件，经过上面if后，此结点是匹配的，当此结点匹配且是字符串的最后一个元素时返回true*/</span>\n        <span>if</span><span>(</span>k <span>==</span> words<span>.</span>length <span>-</span> <span>1</span><span>)</span><span>{</span>\n            <span>return</span> <span>true</span><span>;</span>\n        <span>}</span>\n        <span>/*保留字符*/</span>\n        <span>char</span> tmp <span>=</span> board<span>[</span>i<span>]</span><span>[</span>j<span>]</span><span>;</span>\n        <span>/*经过前面的判断，此时这个结点没越界且匹配字符串，所以将此字符串设为'/'表示遍历过*/</span>\n        board<span>[</span>i<span>]</span><span>[</span>j<span>]</span> <span>=</span> <span>'/'</span><span>;</span>\n        <span>/*此时往四个方向继续遍历，只要这四个方向有一个是匹配的，则说明这个结点是匹配且是连续的*/</span>\n        <span>boolean</span> res <span>=</span> <span>dfs</span><span>(</span>board<span>,</span> words<span>,</span> i <span>+</span> <span>1</span><span>,</span> j<span>,</span> k <span>+</span> <span>1</span><span>)</span> <span>||</span> <span>dfs</span><span>(</span>board<span>,</span> words<span>,</span> i <span>-</span> <span>1</span><span>,</span> j<span>,</span> k <span>+</span> <span>1</span><span>)</span>\n                <span>||</span> <span>dfs</span><span>(</span>board<span>,</span> words<span>,</span> i<span>,</span> j <span>+</span> <span>1</span><span>,</span> k <span>+</span> <span>1</span><span>)</span> <span>||</span> <span>dfs</span><span>(</span>board<span>,</span> words<span>,</span> i<span>,</span> j <span>-</span> <span>1</span><span>,</span> k <span>+</span> <span>1</span><span>)</span><span>;</span>\n\n        board<span>[</span>i<span>]</span><span>[</span>j<span>]</span> <span>=</span> tmp<span>;</span>\n        <span>return</span> res<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br></div></div><h2 id=\"_13-剑指-offer-13-机器人的运动范围\"> <a href=\"https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/\" target=\"_blank\" rel=\"noopener noreferrer\">13. 剑指 Offer 13. 机器人的运动范围</a></h2>\n<p><code>DFS</code> <code>剪枝</code></p>\n<p>这道题也是矩阵搜索</p>\n<div><pre><code><span>class</span> <span>Solution</span> <span>{</span>\n    <span>int</span> m<span>;</span>\n    <span>int</span> n<span>;</span>\n    <span>int</span> k<span>;</span>\n    <span>boolean</span><span>[</span><span>]</span><span>[</span><span>]</span> visited<span>;</span>\n\n    <span>public</span> <span>int</span> <span>movingCount</span><span>(</span><span>int</span> m<span>,</span> <span>int</span> n<span>,</span> <span>int</span> k<span>)</span><span>{</span>\n        <span>this</span><span>.</span>m <span>=</span> m<span>;</span>\n        <span>this</span><span>.</span>n <span>=</span> n<span>;</span>\n        <span>this</span><span>.</span>k <span>=</span> k<span>;</span>\n        visited <span>=</span> <span>new</span> <span>boolean</span><span>[</span>m<span>]</span><span>[</span>n<span>]</span><span>;</span>\n        <span>return</span> <span>dfs</span><span>(</span><span>0</span><span>,</span> <span>0</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>int</span> <span>dfs</span><span>(</span><span>int</span> i<span>,</span> <span>int</span> j<span>)</span><span>{</span>\n        <span>if</span><span>(</span>i <span>>=</span> m <span>||</span> j <span>>=</span> n <span>||</span> <span>getSum</span><span>(</span>i<span>)</span> <span>+</span> <span>getSum</span><span>(</span>j<span>)</span> <span>></span> k <span>||</span> visited<span>[</span>i<span>]</span><span>[</span>j<span>]</span><span>)</span><span>{</span>\n            <span>return</span> <span>0</span><span>;</span>\n        <span>}</span>\n\n        visited<span>[</span>i<span>]</span><span>[</span>j<span>]</span> <span>=</span> <span>true</span><span>;</span>\n\n        <span>return</span> <span>1</span> <span>+</span> <span>dfs</span><span>(</span>i <span>+</span> <span>1</span><span>,</span> j<span>)</span> <span>+</span> <span>dfs</span><span>(</span>i<span>,</span> j <span>+</span> <span>1</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>/*获取数位和*/</span>\n    <span>public</span> <span>static</span> <span>int</span> <span>getSum</span><span>(</span><span>int</span> i<span>)</span><span>{</span>\n        <span>int</span> sum <span>=</span> <span>0</span><span>;</span>\n        <span>while</span> <span>(</span>i <span>!=</span> <span>0</span><span>)</span><span>{</span>\n            sum <span>+=</span> i <span>%</span> <span>10</span><span>;</span>\n            i <span>=</span> i <span>/</span> <span>10</span><span>;</span>\n        <span>}</span>\n        <span>return</span> sum<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br></div></div><h2 id=\"_52-剑指-offer-52-两个链表的第一个公共节点\"> <a href=\"https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/\" target=\"_blank\" rel=\"noopener noreferrer\">52. 剑指 Offer 52. 两个链表的第一个公共节点</a></h2>\n<p><code>双指针</code></p>\n<p><img src=\"./images/DataStructure&algorithm_question/SwordOffer52.png\" alt=\"剑指Offer52两个链表的第一个公共节点\" /></p>\n<p>使用双指针，注意结点的数字相同不代表结点对象相同</p>\n<div><pre><code>    <span>public</span> <span>static</span> <span>class</span> <span>ListNode</span> <span>{</span>\n      <span>int</span> val<span>;</span>\n      <span>ListNode</span> next<span>;</span>\n      <span>ListNode</span><span>(</span><span>int</span> val<span>)</span> <span>{</span>\n          val <span>=</span> val<span>;</span>\n          next <span>=</span> <span>null</span><span>;</span>\n      <span>}</span>\n  <span>}</span>\n\n    <span>/*双指针*/</span>\n    <span>public</span> <span>static</span> <span>ListNode</span> <span>getIntersectionNode</span><span>(</span><span>ListNode</span> headA <span>,</span> <span>ListNode</span> headB<span>)</span><span>{</span>\n                <span>if</span> <span>(</span>headA <span>==</span> <span>null</span> <span>||</span> headB <span>==</span> <span>null</span><span>)</span> <span>{</span>\n                    <span>return</span> <span>null</span><span>;</span>\n                <span>}</span>\n                <span>ListNode</span> node1<span>=</span>headA<span>;</span>\n                <span>ListNode</span> node2<span>=</span>headB<span>;</span>\n                <span>while</span> <span>(</span>node1<span>!=</span>node2<span>)</span><span>{</span>\n                    node1<span>=</span><span>(</span>node1<span>==</span><span>null</span><span>)</span><span>?</span>headB<span>:</span>node1<span>.</span>next<span>;</span>\n                    node2<span>=</span><span>(</span>node2<span>==</span><span>null</span><span>)</span><span>?</span>headA<span>:</span>node2<span>.</span>next<span>;</span>\n                <span>}</span>\n\n                <span>return</span> node1<span>;</span>\n\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><h1 id=\"_3-牛客网\"> 3. 牛客网</h1>\n<h2 id=\"判断一个括号字符串是否匹配正确-如果括号有多种-怎么做-如-正确-错误。\"> 判断一个括号字符串是否匹配正确，如果括号有多种，怎么做？如（（[]））正确，[[(()错误。</h2>\n<h1 id=\"字符串压缩\"> 字符串压缩</h1>\n<p><code>String</code></p>\n<div><pre><code><span>String</span> words <span>=</span> <span>\"HG[3|B[2|CA]]F\"</span><span>;</span>\n        <span>StringBuilder</span> stringBuilder <span>=</span> <span>new</span> <span>StringBuilder</span><span>(</span><span>)</span><span>;</span>\n        <span>while</span> <span>(</span>words<span>.</span><span>contains</span><span>(</span><span>\"]\"</span><span>)</span><span>)</span><span>{</span>\n            <span>int</span> right <span>=</span> words<span>.</span><span>indexOf</span><span>(</span><span>\"]\"</span><span>)</span><span>;</span>\n            <span>int</span> left <span>=</span> words<span>.</span><span>lastIndexOf</span><span>(</span><span>\"[\"</span><span>,</span> right<span>)</span><span>;</span>\n            <span>String</span> repeatStr <span>=</span> words<span>.</span><span>substring</span><span>(</span>left<span>+</span><span>1</span><span>,</span> right<span>)</span><span>;</span>\n            <span>String</span><span>[</span><span>]</span> split <span>=</span> repeatStr<span>.</span><span>split</span><span>(</span><span>\"\\\\|\"</span><span>)</span><span>;</span>\n            stringBuilder <span>=</span> <span>new</span> <span>StringBuilder</span><span>(</span><span>)</span><span>;</span>\n            <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>Integer</span><span>.</span><span>parseInt</span><span>(</span>split<span>[</span><span>0</span><span>]</span><span>)</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>\n                stringBuilder<span>.</span><span>append</span><span>(</span>split<span>[</span><span>1</span><span>]</span><span>)</span><span>;</span>\n            <span>}</span>\n            \n            words <span>=</span> words<span>.</span><span>replace</span><span>(</span>words<span>.</span><span>substring</span><span>(</span>left<span>,</span> right<span>+</span><span>1</span><span>)</span><span>,</span> \n            <span>String</span><span>.</span><span>join</span><span>(</span><span>\"\"</span><span>,</span> <span>Collections</span><span>.</span><span>nCopies</span><span>(</span><span>Integer</span><span>.</span><span>parseInt</span><span>(</span>split<span>[</span><span>0</span><span>]</span><span>)</span><span>,</span> split<span>[</span><span>1</span><span>]</span><span>)</span><span>)</span><span>)</span><span>;</span>\n        <span>}</span>\n\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>words<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div>",
      "date_published": "2020-08-29T19:21:57.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": []
    },
    {
      "title": "数据结构",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/dataStructure&algorithm/DataStructure/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/dataStructure&algorithm/DataStructure/",
      "content_html": "<h2 id=\"参考\"> 参考</h2>\n<div><p>参考</p>\n<ul>\n<li>数据结构第二版</li>\n</ul>\n</div>\n<h2 id=\"数据结构概述\"> 数据结构概述</h2>\n<p>数据的逻辑结构是从逻辑关系上描述数据，它与数据的存储无关，是独立于计算机的。因此， 数据的逻辑结构可以看作是从具体问题抽象出来的数学模型。 数据的逻辑结构有两个要素： 一是数据元素；二是关系。数据元素的含义如前所述，关系是 指数据元素间的逻辑关系。根据数据元素之间关系的不同特性， 通常有四类基本结构， 如图1.3 所示。它们的复杂程度依次递进。</p>\n<p>可以分为</p>\n<ul>\n<li><strong>逻辑结构</strong></li>\n<li><strong>存储结构（物理结构）</strong></li>\n</ul>\n<h3 id=\"逻辑结构\"> 逻辑结构</h3>\n<p>​\t数据的逻辑结构是从逻辑关系上描述数据，它与数据的存储无关，是独立千计算机的。因此， 数据的逻辑结构可以看作是从具体问题抽象出来的数学模型。</p>\n<p>​\t数据的逻辑结构有两个要素： 一是数据元素；二是关系。数据元素的含义如前所述，关系是 指数据元素间的逻辑关系。根据数据元素之间关系的不同特性， 通常有四类基本结构， 如图1.3 所示。它们的复杂程度依次递进。</p>\n<p><img src=\"./images/DataStructure/1.3.jpg\" alt=\"逻辑结构\" /></p>\n<p>下面四种结构中所举的示例是以某班级学生作为数据对象（数据元素是学生的学籍档案记录），来分别考察数据元素之间的关系。</p>\n<ul>\n<li><strong>集合结构</strong> ：数据元素之间除了 “属于同一集合” 的关系外，别无其他关系。例如，确定一名学生是否为班级成员， 只需将班级看做一个集合结构。</li>\n<li><strong>线性结构</strong> ：数据元素之间存在<strong>一对一</strong>的关系。例如，将学生信息数据按照其入学报到的时间先后顺序进 行排列，将组成一个线性结构。</li>\n<li><strong>树结构</strong> ：数据元素之间存在<strong>一对多</strong>的关系。例如，在班级的管理体系中，班长管理多个组长，每位组 长管理多名组员，从而构成树形结构。</li>\n<li><strong>图结构或网状结构</strong> ：数据元素之间存在<strong>多对多</strong>的关系。例如，多位同学之间的朋友关系， 任何两位同学都可以是 朋友，从而构成图状结构或网状结构。</li>\n</ul>\n<p><img src=\"./images/DataStructure/1.4.jpg\" alt=\"几种逻辑结构层次图\" /></p>\n<h3 id=\"存储结构-物理结构\"> 存储结构（物理结构）</h3>\n<p>可以分为</p>\n<ul>\n<li><strong>顺序存储结构</strong></li>\n<li><strong>链式存储结构</strong></li>\n</ul>\n<h2 id=\"时间复杂度分析\"> 时间复杂度分析</h2>\n<p>主要分析核心操作次数和问题规模</p>\n<h3 id=\"分析方法\"> 分析方法</h3>\n<blockquote>\n<p>找出所 数 次 有语句中语句频度最大的那条语句作为基本语 句， 计算基本语句的频度得到问题规模n的某个 函数j(n), 取其数量级用符号&quot;O&quot;表示即可。 具体计算数量级时， 可以遵循以下定理。</p>\n</blockquote>\n<h3 id=\"示例\"> 示例</h3>\n<ul>\n<li>常量阶示例。</li>\n</ul>\n<div><pre><code> <span>{</span>x<span>++</span><span>;</span>s<span>=</span><span>O</span><span>;</span><span>}</span>  \n</code></pre>\n<div><span>1</span><br></div></div><p>两条语句频度均为1' 算法的执行时间是一个与问题规模n无关的常数， 所以算法的时间复 杂度为T(n) = 0(1), 称为常量阶。 实际上，如果算法的执行时间不随问题规模n的增加而增长，算法中语句频度就是某个常数。 即使这个常数再大， 算法的时间复杂度都是 0(1)。例如， 上面的程序作如下改动：</p>\n<div><pre><code><span>for</span> <span>(</span>i<span>=</span><span>O</span><span>;</span>i<span>&lt;</span>lOOOO<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n    x<span>++</span><span>;</span> s<span>=</span><span>O</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>算法的时间复杂度仍然为 <strong>0(1)</strong>。</p>\n<ul>\n<li>线性阶示例。</li>\n</ul>\n<div><pre><code><span>for</span> <span>(</span>i<span>=</span><span>O</span><span>;</span> i<span>&lt;</span>n<span>;</span> i<span>++</span><span>)</span> <span>{</span>x<span>++</span><span>;</span> s<span>=</span><span>O</span><span>;</span><span>)</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>循环体内两条基本语句的频度均为f{n) =n, 所以算法的时间复杂度为T(n) = O(n), 称为线 性阶。</p>\n<ul>\n<li>平方阶示例。</li>\n</ul>\n<div><pre><code>x<span>=</span><span>O</span><span>;</span>y<span>=</span><span>O</span><span>;</span>\n<span>for</span> <span>(</span>k<span>=</span>l<span>;</span> k<span>&lt;=</span>n<span>;</span> k<span>++</span><span>)</span>\n\tx<span>++</span><span>;</span>\n<span>for</span><span>(</span>i<span>=</span>l<span>;</span>i<span>&lt;=</span>n<span>;</span>i<span>++</span><span>)</span>\n\t<span>for</span><span>(</span>j<span>=</span>l<span>;</span>j<span>&lt;=</span>n<span>;</span>j<span>++</span><span>)</span>\n\t\ty<span>++</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>对循环语句只需考虑循环体中语句的执行次数， 以上程序段中频度最大的语句是(6), 其频 度为f(n) = n2 , 所以该算法的时间复杂度为T(n) = O(n2)， 称为平方阶。 <strong>多数情况下， 当有若干个循环语句时， 算法的时间复杂度是由最深层循环内的基本语句的频 度j(n)决定的。</strong></p>\n<ul>\n<li>立方阶示例。</li>\n</ul>\n<div><pre><code>x<span>=</span>l<span>;</span>\n<span>for</span> <span>(</span>i<span>=</span>l<span>;</span> i<span>&lt;=</span>n<span>;</span> i<span>++</span><span>)</span>\n\t<span>for</span><span>(</span>j<span>=</span>l<span>;</span>j<span>&lt;=</span>i<span>;</span>j<span>++</span><span>)</span>\n\t\t<span>for</span> <span>(</span>k<span>=</span>l<span>;</span> k<span>&lt;=</span>j<span>;</span> k<span>++</span><span>)</span>\n\t\t\tx<span>++</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><ul>\n<li>对数阶示例</li>\n</ul>\n<div><pre><code><span>for</span> <span>(</span>i<span>=</span>l<span>;</span> i<span>&lt;=</span>n<span>;</span> i<span>=</span>i<span>*</span><span>2</span><span>)</span> <span>{</span>x<span>++</span><span>;</span>s<span>=</span><span>O</span><span>;</span><span>)</span> \n</code></pre>\n<div><span>1</span><br></div></div><blockquote>\n<p>注：log2n省略为logn，因为即使log的底数不同，整体时间复杂度趋势一样，所以或略</p>\n</blockquote>\n<h3 id=\"比较\"> 比较</h3>\n<p>常量阶 &lt; 对数阶 &lt; 线性阶 &lt; 线性对数阶 &lt; 平方阶 &lt; 立方阶 &lt; n的k次方 &lt; 指数阶</p>\n<h3 id=\"最好、最坏和平均时间复杂度\"> 最好、最坏和平均时间复杂度</h3>\n<h2 id=\"线性表\"> 线性表</h2>\n<h3 id=\"特征\"> 特征</h3>\n<p>对千非空的线性表或线性结构， 其特点是：</p>\n<div><p>特征</p>\n<ul>\n<li>存在唯一的一个被称作 “第一个 ＂ 的数据元素；</li>\n<li>存在唯一的一个被称作 “最后一个＂ 的数据元素；</li>\n<li>除第一个之外， 结构中的每个数据元素均只有一个<strong>前驱</strong>；</li>\n<li>除最后一个之外，结构中的每个数据元素均只有一个<strong>后继</strong>。</li>\n</ul>\n</div>\n<h3 id=\"分类\"> 分类</h3>\n<p>根据<strong>存储结构</strong>划分可分为<strong>顺序存储结构</strong>和<strong>链式存储结构</strong></p>\n<h2 id=\"_3-稀疏数组\"> 3. 稀疏数组</h2>\n<p><strong>只适用于大部分元素为相同时，比如五子棋</strong></p>\n<p><img src=\"./images/DataStructure/SparseArray_1.jpg\" alt=\"稀疏数组1\" /></p>\n<p><strong>第一行记录总行和总列数和除0外有多少个非零数据，剩余的行则记录每个数据的位置和值</strong></p>\n<p><img src=\"./images/DataStructure/SparseArray_2.jpg\" alt=\"稀疏数组2\" /></p>\n<p><strong>etc:五子棋</strong></p>\n<p><img src=\"./images/DataStructure/SparseArray_3.jpg\" alt=\"稀疏数组3\" /></p>\n<p><strong>Java代码</strong></p>\n\n          <div\n            id=\"code-demo-0387b28a\"\n           \n  \n data-title=\"Java%E4%BB%A3%E7%A0%81\"\n\n            data-code=\"%7B%22java%22%3A%22public%20class%20SparseArray%20%7B%5Cn%20%20%20%20public%20static%20void%20main(String%5B%5D%20args)%20%7B%5Cn%20%20%20%20%20%20%20%20%2F*0%EF%BC%9A%E6%B2%A1%E6%9C%89%E6%A3%8B%E5%AD%90%EF%BC%8C1%EF%BC%9A%E8%A1%A8%E7%A4%BA%E9%BB%91%E5%AD%90%EF%BC%8C2%EF%BC%9A%E8%A1%A8%E7%A4%BA%E7%99%BD%E5%AD%90*%2F%5Cn%20%20%20%20%20%20%20%20int%20chessArr%5B%5D%5B%5D%20%3D%20new%20int%5B11%5D%5B11%5D%3B%5Cn%20%20%20%20%20%20%20%20chessArr%5B1%5D%5B2%5D%20%3D%201%3B%5Cn%20%20%20%20%20%20%20%20chessArr%5B2%5D%5B4%5D%20%3D%202%3B%5Cn%20%20%20%20%20%20%20%20chessArr%5B3%5D%5B8%5D%20%3D%2010%3B%5Cn%2F%2F%20%20%20%20%20%20%20%20%E8%BE%93%E5%87%BA%E5%8E%9F%E5%A7%8B%E4%B8%BA%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%5Cn%20%20%20%20%20%20%20%20System.out.println(%5C%22%E5%8E%9F%E5%A7%8B%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%5C%22)%3B%5Cn%20%20%20%20%20%20%20%20for(int%5B%5D%20row%20%3A%20chessArr)%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20for(int%20data%3A%20row)%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20System.out.printf(%5C%22%25d%5C%5Ct%5C%22%2Cdata)%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20%20%20%20%20System.out.println()%3B%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%5Cn%2F%2F%20%20%20%20%20%20%20%20%E5%B0%86%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E8%BD%AC%E4%B8%BA%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84%5Cn%2F%2F%20%20%20%20%20%20%20%201.%E5%85%88%E9%81%8D%E5%8E%86%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E9%9D%9E0%E7%9A%84%E4%B8%AA%E6%95%B0%5Cn%20%20%20%20%20%20%20%20int%20sum%20%3D%200%3B%5Cn%20%20%20%20%20%20%20%20for(int%20i%20%3D%200%3B%20i%20%3C%2011%3Bi%2B%2B)%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20for(int%20j%20%3D%200%3B%20j%20%3C%2011%3Bj%2B%2B)%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20if(chessArr%5Bi%5D%5Bj%5D%20!%3D%200)%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20sum%2B%2B%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%5Cn%20%20%20%20%20%20%20%20System.out.println(%5C%22%E9%9D%9E0%E4%B8%AA%E6%95%B0%E4%B8%BA%5C%22%2Bsum)%3B%5Cn%5Cn%2F%2F%20%20%20%20%20%20%20%202.%E5%88%9B%E5%BB%BA%E7%9B%B8%E5%BA%94%E7%9A%84%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84%5Cn%20%20%20%20%20%20%20%20int%20sparseArr%5B%5D%5B%5D%20%3D%20new%20int%5Bsum%2B1%5D%5B3%5D%3B%5Cn%20%20%20%20%20%20%20%20sparseArr%5B0%5D%5B0%5D%20%3D%2011%3B%5Cn%20%20%20%20%20%20%20%20sparseArr%5B0%5D%5B1%5D%20%3D%2011%3B%5Cn%20%20%20%20%20%20%20%20sparseArr%5B0%5D%5B2%5D%20%3D%20sum%3B%5Cn%5Cn%2F%2F%20%20%20%20%20%20%20%20%E9%81%8D%E5%8E%86%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%EF%BC%8C%E5%B0%86%E9%9D%9E0%E7%9A%84%E5%80%BC%E5%AD%98%E6%94%BE%E5%88%B0sparseArr%E4%B8%AD%5Cn%20%20%20%20%20%20%20%20int%20count%20%3D%200%3B%5Cn%20%20%20%20%20%20%20%20for(int%20i%20%3D%200%3B%20i%20%3C%2011%3B%20i%2B%2B)%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20for(int%20j%20%3D%200%3B%20j%20%3C%2011%3B%20j%2B%2B)%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20if(chessArr%5Bi%5D%5Bj%5D%20!%3D%200)%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20count%2B%2B%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20sparseArr%5Bcount%5D%5B0%5D%20%3D%20i%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20sparseArr%5Bcount%5D%5B1%5D%20%3D%20j%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20sparseArr%5Bcount%5D%5B2%5D%20%3D%20chessArr%5Bi%5D%5Bj%5D%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%5Cn%2F%2F%20%20%20%20%20%20%20%20%E8%BE%93%E5%87%BA%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84%5Cn%20%20%20%20%20%20%20%20System.out.println()%3B%5Cn%20%20%20%20%20%20%20%20System.out.println(%5C%22%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84%5C%22)%3B%5Cn%20%20%20%20%20%20%20%20for(int%5B%5D%20row%20%3A%20sparseArr)%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20for(int%20data%3A%20row)%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20System.out.printf(%5C%22%25d%5C%5Ct%5C%22%2Cdata)%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20%20%20%20%20System.out.println()%3B%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%5Cn%2F%2F%20%20%20%20%20%20%20%203.%E5%B0%86%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%5Cn%2F%2F%20%20%20%20%20%20%20%20%E5%A3%B0%E6%98%8E%E6%95%B0%E7%BB%84%5Cn%20%20%20%20%20%20%20%20int%20chessArry2%5B%5D%5B%5D%20%3D%20new%20int%5BsparseArr%5B0%5D%5B0%5D%5D%5BsparseArr%5B0%5D%5B1%5D%5D%3B%5Cn%5Cn%20%20%20%20%20%20%20%20for(int%20i%20%20%3D%201%3B%20i%20%3C%20sparseArr.length%3B%20i%2B%2B)%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20chessArry2%5BsparseArr%5Bi%5D%5B0%5D%5D%5BsparseArr%5Bi%5D%5B1%5D%5D%20%3D%20sparseArr%5Bi%5D%5B2%5D%3B%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%5Cn%20%20%20%20%20%20%20%20%2F%2F%20%20%20%20%20%20%20%20%E8%BE%93%E5%87%BA%E8%BD%AC%E6%8D%A2%E5%90%8E%E7%9A%84%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%5Cn%20%20%20%20%20%20%20%20System.out.println(%5C%22%E8%BD%AC%E6%8D%A2%E5%90%8E%E7%9A%84%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%5C%22)%3B%5Cn%20%20%20%20%20%20%20%20for(int%5B%5D%20row%20%3A%20chessArr)%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20for(int%20data%3A%20row)%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20System.out.printf(%5C%22%25d%5C%5Ct%5C%22%2Cdata)%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20%20%20%20%20System.out.println()%3B%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%7D%5Cn%5Cn%7D%5Cn%22%7D\"\n          >\n              \n              <div>\n                <div>\n<div><pre><code><span>public</span> <span>class</span> <span>SparseArray</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>/*0：没有棋子，1：表示黑子，2：表示白子*/</span>\n        <span>int</span> chessArr<span>[</span><span>]</span><span>[</span><span>]</span> <span>=</span> <span>new</span> <span>int</span><span>[</span><span>11</span><span>]</span><span>[</span><span>11</span><span>]</span><span>;</span>\n        chessArr<span>[</span><span>1</span><span>]</span><span>[</span><span>2</span><span>]</span> <span>=</span> <span>1</span><span>;</span>\n        chessArr<span>[</span><span>2</span><span>]</span><span>[</span><span>4</span><span>]</span> <span>=</span> <span>2</span><span>;</span>\n        chessArr<span>[</span><span>3</span><span>]</span><span>[</span><span>8</span><span>]</span> <span>=</span> <span>10</span><span>;</span>\n<span>//        输出原始为二维数组</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"原始二维数组\"</span><span>)</span><span>;</span>\n        <span>for</span><span>(</span><span>int</span><span>[</span><span>]</span> row <span>:</span> chessArr<span>)</span><span>{</span>\n            <span>for</span><span>(</span><span>int</span> data<span>:</span> row<span>)</span><span>{</span>\n                <span>System</span><span>.</span>out<span>.</span><span>printf</span><span>(</span><span>\"%d\\t\"</span><span>,</span>data<span>)</span><span>;</span>\n            <span>}</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n\n<span>//        将二维数组转为稀疏数组</span>\n<span>//        1.先遍历二维数组非0的个数</span>\n        <span>int</span> sum <span>=</span> <span>0</span><span>;</span>\n        <span>for</span><span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>11</span><span>;</span>i<span>++</span><span>)</span><span>{</span>\n            <span>for</span><span>(</span><span>int</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> <span>11</span><span>;</span>j<span>++</span><span>)</span><span>{</span>\n                <span>if</span><span>(</span>chessArr<span>[</span>i<span>]</span><span>[</span>j<span>]</span> <span>!=</span> <span>0</span><span>)</span><span>{</span>\n                    sum<span>++</span><span>;</span>\n                <span>}</span>\n            <span>}</span>\n        <span>}</span>\n\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"非0个数为\"</span><span>+</span>sum<span>)</span><span>;</span>\n\n<span>//        2.创建相应的稀疏数组</span>\n        <span>int</span> sparseArr<span>[</span><span>]</span><span>[</span><span>]</span> <span>=</span> <span>new</span> <span>int</span><span>[</span>sum<span>+</span><span>1</span><span>]</span><span>[</span><span>3</span><span>]</span><span>;</span>\n        sparseArr<span>[</span><span>0</span><span>]</span><span>[</span><span>0</span><span>]</span> <span>=</span> <span>11</span><span>;</span>\n        sparseArr<span>[</span><span>0</span><span>]</span><span>[</span><span>1</span><span>]</span> <span>=</span> <span>11</span><span>;</span>\n        sparseArr<span>[</span><span>0</span><span>]</span><span>[</span><span>2</span><span>]</span> <span>=</span> sum<span>;</span>\n\n<span>//        遍历二维数组，将非0的值存放到sparseArr中</span>\n        <span>int</span> count <span>=</span> <span>0</span><span>;</span>\n        <span>for</span><span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>11</span><span>;</span> i<span>++</span><span>)</span><span>{</span>\n            <span>for</span><span>(</span><span>int</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> <span>11</span><span>;</span> j<span>++</span><span>)</span><span>{</span>\n                <span>if</span><span>(</span>chessArr<span>[</span>i<span>]</span><span>[</span>j<span>]</span> <span>!=</span> <span>0</span><span>)</span><span>{</span>\n                    count<span>++</span><span>;</span>\n                    sparseArr<span>[</span>count<span>]</span><span>[</span><span>0</span><span>]</span> <span>=</span> i<span>;</span>\n                    sparseArr<span>[</span>count<span>]</span><span>[</span><span>1</span><span>]</span> <span>=</span> j<span>;</span>\n                    sparseArr<span>[</span>count<span>]</span><span>[</span><span>2</span><span>]</span> <span>=</span> chessArr<span>[</span>i<span>]</span><span>[</span>j<span>]</span><span>;</span>\n                <span>}</span>\n            <span>}</span>\n        <span>}</span>\n\n<span>//        输出稀疏数组</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"稀疏数组\"</span><span>)</span><span>;</span>\n        <span>for</span><span>(</span><span>int</span><span>[</span><span>]</span> row <span>:</span> sparseArr<span>)</span><span>{</span>\n            <span>for</span><span>(</span><span>int</span> data<span>:</span> row<span>)</span><span>{</span>\n                <span>System</span><span>.</span>out<span>.</span><span>printf</span><span>(</span><span>\"%d\\t\"</span><span>,</span>data<span>)</span><span>;</span>\n            <span>}</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n\n<span>//        3.将稀疏数组转换为二维数组</span>\n<span>//        声明数组</span>\n        <span>int</span> chessArry2<span>[</span><span>]</span><span>[</span><span>]</span> <span>=</span> <span>new</span> <span>int</span><span>[</span>sparseArr<span>[</span><span>0</span><span>]</span><span>[</span><span>0</span><span>]</span><span>]</span><span>[</span>sparseArr<span>[</span><span>0</span><span>]</span><span>[</span><span>1</span><span>]</span><span>]</span><span>;</span>\n\n        <span>for</span><span>(</span><span>int</span> i  <span>=</span> <span>1</span><span>;</span> i <span>&lt;</span> sparseArr<span>.</span>length<span>;</span> i<span>++</span><span>)</span><span>{</span>\n            chessArry2<span>[</span>sparseArr<span>[</span>i<span>]</span><span>[</span><span>0</span><span>]</span><span>]</span><span>[</span>sparseArr<span>[</span>i<span>]</span><span>[</span><span>1</span><span>]</span><span>]</span> <span>=</span> sparseArr<span>[</span>i<span>]</span><span>[</span><span>2</span><span>]</span><span>;</span>\n        <span>}</span>\n\n        <span>//        输出转换后的二维数组</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"转换后的二维数组\"</span><span>)</span><span>;</span>\n        <span>for</span><span>(</span><span>int</span><span>[</span><span>]</span> row <span>:</span> chessArr<span>)</span><span>{</span>\n            <span>for</span><span>(</span><span>int</span> data<span>:</span> row<span>)</span><span>{</span>\n                <span>System</span><span>.</span>out<span>.</span><span>printf</span><span>(</span><span>\"%d\\t\"</span><span>,</span>data<span>)</span><span>;</span>\n            <span>}</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br></div></div>\n            </div>\n          </div>\n          \n        </div>\n<p><strong>运行结果</strong></p>\n<p><img src=\"./images/DataStructure/SparseArray_run_results.jpg\" alt=\"稀疏数组运行结果\" /></p>\n<h2 id=\"_4-队列\"> 4. 队列</h2>\n<p>先进先出</p>\n<h3 id=\"_4-1-用数组模拟队列实现\"> 4.1 用数组模拟队列实现</h3>\n<ul>\n<li>\n<p>队列本身是<strong>有序列表</strong>,若使用数组的结构来存储队列的数据,则队列数组的声明如下图,其中<strong>maxSize</strong>是该队列的最大容量</p>\n</li>\n<li>\n<p>因为队列的输出、翰入是分别从前后端来处理,因此需要两个变量 <strong>front</strong> 及<strong>rear</strong>分别记录队列前后端的下标,<strong>front会随着数据输出而改变,而rear则是随着数据输入而改变</strong>,如图所示:</p>\n</li>\n</ul>\n<p><img src=\"./images/DataStructure/queue.jpg\" alt=\"队列\" /></p>\n<ol>\n<li><strong>初始化队列</strong></li>\n</ol>\n<div><pre><code>    <span>private</span> <span>int</span> maxSize<span>;</span><span>// 表示数组最大容量</span>\n    <span>private</span> <span>int</span> front<span>;</span> <span>// 队列头指针指向队列头的前一个位置</span>\n    <span>private</span> <span>int</span> rear<span>;</span> <span>// 队列尾指针</span>\n    <span>private</span> <span>int</span><span>[</span><span>]</span> arr<span>;</span> <span>// 该数据用于存放数据，模拟队列</span>\n\n    <span>//        创建队列的构造器</span>\n    <span>public</span> <span>ArrayQueue</span><span>(</span><span>int</span> arrMaxSize<span>)</span> <span>{</span>\n        maxSize <span>=</span> arrMaxSize<span>;</span>\n        arrQueue <span>=</span> <span>new</span> <span>int</span><span>[</span>maxSize<span>]</span><span>;</span>\n        front <span>=</span> <span>-</span><span>1</span><span>;</span> <span>// 指向队列头部，分析出front是指向队列头的前一个位置，当队列执行出操作时++</span>\n        rear <span>=</span> <span>-</span><span>1</span><span>;</span> <span>// 向队列队尾，指向队列尾的数据(队列最后一个数据)，当队列执行入操作时++</span>\n    <span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><ol start=\"2\">\n<li><strong>判断队列是否已满</strong></li>\n</ol>\n<p>当 <strong>rear = maxSize - 1</strong> 时队列满</p>\n<div><pre><code>    <span>//        判断队列是否满</span>\n    <span>public</span> <span>boolean</span> <span>isFull</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> rear <span>==</span> maxSize <span>-</span> <span>1</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><ol start=\"3\">\n<li><strong>判断队列是否为空</strong></li>\n</ol>\n<p>当 <strong>rear == front</strong> 时队列为空</p>\n<div><pre><code>    <span>//        判断队列是否空</span>\n    <span>public</span> <span>boolean</span> <span>isEmpty</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> rear <span>==</span> front<span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><ol start=\"4\">\n<li><strong>入队操作 addQueue</strong></li>\n</ol>\n<p><strong>需要两个步骤</strong></p>\n<ul>\n<li>先判断队列是否已满，当 <strong>rear == maxSize-1</strong> 时队列满无法插入</li>\n<li>若尾指针 <strong>rear</strong> 小于队列的最大下标 <strong>maxSize-1</strong> ,则先将 <strong>rear++</strong>，再将数据n赋值给 <strong>arrQueue[rear] = n</strong></li>\n</ul>\n<div><pre><code>    <span>//        入队操作</span>\n    <span>public</span> <span>void</span> <span>addQueue</span><span>(</span><span>int</span> n<span>)</span> <span>{</span>\n        <span>//        判断队列是否满</span>\n        <span>if</span> <span>(</span><span>isFull</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"队列已满\"</span><span>)</span><span>;</span>\n            <span>return</span><span>;</span>\n        <span>}</span>\n        rear<span>++</span><span>;</span>\n        arr<span>[</span>rear<span>]</span> <span>=</span> n<span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><ol start=\"5\">\n<li><strong>出队操作 outQueue</strong></li>\n</ol>\n<p><strong>需要两个步骤</strong></p>\n<ul>\n<li>先判断队列是否为空，当 <strong>rear == front</strong> 时队列为空无法出队</li>\n<li>若头指针 <strong>front != rear</strong> ，<strong>front++</strong> ，因为front指向队列头的前一个位置，所以返回的出队数据为 <strong>arrQueue[front]</strong></li>\n</ul>\n<div><pre><code>    <span>//        出队操作</span>\n    <span>public</span> <span>int</span> <span>outQueue</span><span>(</span><span>)</span> <span>{</span>\n        <span>//        判断队列是否满</span>\n        <span>if</span> <span>(</span><span>isEmpty</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"队列为空\"</span><span>)</span><span>;</span>\n            <span>throw</span> <span>new</span> <span>RuntimeException</span><span>(</span><span>\"队列为空\"</span><span>)</span><span>;</span>\n        <span>}</span>\n        front<span>++</span><span>;</span>\n        <span>return</span> arrQueue<span>[</span>front<span>]</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><ol start=\"6\">\n<li><strong>显示队列</strong></li>\n</ol>\n<div><pre><code>    <span>public</span> <span>void</span> <span>showQueue</span><span>(</span><span>)</span> <span>{</span>\n        <span>//遍历</span>\n        <span>if</span> <span>(</span><span>isEmpty</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"队列为空\"</span><span>)</span><span>;</span>\n            <span>return</span><span>;</span>\n        <span>}</span>\n        <span>for</span> <span>(</span><span>int</span> i <span>=</span> front<span>+</span><span>1</span><span>;</span> i <span>&lt;</span> rear<span>+</span><span>1</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>printf</span><span>(</span><span>\"arr[%d] = %d\\n\"</span><span>,</span> i<span>,</span> arrQueue<span>[</span>i<span>]</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><ol start=\"7\">\n<li><strong>用数组实现队列模拟代码</strong></li>\n</ol>\n<div><pre><code><span>public</span> <span>class</span> <span>ArrayQueue</span> <span>{</span>\n    <span>private</span> <span>int</span> maxSize<span>;</span><span>// 表示数组最大容量</span>\n    <span>private</span> <span>int</span> front<span>;</span> <span>// 队列头指针指向队列头的前一个位置</span>\n    <span>private</span> <span>int</span> rear<span>;</span> <span>// 队列尾指针</span>\n    <span>private</span> <span>int</span><span>[</span><span>]</span> arrQueue<span>;</span> <span>// 该数据用于存放数据，模拟队列</span>\n\n    <span>//        创建队列的构造器</span>\n    <span>public</span> <span>ArrayQueue</span><span>(</span><span>int</span> arrMaxSize<span>)</span> <span>{</span>\n        maxSize <span>=</span> arrMaxSize<span>;</span>\n        arrQueue <span>=</span> <span>new</span> <span>int</span><span>[</span>maxSize<span>]</span><span>;</span>\n        front <span>=</span> <span>-</span><span>1</span><span>;</span> <span>// 指向队列头部，分析出front是指向队列头的前一个位置，当队列执行出操作时++</span>\n        rear <span>=</span> <span>-</span><span>1</span><span>;</span> <span>// 向队列队尾，指向队列尾的数据(队列最后一个数据)，当队列执行入操作时++</span>\n    <span>}</span>\n\n    <span>//        判断队列是否满</span>\n    <span>public</span> <span>boolean</span> <span>isFull</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> rear <span>==</span> maxSize <span>-</span> <span>1</span><span>;</span>\n    <span>}</span>\n\n    <span>//        判断队列是否空</span>\n    <span>public</span> <span>boolean</span> <span>isEmpty</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> rear <span>==</span> front<span>;</span>\n    <span>}</span>\n\n    <span>//        入队操作</span>\n    <span>public</span> <span>void</span> <span>addQueue</span><span>(</span><span>int</span> n<span>)</span> <span>{</span>\n        <span>//        判断队列是否满</span>\n        <span>if</span> <span>(</span><span>isFull</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"队列已满\"</span><span>)</span><span>;</span>\n            <span>return</span><span>;</span>\n        <span>}</span>\n        rear<span>++</span><span>;</span>\n        arrQueue<span>[</span>rear<span>]</span> <span>=</span> n<span>;</span>\n    <span>}</span>\n\n    <span>//        出队操作</span>\n    <span>public</span> <span>int</span> <span>outQueue</span><span>(</span><span>)</span> <span>{</span>\n        <span>//        判断队列是否满</span>\n        <span>if</span> <span>(</span><span>isEmpty</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"队列为空\"</span><span>)</span><span>;</span>\n            <span>throw</span> <span>new</span> <span>RuntimeException</span><span>(</span><span>\"队列为空\"</span><span>)</span><span>;</span>\n        <span>}</span>\n        front<span>++</span><span>;</span>\n        <span>return</span> arrQueue<span>[</span>front<span>]</span><span>;</span>\n    <span>}</span>\n\n    <span>//    查看未出队的数据</span>\n    <span>public</span> <span>void</span> <span>showQueue</span><span>(</span><span>)</span> <span>{</span>\n        <span>//遍历</span>\n        <span>if</span> <span>(</span><span>isEmpty</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"队列为空\"</span><span>)</span><span>;</span>\n            <span>return</span><span>;</span>\n        <span>}</span>\n        <span>for</span> <span>(</span><span>int</span> i <span>=</span> front<span>+</span><span>1</span><span>;</span> i <span>&lt;</span> rear<span>+</span><span>1</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>printf</span><span>(</span><span>\"arr[%d] = %d\\n\"</span><span>,</span> i<span>,</span> arrQueue<span>[</span>i<span>]</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>//    显示队列的头数据，并不是取出操作</span>\n    <span>public</span> <span>int</span> <span>headQueue</span><span>(</span><span>)</span> <span>{</span>\n        <span>if</span><span>(</span><span>isEmpty</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n            <span>throw</span> <span>new</span> <span>RuntimeException</span><span>(</span><span>\"队列为空\"</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>return</span> arrQueue<span>[</span>front <span>+</span> <span>1</span><span>]</span><span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n<span>//        构造数组队列</span>\n        <span>ArrayQueue</span> arrayQueue <span>=</span> <span>new</span> <span>ArrayQueue</span><span>(</span><span>2</span><span>)</span><span>;</span>\n        <span>char</span> input<span>;</span>\n        <span>Scanner</span> scanner <span>=</span> <span>new</span> <span>Scanner</span><span>(</span><span>System</span><span>.</span>in<span>)</span><span>;</span>\n        <span>boolean</span> loop <span>=</span> <span>true</span><span>;</span>\n\n        <span>while</span> <span>(</span>loop<span>)</span><span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>)</span><span>;</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"a(add)：入队\"</span><span>)</span><span>;</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"g(get)：出队\"</span><span>)</span><span>;</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"s(show)：显示队列\"</span><span>)</span><span>;</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"h(head)：查看队列头数据\"</span><span>)</span><span>;</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"e(exit)：退出程序\"</span><span>)</span><span>;</span>\n\n            input <span>=</span> scanner<span>.</span><span>next</span><span>(</span><span>)</span><span>.</span><span>charAt</span><span>(</span><span>0</span><span>)</span><span>;</span>\n            <span>switch</span> <span>(</span>input<span>)</span><span>{</span>\n\n                <span>//输出队列</span>\n                <span>case</span>  <span>'s'</span> <span>:</span>\n                    arrayQueue<span>.</span><span>showQueue</span><span>(</span><span>)</span><span>;</span>\n                    <span>break</span><span>;</span>\n\n                <span>//入队操作</span>\n                <span>case</span>  <span>'a'</span> <span>:</span>\n                    <span>int</span> value <span>=</span> scanner<span>.</span><span>nextInt</span><span>(</span><span>)</span><span>;</span>\n                    arrayQueue<span>.</span><span>addQueue</span><span>(</span>value<span>)</span><span>;</span>\n                    <span>break</span><span>;</span>\n\n                <span>//出队操作</span>\n                <span>case</span>  <span>'g'</span> <span>:</span>\n                    <span>try</span> <span>{</span>\n                        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"出队的数据为 = \"</span> <span>+</span> arrayQueue<span>.</span><span>outQueue</span><span>(</span><span>)</span><span>)</span><span>;</span>\n                    <span>}</span><span>catch</span> <span>(</span><span>Exception</span> e<span>)</span><span>{</span>\n                        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>e<span>.</span><span>getMessage</span><span>(</span><span>)</span><span>)</span><span>;</span>\n                    <span>}</span>\n                    <span>break</span><span>;</span>\n\n                <span>//输出队列头数据</span>\n                <span>case</span>  <span>'h'</span> <span>:</span>\n                    <span>try</span> <span>{</span>\n                        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"队列的头数据为 = \"</span> <span>+</span> arrayQueue<span>.</span><span>headQueue</span><span>(</span><span>)</span><span>)</span><span>;</span>\n                    <span>}</span><span>catch</span> <span>(</span><span>Exception</span> e<span>)</span><span>{</span>\n                        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>e<span>.</span><span>getMessage</span><span>(</span><span>)</span><span>)</span><span>;</span>\n                    <span>}</span>\n                    <span>break</span><span>;</span>\n\n                <span>//退出</span>\n                <span>case</span>  <span>'e'</span> <span>:</span>\n                    scanner<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span>\n                    loop <span>=</span> <span>false</span><span>;</span>\n                   <span>break</span><span>;</span>\n\n                <span>default</span><span>:</span>\n                    <span>break</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br><span>111</span><br><span>112</span><br><span>113</span><br><span>114</span><br><span>115</span><br><span>116</span><br><span>117</span><br><span>118</span><br><span>119</span><br><span>120</span><br><span>121</span><br><span>122</span><br><span>123</span><br><span>124</span><br><span>125</span><br></div></div><h2 id=\"_5-树\"> 5 树</h2>\n<h3 id=\"_5-1-二叉树\"> 5.1 二叉树</h3>\n<p>参考</p>\n<blockquote>\n<ul>\n<li>https://mp.weixin.qq.com/s/mBXfpH4nuIltyHm72zLryw</li>\n</ul>\n</blockquote>\n<ul>\n<li>前序遍历：根结点 -&gt; 左子树 -&gt; 右子树</li>\n<li>中序遍历：左子树 -&gt; 根结点 -&gt; 右子树</li>\n<li>后序遍历：左子树 -&gt; 右子树 -&gt; 根结点</li>\n</ul>\n<h4 id=\"二叉树结点构造\"> 二叉树结点构造</h4>\n<div><pre><code><span>public</span> <span>class</span> <span>TreeNode</span> <span>{</span>\n    <span>public</span> <span>int</span> val<span>;</span>\n    <span>public</span> <span>TreeNode</span> left<span>;</span>\n    <span>public</span> <span>TreeNode</span> right<span>;</span>\n \n     <span>public</span> <span>TreeNode</span><span>(</span><span>int</span> x<span>)</span> <span>{</span>\n         val <span>=</span> x<span>;</span>\n     <span>}</span>\n \n    <span>public</span> <span>TreeNode</span><span>(</span><span>)</span> <span>{</span>\n    <span>}</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>String</span> <span>toString</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>\"[\"</span> <span>+</span> val <span>+</span> <span>\"]\"</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h4 id=\"前序遍历\"> 前序遍历</h4>\n<p><img src=\"./images/DataStructure/Preorder_traversal.jpg\" alt=\"前序遍历\" /></p>\n<div><pre><code><span>static</span> <span>ArrayList</span><span><span>&lt;</span><span>Integer</span><span>></span></span> arrayList <span>=</span> <span>new</span> <span>ArrayList</span><span>(</span><span>)</span><span>;</span>\n<span>public</span> <span>static</span> <span>void</span> <span>preOrder</span><span>(</span><span>TreeNode</span> tree<span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>tree <span>==</span> <span>null</span><span>)</span>\n        <span>return</span><span>;</span>\n  \tarrayList<span>.</span><span>add</span><span>(</span>tree<span>.</span>val<span>)</span>\n    <span>preOrder</span><span>(</span>tree<span>.</span>left<span>)</span><span>;</span>\n    <span>preOrder</span><span>(</span>tree<span>.</span>right<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h4 id=\"中序遍历\"> 中序遍历</h4>\n<p><img src=\"./images/DataStructure/in-order_traversal.jpg\" alt=\"中序遍历\" /></p>\n<div><pre><code><span>static</span> <span>ArrayList</span><span><span>&lt;</span><span>Integer</span><span>></span></span> arrayList <span>=</span> <span>new</span> <span>ArrayList</span><span>(</span><span>)</span><span>;</span>\n<span>public</span> <span>static</span> <span>void</span> <span>inOrderTraversal</span><span>(</span><span>TreeNode</span> node<span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>node <span>==</span> <span>null</span><span>)</span>\n        <span>return</span><span>;</span>\n    <span>inOrderTraversal</span><span>(</span>node<span>.</span>left<span>)</span><span>;</span>\n    arrayList<span>.</span><span>add</span><span>(</span>tree<span>.</span>val<span>)</span>\n    <span>inOrderTraversal</span><span>(</span>node<span>.</span>right<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h4 id=\"后序遍历\"> 后序遍历</h4>\n<p><img src=\"./images/DataStructure/Post-order_traversal.jpg\" alt=\"后序遍历\" /></p>\n<div><pre><code><span>static</span> <span>ArrayList</span><span><span>&lt;</span><span>Integer</span><span>></span></span> arrayList <span>=</span> <span>new</span> <span>ArrayList</span><span>(</span><span>)</span><span>;</span>\n<span>public</span> <span>static</span> <span>void</span> <span>inOrderTraversal</span><span>(</span><span>TreeNode</span> node<span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>node <span>==</span> <span>null</span><span>)</span>\n        <span>return</span><span>;</span>\n    <span>inOrderTraversal</span><span>(</span>node<span>.</span>left<span>)</span><span>;</span>  \n    <span>inOrderTraversal</span><span>(</span>node<span>.</span>right<span>)</span><span>;</span>\n  \tarrayList<span>.</span><span>add</span><span>(</span>tree<span>.</span>val<span>)</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h4 id=\"根据前序和中序遍历构建二叉树\"> 根据前序和中序遍历构建二叉树</h4>\n<div><pre><code><span>class</span> <span>Solution</span> <span>{</span>\n    <span>HashMap</span><span><span>&lt;</span><span>Integer</span><span>,</span> <span>Integer</span><span>></span></span> dic <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n    <span>int</span><span>[</span><span>]</span> po<span>;</span>\n    <span>public</span> <span>TreeNode</span> <span>buildTree</span><span>(</span><span>int</span><span>[</span><span>]</span> preorder<span>,</span> <span>int</span><span>[</span><span>]</span> inorder<span>)</span> <span>{</span>\n        po <span>=</span> preorder<span>;</span>\n        <span>for</span><span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> inorder<span>.</span>length<span>;</span> i<span>++</span><span>)</span> \n            dic<span>.</span><span>put</span><span>(</span>inorder<span>[</span>i<span>]</span><span>,</span> i<span>)</span><span>;</span>\n        <span>return</span> <span>recur</span><span>(</span><span>0</span><span>,</span> <span>0</span><span>,</span> inorder<span>.</span>length <span>-</span> <span>1</span><span>)</span><span>;</span>\n    <span>}</span>\n    <span>TreeNode</span> <span>recur</span><span>(</span><span>int</span> pre_root<span>,</span> <span>int</span> in_left<span>,</span> <span>int</span> in_right<span>)</span> <span>{</span>\n        <span>if</span><span>(</span>in_left <span>></span> in_right<span>)</span> <span>return</span> <span>null</span><span>;</span>\n        <span>TreeNode</span> root <span>=</span> <span>new</span> <span>TreeNode</span><span>(</span>po<span>[</span>pre_root<span>]</span><span>)</span><span>;</span>\n        <span>int</span> i <span>=</span> dic<span>.</span><span>get</span><span>(</span>po<span>[</span>pre_root<span>]</span><span>)</span><span>;</span>\n        root<span>.</span>left <span>=</span> <span>recur</span><span>(</span>pre_root <span>+</span> <span>1</span><span>,</span> in_left<span>,</span> i <span>-</span> <span>1</span><span>)</span><span>;</span>\n        root<span>.</span>right <span>=</span> <span>recur</span><span>(</span>pre_root <span>+</span> i <span>-</span> in_left <span>+</span> <span>1</span><span>,</span> i <span>+</span> <span>1</span><span>,</span> in_right<span>)</span><span>;</span>\n        <span>return</span> root<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h4 id=\"bfs-广度优先搜索\"> BFS(广度优先搜索)</h4>\n<p>一层一层往下访问</p>\n<p><img src=\"./images/DataStructure/BFS.jpg\" alt=\"广度优先搜索\" /></p>\n<ul>\n<li>BFS代码</li>\n</ul>\n<div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>levelOrder</span><span>(</span><span>TreeNode</span> tree<span>)</span> <span>{</span>\n     <span>if</span> <span>(</span>tree <span>==</span> <span>null</span><span>)</span>\n         <span>return</span><span>;</span>\n     <span>LinkedList</span><span><span>&lt;</span><span>TreeNode</span><span>></span></span> list <span>=</span> <span>new</span> <span>LinkedList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span><span>//链表，这里我们可以把它看做队列</span>\n     list<span>.</span><span>add</span><span>(</span>tree<span>)</span><span>;</span><span>//相当于把数据加入到队列尾部</span>\n     <span>while</span> <span>(</span><span>!</span>list<span>.</span><span>isEmpty</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n         <span>TreeNode</span> node <span>=</span> list<span>.</span><span>poll</span><span>(</span><span>)</span><span>;</span><span>//poll方法相当于移除队列头部的元素</span>\n         <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>node<span>.</span>val<span>)</span><span>;</span>\n        <span>if</span> <span>(</span>node<span>.</span>left <span>!=</span> <span>null</span><span>)</span>\n            list<span>.</span><span>add</span><span>(</span>node<span>.</span>left<span>)</span><span>;</span>\n        <span>if</span> <span>(</span>node<span>.</span>right <span>!=</span> <span>null</span><span>)</span>\n            list<span>.</span><span>add</span><span>(</span>node<span>.</span>right<span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><ul>\n<li>递归的写法</li>\n</ul>\n<div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>levelOrder</span><span>(</span><span>TreeNode</span> tree<span>)</span> <span>{</span>\n     <span>int</span> depth <span>=</span> <span>depth</span><span>(</span>tree<span>)</span><span>;</span>\n     <span>for</span> <span>(</span><span>int</span> level <span>=</span> <span>0</span><span>;</span> level <span>&lt;</span> depth<span>;</span> level<span>++</span><span>)</span> <span>{</span>\n         <span>printLevel</span><span>(</span>tree<span>,</span> level<span>)</span><span>;</span>\n     <span>}</span>\n <span>}</span>\n \n <span>private</span> <span>static</span> <span>int</span> <span>depth</span><span>(</span><span>TreeNode</span> tree<span>)</span> <span>{</span>\n     <span>if</span> <span>(</span>tree <span>==</span> <span>null</span><span>)</span>\n        <span>return</span> <span>0</span><span>;</span>\n    <span>int</span> leftDepth <span>=</span> <span>depth</span><span>(</span>tree<span>.</span>left<span>)</span><span>;</span>\n    <span>int</span> rightDepth <span>=</span> <span>depth</span><span>(</span>tree<span>.</span>right<span>)</span><span>;</span>\n    <span>return</span> <span>Math</span><span>.</span><span>max</span><span>(</span>leftDepth<span>,</span> rightDepth<span>)</span> <span>+</span> <span>1</span><span>;</span>\n<span>}</span>\n\n\n<span>private</span> <span>static</span> <span>void</span> <span>printLevel</span><span>(</span><span>TreeNode</span> tree<span>,</span> <span>int</span> level<span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>tree <span>==</span> <span>null</span><span>)</span>\n        <span>return</span><span>;</span>\n    <span>if</span> <span>(</span>level <span>==</span> <span>0</span><span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>print</span><span>(</span><span>\" \"</span> <span>+</span> tree<span>.</span>val<span>)</span><span>;</span>\n    <span>}</span> <span>else</span> <span>{</span>\n        <span>printLevel</span><span>(</span>tree<span>.</span>left<span>,</span> level <span>-</span> <span>1</span><span>)</span><span>;</span>\n        <span>printLevel</span><span>(</span>tree<span>.</span>right<span>,</span> level <span>-</span> <span>1</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><h4 id=\"如果想把遍历的结果存放到list中-我们还可以这样写\"> 如果想把遍历的结果存放到list中，我们还可以这样写</h4>\n<div><pre><code><span>public</span> <span>static</span> <span>List</span><span><span>&lt;</span><span>List</span><span>&lt;</span><span>Integer</span><span>></span><span>></span></span> <span>levelOrder</span><span>(</span><span>TreeNode</span> tree<span>)</span> <span>{</span>\n     <span>if</span> <span>(</span>tree <span>==</span> <span>null</span><span>)</span>\n         <span>return</span> <span>null</span><span>;</span>\n     <span>List</span><span><span>&lt;</span><span>List</span><span>&lt;</span><span>Integer</span><span>></span><span>></span></span> list <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n     <span>bfs</span><span>(</span>tree<span>,</span> <span>0</span><span>,</span> list<span>)</span><span>;</span>\n     <span>return</span> list<span>;</span>\n <span>}</span>\n \n <span>private</span> <span>static</span> <span>void</span> <span>bfs</span><span>(</span><span>TreeNode</span> tree<span>,</span> <span>int</span> level<span>,</span> <span>List</span><span><span>&lt;</span><span>List</span><span>&lt;</span><span>Integer</span><span>></span><span>></span></span> list<span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>tree <span>==</span> <span>null</span><span>)</span>\n        <span>return</span><span>;</span>\n    <span>if</span> <span>(</span>level <span>>=</span> list<span>.</span><span>size</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n        <span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> subList <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n        subList<span>.</span><span>add</span><span>(</span>tree<span>.</span>val<span>)</span><span>;</span>\n        list<span>.</span><span>add</span><span>(</span>subList<span>)</span><span>;</span>\n    <span>}</span> <span>else</span> <span>{</span>\n        list<span>.</span><span>get</span><span>(</span>level<span>)</span><span>.</span><span>add</span><span>(</span>tree<span>.</span>val<span>)</span><span>;</span>\n    <span>}</span>\n    <span>bfs</span><span>(</span>tree<span>.</span>left<span>,</span> level <span>+</span> <span>1</span><span>,</span> list<span>)</span><span>;</span>\n    <span>bfs</span><span>(</span>tree<span>.</span>right<span>,</span> level <span>+</span> <span>1</span><span>,</span> list<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><h3 id=\"_5-2-b树和b-树\"> 5.2 B树和B+树</h3>\n<p>参考</p>\n<blockquote>\n<ul>\n<li>https://www.jianshu.com/p/ee10f01d3247</li>\n<li>https://blog.csdn.net/weichi7549/article/details/107333942</li>\n</ul>\n</blockquote>\n<p>B树</p>\n<p>在计算机科学中，B树（B-tree）是一种树状数据结构，它能够存储数据、对其进行排序并允许以<code>O(log n)</code>的时间复杂度运行进行查找、顺序读取、插入和删除的数据结构。B树，概括来说是一个节点可以拥有多于2个子节点的二叉查找树。与自平衡二叉查找树不同，B-树为系统最优化<strong>大块数据的读和写操作</strong>。B-tree算法减少定位记录时所经历的中间过程，从而加快存取速度。普遍运用在<strong>数据库</strong>和<strong>文件系统</strong>。</p>\n<p>B+树</p>\n<p>B和B+树的区别在于，B+树的非叶子结点只包含导航信息，不包含实际的值，所有的叶子结点和相连的节点使用链表相连，便于区间查找和遍历。</p>\n<p>优点在于</p>\n<blockquote>\n<ul>\n<li>由于B+树在内部节点上不好含数据信息，因此在内存页中能够存放更多的key。 数据存放的更加紧密，具有更好的空间局部性。因此访问叶子几点上关联的数据也具有更好的缓存命中率。</li>\n<li>B+树的叶子结点都是相链的，因此对整棵树的便利只需要一次线性遍历叶子结点即可。而且由于数据顺序排列并且相连，所以便于区间查找和搜索。而B树则需要进行每一层的递归遍历。相邻的元素可能在内存中不相邻，所以缓存命中性没有B+树好。</li>\n</ul>\n</blockquote>\n<p>区别</p>\n<blockquote>\n<ul>\n<li>B树的每个结点都存储了key和data，B+树的data存储在叶子节点上。节点不存储data，这样一个节点就可以存储更多的key。可以使得树更矮，所以IO操作次数更少。非叶结点仅具有索引作用,跟记录有关的信息均存放在叶结点中。</li>\n<li>树的所有叶结点构成一个有序链表，可以按照关键码排序的次序遍历全部记录由于数据顺序排列并且相连，所以便于区间查找和搜索。而B树则需要进行每一层的递归遍历。相邻的元素可能在内存中不相邻，所以缓存命中性没有B+树好。</li>\n</ul>\n</blockquote>\n<p>总的来说，通过对每个节点存储个数的扩展，使得对连续的数据能够进行较快的定位和访问，能够有效减少查找时间，提高存储的空间局部性从而减少IO操作。对于树来说，IO次数就是树的高度，而“矮胖”就是b树的特征之一</p>\n<p>同时应用于数据库中两种数据库引擎实现的方式有些不同</p>\n<h3 id=\"_5-3-红黑树\"> 5.3 红黑树</h3>\n<div><p>参考</p>\n<ul>\n<li><a href=\"https://www.jianshu.com/p/e136ec79235c\" target=\"_blank\" rel=\"noopener noreferrer\">30张图带你彻底理解红黑树</a></li>\n</ul>\n</div>\n<h2 id=\"_6-排序算法\"> 6. 排序算法</h2>\n<h3 id=\"_6-1-时间复杂度和稳定性\"> 6.1 时间复杂度和稳定性</h3>\n<p>排序算法可以分为内部排序和外部排序，内部排序是数据记录在内存中进行排序，而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。常见的内部排序算法有：插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序等。用一张图概括：</p>\n<p><img src=\"./images/DataStructure/Ten_classic_sorting_algorithms.png\" alt=\"\" /></p>\n<p><img src=\"./images/DataStructure/Ten_classic_sorting_algorithms_compare.png\" alt=\"\" /></p>\n<p><img src=\"./images/DataStructure/Ten_classic_sorting_algorithms_description.png\" alt=\"\" /></p>\n<h4 id=\"时间复杂度\"> 时间复杂度</h4>\n<p>平方阶 (O(n2)) 排序 各类简单排序：直接插入、直接选择和冒泡排序。</p>\n<p>线性对数阶 (O(nlog2n)) 排序 快速排序、堆排序和归并排序；</p>\n<p>O(n1+§)) 排序，§ 是介于 0 和 1 之间的常数。 希尔排序</p>\n<p>线性阶 (O(n)) 排序 基数排序，此外还有桶、箱排序。</p>\n<p>关于稳定性</p>\n<p>稳定的排序算法：冒泡排序、插入排序、归并排序和基数排序。</p>\n<p>不是稳定的排序算法：选择排序、快速排序、希尔排序、堆排序。</p>\n<p>名词解释：</p>\n<ul>\n<li>n：数据规模</li>\n<li>k：&quot;桶&quot;的个数</li>\n<li><code>In-place</code>：占用常数内存，不占用额外内存</li>\n<li><code>Out-place</code>：占用额外内存</li>\n<li>稳定性：如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变，那么这种排序算法叫做稳定的排序算法；如果前后顺序发生变化，那么对应的排序算法就是不稳定的排序算法。在实际的排序应用中，往往不是对单一关键值进行排序，而是要求排序结果对所有的关键值都有序。所以，稳定的排序算法往往适用场景更广。</li>\n</ul>\n<h4 id=\"稳定性\"> 稳定性</h4>\n<p><img src=\"./images/DataStructure/6.1.jpg\" alt=\"稳定性意义\" /></p>\n<h3 id=\"_6-2-冒泡排序\"> 6.2 冒泡排序</h3>\n<p>参考</p>\n<blockquote>\n<ul>\n<li>https://www.runoob.com/w3cnote/bubble-sort.html</li>\n</ul>\n</blockquote>\n<p>两两比较相邻元素是否有序，如果逆序则交换两个元素，直到没有逆序的数据元素为止。每次冒泡都会至少让一个元素移动到它应该在的位置。</p>\n<p><img src=\"./images/DataStructure/BubbleSort.gif\" alt=\"冒泡排序\" /></p>\n<h4 id=\"_6-2-1-步骤\"> 6.2.1 步骤</h4>\n<blockquote>\n<ol>\n<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>\n<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li>\n<li>针对所有的元素重复以上的步骤，除了最后一个。</li>\n<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>\n</ol>\n</blockquote>\n<h4 id=\"_6-2-2-什么时候最快\"> 6.2.2 什么时候最快</h4>\n<p>当输入的数据已经是正序时（都已经是正序了，我还要你冒泡排序有何用啊），当待排序列已有序时，只需一次冒泡即可。时间复杂度为O(n)；</p>\n<h4 id=\"_6-2-3-什么时候最慢\"> 6.2.3 什么时候最慢</h4>\n<p>当输入的数据是反序时（写一个 for 循环反序输出数据不就行了，干嘛要用你冒泡排序呢，我是闲的吗），当待排序列完全逆序时，需要n次冒泡。时间复杂度为O(n2)；</p>\n<h4 id=\"_6-2-4-空间复杂度\"> 6.2.4 空间复杂度</h4>\n<p>只借助了一个临时变量temp，所以空间复杂度为O(1)。</p>\n<h4 id=\"_6-2-5-稳定性分析\"> 6.2.5 稳定性分析</h4>\n<p>该算法中只有交换操作会改变数据元素的顺序，只要我们在数据元素值相等时不交换数据元素，那么算法就是稳定的。</p>\n<h4 id=\"_6-2-6-代码实现\"> 6.2.6 代码实现</h4>\n<div><pre><code><span>public</span> <span>class</span> <span>BubbleSort</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>int</span><span>[</span><span>]</span> arr <span>=</span> <span>{</span><span>3</span><span>,</span><span>2</span><span>,</span><span>1</span><span>,</span><span>5</span><span>}</span><span>;</span>\n        <span>/*控制比较次数*/</span>\n        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;</span> arr<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n            <span>boolean</span> flag <span>=</span> <span>true</span><span>;</span>\n            <span>/*控制比较次数*/</span>\n            <span>for</span> <span>(</span><span>int</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> arr<span>.</span>length <span>-</span> i<span>;</span> j<span>++</span><span>)</span> <span>{</span>\n                <span>if</span><span>(</span>arr<span>[</span>j<span>]</span> <span>></span> arr<span>[</span>j<span>+</span><span>1</span><span>]</span><span>)</span><span>{</span>\n                    <span>int</span> tmp <span>=</span> arr<span>[</span>j<span>]</span><span>;</span>\n                    arr<span>[</span>j<span>]</span> <span>=</span> arr<span>[</span>j<span>+</span><span>1</span><span>]</span><span>;</span>\n                    arr<span>[</span>j<span>+</span><span>1</span><span>]</span> <span>=</span> tmp<span>;</span>\n                    flag <span>=</span> <span>false</span><span>;</span>\n                <span>}</span>\n            <span>}</span>\n            <span>if</span><span>(</span>flag<span>)</span><span>{</span>\n                <span>break</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Arrays</span><span>.</span><span>toString</span><span>(</span>arr<span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><h3 id=\"_6-3-选择排序\"> 6.3 选择排序</h3>\n<p><img src=\"./images/DataStructure/selectionSort.gif\" alt=\"选择排序\" /></p>\n<p>选择排序是一种简单直观的排序算法，无论什么数据进去都是 <code>O(n²)</code> 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。</p>\n<h4 id=\"_6-3-1-时间复杂度\"> 6.3.1 时间复杂度</h4>\n<p>不管是已有序序列还是完全逆序序列，都要进行n次遍历无序区间操作，时间复杂度为O(n2)。</p>\n<p><img src=\"./images/DataStructure/selectionSort.jpg\" alt=\"选择排序时间复杂度分析\" /></p>\n<h4 id=\"_6-3-2-稳定性\"> 6.3.2 稳定性</h4>\n<p>选择排序算法中改变数据元素相对位置的操作为交换操作，当第i次中第i个数据元素不为当前无序区间最小值时则和最小值交换数据元素。当有重复元素时，就有可能发生相对位置改变。例如5，3，4，5，1第一次选择操作后为1，3，4，5，5，此时两个5的相对位置已经改变。所以选择排序算法不是稳定的。</p>\n<h4 id=\"_6-3-3-步骤\"> 6.3.3 步骤</h4>\n<blockquote>\n<ul>\n<li>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。</li>\n<li>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</li>\n<li>重复第二步，直到所有元素均排序完毕。</li>\n</ul>\n</blockquote>\n<div><pre><code>    <span>public</span> <span>static</span> <span>void</span> <span>SelectionSort</span><span>(</span><span>int</span><span>[</span><span>]</span> arr<span>)</span><span>{</span>\n        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> arr<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n            <span>int</span> min <span>=</span> i<span>;</span>\n            <span>for</span> <span>(</span><span>int</span> j <span>=</span> i <span>+</span> <span>1</span><span>;</span> j <span>&lt;</span> arr<span>.</span>length<span>;</span> j<span>++</span><span>)</span> <span>{</span>\n                <span>if</span><span>(</span>arr<span>[</span>j<span>]</span> <span>&lt;</span> arr<span>[</span>min<span>]</span><span>)</span><span>{</span>\n                    min <span>=</span> j<span>;</span>\n                <span>}</span>\n            <span>}</span>\n            <span>int</span> tmp <span>=</span> arr<span>[</span>min<span>]</span><span>;</span>\n            arr<span>[</span>min<span>]</span> <span>=</span> arr<span>[</span>i<span>]</span><span>;</span>\n            arr<span>[</span>i<span>]</span> <span>=</span> tmp<span>;</span>\n        <span>}</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h3 id=\"_6-4-插入排序\"> 6.4 插入排序</h3>\n<blockquote>\n<ul>\n<li>https://www.cnblogs.com/coding-996/p/12275710.html</li>\n</ul>\n</blockquote>\n<p><img src=\"./images/DataStructure/insertionSort.gif\" alt=\"插入排序\" /></p>\n<p>插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p>\n<p>插入排序和冒泡排序一样，也有一种优化算法，叫做拆半插入。</p>\n<h4 id=\"_6-4-1-时间复杂度\"> 6.4.1 时间复杂度</h4>\n<ul>\n<li>最好：当待排序列已有序时，只需遍历一次即可完成排序。时间复杂度为O(n)；</li>\n<li>最坏：当待排序列完全逆序时，需要进行n-1次数据搬移和插入操作。时间复杂度为O(n2)；</li>\n<li>平均：与冒泡法的分析过程一样，平均情况时间复杂度为O(n2)。</li>\n</ul>\n<p><img src=\"./images/DataStructure/insertionSort.jpg\" alt=\"插入排序时间复杂度\" /></p>\n<h4 id=\"_6-4-2-空间复杂度\"> 6.4.2 空间复杂度</h4>\n<p>排序过程中只需要一个临时变量存储待插入数据，空间复杂度为O(1)。</p>\n<h4 id=\"_6-4-3-稳定性\"> 6.4.3 稳定性</h4>\n<p>插入排序过程中只有插入操作会改变数据元素的相对位置，只要元素大小比较时相等情况下不进行插入操作，插入排序算法就是稳定的。</p>\n<h4 id=\"_6-4-4-算法步骤\"> 6.4.4 算法步骤</h4>\n<blockquote>\n<ul>\n<li>将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。</li>\n<li>从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）</li>\n</ul>\n</blockquote>\n<div><pre><code>    <span>public</span> <span>static</span> <span>void</span> <span>InsertionSort</span><span>(</span><span>int</span><span>[</span><span>]</span> arr<span>)</span><span>{</span>\n        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;</span> arr<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n            <span>for</span> <span>(</span><span>int</span> j <span>=</span> i<span>;</span> j <span>></span> <span>0</span><span>;</span> j<span>--</span><span>)</span> <span>{</span>\n                <span>/*如果要插入的数小于排好序的最后一个数，即arr[j] &lt; arr[j - 1]那就交换*/</span>\n                <span>if</span><span>(</span>arr<span>[</span>j<span>]</span> <span>&lt;</span> arr<span>[</span>j <span>-</span> <span>1</span><span>]</span><span>)</span><span>{</span>\n                    <span>int</span> tmp <span>=</span> arr<span>[</span>j<span>]</span><span>;</span>\n                    arr<span>[</span>j<span>]</span> <span>=</span> arr<span>[</span>j <span>-</span> <span>1</span><span>]</span><span>;</span>\n                    arr<span>[</span>j <span>-</span> <span>1</span><span>]</span> <span>=</span> tmp<span>;</span>\n                <span>}</span>\n                <span>/*否则直接退出遍历*/</span>\n                <span>else</span><span>{</span>\n                    <span>break</span><span>;</span>\n                <span>}</span>\n            <span>}</span>\n        <span>}</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h3 id=\"_6-5-快速排序\"> 6.5 快速排序</h3>\n<p><img src=\"./images/DataStructure/quickSort.gif\" alt=\"快速排序\" /></p>\n<p>参考</p>\n<blockquote>\n<ul>\n<li>https://www.runoob.com/w3cnote/quick-sort-2.html</li>\n<li>https://www.runoob.com/w3cnote/quick-sort.html</li>\n<li>https://blog.csdn.net/nrsc272420199/article/details/82587933</li>\n<li>https://www.sohu.com/a/246785807_684445</li>\n</ul>\n</blockquote>\n<h4 id=\"_6-5-1-步骤\"> 6.5.1 步骤</h4>\n<blockquote>\n<ol>\n<li>从数列中挑出一个元素，称为 &quot;基准&quot;（pivot）;</li>\n<li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li>\n<li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；</li>\n</ol>\n</blockquote>\n<h4 id=\"_6-5-2-挖坑-分治\"> 6.5.2 挖坑+分治</h4>\n<blockquote>\n<ul>\n<li>https://blog.csdn.net/nrsc272420199/article/details/82587933</li>\n</ul>\n</blockquote>\n<div><pre><code>    <span>public</span> <span>static</span> <span>void</span> <span>quickSort</span><span>(</span><span>int</span><span>[</span><span>]</span> arr<span>,</span> <span>int</span> low<span>,</span> <span>int</span> high<span>)</span><span>{</span>\n        <span>if</span><span>(</span>low <span>&lt;</span> high<span>)</span><span>{</span>\n            <span>int</span> l <span>=</span> low<span>,</span> h <span>=</span> high<span>;</span>\n            <span>int</span> pivot <span>=</span> arr<span>[</span>low<span>]</span><span>;</span>\n            <span>while</span> <span>(</span>low <span>&lt;</span> high<span>)</span><span>{</span>\n                <span>//从high指针往前，遇到小于基准数时将arr[low] = arr[high]</span>\n                <span>while</span> <span>(</span>low <span>&lt;</span> high <span>&amp;&amp;</span> arr<span>[</span>high<span>]</span> <span>>=</span> pivot<span>)</span><span>{</span>\n                    high<span>--</span><span>;</span>\n                <span>}</span>\n                arr<span>[</span>low<span>]</span> <span>=</span> arr<span>[</span>high<span>]</span><span>;</span>\n\n                <span>//从low指针往后，遇到大于基准数时将</span>\n                <span>while</span> <span>(</span>low <span>&lt;</span> high <span>&amp;&amp;</span> arr<span>[</span>low<span>]</span> <span>&lt;=</span> pivot<span>)</span><span>{</span>\n                    low<span>++</span><span>;</span>\n                <span>}</span>\n                arr<span>[</span>high<span>]</span> <span>=</span> arr<span>[</span>low<span>]</span><span>;</span>\n            <span>}</span>\n            arr<span>[</span>low<span>]</span> <span>=</span> pivot<span>;</span>\n            <span>int</span> index <span>=</span> low<span>;</span>\n            \n            <span>quickSort</span><span>(</span>arr<span>,</span> l<span>,</span> index <span>-</span> <span>1</span><span>)</span><span>;</span>\n            <span>quickSort</span><span>(</span>arr<span>,</span> index <span>+</span> <span>1</span><span>,</span> h<span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><h4 id=\"_6-5-3-指针交换法\"> 6.5.3 指针交换法</h4>\n<p>参考</p>\n<blockquote>\n<ul>\n<li>https://www.sohu.com/a/246785807_684445</li>\n</ul>\n</blockquote>\n<div><pre><code>    <span>/*指针交换法*/</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>quickSort_2</span><span>(</span><span>int</span><span>[</span><span>]</span> arr<span>,</span> <span>int</span> low<span>,</span> <span>int</span> high<span>)</span><span>{</span>\n        <span>if</span><span>(</span>low <span>&lt;</span> high<span>)</span><span>{</span>\n            <span>int</span> l <span>=</span> low<span>,</span> h <span>=</span> high<span>;</span>\n            <span>int</span> pivot <span>=</span> arr<span>[</span>l<span>]</span><span>;</span>\n            <span>while</span> <span>(</span>low <span>&lt;</span> high<span>)</span><span>{</span>\n                <span>//从high指针往前，遇到小于基准数时将arr[low] = arr[high]</span>\n                <span>while</span> <span>(</span>low <span>&lt;</span> high <span>&amp;&amp;</span> arr<span>[</span>high<span>]</span> <span>>=</span> pivot<span>)</span><span>{</span>\n                    high<span>--</span><span>;</span>\n                <span>}</span>\n                <span>//从low指针往后，遇到大于基准数时将</span>\n                <span>while</span> <span>(</span>low <span>&lt;</span> high <span>&amp;&amp;</span> arr<span>[</span>low<span>]</span> <span>&lt;=</span> pivot<span>)</span><span>{</span>\n                    low<span>++</span><span>;</span>\n                <span>}</span>\n                <span>int</span> tmp <span>=</span> arr<span>[</span>low<span>]</span><span>;</span>\n                arr<span>[</span>low<span>]</span> <span>=</span> arr<span>[</span>high<span>]</span><span>;</span>\n                arr<span>[</span>high<span>]</span> <span>=</span> tmp<span>;</span>\n            <span>}</span>\n            arr<span>[</span>l<span>]</span> <span>=</span> arr<span>[</span>low<span>]</span><span>;</span>\n            arr<span>[</span>low<span>]</span> <span>=</span> pivot<span>;</span>\n            <span>quickSort_2</span><span>(</span>arr<span>,</span> l<span>,</span> low <span>-</span> <span>1</span><span>)</span><span>;</span>\n            <span>quickSort_2</span><span>(</span>arr<span>,</span> low <span>+</span> <span>1</span><span>,</span> h<span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><h3 id=\"_6-6-希尔排序\"> 6.6 希尔排序</h3>\n<p>希尔排序，也称递减增量排序算法，是<code>插入排序</code>的一种更高效的改进版本。但希尔排序是非稳定排序算法。</p>\n<p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p>\n<blockquote>\n<ul>\n<li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；</li>\n<li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；</li>\n</ul>\n</blockquote>\n<p>希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录&quot;基本有序&quot;时，再对全体记录进行依次直接插入排序。</p>\n<h4 id=\"_6-6-1-算法步骤\"> 6.6.1 算法步骤</h4>\n<blockquote>\n<ul>\n<li>选择一个增量序列 t1，t2，……，tk，其中 ti &gt; tj, tk = 1；</li>\n<li>按增量序列个数 k，对序列进行 k 趟排序；</li>\n<li>每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li>\n</ul>\n</blockquote>\n<div><pre><code><span>/*这里设置gap增量每次为上一次的/2*/</span>\n<span>int</span> <span>N</span> <span>=</span> a<span>.</span>length<span>;</span>\n<span>//希尔增量</span>\n<span>for</span><span>(</span><span>int</span> h <span>=</span> <span>N</span> <span>/</span> <span>2</span><span>;</span> h <span>></span> <span>0</span><span>;</span> h <span>/=</span> <span>2</span><span>)</span><span>{</span>\n    <span>for</span><span>(</span><span>int</span> i <span>=</span> h<span>;</span> i <span>&lt;</span> <span>N</span><span>;</span> i<span>++</span><span>)</span><span>{</span>\n        <span>//将a[i]插入到a[i-h],a[i-2h],a[i-3h]...中</span>\n        <span>for</span><span>(</span><span>int</span> j <span>=</span> i<span>;</span> j <span>>=</span> h <span>&amp;&amp;</span> a<span>[</span>j<span>]</span> <span>&lt;</span> a<span>[</span>j <span>-</span> h<span>]</span><span>;</span> j <span>-=</span> h<span>)</span><span>{</span>\n            <span>int</span> temp <span>=</span> a<span>[</span>j<span>]</span><span>;</span>\n            a<span>[</span>j<span>]</span> <span>=</span> a<span>[</span>j<span>-</span>h<span>]</span><span>;</span>\n            a<span>[</span>j<span>-</span>h<span>]</span> <span>=</span> temp<span>;</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h3 id=\"_6-7-归并排序\"> 6.7 归并排序</h3>\n<blockquote>\n<ul>\n<li>https://www.cnblogs.com/exzlc/p/12203681.html</li>\n</ul>\n</blockquote>\n<p><img src=\"./images/DataStructure/mergeSort.jpg\" alt=\"归并排序\" /></p>\n<h4 id=\"_6-7-1-时间复杂度\"> 6.7.1 时间复杂度</h4>\n<p><img src=\"./images/DataStructure/mergeSort2.jpg\" alt=\"归并排序时间复杂度\" /></p>\n<blockquote>\n<p>需要申请额外的空间，空间复杂度较大，典型的空间换时间的算法</p>\n</blockquote>\n<h4 id=\"_6-7-1-算法步骤\"> 6.7.1 算法步骤</h4>\n<blockquote>\n<ol>\n<li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</li>\n<li>设定两个指针，最初位置分别为两个已经排序序列的起始位置；</li>\n<li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</li>\n<li>重复步骤 3 直到某一指针达到序列尾；</li>\n<li>将另一序列剩下的所有元素直接复制到合并序列尾。</li>\n</ol>\n</blockquote>\n<div><pre><code>    <span>public</span> <span>static</span> <span>void</span> <span>merge</span><span>(</span><span>int</span><span>[</span><span>]</span> arr<span>,</span> <span>int</span> low<span>,</span> <span>int</span> mid<span>,</span> <span>int</span> high<span>)</span> <span>{</span>\n        <span>/*首先定义一个辅助数组*/</span>\n        <span>int</span><span>[</span><span>]</span> helpArr <span>=</span> <span>new</span> <span>int</span><span>[</span>high <span>-</span> low <span>+</span> <span>1</span><span>]</span><span>;</span>\n        <span>/*左指针*/</span>\n        <span>int</span> lPoint <span>=</span> low<span>;</span>\n        <span>/*右指针*/</span>\n        <span>int</span> hPoint <span>=</span> mid <span>+</span> <span>1</span><span>;</span>\n        <span>/*辅助指针*/</span>\n        <span>int</span> i <span>=</span> <span>0</span><span>;</span>\n        <span>//比较并填充辅助数组</span>\n        <span>while</span> <span>(</span>lPoint <span>&lt;=</span> mid <span>&amp;&amp;</span> hPoint <span>&lt;=</span> high<span>)</span><span>{</span>\n            <span>if</span><span>(</span>arr<span>[</span>lPoint<span>]</span> <span>&lt;=</span> arr<span>[</span>hPoint<span>]</span><span>)</span><span>{</span>\n                helpArr<span>[</span>i<span>++</span><span>]</span> <span>=</span> arr<span>[</span>lPoint<span>++</span><span>]</span><span>;</span>\n            <span>}</span><span>else</span><span>{</span>\n                helpArr<span>[</span>i<span>++</span><span>]</span> <span>=</span> arr<span>[</span>hPoint<span>++</span><span>]</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n        <span>//将剩余元素填充至辅助数组</span>\n        <span>while</span> <span>(</span>lPoint <span>&lt;=</span> mid<span>)</span><span>{</span>\n            helpArr<span>[</span>i<span>++</span><span>]</span> <span>=</span> arr<span>[</span>lPoint<span>++</span><span>]</span><span>;</span>\n        <span>}</span>\n        <span>while</span> <span>(</span>hPoint <span>&lt;=</span> high<span>)</span><span>{</span>\n            helpArr<span>[</span>i<span>++</span><span>]</span> <span>=</span> arr<span>[</span>hPoint<span>++</span><span>]</span><span>;</span>\n        <span>}</span>\n        <span>//将辅助数组中的元素回填至原数组</span>\n        <span>for</span> <span>(</span><span>int</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> helpArr<span>.</span>length<span>;</span> j<span>++</span><span>)</span> <span>{</span>\n            arr<span>[</span>low <span>+</span> j<span>]</span> <span>=</span> helpArr<span>[</span>j<span>]</span><span>;</span>\n        <span>}</span>\n\n    <span>}</span>\n\n\n    <span>public</span> <span>static</span> <span>void</span> <span>mergeSort</span><span>(</span><span>int</span><span>[</span><span>]</span> arr<span>,</span><span>int</span> low<span>,</span><span>int</span> high<span>)</span><span>{</span>\n        <span>if</span><span>(</span>arr <span>==</span> <span>null</span> <span>||</span> high <span>==</span> low<span>)</span><span>{</span>\n            <span>return</span> <span>;</span><span>//终止条件</span>\n        <span>}</span>\n        <span>//确定分割的边界</span>\n        <span>int</span> mid <span>=</span> low <span>+</span> <span>(</span>high <span>-</span> low<span>)</span> <span>/</span> <span>2</span><span>;</span>\n        <span>//对左半部分调用递归方法，使其有序</span>\n        <span>mergeSort</span><span>(</span>arr<span>,</span>low<span>,</span>mid<span>)</span><span>;</span>\n        <span>//对右半部分调用递归方法，使其有序</span>\n        <span>mergeSort</span><span>(</span>arr<span>,</span>mid <span>+</span> <span>1</span><span>,</span>high<span>)</span><span>;</span>\n        <span>//合并左右两部分，使整个数组有序</span>\n        <span>merge</span><span>(</span>arr<span>,</span>low<span>,</span>mid<span>,</span>high<span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br></div></div><h3 id=\"_6-8-堆排序\"> 6.8 堆排序</h3>\n<blockquote>\n<ul>\n<li>https://www.cnblogs.com/chengxiao/p/6129630.html</li>\n</ul>\n</blockquote>\n<p><img src=\"./images/DataStructure/heapSort.gif\" alt=\"堆排序\" /></p>\n<p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个<code>近似完全二叉树</code>的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：</p>\n<blockquote>\n<ol>\n<li>大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；</li>\n<li>小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；</li>\n</ol>\n</blockquote>\n<p><img src=\"./images/DataStructure/Big-top-pile&small-top-pile.png\" alt=\"大顶堆和小顶堆\" /></p>\n<p>同时，我们对堆中的结点按层进行编号，将这种逻辑结构映射到数组中就是下面这个样子(<code>大顶堆</code>)</p>\n<p><img src=\"./images/DataStructure/Big-top-pile&small-top-pile_2.png\" alt=\"大顶堆和小顶堆2\" /></p>\n<p>该数组从逻辑上讲就是一个堆结构，我们用简单的公式来描述一下堆的定义就是：</p>\n<blockquote>\n<ul>\n<li>第一个非叶子结点为：<code>arr[arr.length/2-1]</code></li>\n<li>左结点： <code>arr[2i+1]</code></li>\n<li>右结点：<code>arr[2i+2]</code></li>\n<li><strong>大顶堆：arr[i] &gt;= arr[2i+1] &amp;&amp; arr[i] &gt;= arr[2i+2]</strong></li>\n<li><strong>小顶堆：arr[i] &lt;= arr[2i+1] &amp;&amp; arr[i] &lt;= arr[2i+2]</strong></li>\n<li><strong>它的父结点是：arr[(i-1)/2]</strong></li>\n</ul>\n</blockquote>\n<h4 id=\"_6-8-1-算法步骤\"> 6.8.1 算法步骤</h4>\n<blockquote>\n<ul>\n<li>https://www.cnblogs.com/chengxiao/p/6129630.html</li>\n<li>https://www.cnblogs.com/jingmoxukong/p/4303826.html</li>\n</ul>\n</blockquote>\n<blockquote>\n<ol>\n<li>首先，按堆的定义将数组R[0..n]调整为堆（这个过程称为创建初始堆），交换R[0]和R[n]；</li>\n<li>然后，将R[0..n-1]调整为堆，交换R[0]和R[n-1]；</li>\n<li>如此反复，直到交换了R[0]和R[1]为止。</li>\n</ol>\n</blockquote>\n<p>以上思想可归纳为两个操作：</p>\n<blockquote>\n<ul>\n<li>根据初始数组去<strong>构造初始堆</strong>（构建一个完全二叉树，保证所有的父结点都比它的孩子结点数值大）。</li>\n<li>每次<strong>交换第一个和最后一个元素，输出最后一个元素</strong>（最大值），然后把剩下元素<strong>重新调整</strong>为大根堆。</li>\n</ul>\n</blockquote>\n<p>设有一个无序序列 <code>{ 1, 3, 4, 5, 2, 6, 9, 7, 8, 0 }</code>。</p>\n<p><img src=\"./images/DataStructure/HeapSort_step_1.png\" alt=\"堆排序步骤一\" /></p>\n<p>构造了初始堆后，我们来看一下完整的堆排序处理：</p>\n<p>还是针对前面提到的无序序列 { 1, 3, 4, 5, 2, 6, 9, 7, 8, 0 } 来加以说明。</p>\n<p><img src=\"./images/DataStructure/HeapSort_step_2.png\" alt=\"堆排序步骤一\" /></p>\n<div><pre><code>    <span>public</span> <span>static</span> <span>void</span> <span>HeapSort</span><span>(</span><span>int</span> <span>[</span><span>]</span>arr<span>)</span><span>{</span>\n        <span>//1.构建大顶堆</span>\n        <span>for</span><span>(</span><span>int</span> i <span>=</span> <span>(</span>arr<span>.</span>length <span>/</span> <span>2</span> <span>-</span> <span>1</span><span>)</span><span>;</span> i <span>>=</span> <span>0</span><span>;</span> i<span>--</span><span>)</span><span>{</span>\n            <span>//从第一个非叶子结点从下至上，从右至左调整结构</span>\n            <span>adjustHeap</span><span>(</span>arr<span>,</span> i<span>,</span> arr<span>.</span>length<span>)</span><span>;</span>\n        <span>}</span>\n        <span>//2.调整堆结构+交换堆顶元素与末尾元素</span>\n        <span>for</span><span>(</span><span>int</span> j <span>=</span> arr<span>.</span>length <span>-</span> <span>1</span><span>;</span> j <span>></span> <span>0</span><span>;</span> j<span>--</span><span>)</span><span>{</span>\n            <span>//将堆顶元素与末尾元素进行交换</span>\n            <span>int</span> temp <span>=</span> arr<span>[</span><span>0</span><span>]</span><span>;</span>\n            arr<span>[</span><span>0</span><span>]</span> <span>=</span> arr<span>[</span>j<span>]</span><span>;</span>\n            arr<span>[</span>j<span>]</span> <span>=</span> temp<span>;</span>\n            <span>//因为首元素和末尾元素调换，不满足最大堆需要重新调整为大顶堆。</span>\n            <span>//重新对堆进行调整,每次传入的j--作为堆的length即对除了末尾元素的堆重新调整将最大值调整在最上面</span>\n            <span>adjustHeap</span><span>(</span>arr<span>,</span> <span>0</span><span>,</span> j<span>)</span><span>;</span>\n        <span>}</span>\n\n    <span>}</span>\n\n    <span>public</span> <span>static</span> <span>void</span> <span>adjustHeap</span><span>(</span><span>int</span><span>[</span><span>]</span> arr<span>,</span> <span>int</span> i<span>,</span> <span>int</span> length<span>)</span><span>{</span>\n        <span>//先取出当前元素i</span>\n        <span>int</span> temp <span>=</span> arr<span>[</span>i<span>]</span><span>;</span>\n        <span>//从i结点的左子结点开始，也就是2i+1处开始</span>\n        <span>for</span><span>(</span><span>int</span> k <span>=</span> <span>(</span>i <span>*</span> <span>2</span> <span>+</span> <span>1</span><span>)</span><span>;</span> k <span>&lt;</span> length <span>;</span> k <span>=</span> <span>(</span>k <span>*</span> <span>2</span> <span>+</span> <span>1</span><span>)</span><span>)</span><span>{</span>\n            <span>//如果左子结点小于右子结点，k指向右子结点</span>\n            <span>if</span><span>(</span>k <span>+</span> <span>1</span> <span>&lt;</span> length <span>&amp;&amp;</span> arr<span>[</span>k<span>]</span> <span>&lt;</span> arr<span>[</span>k <span>+</span> <span>1</span><span>]</span><span>)</span><span>{</span>\n                k<span>++</span><span>;</span>\n            <span>}</span>\n            <span>//如果子节点大于父节点，将子节点值赋给父节点（不用进行交换）</span>\n            <span>if</span><span>(</span>arr<span>[</span>k<span>]</span> <span>></span> temp<span>)</span><span>{</span>\n                arr<span>[</span>i<span>]</span> <span>=</span> arr<span>[</span>k<span>]</span><span>;</span>\n                <span>//让i指向替换的值的下标，如果下一次循环的左右结点大于temp</span>\n                <span>//就直接继续覆盖i指向下标的值</span>\n                <span>//循环结束后，再将temp值赋给它被交换后在的位置，也就是i指向的位置</span>\n                i <span>=</span> k<span>;</span>\n            <span>}</span><span>else</span><span>{</span>\n                <span>break</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n        <span>//将temp值放到最终的位置</span>\n        arr<span>[</span>i<span>]</span> <span>=</span> temp<span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br></div></div><h3 id=\"_6-9-计数排序\"> 6.9 计数排序</h3>\n<p><img src=\"./images/DataStructure/countingSort.gif\" alt=\"计数排序\" /></p>\n<p>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p>\n<h4 id=\"_6-9-1-计数排序的特征\"> 6.9.1 计数排序的特征</h4>\n<p>当输入的元素是 n 个 0 到 k 之间的整数时，它的运行时间是 O(n + k)。计数排序不是比较排序，排序的速度快于任何比较排序算法。</p>\n<p>由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。例如：计数排序是用来排序0到100之间的数字的最好的算法，但是它不适合按字母顺序排序人名。但是，计数排序可以用在基数排序中的算法来排序数据范围很大的数组。</p>\n<p>通俗地理解，例如有 10 个年龄不同的人，统计出有 8 个人的年龄比 A 小，那 A 的年龄就排在第 9 位,用这个方法可以得到其他每个人的位置,也就排好了序。当然，年龄有重复时需要特殊处理（保证稳定性），这就是为什么最后要反向填充目标数组，以及将每个数字的统计减去 1 的原因。</p>\n<h4 id=\"_6-9-2-算法步骤\"> 6.9.2 算法步骤</h4>\n<blockquote>\n<ol>\n<li>找出待排序的数组中最大和最小的元素</li>\n<li>统计数组中每个值为i的元素出现的次数，存入数组C的第i项</li>\n<li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）</li>\n<li>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1</li>\n</ol>\n</blockquote>\n<div><pre><code>    <span>public</span> <span>static</span> <span>void</span> <span>CountingSort</span><span>(</span><span>int</span><span>[</span><span>]</span> arr<span>)</span> <span>{</span>\n        <span>int</span> max <span>=</span> arr<span>[</span><span>0</span><span>]</span><span>;</span>\n        <span>/*获取最大值*/</span>\n        <span>for</span><span>(</span><span>int</span> val <span>:</span> arr<span>)</span><span>{</span>\n            max <span>=</span> <span>Math</span><span>.</span><span>max</span><span>(</span>val<span>,</span> max<span>)</span><span>;</span>\n        <span>}</span>\n        <span>/*新建计数数组，长度为arr中最大值max*/</span>\n        <span>int</span><span>[</span><span>]</span> helpArr <span>=</span> <span>new</span> <span>int</span><span>[</span>max <span>+</span> <span>1</span><span>]</span><span>;</span>\n        <span>for</span><span>(</span><span>int</span> val <span>:</span> arr<span>)</span><span>{</span>\n            helpArr<span>[</span>val<span>]</span><span>++</span><span>;</span>\n        <span>}</span>\n        <span>/*重新填回原数组*/</span>\n        <span>int</span> index <span>=</span> <span>0</span><span>;</span>\n        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> helpArr<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n            <span>if</span><span>(</span>helpArr<span>[</span>i<span>]</span> <span>==</span> <span>0</span><span>)</span><span>{</span>\n                <span>continue</span><span>;</span>\n            <span>}</span>\n            <span>for</span> <span>(</span><span>int</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> helpArr<span>[</span>i<span>]</span><span>;</span> j<span>++</span><span>)</span> <span>{</span>\n                arr<span>[</span>index<span>+</span>j<span>]</span> <span>=</span> i<span>;</span>\n            <span>}</span>\n            index<span>+=</span>helpArr<span>[</span>i<span>]</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><h3 id=\"_6-10-桶排序\"> 6.10 桶排序</h3>\n<blockquote>\n<ul>\n<li>https://blog.csdn.net/qq_27124771/article/details/87651495</li>\n</ul>\n</blockquote>\n<p><strong>划分多个范围相同的区间，每个子区间自排序，最后合并</strong>。</p>\n<p><img src=\"./images/DataStructure/BucketSort.png\" alt=\"桶排序\" /></p>\n<p>桶排序是<code>计数排序</code>的升级版。计数排序可以看成每个桶只存储相同元素，而桶排序每个桶存储一定范围的元素。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序需要尽量保证元素分散均匀，否则当所有数据集中在同一个桶中时，桶排序失效。为了使桶排序更加高效，我们需要做到这两点：</p>\n<blockquote>\n<ul>\n<li>在额外空间充足的情况下，尽量增大桶的数量</li>\n<li>使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中</li>\n</ul>\n</blockquote>\n<h4 id=\"_6-10-1-什么时候最快\"> 6.10.1 什么时候最快</h4>\n<p>当输入的数据可以均匀的分配到每一个桶中。</p>\n<h4 id=\"_6-10-2-什么时候最慢\"> 6.10.2 什么时候最慢</h4>\n<p>当输入的数据被分配到了同一个桶中。</p>\n<h4 id=\"_6-10-3-步骤\"> 6.10.3 步骤</h4>\n<blockquote>\n<ul>\n<li>找出最大值max和最小值min，然后根据<code>(max - min)/arr.length - 1</code>算出桶的数量，以此构建二维数组</li>\n<li>遍历待排序数组，通过<code>(arr[i] - min) / (arr.length)</code>计算该放到哪个桶</li>\n<li>遍历桶二维数组，对每个桶内部数据进行排序</li>\n<li>遍历桶二维数组，重新填回待排序数组</li>\n</ul>\n</blockquote>\n<div><pre><code>    <span>public</span> <span>static</span> <span>void</span> <span>BucketSort</span><span>(</span><span>int</span><span>[</span><span>]</span> arr<span>)</span><span>{</span>\n        <span>if</span><span>(</span>arr<span>.</span>length <span>&lt;=</span> <span>1</span><span>)</span><span>{</span>\n            <span>return</span><span>;</span>\n        <span>}</span>\n        <span>// 计算最大值与最小值</span>\n        <span>int</span> max <span>=</span> arr<span>[</span><span>0</span><span>]</span><span>;</span>\n        <span>int</span> min <span>=</span> arr<span>[</span><span>0</span><span>]</span><span>;</span>\n        <span>for</span><span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> arr<span>.</span>length<span>;</span> i<span>++</span><span>)</span><span>{</span>\n            max <span>=</span> <span>Math</span><span>.</span><span>max</span><span>(</span>max<span>,</span> arr<span>[</span>i<span>]</span><span>)</span><span>;</span>\n            min <span>=</span> <span>Math</span><span>.</span><span>min</span><span>(</span>min<span>,</span> arr<span>[</span>i<span>]</span><span>)</span><span>;</span>\n        <span>}</span>\n\n        <span>// 计算桶的数量</span>\n        <span>int</span> bucketNum <span>=</span> <span>(</span>max <span>-</span> min<span>)</span> <span>/</span> arr<span>.</span>length <span>+</span> <span>1</span><span>;</span>\n        <span>ArrayList</span><span><span>&lt;</span><span>ArrayList</span><span>&lt;</span><span>Integer</span><span>></span><span>></span></span> bucketArr <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span>bucketNum<span>)</span><span>;</span>\n        <span>for</span><span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> bucketNum<span>;</span> i<span>++</span><span>)</span><span>{</span>\n            bucketArr<span>.</span><span>add</span><span>(</span><span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>Integer</span><span>></span></span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>}</span>\n\n        <span>// 将每个元素放入桶</span>\n        <span>for</span><span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> arr<span>.</span>length<span>;</span> i<span>++</span><span>)</span><span>{</span>\n            <span>/*计算该放在哪个桶中*/</span>\n            <span>int</span> num <span>=</span> <span>(</span>arr<span>[</span>i<span>]</span> <span>-</span> min<span>)</span> <span>/</span> <span>(</span>arr<span>.</span>length<span>)</span><span>;</span>\n            bucketArr<span>.</span><span>get</span><span>(</span>num<span>)</span><span>.</span><span>add</span><span>(</span>arr<span>[</span>i<span>]</span><span>)</span><span>;</span>\n        <span>}</span>\n\n        <span>// 对每个桶进行排序</span>\n        <span>for</span><span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> bucketArr<span>.</span><span>size</span><span>(</span><span>)</span><span>;</span> i<span>++</span><span>)</span><span>{</span>\n            <span>Collections</span><span>.</span><span>sort</span><span>(</span>bucketArr<span>.</span><span>get</span><span>(</span>i<span>)</span><span>)</span><span>;</span>\n        <span>}</span>\n\n        <span>// 将桶中的元素赋值到原序列</span>\n        <span>int</span> index <span>=</span> <span>0</span><span>;</span>\n        <span>for</span> <span>(</span><span>ArrayList</span><span><span>&lt;</span><span>Integer</span><span>></span></span> list <span>:</span> bucketArr<span>)</span><span>{</span>\n            <span>for</span> <span>(</span><span>int</span> val <span>:</span> list<span>)</span><span>{</span>\n                arr<span>[</span>index<span>++</span><span>]</span> <span>=</span> val<span>;</span>\n            <span>}</span>\n        <span>}</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br></div></div><h3 id=\"_6-11-基数排序\"> 6.11 基数排序</h3>\n<p>参考</p>\n<blockquote>\n<ul>\n<li>https://www.cnblogs.com/yangquanhui/p/4937464.html</li>\n</ul>\n</blockquote>\n<p><img src=\"./images/DataStructure/radixSort.gif\" alt=\"基数排序\" /></p>\n<p><img src=\"./images/DataStructure/radixSort.jpg\" alt=\"基数排序\" /></p>\n<p>基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</p>\n<h4 id=\"_6-11-1-基数排序-vs-计数排序-vs-桶排序\"> 6.11.1 基数排序 vs 计数排序 vs 桶排序</h4>\n<p>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p>\n<blockquote>\n<ul>\n<li>基数排序：根据键值的每位数字(个，十，百，千)来分配桶；</li>\n<li>计数排序：每个桶只存储单一键值；</li>\n<li>桶排序：每个桶存储一定范围的数值；</li>\n</ul>\n</blockquote>\n<p>基数排序有两种方法：</p>\n<blockquote>\n<ul>\n<li>从低位到高位开始分配桶为<code>LSD（Least significant digital）</code>；</li>\n<li>从高位到低位分配为<code>MSD（Most significant digital）</code></li>\n</ul>\n</blockquote>\n<h2 id=\"_5-查找算法\"> 5. 查找算法</h2>\n<h3 id=\"_5-1-二分查找\"> 5.1 二分查找</h3>\n<p>参考</p>\n<blockquote>\n<ul>\n<li>https://www.cnblogs.com/kyoner/p/11080078.html</li>\n</ul>\n</blockquote>\n<h3 id=\"_5-2-最基本的二分查找算法\"> 5.2 最基本的二分查找算法</h3>\n<div><pre><code>    <span>/*基本二分查找框架*/</span>\n    <span>public</span> <span>static</span> <span>int</span> <span>binarySearch</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>,</span> <span>int</span> target<span>)</span> <span>{</span>\n      <span>if</span> <span>(</span>nums<span>.</span>length <span>==</span> <span>0</span><span>)</span> <span>return</span> <span>-</span><span>1</span><span>;</span>\n      \t<span>/*left指针指向下标为0，right指针指向最后一个元素*/</span>\n        <span>int</span> left <span>=</span> <span>0</span><span>,</span> right <span>=</span> nums<span>.</span>length <span>-</span> <span>1</span><span>;</span>\n        <span>while</span><span>(</span>left <span>&lt;=</span> right<span>)</span> <span>{</span>\n          <span>/*mid赋值时防止当right + left数据过大时溢出*/</span>\n            <span>int</span> mid <span>=</span> left <span>+</span> <span>(</span>right <span>-</span> left<span>)</span> <span>/</span> <span>2</span><span>;</span>\n            <span>if</span> <span>(</span>nums<span>[</span>mid<span>]</span> <span>==</span> target<span>)</span> <span>{</span>\n                <span>return</span> mid<span>;</span>\n            <span>}</span> <span>else</span> <span>if</span> <span>(</span>nums<span>[</span>mid<span>]</span> <span>&lt;</span> target<span>)</span> <span>{</span>\n                left <span>=</span> mid <span>+</span> <span>1</span><span>;</span>\n            <span>}</span> <span>else</span> <span>if</span> <span>(</span>nums<span>[</span>mid<span>]</span> <span>></span> target<span>)</span> <span>{</span>\n                right <span>=</span> mid <span>-</span> <span>1</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n        <span>return</span> <span>-</span><span>1</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h3 id=\"_5-3-寻找左侧边界的二分查找\"> 5.3 寻找左侧边界的二分查找</h3>\n<blockquote>\n<p>因为我们初始化 <code>right = nums.length</code> 所以决定了我们的「搜索区间」是 <code>[left, right)</code> 所以决定了 <code>while (left &lt; right)</code> 同时也决定了 <code>left = mid+1</code> 和 <code>right = mid</code> 因为我们需找到 target 的最左侧索引 所以当 nums[mid] == target 时不要立即返回 而要收紧<code>右侧边界以锁定左侧边界</code></p>\n</blockquote>\n<div><pre><code>    <span>/*查询最左侧索引*/</span>\n    <span>public</span> <span>static</span> <span>int</span> <span>binarySearch_Left</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>,</span> <span>int</span> target<span>)</span><span>{</span>\n        <span>if</span> <span>(</span>nums<span>.</span>length <span>==</span> <span>0</span><span>)</span><span>{</span>\n            <span>return</span> <span>-</span><span>1</span><span>;</span>\n        <span>}</span>\n\n        <span>int</span> left <span>=</span> <span>0</span> <span>,</span> right <span>=</span> nums<span>.</span>length <span>-</span> <span>1</span><span>;</span>\n        <span>while</span> <span>(</span>left <span>&lt;=</span> right<span>)</span><span>{</span>\n            <span>int</span> mid <span>=</span> left <span>+</span> <span>(</span>right <span>-</span> left<span>)</span> <span>/</span> <span>2</span><span>;</span>\n            <span>/*当相等时，并不是直接返回，而是收紧右侧区间在mid的前一个*/</span>\n            <span>if</span><span>(</span>target <span>==</span> nums<span>[</span>mid<span>]</span><span>)</span><span>{</span>\n                right <span>=</span> mid <span>-</span> <span>1</span><span>;</span>\n            <span>}</span>\n            <span>/*当target > nums[mid]时收紧左侧区间，即left = mid + 1*/</span>\n            <span>else</span> <span>if</span><span>(</span>target <span>></span> nums<span>[</span>mid<span>]</span><span>)</span><span>{</span>\n                left <span>=</span> mid <span>+</span> <span>1</span><span>;</span>\n            <span>}</span>\n            <span>/*当target &lt; nums[mid]时收紧右侧区间，即right = mid - 1*/</span>\n            <span>else</span> <span>if</span><span>(</span>target <span>&lt;</span> nums<span>[</span>mid<span>]</span><span>)</span><span>{</span>\n                right <span>=</span> mid <span>-</span> <span>1</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n        <span>return</span> left<span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><h3 id=\"_5-4-寻找右侧边界的二分查找\"> 5.4 寻找右侧边界的二分查找</h3>\n<div><pre><code>    <span>/*查询最右侧索引*/</span>\n    <span>public</span> <span>static</span> <span>int</span> <span>binarySearch_Right</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>,</span> <span>int</span> target<span>)</span><span>{</span>\n        <span>if</span> <span>(</span>nums<span>.</span>length <span>==</span> <span>0</span><span>)</span><span>{</span>\n            <span>return</span> <span>-</span><span>1</span><span>;</span>\n        <span>}</span>\n\n        <span>int</span> left <span>=</span> <span>0</span> <span>,</span> right <span>=</span> nums<span>.</span>length <span>-</span> <span>1</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"nums.length : \"</span> <span>+</span> nums<span>.</span>length<span>)</span><span>;</span>\n\n        <span>while</span> <span>(</span>left <span>&lt;=</span> right<span>)</span><span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"left : \"</span> <span>+</span> left<span>)</span><span>;</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"right : \"</span> <span>+</span> right<span>)</span><span>;</span>\n            <span>int</span> mid <span>=</span> left <span>+</span> <span>(</span>right <span>-</span> left<span>)</span> <span>/</span> <span>2</span><span>;</span>\n            <span>/*当相等时，并不是直接返回，而是收紧左侧区间在mid的后一个，以此查找是否右边还有此值*/</span>\n            <span>if</span><span>(</span>target <span>==</span> nums<span>[</span>mid<span>]</span><span>)</span><span>{</span>\n                left <span>=</span> mid <span>+</span> <span>1</span><span>;</span>\n            <span>}</span>\n            <span>/*当target > nums[mid]时收紧左侧区间，即left = mid + 1*/</span>\n            <span>else</span> <span>if</span><span>(</span>target <span>></span> nums<span>[</span>mid<span>]</span><span>)</span><span>{</span>\n                left <span>=</span> mid <span>+</span> <span>1</span><span>;</span>\n            <span>}</span>\n            <span>/*当target &lt; nums[mid]时收紧右侧区间，即right = mid - 1*/</span>\n            <span>else</span> <span>if</span><span>(</span>target <span>&lt;</span> nums<span>[</span>mid<span>]</span><span>)</span><span>{</span>\n                right <span>=</span> mid <span>-</span> <span>1</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n        <span>return</span> right<span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><h2 id=\"tip\"> tip</h2>\n<ul>\n<li>在写判定条件 &amp;&amp; 运算时，尽量把简单的操作写在&amp;&amp;之前</li>\n</ul>\n",
      "date_published": "2020-08-30T18:03:39.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": []
    },
    {
      "title": "数据结构&算法学习目录",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/dataStructure&algorithm/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/dataStructure&algorithm/",
      "content_html": "",
      "date_published": "2020-11-24T23:10:27.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": []
    },
    {
      "title": "Hadoop伪分布式配置",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/database/hadoop/Hadoop_pseudo-distributed_configuration/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/database/hadoop/Hadoop_pseudo-distributed_configuration/",
      "content_html": "<h2 id=\"_1-准备\"> 1. 准备</h2>\n<blockquote>\n<ol>\n<li>java</li>\n<li>Hadoop,<a href=\"http://mirror.bit.edu.cn/apache/hadoop/common/\" target=\"_blank\" rel=\"noopener noreferrer\">镜像下载地址</a></li>\n<li>deepin linux操作系统(或其他Ubuntu)</li>\n</ol>\n</blockquote>\n<h2 id=\"_2-配置\"> 2. 配置</h2>\n<h3 id=\"_2-1-安装ssh、配置ssh无密码登陆\"> 2.1 安装SSH、配置SSH无密码登陆</h3>\n<p>Ubuntu 默认已安装了 SSH client，此外还需要安装 SSH server：</p>\n<div><pre><code><span>sudo</span> <span>apt-get</span> <span>install</span> openssh-server\n</code></pre>\n<div><span>1</span><br></div></div><p>安装后，可以使用如下命令登陆本机：</p>\n<div><pre><code><span>ssh</span> localhost\n</code></pre>\n<div><span>1</span><br></div></div><p>然后用输入yes登录</p>\n<p><img src=\"./Hadoop/ssh_login.png\" alt=\"\" /></p>\n<p>生成无密码登录：</p>\n<div><pre><code><span>exit</span>                       <span># 退出刚才的 ssh localhost</span>\n<span>cd</span> ~/.ssh/      <span># 若没有该目录，请先执行一次ssh localhost</span>\nssh-keygen -t rsa             <span># 会有提示，都按回车就可以</span>\n<span>cat</span> ./id_rsa.pub <span>>></span> ./authorized_keys  <span># 加入授权</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id=\"_2-2-配置java环境\"> 2.2 配置java环境</h3>\n<p>先执行</p>\n<div><pre><code>java -version\n</code></pre>\n<div><span>1</span><br></div></div><p>如果版本是openjdk，则删除并下载jdk</p>\n<div><pre><code><span>sudo</span> <span>apt-get</span> remove openjdk*\n</code></pre>\n<div><span>1</span><br></div></div><p>删除并下载好jdk后配置java环境变量</p>\n<div><pre><code><span>sudo</span> <span>vi</span> /etc/bash.bashrc <span>#配置永久环境变量</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>然后插入</p>\n<div><pre><code><span>export</span> <span>JAVA_HOME</span><span>=</span>/usr/lib/jvm/jdk1.x.y\n<span>export</span> <span>JRE_HOME</span><span>=</span><span>${JAVA_HOME}</span>/jre\n<span>export</span> <span>CLASSPATH</span><span>=</span>.:<span>${JAVA_HOME}</span>/lib:<span>${JRE_HOME}</span>/lib\n<span>export</span> <span><span>PATH</span></span><span>=</span><span>${JAVA_HOME}</span>/bin:<span>$PATH</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>再使其生效</p>\n<div><pre><code><span>source</span> /etc/bash.bashrc\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"_2-3-配置hadoop\"> 2.3 配置Hadoop</h3>\n<p>安装hadoop到/usr下</p>\n<p>检验是否安装成功，进入hadoop-2.x.y/bin/hadoop下</p>\n<div><pre><code><span>cd</span> /usr/local/hadoop-2.x.y/bin/hadoop\nhadoop version\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>显示版本等信息即成功</p>\n<p>更改环境变量，同上java配置，插入</p>\n<div><pre><code><span>export</span> <span>HADOOP_HOME</span><span>=</span>/usr/local/hadoop\n<span>export</span> <span>HADOOP_COMMON_LIB_NATIVE_DIR</span><span>=</span><span>$HADOOP_HOME</span>/lib/native\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>配置伪分布式需要更改配置文件，首先进入</p>\n<div><pre><code><span>cd</span> /usr/local/hadoop-2.x.y/etc/hadoop\n</code></pre>\n<div><span>1</span><br></div></div><p>更改==core-site.xml==</p>\n<div><pre><code><span><span><span>&lt;</span>configuration</span><span>></span></span>\n    <span><span><span>&lt;</span>property</span><span>></span></span>\n        <span><span><span>&lt;</span>name</span><span>></span></span>hadoop.tmp.dir<span><span><span>&lt;/</span>name</span><span>></span></span>\n        <span><span><span>&lt;</span>value</span><span>></span></span>file:/usr/local/hadoop-2.x.y/tmp<span><span><span>&lt;/</span>value</span><span>></span></span>\n        <span><span><span>&lt;</span>description</span><span>></span></span>Abase for other temporary directories.<span><span><span>&lt;/</span>description</span><span>></span></span>\n    <span><span><span>&lt;/</span>property</span><span>></span></span>\n    <span><span><span>&lt;</span>property</span><span>></span></span>\n        <span><span><span>&lt;</span>name</span><span>></span></span>fs.defaultFS<span><span><span>&lt;/</span>name</span><span>></span></span>\n        <span><span><span>&lt;</span>value</span><span>></span></span>hdfs://localhost:9000<span><span><span>&lt;/</span>value</span><span>></span></span>\n <span><span><span>&lt;/</span>property</span><span>></span></span>\n<span><span><span>&lt;/</span>configuration</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>更改==hdfs-site.xml==</p>\n<div><pre><code><span><span><span>&lt;</span>configuration</span><span>></span></span>\n    <span><span><span>&lt;</span>property</span><span>></span></span>\n        <span><span><span>&lt;</span>name</span><span>></span></span>dfs.replication<span><span><span>&lt;/</span>name</span><span>></span></span>\n        <span><span><span>&lt;</span>value</span><span>></span></span>1<span><span><span>&lt;/</span>value</span><span>></span></span>\n    <span><span><span>&lt;/</span>property</span><span>></span></span>\n    <span><span><span>&lt;</span>property</span><span>></span></span>\n        <span><span><span>&lt;</span>name</span><span>></span></span>dfs.namenode.name.dir<span><span><span>&lt;/</span>name</span><span>></span></span>        <span><span><span>&lt;</span>value</span><span>></span></span>file:/usr/local/hadoop/tmp/dfs/name<span><span><span>&lt;/</span>value</span><span>></span></span>\n    <span><span><span>&lt;/</span>property</span><span>></span></span>\n    <span><span><span>&lt;</span>property</span><span>></span></span>\n        <span><span><span>&lt;</span>name</span><span>></span></span>dfs.datanode.data.dir<span><span><span>&lt;/</span>name</span><span>></span></span>     <span><span><span>&lt;</span>value</span><span>></span></span>file:/usr/local/hadoop/tmp/dfs/data<span><span><span>&lt;/</span>value</span><span>></span></span>\n    <span><span><span>&lt;/</span>property</span><span>></span></span>\n<span><span><span>&lt;/</span>configuration</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>配置完成后，执行 NameNode 的格式化:</p>\n<div><pre><code><span>cd</span> /usr/local/hadoop\n\n./bin/hdfs namenode -format\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>如果出现<strong>Error: JAVA_HOME is not set and could not be found</strong></p>\n<p>java没配好，或者更改==hadoop-env.sh==</p>\n<div><pre><code><span>export</span> <span>JAVA_HOME</span><span>=</span><span>${JAVA_HOME}</span>\n更改为\n<span>export</span> <span>JAVA_HOME</span><span>=</span>/usr/java/jdk1.8 <span>#java路径</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>接着开启 NameNode 和 DataNode 守护进程：</p>\n<p>进入sbin文件夹下打开终端，输入</p>\n<div><pre><code>start-all.sh\n</code></pre>\n<div><span>1</span><br></div></div><h2 id=\"_3-检验\"> 3. 检验</h2>\n<p>输入==jps==查看进程状态，如下则说明成功</p>\n<p><img src=\"./Hadoop/jps_watch.png\" alt=\"\" /></p>\n<p>然后进入网址</p>\n<ol>\n<li>\n<p>http://localhost:50070</p>\n<p><img src=\"./Hadoop/50070.png\" alt=\"\" /></p>\n</li>\n<li>\n<p>http://localhost:18088</p>\n<p><img src=\"./Hadoop/18088.png\" alt=\"\" /></p>\n</li>\n</ol>\n<p>运算实例：执行jar包计算圆周率</p>\n<div><pre><code>hadoop jar /usr/local/hadoop-2.7.7/share/hadoop/mapreduce/hadoop-mapreduce-examples-2.7.7.jar pi  <span>10</span>  <span>10</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>第一个10是运行10次map任务，第二个10是每个map任务投掷次数，可以改变，可得到不同的近似pi值</p>\n<p><img src=\"./Hadoop/pi_result.png\" alt=\"\" /></p>\n<h2 id=\"_4-参考\"> 4. 参考</h2>\n<p><a href=\"http://dblab.xmu.edu.cn/blog/install-hadoop/\" target=\"_blank\" rel=\"noopener noreferrer\">厦门大学大数据实验室Hadoop配置</a></p>\n",
      "date_published": "2020-05-02T18:59:32.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": []
    },
    {
      "title": "Mysql理论学习笔记",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/database/mysql/Mysql_theory_note/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/database/mysql/Mysql_theory_note/",
      "content_html": "<h2 id=\"_1-参考\"> 1. 参考</h2>\n<h2 id=\"_2-存储引擎\"> 2. 存储引擎</h2>\n<h3 id=\"_2-1-查看mysql提供的所有存储引擎\"> 2.1 查看MySQL提供的所有存储引擎</h3>\n<div><pre><code>\n</code></pre>\n<div><span>1</span><br></div></div><p><img src=\"./images/Mysql_theory_note/mysql_engine.jpg\" alt=\"mysql存储引擎\" /></p>\n<p>从上图我们可以查看出 MySQL 当前默认的存储引擎是<code>InnoDB</code>,并且在5.7版本所有的存储引擎中只有 <code>InnoDB</code> 是事务性存储引擎，也就是说只有 InnoDB ⽀持事务。</p>\n<h3 id=\"_2-2-查看mysql当前默认的存储引擎\"> 2.2 查看MySQL当前默认的存储引擎</h3>\n<p>我们也可以通过下⾯的命令查看默认的存储引擎。</p>\n<div><pre><code>mysql<span>></span> <span>show</span> variables <span>like</span> <span>'%storage_engine%'</span><span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>查看表的存储引擎</p>\n<div><pre><code><span>show</span> <span>table</span> <span>status</span> <span>like</span> <span>\"table_name\"</span> <span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"_2-3-innodb四大特性\"> 2.3 InnoDB四大特性</h3>\n<p>参考</p>\n<blockquote>\n<ul>\n<li>https://www.cnblogs.com/zhs0/p/10528520.html</li>\n</ul>\n</blockquote>\n<ul>\n<li>插入缓冲( insert buffer)</li>\n<li>二次写( double write)</li>\n<li>自适应哈希索引（hash）</li>\n<li>预读( read ahead  ）</li>\n</ul>\n<h3 id=\"_2-4-myisam和innodb区别\"> 2.4 MyISAM和InnoDB区别</h3>\n<ol>\n<li><strong>是否⽀持⾏级锁</strong> : MyISAM 只有表级锁(table-level locking)，⽽InnoDB ⽀持⾏级锁(rowlevel locking)和表级锁,默认为⾏级锁。</li>\n<li><strong>是否⽀持事务和崩溃后的安全恢复</strong>： MyISAM 强调的是性能，每次查询具有原⼦性,其执⾏速度 ⽐InnoDB类型更快，但是不提供事务⽀持。但是InnoDB 提供事务⽀持事务，外部键等⾼级数据 库功能。 具有<code>事务(commit)</code>、<code>回滚(rollback)</code>和<code>崩溃修复能⼒(crash recovery capabilities)</code> 的<code>事务安全(transaction-safe (ACID compliant))</code>型表。</li>\n<li><strong>是否⽀持外键</strong>： MyISAM不⽀持，⽽InnoDB⽀持。</li>\n<li><strong>索引区别</strong>：<code>InnoDB是聚集索引</code>，使用B+Tree作为索引结构，<code>数据文件是和（主键）索引绑在一起的</code>（表数据文件本身就是按B+Tree组织的一个索引结构），<strong>必须要有主键</strong>，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。<code>MyISAM是非聚集索引</code>，也是使用B+Tree作为索引结构，<code>索引和数据文件是分离的</code>，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。</li>\n<li><strong>表行数计算</strong>：InnoDB不保存表的具体行数，执行select count(*) from table时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快（注意不能加有任何WHERE条件）；</li>\n<li><strong>是否⽀持MVCC</strong> ：仅 InnoDB ⽀持。应对⾼并发事务, MVCC⽐单纯的加锁更⾼效;MVCC只在 <code>READ COMMITTED</code> 和 <code>REPEATABLE READ</code> 两个隔离级别下⼯作;MVCC可以使⽤ <code>乐观 (optimistic)锁</code> 和 <code>悲观(pessimistic)锁</code>来实现;各数据库中MVCC实现并不统⼀</li>\n</ol>\n<h3 id=\"_2-5-如何选择\"> 2.5 如何选择</h3>\n<ol>\n<li>\n<p>是否要支持事务，如果要请选择innodb，如果不需要可以考虑MyISAM；</p>\n</li>\n<li>\n<p>如果表中绝大多数都只是读查询，可以考虑MyISAM，如果既有读也有写，请使用InnoDB。</p>\n</li>\n<li>\n<p>系统奔溃后，MyISAM恢复起来更困难，能否接受；</p>\n</li>\n</ol>\n<h2 id=\"_3-索引\"> 3. 索引</h2>\n<p>MySQL索引的建立对于MySQL的高效运行是很重要的，索引可以大大提高MySQL的检索速度。</p>\n<p>打个比方，如果合理的设计且使用索引的MySQL是一辆兰博基尼的话，那么没有设计和使用索引的MySQL就是一个人力三轮车。</p>\n<p>拿汉语字典的目录页（索引）打比方，我们可以按拼音、笔画、偏旁部首等排序的目录（索引）快速查找到需要的字。</p>\n<p>索引分单列索引和组合索引。单列索引，即一个索引只包含单个列，一个表可以有多个单列索引，但这不是组合索引。组合索引，即一个索引包含多个列。</p>\n<p>创建索引时，你需要确保该索引是应用在 SQL 查询语句的条件(一般作为 WHERE 子句的条件)。</p>\n<p>实际上，索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录。</p>\n<p>上面都在说使用索引的好处，但过多的使用索引将会造成滥用。因此索引也会有它的缺点：虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件。</p>\n<p>建立索引会占用磁盘空间的索引文件。</p>\n<h3 id=\"_3-1-缺点\"> 3.1 缺点</h3>\n<ul>\n<li><strong>时间方面</strong>：创建索引和维护索引要耗费时间,具体地,当对表中的数据进行增加、删除和修改的时候,索引也要动态的维护,会降低增/改/删的执行效率</li>\n<li><strong>空间方面</strong>：索引需要占物理空间</li>\n</ul>\n<h3 id=\"_3-2-种类\"> 3.2 种类</h3>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>唯一索引</td>\n<td>不允许有俩行具有相同的值，允许空值</td>\n</tr>\n<tr>\n<td>主键索引</td>\n<td>为了保持数据库表与表之间的关系，不允许空值</td>\n</tr>\n<tr>\n<td>聚集索引</td>\n<td>索引文件和数据文件是<code>绑定</code>的，表中行的物理顺序与键值的逻辑(索引)顺序相同</td>\n</tr>\n<tr>\n<td>非聚集索引</td>\n<td>索引文件和数据文件是<code>分离</code>的，聚集索引和非聚集索引的根本区别是<strong>表记录的排列顺序和与索引的排列顺序是否一致</strong></td>\n</tr>\n<tr>\n<td>复合索引</td>\n<td>在创建索引时,并不是只能对一列进行创建索引,可以与主键样,讲多个组合为索引</td>\n</tr>\n<tr>\n<td>全文索引</td>\n<td>全文索引为在字符串数据中进行复杂的词搜索提供有效支持</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"_3-3-主键索引与唯一索引区别\"> 3.3 主键索引与唯一索引区别</h3>\n<p>回归到主键本身的特点</p>\n<ol>\n<li>主键是一种约束,唯一索引是一种索引,两者在本质上是不同的</li>\n<li>主键创建后一定包含一个唯一性索引,唯一性索引并不一定就是主键。</li>\n<li>唯一性索引列允许空值,而主键列不允许为空值。</li>\n<li>主键列在创建时,已经默认为空值++唯一索引了。</li>\n<li>一个表最多只能创建一个主键,但可以创建多个唯一索引。</li>\n<li>主键更适合那些不容易更改的唯一标识,如自动递增列、身份证号等。</li>\n<li>主键可以被其他表引用为外键,而唯一索引不能</li>\n</ol>\n<h3 id=\"_3-4-使用场景\"> 3.4 使用场景</h3>\n<ol>\n<li>当数据多且字段值有相同的值得时候用普通索引</li>\n<li>当字段多且字段值没有重复的时候用唯一索引</li>\n<li>当有多个字段名都经常被查询的话用复合索引</li>\n<li>普通索引不支持空值,唯一索引支持空值。</li>\n<li>但是,若是这张表增删改多而查询较少的话,就不要创建索引了,因为如果你绐一列创建了索引,那么对该列进行增删改的时候,都会先访问这一列的索引,</li>\n<li>若是增,则在这一列的索引内以新填入的这个字段名的值为名创建索引的子</li>\n<li>若是改,则会把原来的删掉,再添入一个以这个字段名的新值为名创建索引的子集</li>\n<li>若是删,则会把索引中以这个字段为名的索引的子集删掉</li>\n<li>所以,会对增删改的执行减缓速度</li>\n<li>所以,若是这张表增删改多而查询较少的话,就不要创建索引了。</li>\n<li>更新太频繁地字段不适合创建索引</li>\n<li>不会出现在 where条件中的字段不该建立索引</li>\n</ol>\n<h3 id=\"_3-5-哈希索引\"> 3.5 哈希索引</h3>\n<p>MySQL索引使⽤的数据结构主要有<code>BTree索引</code> 和 <code>哈希索引</code> 。对于哈希索引来说，底层的数据结构就是 哈希表，因此在绝⼤多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余⼤部分 场景，建议选择BTree索引。</p>\n<h3 id=\"_3-6-b-树\"> 3.6 B-树</h3>\n<p>参考</p>\n<blockquote>\n<ul>\n<li>https://blog.csdn.net/biggoodloong/article/details/90203301</li>\n</ul>\n</blockquote>\n<p><img src=\"./images/Mysql_theory_note/B-tree.png\" alt=\"B-tree\" /></p>\n<p>一个节点大小限制在<code>16k</code></p>\n<h3 id=\"_3-7-b-树\"> 3.7 B+树</h3>\n<p><img src=\"./images/Mysql_theory_note/B+tree.png\" alt=\"B+tree\" /></p>\n<h4 id=\"b-树特征\"> B+树特征</h4>\n<blockquote>\n<ol>\n<li>\n<p>有k个子树的中间节点包含有k个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。</p>\n</li>\n<li>\n<p>所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接，方便区间查找。</p>\n</li>\n<li>\n<p>所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素。</p>\n</li>\n</ol>\n</blockquote>\n<h4 id=\"b-树优势\"> B+树优势</h4>\n<blockquote>\n<ol>\n<li>\n<p>单一节点存储更多的元素，使得查询的IO次数更少。</p>\n</li>\n<li>\n<p>所有查询都要查找到叶子节点，查询性能稳定。</p>\n</li>\n<li>\n<p>所有叶子节点形成有序链表，便于区间范围查询。</p>\n</li>\n</ol>\n</blockquote>\n<p>MySQL的BTree索引使⽤的是B树中的B+Tree，但对于主要的两种存储引擎的实现⽅式是不同的。</p>\n<h3 id=\"_3-8-myisam实现方式-非聚簇索引\"> 3.8 MyISAM实现方式：非聚簇索引</h3>\n<p>B+Tree叶节点的data域存放的是<code>数据记录的地址</code>。在索引检索的时候，⾸先按照B+Tree 搜索算法搜索索引，如果指定的Key存在，则取出其 data 域的值，然后以 data 域的值为地址 读取相应的数据记录。这被称为“<code>⾮聚簇索引</code>”。</p>\n<p>MyISAM的索引文件仅仅保存<code>数据记录的地址</code>。在MyISAM中，<code>主键索引</code>和<code>辅助索引</code>在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。</p>\n<p><img src=\"./images/Mysql_theory_note/MyISAM_PrimaryKey_index.png\" alt=\"\" /></p>\n<p>这里设表一共有三列，假设我们以Col1为主键，图myisam1是一个MyISAM表的主索引（Primary key）示意。可以看出MyISAM的索引文件仅仅保存<code>数据记录的地址</code>。</p>\n<h4 id=\"辅助索引\"> 辅助索引：</h4>\n<p>在MyISAM中，主索引和辅助索引在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。 如果我们在Col2上建立一个辅助索引，则此索引的结构如下图所示：</p>\n<p><img src=\"./images/Mysql_theory_note/MyISAM_Auxiliary_index.png\" alt=\"\" /></p>\n<h3 id=\"_3-9-innodb实现方式-聚簇索引\"> 3.9 InnoDB实现方式：聚簇索引</h3>\n<p><code>其数据⽂件本身就是索引⽂件</code>。相⽐MyISAM的索引⽂件和数据⽂件是分离的，其<code>表数据⽂件本身就是按B+Tree组织的⼀个索引结构</code>，树的叶节点data域保存了完整的数据记录。这个索 引的key是数据表的主键，因此InnoDB表数据⽂件本身就是主索引。这被称为“聚簇索引（或聚集 索引）”。⽽其余的索引都作为辅助索引，辅助索引的data域存储相应记录<code>主键的值⽽不是地址</code>，这也是和MyISAM不同的地⽅。在根据主索引搜索时，直接找到key所在的节点即可取出数 据；在根据辅助索引查找时，则需要先取出主键索引的值，再⾛⼀遍主索引。 因此，在设计表的时 候，<code>不建议使⽤过⻓的字段作为主键，也不建议使⽤⾮单调的字段作为主键</code>，这样会造成<code>主索引频繁分裂</code>。 PS：整理⾃《Java⼯程师修炼之道》</p>\n<p><img src=\"./images/Mysql_theory_note/InnoDB_PrimaryKey_index.png\" alt=\"\" /></p>\n<p>以上是InnoDB主索引（同时也是数据文件）的示意图，可以看到叶节点包含了完整的数据记录。这种索引叫做<strong>聚集索引</strong>。因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。</p>\n<h4 id=\"辅助索引-2\"> 辅助索引：</h4>\n<p>InnoDB的所有辅助索引都引用主键作为data域，在使用时会先找到主键索引，然后再根据主键索引再来找到叶子节点数据。例如，下图为定义在Col3上的一个辅助索引</p>\n<p><img src=\"./images/Mysql_theory_note/InooDB_Auxiliary_index.png\" alt=\"\" /></p>\n<p><strong>InnoDB 表是基于聚簇索引建立的</strong>。因此InnoDB 的索引能提供一种非常快速的主键查找性能。不过，它的辅助索引（Secondary Index， 也就是非主键索引）也会包含主键列， <strong>所以，如果主键定义的比较大，其他索引也将很大。如果想在表上定义很多索引，则争取尽量把主键定义得小一些。</strong> InnoDB 不会压缩索引。</p>\n<h3 id=\"_3-10-索引使用注意点\"> 3.10 索引使用注意点</h3>\n<table>\n<thead>\n<tr>\n<th>注意点</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>不建议使用过长的字段作为主键</td>\n<td>因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大</td>\n</tr>\n<tr>\n<td>不建议使用单调字段作为主键</td>\n<td>因为InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"_3-11-innodb索引和myisam索引的区别\"> 3.11 <strong>InnoDB索引</strong>和<strong>MyISAM索引</strong>的区别</h3>\n<p>主索引的区别，InnoDB的数据文件本身就是索引文件(<code>聚簇索引</code>)。而MyISAM的索引和数据是分开的(<code>非聚簇索引</code>)。</p>\n<p>辅助索引的区别：InnoDB的辅助索引data域存储相应记录主键的值而不是地址。而MyISAM的辅助索引和主索引没有多大区别</p>\n<h2 id=\"_4-事务\"> 4. 事务</h2>\n<p>事务是逻辑上的⼀组操作，要么都执⾏，要么都不执⾏。 事务最经典也经常被拿出来说例⼦就是转账了。假如⼩明要给⼩红转账1000元，这个转账会涉及到两个 关键操作就是：将⼩明的余额减少1000元，将⼩红的余额增加1000元。万⼀在这两个操作之间突然出现 错误⽐如银⾏系统崩溃，导致⼩明余额减少⽽⼩红的余额没有增加，这样就不对了。事务就是保证这两 个关键操作要么都成功，要么都要失败。</p>\n<h3 id=\"_4-1-什么时候要用到事务\"> 4.1 什么时候要用到事务</h3>\n<p>参考</p>\n<blockquote>\n<ul>\n<li><a href=\"https://blog.csdn.net/sfq_bluesky/article/details/103183535?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param\" target=\"_blank\" rel=\"noopener noreferrer\">什么时候要用到事务</a></li>\n</ul>\n</blockquote>\n<p>当数据库需要处理操作量大、复杂度高的数据的时候需要用到事务。用事务是为了保证数据库的完整性，保证成批的 SQL 语句要么全部执行，要么全部不执行。</p>\n<p>一个数据库事务通常包含了一个序列的对数据库的读/写操作。它的存在包含有以下两个目的：</p>\n<blockquote>\n<ul>\n<li>为数据库操作序列提供了一个从失败中恢复到正常状态的方法，同时提供了数据库即使在异常状态下仍能保持一致性的方法。</li>\n<li>当多个应用程序在并发访问数据库时，可以在这些应用程序之间提供一个隔离方法，以防止彼此的操作互相干扰。</li>\n</ul>\n</blockquote>\n<p>当事务被提交给了数据库管理系统，则数据库管理系统需要确保该事务中的所有操作都成功完成且其结果被永久保存在数据库中，如果事务中有的操作没有成功完成，则事务中的所有操作都需要被回滚，回到事务执行前的状态;同时，该事务对数据库或者其他事务的执行无影响，所有的事务都好像在独立的运行。例如金融</p>\n<h3 id=\"_4-2-回滚注解-transactional\"> 4.2 回滚注解@Transactional</h3>\n<p>参考</p>\n<blockquote>\n<ul>\n<li>https://blog.csdn.net/jiangyu1013/article/details/84397366</li>\n<li>https://www.cnblogs.com/xd502djj/p/10940627.html</li>\n</ul>\n</blockquote>\n<h3 id=\"_4-3-四大特性\"> 4.3 四大特性</h3>\n<p><img src=\"./images/Mysql_theory_note/Affairs_feature.jpg\" alt=\"\" /></p>\n<blockquote>\n<ul>\n<li><strong>原⼦性（Atomicity）</strong>： 事务是最⼩的执⾏单位，不允许分割。事务的原⼦性确保动作要么全部 完成，要么完全不起作⽤；</li>\n<li><strong>⼀致性（Consistency）</strong>： 执⾏事务前后，数据保持⼀致，多个事务对同⼀个数据读取的结果是 相同的；</li>\n<li><strong>隔离性（Isolation）</strong>： 并发访问数据库时，⼀个⽤户的事务不被其他事务所⼲扰，各并发事务之间数据库是独⽴的；</li>\n<li><strong>持久性（Durability）</strong>： ⼀个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发⽣故障也不应该对其有任何影响。</li>\n</ul>\n</blockquote>\n<h3 id=\"_4-4-并发事务带来的问题\"> 4.4 并发事务带来的问题</h3>\n<ul>\n<li><strong>脏读（Dirty read）</strong>: 当⼀个事务正在访问数据并且对数据进⾏了修改，⽽这种修改还没有提交 到数据库中，这时另外⼀个事务也访问了这个数据，然后使⽤了这个数据。因为这个数据是还没 有提交的数据，那么另外⼀个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是 不正确的。</li>\n<li><strong>丢失修改（Lost to modify）</strong>: 指在⼀个事务读取⼀个数据时，另外⼀个事务也访问了该数据， 那么在第⼀个事务中修改了这个数据后，第⼆个事务也修改了这个数据。这样第⼀个事务内的修 改结果就被丢失，因此称为丢失修改。 例如：事务1读取某表中的数据A=20，事务2也读取 A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。</li>\n<li><strong>不可重复读（Unrepeatableread</strong>）: 指在⼀个事务内多次读同⼀数据。在这个事务还没有结束 时，另⼀个事务也访问该数据。那么，在第⼀个事务中的两次读数据之间，由于第⼆个事务的修改导致第⼀个事务两次读取的数据可能不太⼀样。这就发⽣了在⼀个事务内两次读到的数据是不 ⼀样的情况，因此称为不可重复读。</li>\n<li><strong>幻读（Phantom read）</strong>: 幻读与不可重复读类似。它发⽣在⼀个事务（T1）读取了⼏⾏数据，接 着另⼀个并发事务（T2）插⼊了⼀些数据时。在随后的查询中，第⼀个事务（T1）就会发现多了 ⼀些原本不存在的记录，就好像发⽣了幻觉⼀样，所以称为幻读。</li>\n</ul>\n<p>不可重复读和幻读区别：</p>\n<blockquote>\n<p>不可重复读的重点是修改⽐如多次读取⼀条记录发现其中某些列的值被修改，幻读的重点在于新增或者 删除⽐如多次读取⼀条记录发现记录增多或减少了。</p>\n</blockquote>\n<h3 id=\"_4-5-事务隔离级别\"> 4.5 事务隔离级别</h3>\n<p>SQL 标准定义了四个隔离级别：</p>\n<ul>\n<li><strong>READ-UNCOMMITTED(读取未提交)</strong>： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导 致脏读、幻读或不可重复读。</li>\n<li><strong>READ-COMMITTED(读取已提交)</strong>： 允许读取并发事务已经提交的数据，可以阻⽌脏读，但是幻读 或不可重复读仍有可能发⽣。</li>\n<li><strong>REPEATABLE-READ(可重复读)</strong>： 对同⼀字段的多次读取结果都是⼀致的，除⾮数据是被本身事务 ⾃⼰所修改，可以阻⽌脏读和不可重复读，但幻读仍有可能发⽣。</li>\n<li><strong>SERIALIZABLE(可串⾏化)</strong>： 最⾼的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个 执⾏，这样事务之间就完全不可能产⽣⼲扰，也就是说，该级别可以防⽌脏读、不可重复读以及 幻读。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>隔离级别</th>\n<th>脏读</th>\n<th>不可重复读</th>\n<th>幻读</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>READ-UNCOMMITTED</strong></td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr>\n<td><strong>READ-COMMITTED</strong></td>\n<td>×</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr>\n<td><strong>REPEATABLE-READ</strong></td>\n<td>×</td>\n<td>×</td>\n<td>√</td>\n</tr>\n<tr>\n<td><strong>SERIALIZABLE</strong></td>\n<td>×</td>\n<td>×</td>\n<td>×</td>\n</tr>\n</tbody>\n</table>\n<p>MySQL InnoDB 存储引擎的默认⽀持的隔离级别是 <code>REPEATABLE-READ（可重读）</code>。</p>\n<div><pre><code><span>SELECT</span> @<span>@tx_isolation</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>这⾥需要注意的是：与 SQL 标准不同的地⽅在于 InnoDB 存储引擎在 <code>REPEATABLE-READ（可重读）</code> 事 务隔离级别下使⽤的是<code>Next-Key Lock</code> 锁算法，<code>因此可以避免幻读的产⽣</code>，这与其他数据库系统(如 SQL Server) 是不同的。所以说InnoDB 存储引擎的默认⽀持的隔离级别是 REPEATABLE-READ（可重 读） 已经可以完全保证事务的隔离性要求，即达到了 SQL标准的 SERIALIZABLE(可串⾏化) 隔离级 别。因为<code>隔离级别越低，事务请求的锁越少</code>，所以⼤部分数据库系统的隔离级别都是 <code>READCOMMITTED(读取提交内容)</code> ，但是你要知道的是InnoDB 存储引擎默认使⽤ REPEATABLE-READ（可重 读） 并不会有任何性能损失。 InnoDB 存储引擎在 <code>分布式事务</code> 的情况下⼀般会⽤到 <code>SERIALIZABLE(可串⾏化)</code> 隔离级别。</p>\n<h3 id=\"_4-6-mvcc\"> 4.6 MVCC</h3>\n<p>::: tips 参考</p>\n<ul>\n<li>https://blog.csdn.net/SnailMann/article/details/94724197</li>\n</ul>\n<p>:::</p>\n<h2 id=\"_5-三大范式\"> 5. 三大范式</h2>\n<p>参考</p>\n<blockquote>\n<ul>\n<li>https://www.cnblogs.com/linjiqin/archive/2012/04/01/2428695.html</li>\n<li>https://blog.csdn.net/qq_43079376/article/details/93647335</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>第一范式</strong></td>\n<td>据库表中的所有字段值都是不可分解的原子值</td>\n</tr>\n<tr>\n<td><strong>第二范式</strong></td>\n<td>满足第一范式且确保表中的每列都和主键相关，属性完全依赖于主键</td>\n</tr>\n<tr>\n<td><strong>第三范式</strong></td>\n<td>满足第二范式且确保每列都和主键列直接相关，而不是间接相关。非主键外的所有字段必须互不依赖</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"_5-1-第一范式\"> 5.1 第一范式</h3>\n<p>所谓的第一范式就是数据库中的每一列都是不可分割的基本数据项，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性，如果出现重复的属性则需要重新构建实体，新的实体由重复的属性构成。</p>\n<p>第一范式的合理遵循需要根据系统的实际需求来定。比如某些数据库系统中需要用到“地址”这个属性，本来直接将“地址”属性设计成一个数据库表的字段就行。但是如果系统经常会访问“地址”属性中的“城市”部分，那么就非要将“地址”这个属性重新拆分为省份、城市、详细地址等多个部分进行存储，这样在对地址中某一部分操作的时候将非常方便。这样设计才算满足了数据库的第一范式，如下表所示。</p>\n<p><img src=\"./images/Mysql_theory_note/First_normal_form.png\" alt=\"\" /></p>\n<h3 id=\"_5-2-第二范式\"> 5.2 第二范式</h3>\n<p>第二范式在第一范式的基础之上更进一层。第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。也就是说在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。所以有时候需要<code>中间映射表</code></p>\n<p>比如要设计一个订单信息表，因为订单中可能会有多种商品，所以要将订单编号和商品编号作为数据库表的联合主键，如下表所示。</p>\n<p><img src=\"./images/Mysql_theory_note/Second_normal_form_1.png\" alt=\"第二范式1\" /></p>\n<p>这样就产生一个问题：这个表中是以订单编号和商品编号作为联合主键。<strong>这样在该表中商品名称、单位、商品价格等信息不与该表的主键相关，而仅仅是与商品编号相关</strong>。所以在这里违反了第二范式的设计原则。</p>\n<p>而如果把这个订单信息表进行拆分，把商品信息分离到另一个表中，把订单项目表也分离到另一个表中，就非常完美了。如下所示。</p>\n<p><img src=\"./images/Mysql_theory_note/Second_normal_form_2.png\" alt=\"第二范式2\" /></p>\n<h3 id=\"_5-3-第三范式\"> 5.3 第三范式</h3>\n<p>第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。</p>\n<p>比如在设计一个订单数据表的时候，可以将客户编号作为一个外键和订单表建立相应的关系。而不可以在订单表中添加关于客户其它信息（比如姓名、所属公司等）的字段。如下面这两个表所示的设计就是一个满足第三范式的数据库表。</p>\n<p><img src=\"./images/Mysql_theory_note/Thied_normal_form.png\" alt=\"第三范式\" /></p>\n<p>再例如，学生选课表，不能把课程的具体信息列放在此表中，应该多开一个表为课程信息表，然后两个表通过课程id映射。</p>\n<h2 id=\"_6-锁\"> 6. 锁</h2>\n<h2 id=\"_7-mysql的树\"> 7. Mysql的树</h2>\n<h3 id=\"_7-1-字典树-前缀树\"> 7.1 字典树(前缀树)</h3>\n<p>参考</p>\n<blockquote>\n<ul>\n<li>https://www.jianshu.com/p/e431bd41d676</li>\n<li>https://www.jianshu.com/p/bbfe4874f66f</li>\n</ul>\n</blockquote>\n<h4 id=\"性质\"> 性质</h4>\n<p>字典树，一般称为trie树，trie树常用于搜索提示。如当输入一个网址，可以自动搜索出可能的选择。当没有完全匹配的搜索结果，可以返回前缀最相似的可能。</p>\n<p>一个保存了8个键的trie结构，&quot;A&quot;, &quot;to&quot;, &quot;tea&quot;, &quot;ted&quot;, &quot;ten&quot;, &quot;i&quot;, &quot;in&quot;, and &quot;inn&quot;.</p>\n<p><img src=\"./images/Mysql_theory_note/Dictionary_tree.jpg\" alt=\"字典树\" /></p>\n<blockquote>\n<ul>\n<li>根节点不包含字符，除根节点外每个节点都只包含一个字符</li>\n<li>从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串</li>\n<li>每个节点的所有子节点包含的字符都不相同</li>\n</ul>\n</blockquote>\n<h4 id=\"应用场景\"> 应用场景</h4>\n<p>典型应用是用于统计和排序大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：最大限度地减少无谓的字符串比较，查询效率比哈希表高。</p>\n<h4 id=\"优缺点\"> 优缺点</h4>\n<blockquote>\n<ul>\n<li>优点：Trie的核心思想是<strong>空间换时间</strong>。利用字符串的<strong>公共前缀</strong>来降低查询时间的开销以达到提高效率的目的。</li>\n<li>缺点：Trie树也有它的缺点,Trie树的内存消耗非常大.当然,或许用左儿子右兄弟的方法建树的话,可能会好点.</li>\n</ul>\n</blockquote>\n<h4 id=\"插入操作\"> 插入操作</h4>\n<p>Trie.insert(W)：第一个操作是插入操作，就是将一个字符串W加入到集合中。</p>\n<p>参考</p>\n<blockquote>\n<ul>\n<li>https://blog.csdn.net/weixin_39778570/article/details/81990417</li>\n</ul>\n</blockquote>\n<h4 id=\"查找操作\"> 查找操作</h4>\n<p>Trie.search(S)：第二个操作是查询操作，就是查询一个字符串S是不是在集合中。</p>\n<h3 id=\"_7-2-二叉排序树\"> 7.2 二叉排序树</h3>\n<h2 id=\"_8-mysql优化\"> 8. Mysql优化</h2>\n<p>参考</p>\n<blockquote>\n<ul>\n<li>https://blog.csdn.net/qq_35642036/article/details/82820129</li>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247485097&amp;idx=1&amp;sn=84c89da477b1338bdf3e9fcd65514ac1&amp;chksm=cea24962f9d5c074d8d3ff1ab04ee8f0d6486e3d015cfd783503685986485c11738ccb542ba7&amp;token=79317275&amp;lang=zh_CN%23rd\" target=\"_blank\" rel=\"noopener noreferrer\">一条SQL语句在MySQL中如何执行的</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247485117&amp;idx=1&amp;sn=92361755b7c3de488b415ec4c5f46d73&amp;chksm=cea24976f9d5c060babe50c3747616cce63df5d50947903a262704988143c2eeb4069ae45420&amp;token=79317275&amp;lang=zh_CN%23rd\" target=\"_blank\" rel=\"noopener noreferrer\">MySQL高性能优化规范建议</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247485185&amp;idx=1&amp;sn=66ef08b4ab6af5757792223a83fc0d45&amp;chksm=cea248caf9d5c1dc72ec8a281ec16aa3ec3e8066dbb252e27362438a26c33fbe842b0e0adf47&amp;token=79317275&amp;lang=zh_CN%23rd\" target=\"_blank\" rel=\"noopener noreferrer\">一条SQL语句执行得很慢的原因有哪些？</a></li>\n<li><a href=\"https://blog.csdn.net/qq_35642036/article/details/82820129\" target=\"_blank\" rel=\"noopener noreferrer\">实践中如何优化MySQL（精）</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000006158186\" target=\"_blank\" rel=\"noopener noreferrer\">Mysql大表优化</a></li>\n</ul>\n</blockquote>\n<p>可以用<code>explain</code>放在语句前面查看这个语句的执行条件，包括是全表扫描还是走索引</p>\n<h3 id=\"索引-使数据库放弃索引的情况\"> 索引/使数据库放弃索引的情况</h3>\n<div><p>参考</p>\n<ul>\n<li><a href=\"https://segmentfault.com/a/1190000021464570\" target=\"_blank\" rel=\"noopener noreferrer\">一张图搞懂MySQL的索引失效</a></li>\n</ul>\n</div>\n<p>需要优化的是有些查询会使索引失效</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000021464574\" alt=\"索引失效的情况\" /></p>\n<h2 id=\"sql注入\"> SQL注入</h2>\n<div><p>Tips</p>\n<ul>\n<li>https://blog.csdn.net/weixin_40300139/article/details/107855645</li>\n</ul>\n</div>\n",
      "date_published": "2020-09-16T18:10:26.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": []
    },
    {
      "title": "SQL学习笔记",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/database/mysql/SQL_note/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/database/mysql/SQL_note/",
      "content_html": "<h1 id=\"参考\"> 参考</h1>\n<blockquote>\n<ul>\n<li><a href=\"https://www.runoob.com/mysql/mysql-tutorial.html\" target=\"_blank\" rel=\"noopener noreferrer\">MYSQL菜鸟教程</a></li>\n</ul>\n</blockquote>\n<h1 id=\"索引\"> 索引</h1>\n<p>参考</p>\n<blockquote>\n<ul>\n<li>https://www.runoob.com/mysql/mysql-index.html</li>\n<li>https://www.cnblogs.com/songzhixue/p/11160201.html</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>普通索引</td>\n<td>普通索引</td>\n</tr>\n<tr>\n<td>唯一索引</td>\n<td>不允许有俩行具有相同的值，允许空值</td>\n</tr>\n<tr>\n<td>主键索引</td>\n<td>为了保持数据库表与表之间的关系，不允许空值</td>\n</tr>\n<tr>\n<td>全文索引</td>\n<td>全文索引为在字符串数据中进行复杂的词搜索提供有效支持</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"创建表时\"> 创建表时</h2>\n<div><pre><code><span>CREATE</span> <span>TABLE</span> 表名 <span>(</span>\n  字段名<span>1</span>  数据类型 <span>[</span>完整性约束条件…<span>]</span><span>,</span>\n  字段名<span>2</span>  数据类型 <span>[</span>完整性约束条件…<span>]</span><span>,</span>\n  <span>[</span><span>UNIQUE</span> <span>|</span> FULLTEXT <span>|</span> SPATIAL <span>]</span>   <span>INDEX</span> <span>|</span> <span>KEY</span> <span>[</span>索引名<span>]</span>  <span>(</span>字段名<span>[</span><span>(</span>长度<span>)</span><span>]</span>  <span>[</span><span>ASC</span> <span>|</span><span>DESC</span><span>]</span><span>)</span> \n  \n<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>普通索引直接</p>\n<div><pre><code><span>INDEX</span> 索引名 <span>[</span>索引名<span>]</span>  <span>(</span>字段名<span>[</span><span>(</span>长度<span>)</span><span>]</span>  <span>[</span><span>ASC</span> <span>|</span><span>DESC</span><span>]</span><span>)</span> \n</code></pre>\n<div><span>1</span><br></div></div><p>主键索引标注索引时自动为主键索引</p>\n<h2 id=\"create在已存在的表上创建索引\"> CREATE在已存在的表上创建索引</h2>\n<div><pre><code><span>CREATE</span>  <span>[</span><span>UNIQUE</span> <span>|</span> FULLTEXT <span>|</span> SPATIAL <span>]</span>  <span>INDEX</span>  索引名 <span>ON</span> 表名 <span>(</span>字段名<span>[</span><span>(</span>长度<span>)</span><span>]</span>  <span>[</span><span>ASC</span> <span>|</span><span>DESC</span><span>]</span><span>)</span> <span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><h2 id=\"alter-table\"> ALTER TABLE</h2>\n<div><pre><code><span>ALTER</span> <span>TABLE</span> 表名 <span>ADD</span>  <span>[</span><span>UNIQUE</span> <span>|</span> FULLTEXT <span>|</span> SPATIAL <span>]</span> <span>INDEX</span> 索引名 <span>(</span>字段名<span>[</span><span>(</span>长度<span>)</span><span>]</span>  <span>[</span><span>ASC</span> <span>|</span><span>DESC</span><span>]</span><span>)</span> <span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><h2 id=\"删除索引\"> 删除索引</h2>\n<div><pre><code><span>DROP</span> <span>INDEX</span> 索引名 <span>ON</span> 表名字\n</code></pre>\n<div><span>1</span><br></div></div><p>删除主键索引</p>\n<div><pre><code><span>ALTER</span> <span>TABLE</span> 表名 <span>DROP</span> <span>PRIMARY</span> <span>KEY</span>\n</code></pre>\n<div><span>1</span><br></div></div><h2 id=\"显示索引信息\"> 显示索引信息</h2>\n<p>你可以使用 SHOW INDEX 命令来列出表中的相关的索引信息。可以通过添加 \\G 来格式化输出信息。</p>\n<div><pre><code><span>SHOW</span> <span>INDEX</span> <span>FROM</span> table_name<span>;</span> \\G\n</code></pre>\n<div><span>1</span><br></div></div>",
      "date_published": "2020-10-12T20:47:17.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": []
    },
    {
      "title": "数据库学习目录",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/database/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/database/",
      "content_html": "",
      "date_published": "2020-11-25T22:10:27.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": []
    },
    {
      "title": "Redis集群和哨兵",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/database/redis/Redis-cluster&sentinel/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/database/redis/Redis-cluster&sentinel/",
      "content_html": "<p>Redis集群和哨兵</p>\n",
      "date_published": "2021-01-03T22:17:53.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": []
    },
    {
      "title": "Redis部署与基本使用",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/database/redis/Redis_deployment&use/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/database/redis/Redis_deployment&use/",
      "content_html": "<h2 id=\"参考\"> 参考</h2>\n<div><p>Tips</p>\n<ul>\n<li><a href=\"https://www.runoob.com/redis/redis-tutorial.html\" target=\"_blank\" rel=\"noopener noreferrer\">菜鸟笔记Redis</a></li>\n<li><a href=\"http://doc.redisfans.com/\" target=\"_blank\" rel=\"noopener noreferrer\">Redis 命令参考 — Redis 命令参考 (redisfans.com)</a></li>\n</ul>\n</div>\n<h2 id=\"_1-redis安装\"> 1. Redis安装</h2>\n<h3 id=\"使用docker在linux下安装\"> 使用Docker在Linux下安装</h3>\n<p>参考</p>\n<blockquote>\n<ul>\n<li>https://www.runoob.com/docker/docker-install-redis.html</li>\n</ul>\n</blockquote>\n<div><p>Note</p>\n<p><code>redis.conf</code>中是否在后台开启的属性<code>daemonize</code>只能是<code>NO</code>，如果为<code>YES</code> 会的导致 redis 无法启动，因为后台会导致docker无任务可做而退出。</p>\n<div><pre><code>daemonize no\n</code></pre>\n<div><span>1</span><br></div></div></div>\n<h3 id=\"以配置文件方式启动\"> 以配置文件方式启动</h3>\n<p>参考</p>\n<blockquote>\n<ul>\n<li>https://blog.csdn.net/weixin_42456466/article/details/87270959</li>\n</ul>\n</blockquote>\n<p>已配置文件方式启动redis容器</p>\n<div><pre><code><span>docker</span> run -p <span>6379</span>:6379 --name redis-6379 -v /usr/local/docker/redis/redis-6379.conf:/etc/redis/redis-6379.conf -v /usr/local/docker/redis/data:/data -d redis redis-server /etc/redis/redis-6379.conf\n</code></pre>\n<div><span>1</span><br></div></div><p>说明</p>\n<blockquote>\n<ul>\n<li>-p 6378:6379 ：<code>docker端口:本机端口</code>，意思为将容器内6379端口映射到本机器的6379端口</li>\n<li>--name redis01：容器 名字 为 redis01</li>\n<li>-v 映射指向，将本机/data/中<code>/data/docker_data/redis/conf/redis.conf</code>映射到容器中<code>/usr/local/etc/redis/redis.conf</code>文件，修改本机该文件即可同步如容器中的指定文件，这里避免了每次进入容器修改文件的繁琐操作</li>\n<li>-d 后台启动</li>\n<li>redis：镜像名称</li>\n</ul>\n</blockquote>\n<p>进入容器</p>\n<div><pre><code><span>docker</span> <span>exec</span> -it redis-6379 /bin/bash\n</code></pre>\n<div><span>1</span><br></div></div><p>运行redis</p>\n<div><pre><code>redis-cli -p <span>6379</span>\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"修改密码\"> 修改密码</h3>\n<p>参考</p>\n<blockquote>\n<ul>\n<li>https://www.cnblogs.com/x-ll123/p/9717351.html</li>\n</ul>\n</blockquote>\n<h3 id=\"使用redisdesktopmanager连接\"> 使用RedisDesktopManager连接</h3>\n<p>下载RedisDesktopManager后直接连接即可</p>\n<p><img src=\"./images/Redis_deployment&use/RedisDesktopManager.jpg\" alt=\"\" /></p>\n<p>连接后</p>\n<p><img src=\"./images/Redis_deployment&use/RedisDesktopManager-2.jpg\" alt=\"\" /></p>\n<h2 id=\"_2-redis性能测试redis-benchmark\"> 2. Redis性能测试redis-benchmark</h2>\n<p>参考</p>\n<blockquote>\n<ul>\n<li>https://www.runoob.com/redis/redis-benchmarks.html</li>\n</ul>\n</blockquote>\n<p><code>Docker</code>中的<code>redis-benchmark</code>测试命令</p>\n<p>参考</p>\n<blockquote>\n<ul>\n<li>https://blog.csdn.net/jianjun_fei/article/details/95108694</li>\n</ul>\n</blockquote>\n<div><pre><code><span>docker</span> <span>exec</span> -it containerName/containerid redis-benchmark -h <span>127.0</span>.0.1 -p <span>6379</span> -c <span>100</span> -n <span>100000</span>\n</code></pre>\n<div><span>1</span><br></div></div><p><img src=\"./images/Redis_deployment&use/redis-benchmark.jpg\" alt=\"\" /></p>\n<h2 id=\"_3-redis基本命令使用\"> 3. Redis基本命令使用</h2>\n<p>参考</p>\n<blockquote>\n<ul>\n<li><a href=\"https://redis.io/commands\" target=\"_blank\" rel=\"noopener noreferrer\">官方命令文档</a></li>\n<li><a href=\"http://redisdoc.com/\" target=\"_blank\" rel=\"noopener noreferrer\">redis中文文档</a></li>\n<li><a href=\"http://doc.redisfans.com/\" target=\"_blank\" rel=\"noopener noreferrer\">Redis 命令参考 — Redis 命令参考 (redisfans.com)</a></li>\n<li><a href=\"https://www.runoob.com/redis/redis-commands.html\" target=\"_blank\" rel=\"noopener noreferrer\">菜鸟</a></li>\n</ul>\n</blockquote>\n<h3 id=\"查看redis系统状态\"> 查看redis系统状态</h3>\n<div><p>参考</p>\n<ul>\n<li>https://www.cnblogs.com/wshenjin/p/11431378.html</li>\n</ul>\n</div>\n<div><pre><code><span>#部分Redis系统状态统计信息。</span>\ninfo\n<span>#全部Redis系统状态统计信息。</span>\ninfo all\n<span>#某一块的系统状态统计信息，其中section可以忽略大小写。</span>\ninfo section\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id=\"_3-1-数据库\"> 3.1 数据库</h3>\n<p>切换数据库</p>\n<div><pre><code><span>select</span> <span>0</span>\n<span>select</span> <span>1</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>数据库大小(key数量)</p>\n<div><pre><code>dbsize\n</code></pre>\n<div><span>1</span><br></div></div><p>清空当前数据库</p>\n<div><pre><code>flushdb\n\n<span>#清空所有</span>\nflushall\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id=\"_3-2-键key\"> 3.2 键Key</h3>\n<p>参考</p>\n<blockquote>\n<ul>\n<li>https://www.runoob.com/redis/redis-keys.html</li>\n</ul>\n</blockquote>\n<h4 id=\"查看所有key\"> 查看所有key</h4>\n<div><pre><code>keys *\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"设置过期时间\"> 设置过期时间</h4>\n<div><pre><code>expire <span>[</span>key<span>]</span> <span>[</span>second<span>]</span>\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"查看剩余时间\"> 查看剩余时间</h4>\n<div><pre><code>ttl <span>[</span>key<span>]</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>两种情况</p>\n<blockquote>\n<ul>\n<li>-1：未设置过期时间</li>\n<li>-2：已过期或不存在key</li>\n</ul>\n</blockquote>\n<h4 id=\"查看key对应的value类型\"> 查看key对应的value类型</h4>\n<div><pre><code><span>type</span> key\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"给某个key的value拼接\"> 给某个key的value拼接</h4>\n<div><pre><code>append <span>[</span>key<span>]</span> <span>[</span>value<span>]</span>\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"获取key对应value的长度\"> 获取key对应value的长度</h4>\n<div><pre><code>strlen <span>[</span>key<span>]</span>\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"根据range截取\"> 根据range截取</h4>\n<div><pre><code><span>#截取字符串[0,3]</span>\ngetrange <span>[</span>key<span>]</span> <span>0</span> <span>3</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h4 id=\"替换\"> 替换</h4>\n<div><pre><code><span>#从0开始替换为value</span>\nsetrange <span>[</span>key<span>]</span> <span>0</span> <span>[</span>value<span>]</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h4 id=\"对于value为integer类型的操作\"> 对于value为integer类型的操作</h4>\n<h5 id=\"自增长\"> 自增长++</h5>\n<div><pre><code>incr <span>[</span>key<span>]</span>\n</code></pre>\n<div><span>1</span><br></div></div><h5 id=\"自减小\"> 自减小--</h5>\n<div><pre><code>decr <span>[</span>key<span>]</span>\n</code></pre>\n<div><span>1</span><br></div></div><h5 id=\"指定增加大小\"> 指定增加大小</h5>\n<div><pre><code>incrby <span>[</span>key<span>]</span> <span>[</span>number<span>]</span>\n</code></pre>\n<div><span>1</span><br></div></div><h5 id=\"指定减小大小\"> 指定减小大小</h5>\n<div><pre><code>decrby <span>[</span>key<span>]</span> <span>[</span>number<span>]</span>\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"_3-3-list\"> 3.3 List</h3>\n<p>参考</p>\n<blockquote>\n<ul>\n<li><a href=\"https://www.runoob.com/redis/redis-lists.html\" target=\"_blank\" rel=\"noopener noreferrer\">Redis 列表(List) | 菜鸟教程 (runoob.com)</a></li>\n</ul>\n</blockquote>\n<h3 id=\"_3-4-set\"> 3.4 Set</h3>\n<p>参考</p>\n<blockquote>\n<ul>\n<li><a href=\"https://www.runoob.com/redis/redis-sets.html\" target=\"_blank\" rel=\"noopener noreferrer\">Redis 集合(Set) | 菜鸟教程 (runoob.com)</a></li>\n</ul>\n</blockquote>\n<h3 id=\"_3-5-hash\"> 3.5 Hash</h3>\n<p>参考</p>\n<blockquote>\n<ul>\n<li><a href=\"https://www.runoob.com/redis/redis-hashes.html\" target=\"_blank\" rel=\"noopener noreferrer\">Redis 哈希(Hash) | 菜鸟教程 (runoob.com)</a></li>\n</ul>\n</blockquote>\n<h3 id=\"_3-6-zset\"> 3.6 ZSet</h3>\n<p>参考</p>\n<blockquote>\n<ul>\n<li><a href=\"https://www.runoob.com/redis/redis-sorted-sets.html\" target=\"_blank\" rel=\"noopener noreferrer\">Redis 有序集合(sorted set) | 菜鸟教程 (runoob.com)</a></li>\n</ul>\n</blockquote>\n<h3 id=\"_3-7-geospatial\"> 3.7 Geospatial</h3>\n<p>地图经纬度，底层是用ZSet，可以使用ZSet的命令</p>\n<h3 id=\"_3-8-hyperloglog\"> 3.8 Hyperloglog</h3>\n<p>基数</p>\n<h3 id=\"_3-9-bitmap\"> 3.9 Bitmap</h3>\n<p>参考</p>\n<div><p>参考</p>\n<ul>\n<li><a href=\"https://blog.csdn.net/u011957758/article/details/74783347\" target=\"_blank\" rel=\"noopener noreferrer\">一看就懂系列之 详解redis的bitmap在亿级项目中的应用</a></li>\n<li>https://www.cnblogs.com/wuhaidong/articles/10389484.html</li>\n</ul>\n</div>\n<p>二进制，可用于打卡等状态变化</p>\n<h2 id=\"_4-redis事务\"> 4. Redis事务</h2>\n<p>Redis 事务可以一次执行多个命令， 并且带有以下三个重要的保证：</p>\n<blockquote>\n<ul>\n<li>批量操作在发送 EXEC 命令前被放入队列缓存。</li>\n<li>收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行。</li>\n<li>在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中。</li>\n</ul>\n</blockquote>\n<p>一个事务从开始到执行会经历以下三个阶段：</p>\n<blockquote>\n<ul>\n<li>开始事务。</li>\n<li>命令入队。</li>\n<li>执行事务。</li>\n</ul>\n</blockquote>\n<p>以下是一个事务的例子， 它先以 <strong>MULTI</strong> 开始一个事务， 然后将多个命令入队到事务中， 最后由 <strong>EXEC</strong> 命令触发事务， 一并执行事务中的所有命令：</p>\n<div><pre><code>redis <span>127.0</span>.0.1:637<span><span>9</span>></span> MULTI\nOK\n\nredis <span>127.0</span>.0.1:637<span><span>9</span>></span> SET book-name <span>\"Mastering C++ in 21 days\"</span>\nQUEUED\n\nredis <span>127.0</span>.0.1:637<span><span>9</span>></span> GET book-name\nQUEUED\n\nredis <span>127.0</span>.0.1:637<span><span>9</span>></span> SADD tag <span>\"C++\"</span> <span>\"Programming\"</span> <span>\"Mastering Series\"</span>\nQUEUED\n\nredis <span>127.0</span>.0.1:637<span><span>9</span>></span> SMEMBERS tag\nQUEUED\n\nredis <span>127.0</span>.0.1:637<span><span>9</span>></span> EXEC\n<span>1</span><span>)</span> OK\n<span>2</span><span>)</span> <span>\"Mastering C++ in 21 days\"</span>\n<span>3</span><span>)</span> <span>(</span>integer<span>)</span> <span>3</span>\n<span>4</span><span>)</span> <span>1</span><span>)</span> <span>\"Mastering Series\"</span>\n   <span>2</span><span>)</span> <span>\"C++\"</span>\n   <span>3</span><span>)</span> <span>\"Programming\"</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><p>单个 Redis 命令的执行是原子性的，但 Redis 没有在事务上增加任何维持原子性的机制，所以 Redis 事务的执行并不是原子性的。</p>\n<p>事务可以理解为一个打包的批量执行脚本，但批量指令并非原子化的操作，中间某条指令的失败不会导致前面已做指令的回滚，也不会造成后续的指令不做。</p>\n<div><pre><code>redis <span>127.0</span>.0.1:700<span><span>0</span>></span> multi\nOK\nredis <span>127.0</span>.0.1:700<span><span>0</span>></span> <span>set</span> a aaa\nQUEUED\nredis <span>127.0</span>.0.1:700<span><span>0</span>></span> <span>set</span> b bbb\nQUEUED\nredis <span>127.0</span>.0.1:700<span><span>0</span>></span> <span>set</span> c ccc\nQUEUED\nredis <span>127.0</span>.0.1:700<span><span>0</span>></span> <span>exec</span>\n<span>1</span><span>)</span> OK\n<span>2</span><span>)</span> OK\n<span>3</span><span>)</span> OK\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>如果在 <code>set b bbb</code> 处失败，<code>set a</code> 已成功不会回滚，<code>set c</code> 还会继续执行。</p>\n<p>取消事务</p>\n<div><pre><code>discard\n</code></pre>\n<div><span>1</span><br></div></div><h2 id=\"_5-redis用监视器实现锁\"> 5. Redis用监视器实现锁</h2>\n<p>开启一个线程，开启监视器监视key<code>money</code></p>\n<div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> get money\n<span>\"1080\"</span>\n<span>127.0</span>.0.1:637<span><span>9</span>></span> <span>watch</span> money\nOK\n<span>127.0</span>.0.1:637<span><span>9</span>></span> multi\nOK\n<span>127.0</span>.0.1:637<span><span>9</span>></span> incrby money <span>100</span>\nQUEUED\n\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>在执行事务前修改前，用另一个线程修改<code>money</code>的值</p>\n<div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> get money\n<span>\"1080\"</span>\n<span>127.0</span>.0.1:637<span><span>9</span>></span> <span>set</span> money <span>2000</span>\nOK\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>此时再执行第一个线程的事务，redis发现监视的值<code>money</code>被更改，不会执行关于<code>money</code>的操作</p>\n<div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> <span>exec</span>\n<span>(</span>nil<span>)</span>\n<span>127.0</span>.0.1:637<span><span>9</span>></span> \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id=\"原理\"> 原理</h3>\n<p>watch相当于实现了<code>乐观锁</code></p>\n<h2 id=\"_6-jedis操作redis\"> 6. Jedis操作Redis</h2>\n<p>导入包</p>\n<div><pre><code>        <span>&lt;!-- https://mvnrepository.com/artifact/redis.clients/jedis --></span>\n        <span><span><span>&lt;</span>dependency</span><span>></span></span>\n            <span><span><span>&lt;</span>groupId</span><span>></span></span>redis.clients<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n            <span><span><span>&lt;</span>artifactId</span><span>></span></span>jedis<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n            <span><span><span>&lt;</span>version</span><span>></span></span>3.3.0<span><span><span>&lt;/</span>version</span><span>></span></span>\n        <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n\n        <span><span><span>&lt;</span>dependency</span><span>></span></span>\n            <span><span><span>&lt;</span>groupId</span><span>></span></span>com.alibaba<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n            <span><span><span>&lt;</span>artifactId</span><span>></span></span>fastjson<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n            <span><span><span>&lt;</span>version</span><span>></span></span>1.2.70<span><span><span>&lt;/</span>version</span><span>></span></span>\n        <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h3 id=\"_6-1-测试连接\"> 6.1 测试连接</h3>\n<div><pre><code><span>public</span> <span>class</span> pingTest <span>{</span>\n    \n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>Jedis</span> jedis <span>=</span> <span>new</span> <span>Jedis</span><span>(</span><span>\"127.0.0.1\"</span><span>,</span> <span>6379</span><span>)</span><span>;</span>\n        <span>//密码验证</span>\n        jedis<span>.</span><span>auth</span><span>(</span><span>\"123456\"</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>jedis<span>.</span><span>ping</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id=\"_6-2-hashtest\"> 6.2 HashTest</h3>\n<div><pre><code><span>public</span> <span>class</span> <span>TestHash</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>Jedis</span> jedis <span>=</span> <span>new</span> <span>Jedis</span><span>(</span><span>\"47.100.59.153\"</span><span>,</span> <span>6379</span><span>)</span><span>;</span>\n        jedis<span>.</span><span>auth</span><span>(</span><span>\"0.00.0\"</span><span>)</span><span>;</span>\n        jedis<span>.</span><span>flushDB</span><span>(</span><span>)</span><span>;</span>\n        <span>Map</span><span><span>&lt;</span><span>String</span><span>,</span><span>String</span><span>></span></span> map <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>String</span><span>,</span><span>String</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n        map<span>.</span><span>put</span><span>(</span><span>\"key1\"</span><span>,</span><span>\"value1\"</span><span>)</span><span>;</span>\n        map<span>.</span><span>put</span><span>(</span><span>\"key2\"</span><span>,</span><span>\"value2\"</span><span>)</span><span>;</span>\n        map<span>.</span><span>put</span><span>(</span><span>\"key3\"</span><span>,</span><span>\"value3\"</span><span>)</span><span>;</span>\n        map<span>.</span><span>put</span><span>(</span><span>\"key4\"</span><span>,</span><span>\"value4\"</span><span>)</span><span>;</span>\n        <span>//添加名称为hash（key）的hash元素</span>\n        jedis<span>.</span><span>hmset</span><span>(</span><span>\"hash\"</span><span>,</span>map<span>)</span><span>;</span>\n        <span>//向名称为hash的hash中添加key为key5，value为value5元素</span>\n        jedis<span>.</span><span>hset</span><span>(</span><span>\"hash\"</span><span>,</span> <span>\"key5\"</span><span>,</span> <span>\"value5\"</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"散列hash的所有键值对为：\"</span><span>+</span>jedis<span>.</span><span>hgetAll</span><span>(</span><span>\"hash\"</span><span>)</span><span>)</span><span>;</span><span>//return Map&lt;String,String></span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"散列hash的所有键为：\"</span><span>+</span>jedis<span>.</span><span>hkeys</span><span>(</span><span>\"hash\"</span><span>)</span><span>)</span><span>;</span><span>//return Set&lt;String></span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"散列hash的所有值为：\"</span><span>+</span>jedis<span>.</span><span>hvals</span><span>(</span><span>\"hash\"</span><span>)</span><span>)</span><span>;</span><span>//return List&lt;String></span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"将key6保存的值加上一个整数，如果key6不存在则添加key6：\"</span><span>+</span>jedis<span>.</span><span>hincrBy</span><span>(</span><span>\"hash\"</span><span>,</span> <span>\"key6\"</span><span>,</span> <span>6</span><span>)</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"散列hash的所有键值对为：\"</span><span>+</span>jedis<span>.</span><span>hgetAll</span><span>(</span><span>\"hash\"</span><span>)</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"将key6保存的值加上一个整数，如果key6不存在则添加key6：\"</span><span>+</span>jedis<span>.</span><span>hincrBy</span><span>(</span><span>\"hash\"</span><span>,</span> <span>\"key6\"</span><span>,</span> <span>3</span><span>)</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"散列hash的所有键值对为：\"</span><span>+</span>jedis<span>.</span><span>hgetAll</span><span>(</span><span>\"hash\"</span><span>)</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"删除一个或者多个键值对：\"</span><span>+</span>jedis<span>.</span><span>hdel</span><span>(</span><span>\"hash\"</span><span>,</span> <span>\"key2\"</span><span>)</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"散列hash的所有键值对为：\"</span><span>+</span>jedis<span>.</span><span>hgetAll</span><span>(</span><span>\"hash\"</span><span>)</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"散列hash中键值对的个数：\"</span><span>+</span>jedis<span>.</span><span>hlen</span><span>(</span><span>\"hash\"</span><span>)</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"判断hash中是否存在key2：\"</span><span>+</span>jedis<span>.</span><span>hexists</span><span>(</span><span>\"hash\"</span><span>,</span><span>\"key2\"</span><span>)</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"判断hash中是否存在key3：\"</span><span>+</span>jedis<span>.</span><span>hexists</span><span>(</span><span>\"hash\"</span><span>,</span><span>\"key3\"</span><span>)</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"获取hash中的值：\"</span><span>+</span>jedis<span>.</span><span>hmget</span><span>(</span><span>\"hash\"</span><span>,</span><span>\"key3\"</span><span>)</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"获取hash中的值：\"</span><span>+</span>jedis<span>.</span><span>hmget</span><span>(</span><span>\"hash\"</span><span>,</span><span>\"key3\"</span><span>,</span><span>\"key4\"</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><h2 id=\"_7-springboot整合redis\"> 7. SpringBoot整合Redis</h2>\n<p>原先底层使用的是<code>jedis</code>，在Spring2.x后改为<code>lettuce</code></p>\n<blockquote>\n<ul>\n<li>jedis：采用的直连,多个线程操作的话,是不安全的,如果想要避免不安全的,使用 <code>jedis pool</code>连接池!更像<code>BIO模式</code></li>\n<li>lettuce：采用<code>netty</code>，实例可以再多个线程中进行共享,不存在线程不安全的情况!可以减少线程数据了,更像<code>NIO模式</code></li>\n</ul>\n</blockquote>\n<h3 id=\"_7-1-导入依赖\"> 7.1 导入依赖</h3>\n<p><code>pom.xml</code></p>\n<div><pre><code><span><span>&lt;</span>dependency<span>></span></span>\n  <span><span>&lt;</span>groupId<span>></span></span>org<span>.</span>springframework<span>.</span>boot<span>&lt;</span><span>/</span>groupId<span>></span>\n  <span><span>&lt;</span>artifactId<span>></span></span>spring<span>-</span>boot<span>-</span>starter<span>-</span>data<span>-</span>redis<span>&lt;</span><span>/</span>artifactId<span>></span>\n<span>&lt;</span><span>/</span>dependency<span>></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id=\"_7-2-application-yml配置\"> 7.2 <code>application.yml</code>配置</h3>\n<div><pre><code>  <span>#reids相关配置</span>\n  <span>redis</span><span>:</span>\n    <span>#redis服务器地址</span>\n    <span>host</span><span>:</span> 47.100.59.153\n    <span>#redis服务器端口</span>\n    <span>port</span><span>:</span> <span>6379</span>\n    <span>database</span><span>:</span> <span>0</span>\n    <span>#密码</span>\n    <span>password</span><span>:</span> 0.00.0\n    <span>lettuce</span><span>:</span>\n      <span>pool</span><span>:</span>\n        <span>#连接池最大连接数（使用负值表示没有限制）</span>\n        <span>max-active</span><span>:</span> <span>1024</span>\n        <span>#连接池最大阻塞等待时间（使用负值表示没有限制）</span>\n        <span>max-wait</span><span>:</span> 10000ms\n        <span>#连接池中最大空闲连接</span>\n        <span>max-idle</span><span>:</span> <span>200</span>\n        <span>#连接池中最小空闲连接</span>\n        <span>min-idle</span><span>:</span> <span>5</span>\n    <span># 连接超时时间(毫秒)</span>\n    <span>timeout</span><span>:</span> 10000ms\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><h3 id=\"_7-3-简单使用示例\"> 7.3 简单使用示例</h3>\n<p><code>SpringbootDemoApplicationTests.java</code></p>\n<div><pre><code>    <span>@Autowired</span>\n    <span>private</span> <span>RedisTemplate</span><span><span>&lt;</span><span>String</span><span>,</span> <span>String</span><span>></span></span> redisTemplate<span>;</span>\n\n\n    <span>@Test</span>\n    <span>void</span> <span>redisTest</span><span>(</span><span>)</span> <span>{</span>\n        redisTemplate<span>.</span><span>opsForValue</span><span>(</span><span>)</span><span>.</span><span>set</span><span>(</span><span>\"myKey\"</span><span>,</span><span>\"你好\"</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>redisTemplate<span>.</span><span>opsForValue</span><span>(</span><span>)</span><span>.</span><span>get</span><span>(</span><span>\"myKey\"</span><span>)</span><span>)</span><span>;</span>\n\n        <span>/*获得数据库对象*/</span>\n        <span>RedisConnection</span> conn <span>=</span> redisTemplate<span>.</span><span>getConnectionFactory</span><span>(</span><span>)</span><span>.</span><span>getConnection</span><span>(</span><span>)</span><span>;</span>\n        conn<span>.</span><span>flushDb</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h3 id=\"_7-4-序列化配置\"> 7.4 序列化配置</h3>\n<p><code>RedisAutoConfiguration.java</code></p>\n<div><pre><code><span>@Configuration</span><span>(</span>\n  proxyBeanMethods <span>=</span> <span>false</span>\n<span>)</span>\n<span>@ConditionalOnClass</span><span>(</span><span>{</span><span>RedisOperations</span><span>.</span><span>class</span><span>}</span><span>)</span>\n<span>@EnableConfigurationProperties</span><span>(</span><span>{</span><span>RedisProperties</span><span>.</span><span>class</span><span>}</span><span>)</span>\n<span>@Import</span><span>(</span><span>{</span><span>LettuceConnectionConfiguration</span><span>.</span><span>class</span><span>,</span> <span>JedisConnectionConfiguration</span><span>.</span><span>class</span><span>}</span><span>)</span>\n<span>public</span> <span>class</span> <span>RedisAutoConfiguration</span> <span>{</span>\n  <span>public</span> <span>RedisAutoConfiguration</span><span>(</span><span>)</span> <span>{</span>\n  <span>}</span>\n\n  <span>@Bean</span>\n  <span>@ConditionalOnMissingBean</span><span>(</span>\n    name <span>=</span> <span>{</span><span>\"redisTemplate\"</span><span>}</span>\n  <span>)</span> <span>//注解意思为当没有自定义redisTemplate使使用此bean，可以自定义来替换这个默认的</span>\n  <span>public</span> <span>RedisTemplate</span><span><span>&lt;</span><span>Object</span><span>,</span> <span>Object</span><span>></span></span> <span>redisTemplate</span><span>(</span><span>RedisConnectionFactory</span> redisConnectionFactory<span>)</span> <span>throws</span> <span>UnknownHostException</span> <span>{</span>\n    <span>// 默认的RedisTemplate没有过多地设置，redis对象都是需要序列化</span>\n    <span>// 两个泛型都是object object 的类型，我们后使用需要强制转换&lt;String, Object></span>\n    <span>RedisTemplate</span><span><span>&lt;</span><span>Object</span><span>,</span> <span>Object</span><span>></span></span> template <span>=</span> <span>new</span> <span>RedisTemplate</span><span>(</span><span>)</span><span>;</span>\n    template<span>.</span><span>setConnectionFactory</span><span>(</span>redisConnectionFactory<span>)</span><span>;</span>\n    <span>return</span> template<span>;</span>\n  <span>}</span>\n\n  <span>@Bean</span>\n  <span>@ConditionalOnMissingBean</span> <span>//由于string是最常使用的bean，所以这里单独定义一个string的redisTemplate</span>\n  <span>public</span> <span>StringRedisTemplate</span> <span>stringRedisTemplate</span><span>(</span><span>RedisConnectionFactory</span> redisConnectionFactory<span>)</span> <span>throws</span> <span>UnknownHostException</span> <span>{</span>\n    <span>StringRedisTemplate</span> template <span>=</span> <span>new</span> <span>StringRedisTemplate</span><span>(</span><span>)</span><span>;</span>\n    template<span>.</span><span>setConnectionFactory</span><span>(</span>redisConnectionFactory<span>)</span><span>;</span>\n    <span>return</span> template<span>;</span>\n  <span>}</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div><p><code>RedisTemplate.java</code></p>\n<div><pre><code><span>@Nullable</span>\n<span>private</span> <span>RedisSerializer</span><span><span>&lt;</span><span>?</span><span>></span></span> defaultSerializer<span>;</span>\n<span>@Nullable</span>\n<span>private</span> <span>ClassLoader</span> classLoader<span>;</span>\n<span>@Nullable</span>\n<span>private</span> <span>RedisSerializer</span> keySerializer <span>=</span> <span>null</span><span>;</span>\n<span>@Nullable</span>\n<span>private</span> <span>RedisSerializer</span> valueSerializer <span>=</span> <span>null</span><span>;</span>\n<span>@Nullable</span>\n<span>private</span> <span>RedisSerializer</span> hashKeySerializer <span>=</span> <span>null</span><span>;</span>\n<span>@Nullable</span>\n<span>private</span> <span>RedisSerializer</span> hashValueSerializer <span>=</span> <span>null</span><span>;</span>\n\n\n<span>//这里默认使用的是JDK的序列化，可以自定义一个配置类使用JSON序列化</span>\n<span>if</span> <span>(</span><span>this</span><span>.</span>defaultSerializer <span>==</span> <span>null</span><span>)</span> <span>{</span>\n  <span>this</span><span>.</span>defaultSerializer <span>=</span> <span>new</span> <span>JdkSerializationRedisSerializer</span><span>(</span><span>this</span><span>.</span>classLoader <span>!=</span> <span>null</span> <span>?</span> <span>this</span><span>.</span>classLoader <span>:</span> <span>this</span><span>.</span><span>getClass</span><span>(</span><span>)</span><span>.</span><span>getClassLoader</span><span>(</span><span>)</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>当没有序列化对象直接传对象作为<code>value</code>时会报错误<code>SerializationException</code></p>\n<div><pre><code><span>@Autowired</span>\n<span>private</span> <span>RedisTemplate</span> redisTemplate<span>;</span>\n\n<span>@Test</span>\n<span>void</span> <span>redisTest_2</span><span>(</span><span>)</span> <span>throws</span> <span>JsonProcessingException</span> <span>{</span>\n  <span>User</span> user <span>=</span> <span>User</span><span>.</span><span>builder</span><span>(</span><span>)</span><span>.</span><span>uid</span><span>(</span><span>1</span><span>)</span><span>.</span><span>realName</span><span>(</span><span>\"realName\"</span><span>)</span><span>.</span><span>build</span><span>(</span><span>)</span><span>;</span>\n  <span>// 当没有序列化对象时</span>\n  <span>// String jsonUser = new ObjectMapper().writeValueAsString(user);</span>\n  redisTemplate<span>.</span><span>opsForValue</span><span>(</span><span>)</span><span>.</span><span>set</span><span>(</span><span>\"user1\"</span><span>,</span>user<span>)</span><span>;</span>\n  <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>redisTemplate<span>.</span><span>opsForValue</span><span>(</span><span>)</span><span>.</span><span>get</span><span>(</span><span>\"user1\"</span><span>)</span><span>)</span><span>;</span>\n\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p><img src=\"./images/Redis_deployment&use/SerializationException.jpg\" alt=\"\" /></p>\n<h3 id=\"_7-5-配置redisconfig类\"> 7.5 配置redisConfig类</h3>\n<p><code>redisConfig.java</code></p>\n<p>用于替换在<code>RedisAutoConfiguration</code>默认的<code>RedisTemplate</code></p>\n<div><pre><code><span>@Configuration</span>\n<span>public</span> <span>class</span> <span>RedisConfig</span> <span>{</span>\n\n    <span>/*自定义RedisTemplate*/</span>\n    <span>@Bean</span>\n    <span>public</span> <span>RedisTemplate</span> <span>redisTemplate</span><span>(</span><span>RedisConnectionFactory</span> factory<span>)</span> <span>{</span>\n        <span>RedisTemplate</span><span><span>&lt;</span><span>String</span><span>,</span> <span>Object</span><span>></span></span> redisTemplate <span>=</span> <span>new</span> <span>RedisTemplate</span><span><span>&lt;</span><span>String</span><span>,</span> <span>Object</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n        redisTemplate<span>.</span><span>setConnectionFactory</span><span>(</span>factory<span>)</span><span>;</span>\n\n        <span>// 使用Jackson2JsonRedisSerialize 替换默认序列化</span>\n        <span>Jackson2JsonRedisSerializer</span> jackson2JsonRedisSerializer <span>=</span> <span>new</span> <span>Jackson2JsonRedisSerializer</span><span>(</span><span>Object</span><span>.</span><span>class</span><span>)</span><span>;</span>\n        <span>ObjectMapper</span> objectMapper <span>=</span> <span>new</span> <span>ObjectMapper</span><span>(</span><span>)</span><span>;</span>\n        objectMapper<span>.</span><span>setVisibility</span><span>(</span><span>PropertyAccessor</span><span>.</span>ALL<span>,</span> <span>JsonAutoDetect<span>.</span>Visibility</span><span>.</span>ANY<span>)</span><span>;</span>\n        objectMapper<span>.</span><span>enableDefaultTyping</span><span>(</span><span>ObjectMapper<span>.</span>DefaultTyping</span><span>.</span>NON_FINAL<span>)</span><span>;</span>\n        jackson2JsonRedisSerializer<span>.</span><span>setObjectMapper</span><span>(</span>objectMapper<span>)</span><span>;</span>\n\n        <span>// 设置value的序列化规则和 key的序列化规则</span>\n        <span>StringRedisSerializer</span> stringRedisSerializer <span>=</span> <span>new</span> <span>StringRedisSerializer</span><span>(</span><span>)</span><span>;</span>\n        <span>// key采用String的序列化方式</span>\n        redisTemplate<span>.</span><span>setKeySerializer</span><span>(</span>stringRedisSerializer<span>)</span><span>;</span>\n        <span>// hash的key也采用String的序列化方式</span>\n        redisTemplate<span>.</span><span>setHashKeySerializer</span><span>(</span>stringRedisSerializer<span>)</span><span>;</span>\n        <span>// value序列化方式采用jackson</span>\n        redisTemplate<span>.</span><span>setValueSerializer</span><span>(</span>jackson2JsonRedisSerializer<span>)</span><span>;</span>\n        <span>// hash的value也采用jackson</span>\n        redisTemplate<span>.</span><span>setHashValueSerializer</span><span>(</span>jackson2JsonRedisSerializer<span>)</span><span>;</span>\n\n        redisTemplate<span>.</span><span>afterPropertiesSet</span><span>(</span><span>)</span><span>;</span>\n        <span>return</span> redisTemplate<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div><p>存储一个对象</p>\n<div><pre><code><span>@Test</span>\n<span>void</span> <span>redisTest_2</span><span>(</span><span>)</span> <span>throws</span> <span>JsonProcessingException</span> <span>{</span>\n  <span>User</span> user <span>=</span> <span>User</span><span>.</span><span>builder</span><span>(</span><span>)</span><span>.</span><span>uid</span><span>(</span><span>5</span><span>)</span><span>.</span><span>realName</span><span>(</span><span>\"realName\"</span><span>)</span><span>.</span><span>build</span><span>(</span><span>)</span><span>;</span>\n  redisTemplate<span>.</span><span>opsForValue</span><span>(</span><span>)</span><span>.</span><span>set</span><span>(</span><span>\"user5\"</span><span>,</span>user<span>)</span><span>;</span>\n  <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>redisTemplate<span>.</span><span>opsForValue</span><span>(</span><span>)</span><span>.</span><span>get</span><span>(</span><span>\"user5\"</span><span>)</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>存储在redis中的是已经序列化的字符串</p>\n<p><img src=\"./images/Redis_deployment&use/after_serializationException.jpg\" alt=\"存储在Redis中序列化的User\" /></p>\n<p>取出来后会经过反序列化</p>\n<p><img src=\"./images/Redis_deployment&use/after_serializationException_2.jpg\" alt=\"取出User并反序列化\" /></p>\n<h3 id=\"_7-6-封装常用api到redisutil\"> 7.6 封装常用API到<code>RedisUtil</code></h3>\n<details><summary>RedisUtil.java</summary>\n<div><pre><code><span>package</span> <span>com<span>.</span>lifeisgg<span>.</span>springboot_demo<span>.</span>util</span><span>;</span>\n\n<span>import</span> <span>org<span>.</span>springframework<span>.</span>beans<span>.</span>factory<span>.</span>annotation<span>.</span></span><span>Autowired</span><span>;</span>\n<span>import</span> <span>org<span>.</span>springframework<span>.</span>data<span>.</span>redis<span>.</span>core<span>.</span></span><span>RedisTemplate</span><span>;</span>\n<span>import</span> <span>org<span>.</span>springframework<span>.</span>stereotype<span>.</span></span><span>Component</span><span>;</span>\n<span>import</span> <span>org<span>.</span>springframework<span>.</span>util<span>.</span></span><span>CollectionUtils</span><span>;</span>\n\n<span>import</span> <span>java<span>.</span>util<span>.</span></span><span>List</span><span>;</span>\n<span>import</span> <span>java<span>.</span>util<span>.</span></span><span>Map</span><span>;</span>\n<span>import</span> <span>java<span>.</span>util<span>.</span></span><span>Set</span><span>;</span>\n<span>import</span> <span>java<span>.</span>util<span>.</span>concurrent<span>.</span></span><span>TimeUnit</span><span>;</span>\n\n<span>/**\n * @Project: springboot_demo\n * @Package: com.lifeisgg.springboot_demo.util\n * @ClassName: RedisUtil\n * @Author: Chen Long\n * @Description:\n * @Datetime: 2020/12/1  20:32\n */</span>\n<span>@Component</span>\n<span>public</span> <span>final</span> <span>class</span> <span>RedisUtil</span> <span>{</span>\n\n    <span>@Autowired</span>\n    <span>private</span> <span>RedisTemplate</span><span><span>&lt;</span><span>String</span><span>,</span> <span>Object</span><span>></span></span> redisTemplate<span>;</span>\n\n    <span>// =============================common============================</span>\n    <span>/**\n     * 指定缓存失效时间\n     * @param key  键\n     * @param time 时间(秒)\n     */</span>\n    <span>public</span> <span>boolean</span> <span>expire</span><span>(</span><span>String</span> key<span>,</span> <span>long</span> time<span>)</span> <span>{</span>\n        <span>try</span> <span>{</span>\n            <span>if</span> <span>(</span>time <span>></span> <span>0</span><span>)</span> <span>{</span>\n                redisTemplate<span>.</span><span>expire</span><span>(</span>key<span>,</span> time<span>,</span> <span>TimeUnit</span><span>.</span>SECONDS<span>)</span><span>;</span>\n            <span>}</span>\n            <span>return</span> <span>true</span><span>;</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>Exception</span> e<span>)</span> <span>{</span>\n            e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n            <span>return</span> <span>false</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>/**\n     * 根据key 获取过期时间\n     * @param key 键 不能为null\n     * @return 时间(秒) 返回0代表为永久有效\n     */</span>\n    <span>public</span> <span>long</span> <span>getExpire</span><span>(</span><span>String</span> key<span>)</span> <span>{</span>\n        <span>return</span> redisTemplate<span>.</span><span>getExpire</span><span>(</span>key<span>,</span> <span>TimeUnit</span><span>.</span>SECONDS<span>)</span><span>;</span>\n    <span>}</span>\n\n\n    <span>/**\n     * 判断key是否存在\n     * @param key 键\n     * @return true 存在 false不存在\n     */</span>\n    <span>public</span> <span>boolean</span> <span>hasKey</span><span>(</span><span>String</span> key<span>)</span> <span>{</span>\n        <span>try</span> <span>{</span>\n            <span>return</span> redisTemplate<span>.</span><span>hasKey</span><span>(</span>key<span>)</span><span>;</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>Exception</span> e<span>)</span> <span>{</span>\n            e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n            <span>return</span> <span>false</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n\n    <span>/**\n     * 删除缓存\n     * @param key 可以传一个值 或多个\n     */</span>\n    <span>@SuppressWarnings</span><span>(</span><span>\"unchecked\"</span><span>)</span>\n    <span>public</span> <span>void</span> <span>del</span><span>(</span><span>String</span><span>.</span><span>.</span><span>.</span> key<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>key <span>!=</span> <span>null</span> <span>&amp;&amp;</span> key<span>.</span>length <span>></span> <span>0</span><span>)</span> <span>{</span>\n            <span>if</span> <span>(</span>key<span>.</span>length <span>==</span> <span>1</span><span>)</span> <span>{</span>\n                redisTemplate<span>.</span><span>delete</span><span>(</span>key<span>[</span><span>0</span><span>]</span><span>)</span><span>;</span>\n            <span>}</span> <span>else</span> <span>{</span>\n                redisTemplate<span>.</span><span>delete</span><span>(</span><span>CollectionUtils</span><span>.</span><span>arrayToList</span><span>(</span>key<span>)</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n    <span>}</span>\n\n\n    <span>// ============================String=============================</span>\n\n    <span>/**\n     * 普通缓存获取\n     * @param key 键\n     * @return 值\n     */</span>\n    <span>public</span> <span>Object</span> <span>get</span><span>(</span><span>String</span> key<span>)</span> <span>{</span>\n        <span>return</span> key <span>==</span> <span>null</span> <span>?</span> <span>null</span> <span>:</span> redisTemplate<span>.</span><span>opsForValue</span><span>(</span><span>)</span><span>.</span><span>get</span><span>(</span>key<span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>/**\n     * 普通缓存放入\n     * @param key   键\n     * @param value 值\n     * @return true成功 false失败\n     */</span>\n\n    <span>public</span> <span>boolean</span> <span>set</span><span>(</span><span>String</span> key<span>,</span> <span>Object</span> value<span>)</span> <span>{</span>\n        <span>try</span> <span>{</span>\n            redisTemplate<span>.</span><span>opsForValue</span><span>(</span><span>)</span><span>.</span><span>set</span><span>(</span>key<span>,</span> value<span>)</span><span>;</span>\n            <span>return</span> <span>true</span><span>;</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>Exception</span> e<span>)</span> <span>{</span>\n            e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n            <span>return</span> <span>false</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n\n    <span>/**\n     * 普通缓存放入并设置时间\n     * @param key   键\n     * @param value 值\n     * @param time  时间(秒) time要大于0 如果time小于等于0 将设置无限期\n     * @return true成功 false 失败\n     */</span>\n\n    <span>public</span> <span>boolean</span> <span>set</span><span>(</span><span>String</span> key<span>,</span> <span>Object</span> value<span>,</span> <span>long</span> time<span>)</span> <span>{</span>\n        <span>try</span> <span>{</span>\n            <span>if</span> <span>(</span>time <span>></span> <span>0</span><span>)</span> <span>{</span>\n                redisTemplate<span>.</span><span>opsForValue</span><span>(</span><span>)</span><span>.</span><span>set</span><span>(</span>key<span>,</span> value<span>,</span> time<span>,</span> <span>TimeUnit</span><span>.</span>SECONDS<span>)</span><span>;</span>\n            <span>}</span> <span>else</span> <span>{</span>\n                <span>set</span><span>(</span>key<span>,</span> value<span>)</span><span>;</span>\n            <span>}</span>\n            <span>return</span> <span>true</span><span>;</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>Exception</span> e<span>)</span> <span>{</span>\n            e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n            <span>return</span> <span>false</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n\n    <span>/**\n     * 递增\n     * @param key   键\n     * @param delta 要增加几(大于0)\n     */</span>\n    <span>public</span> <span>long</span> <span>incr</span><span>(</span><span>String</span> key<span>,</span> <span>long</span> delta<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>delta <span>&lt;</span> <span>0</span><span>)</span> <span>{</span>\n            <span>throw</span> <span>new</span> <span>RuntimeException</span><span>(</span><span>\"递增因子必须大于0\"</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>return</span> redisTemplate<span>.</span><span>opsForValue</span><span>(</span><span>)</span><span>.</span><span>increment</span><span>(</span>key<span>,</span> delta<span>)</span><span>;</span>\n    <span>}</span>\n\n\n    <span>/**\n     * 递减\n     * @param key   键\n     * @param delta 要减少几(小于0)\n     */</span>\n    <span>public</span> <span>long</span> <span>decr</span><span>(</span><span>String</span> key<span>,</span> <span>long</span> delta<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>delta <span>&lt;</span> <span>0</span><span>)</span> <span>{</span>\n            <span>throw</span> <span>new</span> <span>RuntimeException</span><span>(</span><span>\"递减因子必须大于0\"</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>return</span> redisTemplate<span>.</span><span>opsForValue</span><span>(</span><span>)</span><span>.</span><span>increment</span><span>(</span>key<span>,</span> <span>-</span>delta<span>)</span><span>;</span>\n    <span>}</span>\n\n\n    <span>// ================================Map=================================</span>\n\n    <span>/**\n     * HashGet\n     * @param key  键 不能为null\n     * @param item 项 不能为null\n     */</span>\n    <span>public</span> <span>Object</span> <span>hget</span><span>(</span><span>String</span> key<span>,</span> <span>String</span> item<span>)</span> <span>{</span>\n        <span>return</span> redisTemplate<span>.</span><span>opsForHash</span><span>(</span><span>)</span><span>.</span><span>get</span><span>(</span>key<span>,</span> item<span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>/**\n     * 获取hashKey对应的所有键值\n     * @param key 键\n     * @return 对应的多个键值\n     */</span>\n    <span>public</span> <span>Map</span><span><span>&lt;</span><span>Object</span><span>,</span> <span>Object</span><span>></span></span> <span>hmget</span><span>(</span><span>String</span> key<span>)</span> <span>{</span>\n        <span>return</span> redisTemplate<span>.</span><span>opsForHash</span><span>(</span><span>)</span><span>.</span><span>entries</span><span>(</span>key<span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>/**\n     * HashSet\n     * @param key 键\n     * @param map 对应多个键值\n     */</span>\n    <span>public</span> <span>boolean</span> <span>hmset</span><span>(</span><span>String</span> key<span>,</span> <span>Map</span><span><span>&lt;</span><span>String</span><span>,</span> <span>Object</span><span>></span></span> map<span>)</span> <span>{</span>\n        <span>try</span> <span>{</span>\n            redisTemplate<span>.</span><span>opsForHash</span><span>(</span><span>)</span><span>.</span><span>putAll</span><span>(</span>key<span>,</span> map<span>)</span><span>;</span>\n            <span>return</span> <span>true</span><span>;</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>Exception</span> e<span>)</span> <span>{</span>\n            e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n            <span>return</span> <span>false</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n\n    <span>/**\n     * HashSet 并设置时间\n     * @param key  键\n     * @param map  对应多个键值\n     * @param time 时间(秒)\n     * @return true成功 false失败\n     */</span>\n    <span>public</span> <span>boolean</span> <span>hmset</span><span>(</span><span>String</span> key<span>,</span> <span>Map</span><span><span>&lt;</span><span>String</span><span>,</span> <span>Object</span><span>></span></span> map<span>,</span> <span>long</span> time<span>)</span> <span>{</span>\n        <span>try</span> <span>{</span>\n            redisTemplate<span>.</span><span>opsForHash</span><span>(</span><span>)</span><span>.</span><span>putAll</span><span>(</span>key<span>,</span> map<span>)</span><span>;</span>\n            <span>if</span> <span>(</span>time <span>></span> <span>0</span><span>)</span> <span>{</span>\n                <span>expire</span><span>(</span>key<span>,</span> time<span>)</span><span>;</span>\n            <span>}</span>\n            <span>return</span> <span>true</span><span>;</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>Exception</span> e<span>)</span> <span>{</span>\n            e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n            <span>return</span> <span>false</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n\n    <span>/**\n     * 向一张hash表中放入数据,如果不存在将创建\n     *\n     * @param key   键\n     * @param item  项\n     * @param value 值\n     * @return true 成功 false失败\n     */</span>\n    <span>public</span> <span>boolean</span> <span>hset</span><span>(</span><span>String</span> key<span>,</span> <span>String</span> item<span>,</span> <span>Object</span> value<span>)</span> <span>{</span>\n        <span>try</span> <span>{</span>\n            redisTemplate<span>.</span><span>opsForHash</span><span>(</span><span>)</span><span>.</span><span>put</span><span>(</span>key<span>,</span> item<span>,</span> value<span>)</span><span>;</span>\n            <span>return</span> <span>true</span><span>;</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>Exception</span> e<span>)</span> <span>{</span>\n            e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n            <span>return</span> <span>false</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>/**\n     * 向一张hash表中放入数据,如果不存在将创建\n     *\n     * @param key   键\n     * @param item  项\n     * @param value 值\n     * @param time  时间(秒) 注意:如果已存在的hash表有时间,这里将会替换原有的时间\n     * @return true 成功 false失败\n     */</span>\n    <span>public</span> <span>boolean</span> <span>hset</span><span>(</span><span>String</span> key<span>,</span> <span>String</span> item<span>,</span> <span>Object</span> value<span>,</span> <span>long</span> time<span>)</span> <span>{</span>\n        <span>try</span> <span>{</span>\n            redisTemplate<span>.</span><span>opsForHash</span><span>(</span><span>)</span><span>.</span><span>put</span><span>(</span>key<span>,</span> item<span>,</span> value<span>)</span><span>;</span>\n            <span>if</span> <span>(</span>time <span>></span> <span>0</span><span>)</span> <span>{</span>\n                <span>expire</span><span>(</span>key<span>,</span> time<span>)</span><span>;</span>\n            <span>}</span>\n            <span>return</span> <span>true</span><span>;</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>Exception</span> e<span>)</span> <span>{</span>\n            e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n            <span>return</span> <span>false</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n\n    <span>/**\n     * 删除hash表中的值\n     *\n     * @param key  键 不能为null\n     * @param item 项 可以使多个 不能为null\n     */</span>\n    <span>public</span> <span>void</span> <span>hdel</span><span>(</span><span>String</span> key<span>,</span> <span>Object</span><span>.</span><span>.</span><span>.</span> item<span>)</span> <span>{</span>\n        redisTemplate<span>.</span><span>opsForHash</span><span>(</span><span>)</span><span>.</span><span>delete</span><span>(</span>key<span>,</span> item<span>)</span><span>;</span>\n    <span>}</span>\n\n\n    <span>/**\n     * 判断hash表中是否有该项的值\n     *\n     * @param key  键 不能为null\n     * @param item 项 不能为null\n     * @return true 存在 false不存在\n     */</span>\n    <span>public</span> <span>boolean</span> <span>hHasKey</span><span>(</span><span>String</span> key<span>,</span> <span>String</span> item<span>)</span> <span>{</span>\n        <span>return</span> redisTemplate<span>.</span><span>opsForHash</span><span>(</span><span>)</span><span>.</span><span>hasKey</span><span>(</span>key<span>,</span> item<span>)</span><span>;</span>\n    <span>}</span>\n\n\n    <span>/**\n     * hash递增 如果不存在,就会创建一个 并把新增后的值返回\n     *\n     * @param key  键\n     * @param item 项\n     * @param by   要增加几(大于0)\n     */</span>\n    <span>public</span> <span>double</span> <span>hincr</span><span>(</span><span>String</span> key<span>,</span> <span>String</span> item<span>,</span> <span>double</span> by<span>)</span> <span>{</span>\n        <span>return</span> redisTemplate<span>.</span><span>opsForHash</span><span>(</span><span>)</span><span>.</span><span>increment</span><span>(</span>key<span>,</span> item<span>,</span> by<span>)</span><span>;</span>\n    <span>}</span>\n\n\n    <span>/**\n     * hash递减\n     *\n     * @param key  键\n     * @param item 项\n     * @param by   要减少记(小于0)\n     */</span>\n    <span>public</span> <span>double</span> <span>hdecr</span><span>(</span><span>String</span> key<span>,</span> <span>String</span> item<span>,</span> <span>double</span> by<span>)</span> <span>{</span>\n        <span>return</span> redisTemplate<span>.</span><span>opsForHash</span><span>(</span><span>)</span><span>.</span><span>increment</span><span>(</span>key<span>,</span> item<span>,</span> <span>-</span>by<span>)</span><span>;</span>\n    <span>}</span>\n\n\n    <span>// ============================set=============================</span>\n\n    <span>/**\n     * 根据key获取Set中的所有值\n     * @param key 键\n     */</span>\n    <span>public</span> <span>Set</span><span><span>&lt;</span><span>Object</span><span>></span></span> <span>sGet</span><span>(</span><span>String</span> key<span>)</span> <span>{</span>\n        <span>try</span> <span>{</span>\n            <span>return</span> redisTemplate<span>.</span><span>opsForSet</span><span>(</span><span>)</span><span>.</span><span>members</span><span>(</span>key<span>)</span><span>;</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>Exception</span> e<span>)</span> <span>{</span>\n            e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n            <span>return</span> <span>null</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n\n    <span>/**\n     * 根据value从一个set中查询,是否存在\n     *\n     * @param key   键\n     * @param value 值\n     * @return true 存在 false不存在\n     */</span>\n    <span>public</span> <span>boolean</span> <span>sHasKey</span><span>(</span><span>String</span> key<span>,</span> <span>Object</span> value<span>)</span> <span>{</span>\n        <span>try</span> <span>{</span>\n            <span>return</span> redisTemplate<span>.</span><span>opsForSet</span><span>(</span><span>)</span><span>.</span><span>isMember</span><span>(</span>key<span>,</span> value<span>)</span><span>;</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>Exception</span> e<span>)</span> <span>{</span>\n            e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n            <span>return</span> <span>false</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n\n    <span>/**\n     * 将数据放入set缓存\n     *\n     * @param key    键\n     * @param values 值 可以是多个\n     * @return 成功个数\n     */</span>\n    <span>public</span> <span>long</span> <span>sSet</span><span>(</span><span>String</span> key<span>,</span> <span>Object</span><span>.</span><span>.</span><span>.</span> values<span>)</span> <span>{</span>\n        <span>try</span> <span>{</span>\n            <span>return</span> redisTemplate<span>.</span><span>opsForSet</span><span>(</span><span>)</span><span>.</span><span>add</span><span>(</span>key<span>,</span> values<span>)</span><span>;</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>Exception</span> e<span>)</span> <span>{</span>\n            e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n            <span>return</span> <span>0</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n\n    <span>/**\n     * 将set数据放入缓存\n     *\n     * @param key    键\n     * @param time   时间(秒)\n     * @param values 值 可以是多个\n     * @return 成功个数\n     */</span>\n    <span>public</span> <span>long</span> <span>sSetAndTime</span><span>(</span><span>String</span> key<span>,</span> <span>long</span> time<span>,</span> <span>Object</span><span>.</span><span>.</span><span>.</span> values<span>)</span> <span>{</span>\n        <span>try</span> <span>{</span>\n            <span>Long</span> count <span>=</span> redisTemplate<span>.</span><span>opsForSet</span><span>(</span><span>)</span><span>.</span><span>add</span><span>(</span>key<span>,</span> values<span>)</span><span>;</span>\n            <span>if</span> <span>(</span>time <span>></span> <span>0</span><span>)</span>\n                <span>expire</span><span>(</span>key<span>,</span> time<span>)</span><span>;</span>\n            <span>return</span> count<span>;</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>Exception</span> e<span>)</span> <span>{</span>\n            e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n            <span>return</span> <span>0</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n\n    <span>/**\n     * 获取set缓存的长度\n     *\n     * @param key 键\n     */</span>\n    <span>public</span> <span>long</span> <span>sGetSetSize</span><span>(</span><span>String</span> key<span>)</span> <span>{</span>\n        <span>try</span> <span>{</span>\n            <span>return</span> redisTemplate<span>.</span><span>opsForSet</span><span>(</span><span>)</span><span>.</span><span>size</span><span>(</span>key<span>)</span><span>;</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>Exception</span> e<span>)</span> <span>{</span>\n            e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n            <span>return</span> <span>0</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n\n    <span>/**\n     * 移除值为value的\n     *\n     * @param key    键\n     * @param values 值 可以是多个\n     * @return 移除的个数\n     */</span>\n\n    <span>public</span> <span>long</span> <span>setRemove</span><span>(</span><span>String</span> key<span>,</span> <span>Object</span><span>.</span><span>.</span><span>.</span> values<span>)</span> <span>{</span>\n        <span>try</span> <span>{</span>\n            <span>Long</span> count <span>=</span> redisTemplate<span>.</span><span>opsForSet</span><span>(</span><span>)</span><span>.</span><span>remove</span><span>(</span>key<span>,</span> values<span>)</span><span>;</span>\n            <span>return</span> count<span>;</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>Exception</span> e<span>)</span> <span>{</span>\n            e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n            <span>return</span> <span>0</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>// ===============================list=================================</span>\n\n    <span>/**\n     * 获取list缓存的内容\n     *\n     * @param key   键\n     * @param start 开始\n     * @param end   结束 0 到 -1代表所有值\n     */</span>\n    <span>public</span> <span>List</span><span><span>&lt;</span><span>Object</span><span>></span></span> <span>lGet</span><span>(</span><span>String</span> key<span>,</span> <span>long</span> start<span>,</span> <span>long</span> end<span>)</span> <span>{</span>\n        <span>try</span> <span>{</span>\n            <span>return</span> redisTemplate<span>.</span><span>opsForList</span><span>(</span><span>)</span><span>.</span><span>range</span><span>(</span>key<span>,</span> start<span>,</span> end<span>)</span><span>;</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>Exception</span> e<span>)</span> <span>{</span>\n            e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n            <span>return</span> <span>null</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n\n    <span>/**\n     * 获取list缓存的长度\n     *\n     * @param key 键\n     */</span>\n    <span>public</span> <span>long</span> <span>lGetListSize</span><span>(</span><span>String</span> key<span>)</span> <span>{</span>\n        <span>try</span> <span>{</span>\n            <span>return</span> redisTemplate<span>.</span><span>opsForList</span><span>(</span><span>)</span><span>.</span><span>size</span><span>(</span>key<span>)</span><span>;</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>Exception</span> e<span>)</span> <span>{</span>\n            e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n            <span>return</span> <span>0</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n\n    <span>/**\n     * 通过索引 获取list中的值\n     *\n     * @param key   键\n     * @param index 索引 index>=0时， 0 表头，1 第二个元素，依次类推；index&lt;0时，-1，表尾，-2倒数第二个元素，依次类推\n     */</span>\n    <span>public</span> <span>Object</span> <span>lGetIndex</span><span>(</span><span>String</span> key<span>,</span> <span>long</span> index<span>)</span> <span>{</span>\n        <span>try</span> <span>{</span>\n            <span>return</span> redisTemplate<span>.</span><span>opsForList</span><span>(</span><span>)</span><span>.</span><span>index</span><span>(</span>key<span>,</span> index<span>)</span><span>;</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>Exception</span> e<span>)</span> <span>{</span>\n            e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n            <span>return</span> <span>null</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n\n    <span>/**\n     * 将list放入缓存\n     *\n     * @param key   键\n     * @param value 值\n     */</span>\n    <span>public</span> <span>boolean</span> <span>lSet</span><span>(</span><span>String</span> key<span>,</span> <span>Object</span> value<span>)</span> <span>{</span>\n        <span>try</span> <span>{</span>\n            redisTemplate<span>.</span><span>opsForList</span><span>(</span><span>)</span><span>.</span><span>rightPush</span><span>(</span>key<span>,</span> value<span>)</span><span>;</span>\n            <span>return</span> <span>true</span><span>;</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>Exception</span> e<span>)</span> <span>{</span>\n            e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n            <span>return</span> <span>false</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n\n    <span>/**\n     * 将list放入缓存\n     * @param key   键\n     * @param value 值\n     * @param time  时间(秒)\n     */</span>\n    <span>public</span> <span>boolean</span> <span>lSet</span><span>(</span><span>String</span> key<span>,</span> <span>Object</span> value<span>,</span> <span>long</span> time<span>)</span> <span>{</span>\n        <span>try</span> <span>{</span>\n            redisTemplate<span>.</span><span>opsForList</span><span>(</span><span>)</span><span>.</span><span>rightPush</span><span>(</span>key<span>,</span> value<span>)</span><span>;</span>\n            <span>if</span> <span>(</span>time <span>></span> <span>0</span><span>)</span>\n                <span>expire</span><span>(</span>key<span>,</span> time<span>)</span><span>;</span>\n            <span>return</span> <span>true</span><span>;</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>Exception</span> e<span>)</span> <span>{</span>\n            e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n            <span>return</span> <span>false</span><span>;</span>\n        <span>}</span>\n\n    <span>}</span>\n\n\n    <span>/**\n     * 将list放入缓存\n     *\n     * @param key   键\n     * @param value 值\n     * @return\n     */</span>\n    <span>public</span> <span>boolean</span> <span>lSet</span><span>(</span><span>String</span> key<span>,</span> <span>List</span><span><span>&lt;</span><span>Object</span><span>></span></span> value<span>)</span> <span>{</span>\n        <span>try</span> <span>{</span>\n            redisTemplate<span>.</span><span>opsForList</span><span>(</span><span>)</span><span>.</span><span>rightPushAll</span><span>(</span>key<span>,</span> value<span>)</span><span>;</span>\n            <span>return</span> <span>true</span><span>;</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>Exception</span> e<span>)</span> <span>{</span>\n            e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n            <span>return</span> <span>false</span><span>;</span>\n        <span>}</span>\n\n    <span>}</span>\n\n\n    <span>/**\n     * 将list放入缓存\n     *\n     * @param key   键\n     * @param value 值\n     * @param time  时间(秒)\n     * @return\n     */</span>\n    <span>public</span> <span>boolean</span> <span>lSet</span><span>(</span><span>String</span> key<span>,</span> <span>List</span><span><span>&lt;</span><span>Object</span><span>></span></span> value<span>,</span> <span>long</span> time<span>)</span> <span>{</span>\n        <span>try</span> <span>{</span>\n            redisTemplate<span>.</span><span>opsForList</span><span>(</span><span>)</span><span>.</span><span>rightPushAll</span><span>(</span>key<span>,</span> value<span>)</span><span>;</span>\n            <span>if</span> <span>(</span>time <span>></span> <span>0</span><span>)</span>\n                <span>expire</span><span>(</span>key<span>,</span> time<span>)</span><span>;</span>\n            <span>return</span> <span>true</span><span>;</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>Exception</span> e<span>)</span> <span>{</span>\n            e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n            <span>return</span> <span>false</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n\n    <span>/**\n     * 根据索引修改list中的某条数据\n     *\n     * @param key   键\n     * @param index 索引\n     * @param value 值\n     * @return\n     */</span>\n\n    <span>public</span> <span>boolean</span> <span>lUpdateIndex</span><span>(</span><span>String</span> key<span>,</span> <span>long</span> index<span>,</span> <span>Object</span> value<span>)</span> <span>{</span>\n        <span>try</span> <span>{</span>\n            redisTemplate<span>.</span><span>opsForList</span><span>(</span><span>)</span><span>.</span><span>set</span><span>(</span>key<span>,</span> index<span>,</span> value<span>)</span><span>;</span>\n            <span>return</span> <span>true</span><span>;</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>Exception</span> e<span>)</span> <span>{</span>\n            e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n            <span>return</span> <span>false</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n\n    <span>/**\n     * 移除N个值为value\n     *\n     * @param key   键\n     * @param count 移除多少个\n     * @param value 值\n     * @return 移除的个数\n     */</span>\n\n    <span>public</span> <span>long</span> <span>lRemove</span><span>(</span><span>String</span> key<span>,</span> <span>long</span> count<span>,</span> <span>Object</span> value<span>)</span> <span>{</span>\n        <span>try</span> <span>{</span>\n            <span>Long</span> remove <span>=</span> redisTemplate<span>.</span><span>opsForList</span><span>(</span><span>)</span><span>.</span><span>remove</span><span>(</span>key<span>,</span> count<span>,</span> value<span>)</span><span>;</span>\n            <span>return</span> remove<span>;</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>Exception</span> e<span>)</span> <span>{</span>\n            e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n            <span>return</span> <span>0</span><span>;</span>\n        <span>}</span>\n\n    <span>}</span>\n\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br><span>111</span><br><span>112</span><br><span>113</span><br><span>114</span><br><span>115</span><br><span>116</span><br><span>117</span><br><span>118</span><br><span>119</span><br><span>120</span><br><span>121</span><br><span>122</span><br><span>123</span><br><span>124</span><br><span>125</span><br><span>126</span><br><span>127</span><br><span>128</span><br><span>129</span><br><span>130</span><br><span>131</span><br><span>132</span><br><span>133</span><br><span>134</span><br><span>135</span><br><span>136</span><br><span>137</span><br><span>138</span><br><span>139</span><br><span>140</span><br><span>141</span><br><span>142</span><br><span>143</span><br><span>144</span><br><span>145</span><br><span>146</span><br><span>147</span><br><span>148</span><br><span>149</span><br><span>150</span><br><span>151</span><br><span>152</span><br><span>153</span><br><span>154</span><br><span>155</span><br><span>156</span><br><span>157</span><br><span>158</span><br><span>159</span><br><span>160</span><br><span>161</span><br><span>162</span><br><span>163</span><br><span>164</span><br><span>165</span><br><span>166</span><br><span>167</span><br><span>168</span><br><span>169</span><br><span>170</span><br><span>171</span><br><span>172</span><br><span>173</span><br><span>174</span><br><span>175</span><br><span>176</span><br><span>177</span><br><span>178</span><br><span>179</span><br><span>180</span><br><span>181</span><br><span>182</span><br><span>183</span><br><span>184</span><br><span>185</span><br><span>186</span><br><span>187</span><br><span>188</span><br><span>189</span><br><span>190</span><br><span>191</span><br><span>192</span><br><span>193</span><br><span>194</span><br><span>195</span><br><span>196</span><br><span>197</span><br><span>198</span><br><span>199</span><br><span>200</span><br><span>201</span><br><span>202</span><br><span>203</span><br><span>204</span><br><span>205</span><br><span>206</span><br><span>207</span><br><span>208</span><br><span>209</span><br><span>210</span><br><span>211</span><br><span>212</span><br><span>213</span><br><span>214</span><br><span>215</span><br><span>216</span><br><span>217</span><br><span>218</span><br><span>219</span><br><span>220</span><br><span>221</span><br><span>222</span><br><span>223</span><br><span>224</span><br><span>225</span><br><span>226</span><br><span>227</span><br><span>228</span><br><span>229</span><br><span>230</span><br><span>231</span><br><span>232</span><br><span>233</span><br><span>234</span><br><span>235</span><br><span>236</span><br><span>237</span><br><span>238</span><br><span>239</span><br><span>240</span><br><span>241</span><br><span>242</span><br><span>243</span><br><span>244</span><br><span>245</span><br><span>246</span><br><span>247</span><br><span>248</span><br><span>249</span><br><span>250</span><br><span>251</span><br><span>252</span><br><span>253</span><br><span>254</span><br><span>255</span><br><span>256</span><br><span>257</span><br><span>258</span><br><span>259</span><br><span>260</span><br><span>261</span><br><span>262</span><br><span>263</span><br><span>264</span><br><span>265</span><br><span>266</span><br><span>267</span><br><span>268</span><br><span>269</span><br><span>270</span><br><span>271</span><br><span>272</span><br><span>273</span><br><span>274</span><br><span>275</span><br><span>276</span><br><span>277</span><br><span>278</span><br><span>279</span><br><span>280</span><br><span>281</span><br><span>282</span><br><span>283</span><br><span>284</span><br><span>285</span><br><span>286</span><br><span>287</span><br><span>288</span><br><span>289</span><br><span>290</span><br><span>291</span><br><span>292</span><br><span>293</span><br><span>294</span><br><span>295</span><br><span>296</span><br><span>297</span><br><span>298</span><br><span>299</span><br><span>300</span><br><span>301</span><br><span>302</span><br><span>303</span><br><span>304</span><br><span>305</span><br><span>306</span><br><span>307</span><br><span>308</span><br><span>309</span><br><span>310</span><br><span>311</span><br><span>312</span><br><span>313</span><br><span>314</span><br><span>315</span><br><span>316</span><br><span>317</span><br><span>318</span><br><span>319</span><br><span>320</span><br><span>321</span><br><span>322</span><br><span>323</span><br><span>324</span><br><span>325</span><br><span>326</span><br><span>327</span><br><span>328</span><br><span>329</span><br><span>330</span><br><span>331</span><br><span>332</span><br><span>333</span><br><span>334</span><br><span>335</span><br><span>336</span><br><span>337</span><br><span>338</span><br><span>339</span><br><span>340</span><br><span>341</span><br><span>342</span><br><span>343</span><br><span>344</span><br><span>345</span><br><span>346</span><br><span>347</span><br><span>348</span><br><span>349</span><br><span>350</span><br><span>351</span><br><span>352</span><br><span>353</span><br><span>354</span><br><span>355</span><br><span>356</span><br><span>357</span><br><span>358</span><br><span>359</span><br><span>360</span><br><span>361</span><br><span>362</span><br><span>363</span><br><span>364</span><br><span>365</span><br><span>366</span><br><span>367</span><br><span>368</span><br><span>369</span><br><span>370</span><br><span>371</span><br><span>372</span><br><span>373</span><br><span>374</span><br><span>375</span><br><span>376</span><br><span>377</span><br><span>378</span><br><span>379</span><br><span>380</span><br><span>381</span><br><span>382</span><br><span>383</span><br><span>384</span><br><span>385</span><br><span>386</span><br><span>387</span><br><span>388</span><br><span>389</span><br><span>390</span><br><span>391</span><br><span>392</span><br><span>393</span><br><span>394</span><br><span>395</span><br><span>396</span><br><span>397</span><br><span>398</span><br><span>399</span><br><span>400</span><br><span>401</span><br><span>402</span><br><span>403</span><br><span>404</span><br><span>405</span><br><span>406</span><br><span>407</span><br><span>408</span><br><span>409</span><br><span>410</span><br><span>411</span><br><span>412</span><br><span>413</span><br><span>414</span><br><span>415</span><br><span>416</span><br><span>417</span><br><span>418</span><br><span>419</span><br><span>420</span><br><span>421</span><br><span>422</span><br><span>423</span><br><span>424</span><br><span>425</span><br><span>426</span><br><span>427</span><br><span>428</span><br><span>429</span><br><span>430</span><br><span>431</span><br><span>432</span><br><span>433</span><br><span>434</span><br><span>435</span><br><span>436</span><br><span>437</span><br><span>438</span><br><span>439</span><br><span>440</span><br><span>441</span><br><span>442</span><br><span>443</span><br><span>444</span><br><span>445</span><br><span>446</span><br><span>447</span><br><span>448</span><br><span>449</span><br><span>450</span><br><span>451</span><br><span>452</span><br><span>453</span><br><span>454</span><br><span>455</span><br><span>456</span><br><span>457</span><br><span>458</span><br><span>459</span><br><span>460</span><br><span>461</span><br><span>462</span><br><span>463</span><br><span>464</span><br><span>465</span><br><span>466</span><br><span>467</span><br><span>468</span><br><span>469</span><br><span>470</span><br><span>471</span><br><span>472</span><br><span>473</span><br><span>474</span><br><span>475</span><br><span>476</span><br><span>477</span><br><span>478</span><br><span>479</span><br><span>480</span><br><span>481</span><br><span>482</span><br><span>483</span><br><span>484</span><br><span>485</span><br><span>486</span><br><span>487</span><br><span>488</span><br><span>489</span><br><span>490</span><br><span>491</span><br><span>492</span><br><span>493</span><br><span>494</span><br><span>495</span><br><span>496</span><br><span>497</span><br><span>498</span><br><span>499</span><br><span>500</span><br><span>501</span><br><span>502</span><br><span>503</span><br><span>504</span><br><span>505</span><br><span>506</span><br><span>507</span><br><span>508</span><br><span>509</span><br><span>510</span><br><span>511</span><br><span>512</span><br><span>513</span><br><span>514</span><br><span>515</span><br><span>516</span><br><span>517</span><br><span>518</span><br><span>519</span><br><span>520</span><br><span>521</span><br><span>522</span><br><span>523</span><br><span>524</span><br><span>525</span><br><span>526</span><br><span>527</span><br><span>528</span><br><span>529</span><br><span>530</span><br><span>531</span><br><span>532</span><br><span>533</span><br><span>534</span><br><span>535</span><br><span>536</span><br><span>537</span><br><span>538</span><br><span>539</span><br><span>540</span><br><span>541</span><br><span>542</span><br><span>543</span><br><span>544</span><br><span>545</span><br><span>546</span><br><span>547</span><br><span>548</span><br><span>549</span><br><span>550</span><br><span>551</span><br><span>552</span><br><span>553</span><br><span>554</span><br><span>555</span><br><span>556</span><br><span>557</span><br><span>558</span><br><span>559</span><br><span>560</span><br><span>561</span><br><span>562</span><br><span>563</span><br><span>564</span><br><span>565</span><br><span>566</span><br><span>567</span><br><span>568</span><br><span>569</span><br><span>570</span><br><span>571</span><br><span>572</span><br><span>573</span><br><span>574</span><br><span>575</span><br><span>576</span><br><span>577</span><br><span>578</span><br><span>579</span><br><span>580</span><br><span>581</span><br></div></div></details>\n<h2 id=\"_8-redis-conf详解\"> 8. <code>redis.conf</code>详解</h2>\n<p><code>redis.conf</code>官方下载地址</p>\n<blockquote>\n<ul>\n<li>http://download.redis.io/redis-stable/redis.conf</li>\n</ul>\n</blockquote>\n<h3 id=\"_8-1-存储单位说明\"> 8.1 存储单位说明</h3>\n\n          <div\n            id=\"code-demo-23df6c8e\"\n           \n  \n data-title=\"%E5%AD%98%E5%82%A8%E5%8D%95%E4%BD%8D%E8%AF%B4%E6%98%8E\"\n\n            data-code=\"%7B%22bash%22%3A%22%23%20Redis%20configuration%20file%20example.%5Cn%23%5Cn%23%20Note%20that%20in%20order%20to%20read%20the%20configuration%20file%2C%20Redis%20must%20be%5Cn%23%20started%20with%20the%20file%20path%20as%20first%20argument%3A%5Cn%23%5Cn%23%20.%2Fredis-server%20%2Fpath%2Fto%2Fredis.conf%5Cn%5Cn%23%20Note%20on%20units%3A%20when%20memory%20size%20is%20needed%2C%20it%20is%20possible%20to%20specify%5Cn%23%20it%20in%20the%20usual%20form%20of%201k%205GB%204M%20and%20so%20forth%3A%5Cn%23%5Cn%23%201k%20%3D%3E%201000%20bytes%5Cn%23%201kb%20%3D%3E%201024%20bytes%5Cn%23%201m%20%3D%3E%201000000%20bytes%5Cn%23%201mb%20%3D%3E%201024*1024%20bytes%5Cn%23%201g%20%3D%3E%201000000000%20bytes%5Cn%23%201gb%20%3D%3E%201024*1024*1024%20bytes%5Cn%23%5Cn%23%20units%20are%20case%20insensitive%20so%201GB%201Gb%201gB%20are%20all%20the%20same.%5Cn%22%7D\"\n          >\n              \n              <div>\n                <div>\n<div><pre><code><span># Redis configuration file example.</span>\n<span>#</span>\n<span># Note that in order to read the configuration file, Redis must be</span>\n<span># started with the file path as first argument:</span>\n<span>#</span>\n<span># ./redis-server /path/to/redis.conf</span>\n\n<span># Note on units: when memory size is needed, it is possible to specify</span>\n<span># it in the usual form of 1k 5GB 4M and so forth:</span>\n<span>#</span>\n<span># 1k => 1000 bytes</span>\n<span># 1kb => 1024 bytes</span>\n<span># 1m => 1000000 bytes</span>\n<span># 1mb => 1024*1024 bytes</span>\n<span># 1g => 1000000000 bytes</span>\n<span># 1gb => 1024*1024*1024 bytes</span>\n<span>#</span>\n<span># units are case insensitive so 1GB 1Gb 1gB are all the same.</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div>\n            </div>\n          </div>\n          \n        </div>\n<h3 id=\"_8-2-网络配置\"> 8.2 网络配置</h3>\n\n          <div\n            id=\"code-demo-8faec60e\"\n           \n  \n data-title=\"%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE\"\n\n            data-code=\"%7B%22bash%22%3A%22%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%20NETWORK%20%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%5Cn%5Cn%23%20%E7%BB%91%E5%AE%9A%E7%9A%84IP%5Cnbind%20127.0.0.1%5Cn%5Cn%23%20%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E6%98%AF%E5%90%A6%E5%BC%80%E5%90%AF%EF%BC%8C%E9%BB%98%E8%AE%A4%E5%BC%80%E5%90%AF%5Cnprotected-mode%20yes%5Cn%5Cn%23%20%E7%AB%AF%E5%8F%A3%E5%8F%B7%5Cnport%206379%5Cn%5Cn%23%20TCP%20listen()%20backlog.%5Cn%23%5Cn%23%20In%20high%20requests-per-second%20environments%20you%20need%20a%20high%20backlog%20in%20order%5Cn%23%20to%20avoid%20slow%20clients%20connection%20issues.%20Note%20that%20the%20Linux%20kernel%5Cn%23%20will%20silently%20truncate%20it%20to%20the%20value%20of%20%2Fproc%2Fsys%2Fnet%2Fcore%2Fsomaxconn%20so%5Cn%23%20make%20sure%20to%20raise%20both%20the%20value%20of%20somaxconn%20and%20tcp_max_syn_backlog%5Cn%23%20in%20order%20to%20get%20the%20desired%20effect.%5Cntcp-backlog%20511%5Cn%5Cn%23%20Unix%20socket.%5Cn%23%5Cn%23%20Specify%20the%20path%20for%20the%20Unix%20socket%20that%20will%20be%20used%20to%20listen%20for%5Cn%23%20incoming%20connections.%20There%20is%20no%20default%2C%20so%20Redis%20will%20not%20listen%5Cn%23%20on%20a%20unix%20socket%20when%20not%20specified.%5Cn%23%5Cn%23%20unixsocket%20%2Ftmp%2Fredis.sock%5Cn%23%20unixsocketperm%20700%5Cn%5Cn%23%20Close%20the%20connection%20after%20a%20client%20is%20idle%20for%20N%20seconds%20(0%20to%20disable)%5Cntimeout%200%5Cn%5Cn%23%20TCP%20keepalive.%5Cn%23%5Cn%23%20If%20non-zero%2C%20use%20SO_KEEPALIVE%20to%20send%20TCP%20ACKs%20to%20clients%20in%20absence%5Cn%23%20of%20communication.%20This%20is%20useful%20for%20two%20reasons%3A%5Cn%23%5Cn%23%201)%20Detect%20dead%20peers.%5Cn%23%202)%20Force%20network%20equipment%20in%20the%20middle%20to%20consider%20the%20connection%20to%20be%5Cn%23%20%20%20%20alive.%5Cn%23%5Cn%23%20On%20Linux%2C%20the%20specified%20value%20(in%20seconds)%20is%20the%20period%20used%20to%20send%20ACKs.%5Cn%23%20Note%20that%20to%20close%20the%20connection%20the%20double%20of%20the%20time%20is%20needed.%5Cn%23%20On%20other%20kernels%20the%20period%20depends%20on%20the%20kernel%20configuration.%5Cn%23%5Cn%23%20A%20reasonable%20value%20for%20this%20option%20is%20300%20seconds%2C%20which%20is%20the%20new%5Cn%23%20Redis%20default%20starting%20with%20Redis%203.2.1.%5Cntcp-keepalive%20300%5Cn%22%7D\"\n          >\n              \n              <div>\n                <div>\n<div><pre><code><span>################################## NETWORK #####################################</span>\n\n<span># 绑定的IP</span>\n<span>bind</span> <span>127.0</span>.0.1\n\n<span># 保护模式是否开启，默认开启</span>\nprotected-mode <span>yes</span>\n\n<span># 端口号</span>\nport <span>6379</span>\n\n<span># TCP listen() backlog.</span>\n<span>#</span>\n<span># In high requests-per-second environments you need a high backlog in order</span>\n<span># to avoid slow clients connection issues. Note that the Linux kernel</span>\n<span># will silently truncate it to the value of /proc/sys/net/core/somaxconn so</span>\n<span># make sure to raise both the value of somaxconn and tcp_max_syn_backlog</span>\n<span># in order to get the desired effect.</span>\ntcp-backlog <span>511</span>\n\n<span># Unix socket.</span>\n<span>#</span>\n<span># Specify the path for the Unix socket that will be used to listen for</span>\n<span># incoming connections. There is no default, so Redis will not listen</span>\n<span># on a unix socket when not specified.</span>\n<span>#</span>\n<span># unixsocket /tmp/redis.sock</span>\n<span># unixsocketperm 700</span>\n\n<span># Close the connection after a client is idle for N seconds (0 to disable)</span>\n<span>timeout</span> <span>0</span>\n\n<span># TCP keepalive.</span>\n<span>#</span>\n<span># If non-zero, use SO_KEEPALIVE to send TCP ACKs to clients in absence</span>\n<span># of communication. This is useful for two reasons:</span>\n<span>#</span>\n<span># 1) Detect dead peers.</span>\n<span># 2) Force network equipment in the middle to consider the connection to be</span>\n<span>#    alive.</span>\n<span>#</span>\n<span># On Linux, the specified value (in seconds) is the period used to send ACKs.</span>\n<span># Note that to close the connection the double of the time is needed.</span>\n<span># On other kernels the period depends on the kernel configuration.</span>\n<span>#</span>\n<span># A reasonable value for this option is 300 seconds, which is the new</span>\n<span># Redis default starting with Redis 3.2.1.</span>\ntcp-keepalive <span>300</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br></div></div>\n            </div>\n          </div>\n          \n        </div>\n<h3 id=\"_8-3-基本配置\"> 8.3 基本配置</h3>\n\n          <div\n            id=\"code-demo-496e6ab9\"\n           \n  \n data-title=\"%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE\"\n\n            data-code=\"%7B%22bash%22%3A%22%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%20GENERAL%20%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%5Cn%5Cn%23%20%E6%98%AF%E5%90%A6%E4%BB%A5%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F%E8%BF%90%E8%A1%8C%E5%8D%B3%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%EF%BC%8C%E9%BB%98%E8%AE%A4%E4%B8%BAno%EF%BC%8C%E9%9C%80%E8%A6%81%E6%94%B9%E4%B8%BAyes%5Cndaemonize%20no%5Cn%5Cn%23%20%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%E6%8C%87%E5%AE%9A%E7%9A%84pid%E6%96%87%E4%BB%B6%5Cnpidfile%20%2Fvar%2Frun%2Fredis_6379.pid%5Cn%5Cn%23%20%E6%97%A5%E5%BF%97%E7%BA%A7%E5%88%AB%5Cn%23%20Specify%20the%20server%20verbosity%20level.%5Cn%23%20This%20can%20be%20one%20of%3A%5Cn%23%20debug%20(a%20lot%20of%20information%2C%20useful%20for%20development%2Ftesting)%5Cn%23%20verbose%20(many%20rarely%20useful%20info%2C%20but%20not%20a%20mess%20like%20the%20debug%20level)%5Cn%23%20notice%20(moderately%20verbose%2C%20what%20you%20want%20in%20production%20probably)%5Cn%23%20warning%20(only%20very%20important%20%2F%20critical%20messages%20are%20logged)%5Cnloglevel%20notice%5Cn%5Cn%23%20%E8%BE%93%E5%85%A5%E7%9A%84%E6%97%A5%E5%BF%97%E4%BD%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%90%8D%5Cn%23%20Specify%20the%20log%20file%20name.%20Also%20the%20empty%20string%20can%20be%20used%20to%20force%5Cn%23%20Redis%20to%20log%20on%20the%20standard%20output.%20Note%20that%20if%20you%20use%20standard%5Cn%23%20output%20for%20logging%20but%20daemonize%2C%20logs%20will%20be%20sent%20to%20%2Fdev%2Fnull%5Cnlogfile%20%5C%22%5C%22%5Cn%5Cn%23%20%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B0%E9%87%8F%5Cndatabases%2016%5Cn%5Cn%23%20%E8%BF%90%E8%A1%8C%E6%97%B6%E6%98%BE%E7%A4%BAredislogo%5Cnalways-show-logo%20yes%5Cn%22%7D\"\n          >\n              \n              <div>\n                <div>\n<div><pre><code><span>################################# GENERAL #####################################</span>\n\n<span># 是否以守护进程的方式运行即后台运行，默认为no，需要改为yes</span>\ndaemonize no\n\n<span># 后台运行指定的pid文件</span>\npidfile /var/run/redis_6379.pid\n\n<span># 日志级别</span>\n<span># Specify the server verbosity level.</span>\n<span># This can be one of:</span>\n<span># debug (a lot of information, useful for development/testing)</span>\n<span># verbose (many rarely useful info, but not a mess like the debug level)</span>\n<span># notice (moderately verbose, what you want in production probably)</span>\n<span># warning (only very important / critical messages are logged)</span>\nloglevel notice\n\n<span># 输入的日志位置文件名</span>\n<span># Specify the log file name. Also the empty string can be used to force</span>\n<span># Redis to log on the standard output. Note that if you use standard</span>\n<span># output for logging but daemonize, logs will be sent to /dev/null</span>\nlogfile <span>\"\"</span>\n\n<span># 数据库数量</span>\ndatabases <span>16</span>\n\n<span># 运行时显示redislogo</span>\nalways-show-logo <span>yes</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div>\n            </div>\n          </div>\n          \n        </div>\n<h3 id=\"_8-4-快照配置\"> 8.4 快照配置</h3>\n\n          <div\n            id=\"code-demo-dd0a7862\"\n           \n  \n data-title=\"%E5%BF%AB%E7%85%A7%E9%85%8D%E7%BD%AE\"\n\n            data-code=\"%7B%22bash%22%3A%22%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%20SNAPSHOTTING%20%20%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%5Cn%23%5Cn%23%20Save%20the%20DB%20on%20disk%3A%5Cn%23%5Cn%23%20%20%20save%20%3Cseconds%3E%20%3Cchanges%3E%5Cn%23%5Cn%23%20%20%20Will%20save%20the%20DB%20if%20both%20the%20given%20number%20of%20seconds%20and%20the%20given%5Cn%23%20%20%20number%20of%20write%20operations%20against%20the%20DB%20occurred.%5Cn%23%5Cn%23%20%20%20In%20the%20example%20below%20the%20behavior%20will%20be%20to%20save%3A%5Cn%23%20%20%20after%20900%20sec%20(15%20min)%20if%20at%20least%201%20key%20changed%5Cn%23%20%20%20after%20300%20sec%20(5%20min)%20if%20at%20least%2010%20keys%20changed%5Cn%23%20%20%20after%2060%20sec%20if%20at%20least%2010000%20keys%20changed%5Cn%23%5Cn%23%20%20%20Note%3A%20you%20can%20disable%20saving%20completely%20by%20commenting%20out%20all%20%5C%22save%5C%22%20lines.%5Cn%23%5Cn%23%20%20%20It%20is%20also%20possible%20to%20remove%20all%20the%20previously%20configured%20save%5Cn%23%20%20%20points%20by%20adding%20a%20save%20directive%20with%20a%20single%20empty%20string%20argument%5Cn%23%20%20%20like%20in%20the%20following%20example%3A%5Cn%23%5Cn%23%20%20%20save%20%5C%22%5C%22%5Cn%5Cn%23%20%E5%A6%82%E6%9E%9C900s%E5%86%85%2C%E5%A6%82%E6%9E%9C%E8%87%B3%E5%B0%91%E6%9C%89%E4%B8%80%E4%B8%AA1%E4%B8%AAkey%E8%BF%9B%E8%A1%8C%E4%BA%86%E4%BF%AE%E6%94%B9%2C%E6%88%91%E4%BB%AC%E5%B0%B1%E8%BF%9B%E8%A1%8C%E6%8C%81%E4%B9%85%E5%8C%96%E6%93%8D%E4%BD%9C%5Cnsave%20900%201%5Cn%23%20%E5%A6%82%E6%9E%9C.00s%E5%86%85%2C%E5%A6%82%E6%9E%9C%E8%87%B3%E5%B0%91%E6%9C%89%E4%B8%80%E4%B8%AA10%E4%B8%AAkey%E8%BF%9B%E8%A1%8C%E4%BA%86%E4%BF%AE%E6%94%B9%2C%E6%88%91%E4%BB%AC%E5%B0%B1%E8%BF%9B%E8%A1%8C%E6%8C%81%E4%B9%85%E5%8C%96%E6%93%8D%E4%BD%9C%5Cnsave%20300%2010%5Cn%23%20%E5%A6%82%E6%9E%9C60s%E5%86%85%2C%E5%A6%82%E6%9E%9C%E8%87%B3%E5%B0%91%E6%9C%89%E4%B8%80%E4%B8%AA10000%E4%B8%AAkey%E8%BF%9B%E8%A1%8C%E4%BA%86%E4%BF%AE%E6%94%B9%2C%E6%88%91%E4%BB%AC%E5%B0%B1%E8%BF%9B%E8%A1%8C%E6%8C%81%E4%B9%85%E5%8C%96%E6%93%8D%E4%BD%9C%5Cnsave%2060%2010000%5Cn%5Cn%23%20By%20default%20Redis%20will%20stop%20accepting%20writes%20if%20RDB%20snapshots%20are%20enabled%5Cn%23%20(at%20least%20one%20save%20point)%20and%20the%20latest%20background%20save%20failed.%5Cn%23%20This%20will%20make%20the%20user%20aware%20(in%20a%20hard%20way)%20that%20data%20is%20not%20persisting%5Cn%23%20on%20disk%20properly%2C%20otherwise%20chances%20are%20that%20no%20one%20will%20notice%20and%20some%5Cn%23%20disaster%20will%20happen.%5Cn%23%5Cn%23%20If%20the%20background%20saving%20process%20will%20start%20working%20again%20Redis%20will%5Cn%23%20automatically%20allow%20writes%20again.%5Cn%23%5Cn%23%20However%20if%20you%20have%20setup%20your%20proper%20monitoring%20of%20the%20Redis%20server%5Cn%23%20and%20persistence%2C%20you%20may%20want%20to%20disable%20this%20feature%20so%20that%20Redis%20will%5Cn%23%20continue%20to%20work%20as%20usual%20even%20if%20there%20are%20problems%20with%20disk%2C%5Cn%23%20permissions%2C%20and%20so%20forth.%5Cn%23%20%E6%8C%81%E4%B9%85%E5%8C%96%E6%93%8D%E4%BD%9C%E5%A4%B1%E8%B4%A5%E6%98%AF%E5%90%A6%E8%BF%98%E7%BB%A7%E7%BB%AD%5Cnstop-writes-on-bgsave-error%20yes%5Cn%5Cn%23%20Compress%20string%20objects%20using%20LZF%20when%20dump%20.rdb%20databases%3F%5Cn%23%20By%20default%20compression%20is%20enabled%20as%20it's%20almost%20always%20a%20win.%5Cn%23%20If%20you%20want%20to%20save%20some%20CPU%20in%20the%20saving%20child%20set%20it%20to%20'no'%20but%5Cn%23%20the%20dataset%20will%20likely%20be%20bigger%20if%20you%20have%20compressible%20values%20or%20keys.%5Cn%23%20%E6%98%AF%E5%90%A6%E5%8E%8B%E7%BC%A9rdb%E6%96%87%E4%BB%B6%EF%BC%8C%E6%98%AF%E7%9A%84%E8%AF%9D%E4%BC%9A%E6%B6%88%E8%80%97%E4%B8%80%E5%AE%9ACPU%E8%B5%84%E6%BA%90%5Cnrdbcompression%20yes%5Cn%5Cn%23%20Since%20version%205%20of%20RDB%20a%20CRC64%20checksum%20is%20placed%20at%20the%20end%20of%20the%20file.%5Cn%23%20This%20makes%20the%20format%20more%20resistant%20to%20corruption%20but%20there%20is%20a%20performance%5Cn%23%20hit%20to%20pay%20(around%2010%25)%20when%20saving%20and%20loading%20RDB%20files%2C%20so%20you%20can%20disable%20it%5Cn%23%20for%20maximum%20performances.%5Cn%23%5Cn%23%20RDB%20files%20created%20with%20checksum%20disabled%20have%20a%20checksum%20of%20zero%20that%20will%5Cn%23%20tell%20the%20loading%20code%20to%20skip%20the%20check.%5Cn%23%20%E4%BF%9D%E5%AD%98rdb%E6%96%87%E4%BB%B6%E7%9A%84%E6%97%B6%E5%80%99%E6%98%AF%E5%90%A6%E6%A0%A1%E9%AA%8Crdb%E6%96%87%E4%BB%B6%5Cnrdbchecksum%20yes%5Cn%5Cn%23%20The%20filename%20where%20to%20dump%20the%20DB%5Cndbfilename%20dump.rdb%5Cn%5Cn%23%20Remove%20RDB%20files%20used%20by%20replication%20in%20instances%20without%20persistence%5Cn%23%20enabled.%20By%20default%20this%20option%20is%20disabled%2C%20however%20there%20are%20environments%5Cn%23%20where%20for%20regulations%20or%20other%20security%20concerns%2C%20RDB%20files%20persisted%20on%5Cn%23%20disk%20by%20masters%20in%20order%20to%20feed%20replicas%2C%20or%20stored%20on%20disk%20by%20replicas%5Cn%23%20in%20order%20to%20load%20them%20for%20the%20initial%20synchronization%2C%20should%20be%20deleted%5Cn%23%20ASAP.%20Note%20that%20this%20option%20ONLY%20WORKS%20in%20instances%20that%20have%20both%20AOF%5Cn%23%20and%20RDB%20persistence%20disabled%2C%20otherwise%20is%20completely%20ignored.%5Cn%23%5Cn%23%20An%20alternative%20(and%20sometimes%20better)%20way%20to%20obtain%20the%20same%20effect%20is%5Cn%23%20to%20use%20diskless%20replication%20on%20both%20master%20and%20replicas%20instances.%20However%5Cn%23%20in%20the%20case%20of%20replicas%2C%20diskless%20is%20not%20always%20an%20option.%5Cnrdb-del-sync-files%20no%5Cn%5Cn%23%20The%20working%20directory.%5Cn%23%5Cn%23%20The%20DB%20will%20be%20written%20inside%20this%20directory%2C%20with%20the%20filename%20specified%5Cn%23%20above%20using%20the%20'dbfilename'%20configuration%20directive.%5Cn%23%5Cn%23%20The%20Append%20Only%20File%20will%20also%20be%20created%20inside%20this%20directory.%5Cn%23%5Cn%23%20Note%20that%20you%20must%20specify%20a%20directory%20here%2C%20not%20a%20file%20name.%5Cn%23%20rdb%E6%96%87%E4%BB%B6%E4%BF%9D%E5%AD%98%E7%9A%84%E7%9B%AE%E5%BD%95%5Cndir%20.%2F%5Cn%22%7D\"\n          >\n              \n              <div>\n                <div>\n<div><pre><code><span>################################ SNAPSHOTTING  ################################</span>\n<span>#</span>\n<span># Save the DB on disk:</span>\n<span>#</span>\n<span>#   save &lt;seconds> &lt;changes></span>\n<span>#</span>\n<span>#   Will save the DB if both the given number of seconds and the given</span>\n<span>#   number of write operations against the DB occurred.</span>\n<span>#</span>\n<span>#   In the example below the behavior will be to save:</span>\n<span>#   after 900 sec (15 min) if at least 1 key changed</span>\n<span>#   after 300 sec (5 min) if at least 10 keys changed</span>\n<span>#   after 60 sec if at least 10000 keys changed</span>\n<span>#</span>\n<span>#   Note: you can disable saving completely by commenting out all \"save\" lines.</span>\n<span>#</span>\n<span>#   It is also possible to remove all the previously configured save</span>\n<span>#   points by adding a save directive with a single empty string argument</span>\n<span>#   like in the following example:</span>\n<span>#</span>\n<span>#   save \"\"</span>\n\n<span># 如果900s内,如果至少有一个1个key进行了修改,我们就进行持久化操作</span>\nsave <span>900</span> <span>1</span>\n<span># 如果.00s内,如果至少有一个10个key进行了修改,我们就进行持久化操作</span>\nsave <span>300</span> <span>10</span>\n<span># 如果60s内,如果至少有一个10000个key进行了修改,我们就进行持久化操作</span>\nsave <span>60</span> <span>10000</span>\n\n<span># By default Redis will stop accepting writes if RDB snapshots are enabled</span>\n<span># (at least one save point) and the latest background save failed.</span>\n<span># This will make the user aware (in a hard way) that data is not persisting</span>\n<span># on disk properly, otherwise chances are that no one will notice and some</span>\n<span># disaster will happen.</span>\n<span>#</span>\n<span># If the background saving process will start working again Redis will</span>\n<span># automatically allow writes again.</span>\n<span>#</span>\n<span># However if you have setup your proper monitoring of the Redis server</span>\n<span># and persistence, you may want to disable this feature so that Redis will</span>\n<span># continue to work as usual even if there are problems with disk,</span>\n<span># permissions, and so forth.</span>\n<span># 持久化操作失败是否还继续</span>\nstop-writes-on-bgsave-error <span>yes</span>\n\n<span># Compress string objects using LZF when dump .rdb databases?</span>\n<span># By default compression is enabled as it's almost always a win.</span>\n<span># If you want to save some CPU in the saving child set it to 'no' but</span>\n<span># the dataset will likely be bigger if you have compressible values or keys.</span>\n<span># 是否压缩rdb文件，是的话会消耗一定CPU资源</span>\nrdbcompression <span>yes</span>\n\n<span># Since version 5 of RDB a CRC64 checksum is placed at the end of the file.</span>\n<span># This makes the format more resistant to corruption but there is a performance</span>\n<span># hit to pay (around 10%) when saving and loading RDB files, so you can disable it</span>\n<span># for maximum performances.</span>\n<span>#</span>\n<span># RDB files created with checksum disabled have a checksum of zero that will</span>\n<span># tell the loading code to skip the check.</span>\n<span># 保存rdb文件的时候是否校验rdb文件</span>\nrdbchecksum <span>yes</span>\n\n<span># The filename where to dump the DB</span>\ndbfilename dump.rdb\n\n<span># Remove RDB files used by replication in instances without persistence</span>\n<span># enabled. By default this option is disabled, however there are environments</span>\n<span># where for regulations or other security concerns, RDB files persisted on</span>\n<span># disk by masters in order to feed replicas, or stored on disk by replicas</span>\n<span># in order to load them for the initial synchronization, should be deleted</span>\n<span># ASAP. Note that this option ONLY WORKS in instances that have both AOF</span>\n<span># and RDB persistence disabled, otherwise is completely ignored.</span>\n<span>#</span>\n<span># An alternative (and sometimes better) way to obtain the same effect is</span>\n<span># to use diskless replication on both master and replicas instances. However</span>\n<span># in the case of replicas, diskless is not always an option.</span>\nrdb-del-sync-files no\n\n<span># The working directory.</span>\n<span>#</span>\n<span># The DB will be written inside this directory, with the filename specified</span>\n<span># above using the 'dbfilename' configuration directive.</span>\n<span>#</span>\n<span># The Append Only File will also be created inside this directory.</span>\n<span>#</span>\n<span># Note that you must specify a directory here, not a file name.</span>\n<span># rdb文件保存的目录</span>\n<span>dir</span> ./\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br></div></div>\n            </div>\n          </div>\n          \n        </div>\n<h3 id=\"_8-5-主从复制相关\"> 8.5 主从复制相关</h3>\n\n          <div\n            id=\"code-demo-2640955e\"\n           \n  \n data-title=\"%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9B%B8%E5%85%B3\"\n\n            data-code=\"%7B%22bash%22%3A%22%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%20REPLICATION%20%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%5Cn%5Cn%23%20Master-Replica%20replication.%20Use%20replicaof%20to%20make%20a%20Redis%20instance%20a%20copy%20of%5Cn%23%20another%20Redis%20server.%20A%20few%20things%20to%20understand%20ASAP%20about%20Redis%20replication.%5Cn%23%5Cn%23%20%20%20%2B------------------%2B%20%20%20%20%20%20%2B---------------%2B%5Cn%23%20%20%20%7C%20%20%20%20%20%20Master%20%20%20%20%20%20%7C%20---%3E%20%7C%20%20%20%20Replica%20%20%20%20%7C%5Cn%23%20%20%20%7C%20(receive%20writes)%20%7C%20%20%20%20%20%20%7C%20%20(exact%20copy)%20%7C%5Cn%23%20%20%20%2B------------------%2B%20%20%20%20%20%20%2B---------------%2B%5Cn%23%5Cn%23%201)%20Redis%20replication%20is%20asynchronous%2C%20but%20you%20can%20configure%20a%20master%20to%5Cn%23%20%20%20%20stop%20accepting%20writes%20if%20it%20appears%20to%20be%20not%20connected%20with%20at%20least%5Cn%23%20%20%20%20a%20given%20number%20of%20replicas.%5Cn%23%202)%20Redis%20replicas%20are%20able%20to%20perform%20a%20partial%20resynchronization%20with%20the%5Cn%23%20%20%20%20master%20if%20the%20replication%20link%20is%20lost%20for%20a%20relatively%20small%20amount%20of%5Cn%23%20%20%20%20time.%20You%20may%20want%20to%20configure%20the%20replication%20backlog%20size%20(see%20the%20next%5Cn%23%20%20%20%20sections%20of%20this%20file)%20with%20a%20sensible%20value%20depending%20on%20your%20needs.%5Cn%23%203)%20Replication%20is%20automatic%20and%20does%20not%20need%20user%20intervention.%20After%20a%5Cn%23%20%20%20%20network%20partition%20replicas%20automatically%20try%20to%20reconnect%20to%20masters%5Cn%23%20%20%20%20and%20resynchronize%20with%20them.%5Cn%23%5Cn%23%20replicaof%20%3Cmasterip%3E%20%3Cmasterport%3E%5Cn%5Cn%23%20If%20the%20master%20is%20password%20protected%20(using%20the%20%5C%22requirepass%5C%22%20configuration%5Cn%23%20directive%20below)%20it%20is%20possible%20to%20tell%20the%20replica%20to%20authenticate%20before%5Cn%23%20starting%20the%20replication%20synchronization%20process%2C%20otherwise%20the%20master%20will%5Cn%23%20refuse%20the%20replica%20request.%5Cn%23%5Cn%23%20masterauth%20%3Cmaster-password%3E%5Cn%23%5Cn%23%20However%20this%20is%20not%20enough%20if%20you%20are%20using%20Redis%20ACLs%20(for%20Redis%20version%5Cn%23%206%20or%20greater)%2C%20and%20the%20default%20user%20is%20not%20capable%20of%20running%20the%20PSYNC%5Cn%23%20command%20and%2For%20other%20commands%20needed%20for%20replication.%20In%20this%20case%20it's%5Cn%23%20better%20to%20configure%20a%20special%20user%20to%20use%20with%20replication%2C%20and%20specify%20the%5Cn%23%20masteruser%20configuration%20as%20such%3A%5Cn%23%5Cn%23%20masteruser%20%3Cusername%3E%5Cn%23%5Cn%23%20When%20masteruser%20is%20specified%2C%20the%20replica%20will%20authenticate%20against%20its%5Cn%23%20master%20using%20the%20new%20AUTH%20form%3A%20AUTH%20%3Cusername%3E%20%3Cpassword%3E.%5Cn%5Cn%23%20When%20a%20replica%20loses%20its%20connection%20with%20the%20master%2C%20or%20when%20the%20replication%5Cn%23%20is%20still%20in%20progress%2C%20the%20replica%20can%20act%20in%20two%20different%20ways%3A%5Cn%23%5Cn%23%201)%20if%20replica-serve-stale-data%20is%20set%20to%20'yes'%20(the%20default)%20the%20replica%20will%5Cn%23%20%20%20%20still%20reply%20to%20client%20requests%2C%20possibly%20with%20out%20of%20date%20data%2C%20or%20the%5Cn%23%20%20%20%20data%20set%20may%20just%20be%20empty%20if%20this%20is%20the%20first%20synchronization.%5Cn%23%5Cn%23%202)%20If%20replica-serve-stale-data%20is%20set%20to%20'no'%20the%20replica%20will%20reply%20with%5Cn%23%20%20%20%20an%20error%20%5C%22SYNC%20with%20master%20in%20progress%5C%22%20to%20all%20commands%20except%3A%5Cn%23%20%20%20%20INFO%2C%20REPLICAOF%2C%20AUTH%2C%20PING%2C%20SHUTDOWN%2C%20REPLCONF%2C%20ROLE%2C%20CONFIG%2C%20SUBSCRIBE%2C%5Cn%23%20%20%20%20UNSUBSCRIBE%2C%20PSUBSCRIBE%2C%20PUNSUBSCRIBE%2C%20PUBLISH%2C%20PUBSUB%2C%20COMMAND%2C%20POST%2C%5Cn%23%20%20%20%20HOST%20and%20LATENCY.%5Cn%23%5Cnreplica-serve-stale-data%20yes%5Cn%5Cn%23%20You%20can%20configure%20a%20replica%20instance%20to%20accept%20writes%20or%20not.%20Writing%20against%5Cn%23%20a%20replica%20instance%20may%20be%20useful%20to%20store%20some%20ephemeral%20data%20(because%20data%5Cn%23%20written%20on%20a%20replica%20will%20be%20easily%20deleted%20after%20resync%20with%20the%20master)%20but%5Cn%23%20may%20also%20cause%20problems%20if%20clients%20are%20writing%20to%20it%20because%20of%20a%5Cn%23%20misconfiguration.%5Cn%23%5Cn%23%20Since%20Redis%202.6%20by%20default%20replicas%20are%20read-only.%5Cn%23%5Cn%23%20Note%3A%20read%20only%20replicas%20are%20not%20designed%20to%20be%20exposed%20to%20untrusted%20clients%5Cn%23%20on%20the%20internet.%20It's%20just%20a%20protection%20layer%20against%20misuse%20of%20the%20instance.%5Cn%23%20Still%20a%20read%20only%20replica%20exports%20by%20default%20all%20the%20administrative%20commands%5Cn%23%20such%20as%20CONFIG%2C%20DEBUG%2C%20and%20so%20forth.%20To%20a%20limited%20extent%20you%20can%20improve%5Cn%23%20security%20of%20read%20only%20replicas%20using%20'rename-command'%20to%20shadow%20all%20the%5Cn%23%20administrative%20%2F%20dangerous%20commands.%5Cnreplica-read-only%20yes%5Cn%5Cn%23%20Replication%20SYNC%20strategy%3A%20disk%20or%20socket.%5Cn%23%5Cn%23%20New%20replicas%20and%20reconnecting%20replicas%20that%20are%20not%20able%20to%20continue%20the%5Cn%23%20replication%20process%20just%20receiving%20differences%2C%20need%20to%20do%20what%20is%20called%20a%5Cn%23%20%5C%22full%20synchronization%5C%22.%20An%20RDB%20file%20is%20transmitted%20from%20the%20master%20to%20the%5Cn%23%20replicas.%5Cn%23%5Cn%23%20The%20transmission%20can%20happen%20in%20two%20different%20ways%3A%5Cn%23%5Cn%23%201)%20Disk-backed%3A%20The%20Redis%20master%20creates%20a%20new%20process%20that%20writes%20the%20RDB%5Cn%23%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20file%20on%20disk.%20Later%20the%20file%20is%20transferred%20by%20the%20parent%5Cn%23%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20process%20to%20the%20replicas%20incrementally.%5Cn%23%202)%20Diskless%3A%20The%20Redis%20master%20creates%20a%20new%20process%20that%20directly%20writes%20the%5Cn%23%20%20%20%20%20%20%20%20%20%20%20%20%20%20RDB%20file%20to%20replica%20sockets%2C%20without%20touching%20the%20disk%20at%20all.%5Cn%23%5Cn%23%20With%20disk-backed%20replication%2C%20while%20the%20RDB%20file%20is%20generated%2C%20more%20replicas%5Cn%23%20can%20be%20queued%20and%20served%20with%20the%20RDB%20file%20as%20soon%20as%20the%20current%20child%5Cn%23%20producing%20the%20RDB%20file%20finishes%20its%20work.%20With%20diskless%20replication%20instead%5Cn%23%20once%20the%20transfer%20starts%2C%20new%20replicas%20arriving%20will%20be%20queued%20and%20a%20new%5Cn%23%20transfer%20will%20start%20when%20the%20current%20one%20terminates.%5Cn%23%5Cn%23%20When%20diskless%20replication%20is%20used%2C%20the%20master%20waits%20a%20configurable%20amount%20of%5Cn%23%20time%20(in%20seconds)%20before%20starting%20the%20transfer%20in%20the%20hope%20that%20multiple%5Cn%23%20replicas%20will%20arrive%20and%20the%20transfer%20can%20be%20parallelized.%5Cn%23%5Cn%23%20With%20slow%20disks%20and%20fast%20(large%20bandwidth)%20networks%2C%20diskless%20replication%5Cn%23%20works%20better.%5Cnrepl-diskless-sync%20no%5Cn%5Cn%23%20When%20diskless%20replication%20is%20enabled%2C%20it%20is%20possible%20to%20configure%20the%20delay%5Cn%23%20the%20server%20waits%20in%20order%20to%20spawn%20the%20child%20that%20transfers%20the%20RDB%20via%20socket%5Cn%23%20to%20the%20replicas.%5Cn%23%5Cn%23%20This%20is%20important%20since%20once%20the%20transfer%20starts%2C%20it%20is%20not%20possible%20to%20serve%5Cn%23%20new%20replicas%20arriving%2C%20that%20will%20be%20queued%20for%20the%20next%20RDB%20transfer%2C%20so%20the%5Cn%23%20server%20waits%20a%20delay%20in%20order%20to%20let%20more%20replicas%20arrive.%5Cn%23%5Cn%23%20The%20delay%20is%20specified%20in%20seconds%2C%20and%20by%20default%20is%205%20seconds.%20To%20disable%5Cn%23%20it%20entirely%20just%20set%20it%20to%200%20seconds%20and%20the%20transfer%20will%20start%20ASAP.%5Cnrepl-diskless-sync-delay%205%5Cn%5Cn%23%20-----------------------------------------------------------------------------%5Cn%23%20WARNING%3A%20RDB%20diskless%20load%20is%20experimental.%20Since%20in%20this%20setup%20the%20replica%5Cn%23%20does%20not%20immediately%20store%20an%20RDB%20on%20disk%2C%20it%20may%20cause%20data%20loss%20during%5Cn%23%20failovers.%20RDB%20diskless%20load%20%2B%20Redis%20modules%20not%20handling%20I%2FO%20reads%20may%20also%5Cn%23%20cause%20Redis%20to%20abort%20in%20case%20of%20I%2FO%20errors%20during%20the%20initial%20synchronization%5Cn%23%20stage%20with%20the%20master.%20Use%20only%20if%20your%20do%20what%20you%20are%20doing.%5Cn%23%20-----------------------------------------------------------------------------%5Cn%23%5Cn%23%20Replica%20can%20load%20the%20RDB%20it%20reads%20from%20the%20replication%20link%20directly%20from%20the%5Cn%23%20socket%2C%20or%20store%20the%20RDB%20to%20a%20file%20and%20read%20that%20file%20after%20it%20was%20completely%5Cn%23%20received%20from%20the%20master.%5Cn%23%5Cn%23%20In%20many%20cases%20the%20disk%20is%20slower%20than%20the%20network%2C%20and%20storing%20and%20loading%5Cn%23%20the%20RDB%20file%20may%20increase%20replication%20time%20(and%20even%20increase%20the%20master's%5Cn%23%20Copy%20on%20Write%20memory%20and%20salve%20buffers).%5Cn%23%20However%2C%20parsing%20the%20RDB%20file%20directly%20from%20the%20socket%20may%20mean%20that%20we%20have%5Cn%23%20to%20flush%20the%20contents%20of%20the%20current%20database%20before%20the%20full%20rdb%20was%5Cn%23%20received.%20For%20this%20reason%20we%20have%20the%20following%20options%3A%5Cn%23%5Cn%23%20%5C%22disabled%5C%22%20%20%20%20-%20Don't%20use%20diskless%20load%20(store%20the%20rdb%20file%20to%20the%20disk%20first)%5Cn%23%20%5C%22on-empty-db%5C%22%20-%20Use%20diskless%20load%20only%20when%20it%20is%20completely%20safe.%5Cn%23%20%5C%22swapdb%5C%22%20%20%20%20%20%20-%20Keep%20a%20copy%20of%20the%20current%20db%20contents%20in%20RAM%20while%20parsing%5Cn%23%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20the%20data%20directly%20from%20the%20socket.%20note%20that%20this%20requires%5Cn%23%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20sufficient%20memory%2C%20if%20you%20don't%20have%20it%2C%20you%20risk%20an%20OOM%20kill.%5Cnrepl-diskless-load%20disabled%5Cn%5Cn%23%20Replicas%20send%20PINGs%20to%20server%20in%20a%20predefined%20interval.%20It's%20possible%20to%5Cn%23%20change%20this%20interval%20with%20the%20repl_ping_replica_period%20option.%20The%20default%5Cn%23%20value%20is%2010%20seconds.%5Cn%23%5Cn%23%20repl-ping-replica-period%2010%5Cn%5Cn%23%20The%20following%20option%20sets%20the%20replication%20timeout%20for%3A%5Cn%23%5Cn%23%201)%20Bulk%20transfer%20I%2FO%20during%20SYNC%2C%20from%20the%20point%20of%20view%20of%20replica.%5Cn%23%202)%20Master%20timeout%20from%20the%20point%20of%20view%20of%20replicas%20(data%2C%20pings).%5Cn%23%203)%20Replica%20timeout%20from%20the%20point%20of%20view%20of%20masters%20(REPLCONF%20ACK%20pings).%5Cn%23%5Cn%23%20It%20is%20important%20to%20make%20sure%20that%20this%20value%20is%20greater%20than%20the%20value%5Cn%23%20specified%20for%20repl-ping-replica-period%20otherwise%20a%20timeout%20will%20be%20detected%5Cn%23%20every%20time%20there%20is%20low%20traffic%20between%20the%20master%20and%20the%20replica.%20The%20default%5Cn%23%20value%20is%2060%20seconds.%5Cn%23%5Cn%23%20repl-timeout%2060%5Cn%5Cn%23%20Disable%20TCP_NODELAY%20on%20the%20replica%20socket%20after%20SYNC%3F%5Cn%23%5Cn%23%20If%20you%20select%20%5C%22yes%5C%22%20Redis%20will%20use%20a%20smaller%20number%20of%20TCP%20packets%20and%5Cn%23%20less%20bandwidth%20to%20send%20data%20to%20replicas.%20But%20this%20can%20add%20a%20delay%20for%5Cn%23%20the%20data%20to%20appear%20on%20the%20replica%20side%2C%20up%20to%2040%20milliseconds%20with%5Cn%23%20Linux%20kernels%20using%20a%20default%20configuration.%5Cn%23%5Cn%23%20If%20you%20select%20%5C%22no%5C%22%20the%20delay%20for%20data%20to%20appear%20on%20the%20replica%20side%20will%5Cn%23%20be%20reduced%20but%20more%20bandwidth%20will%20be%20used%20for%20replication.%5Cn%23%5Cn%23%20By%20default%20we%20optimize%20for%20low%20latency%2C%20but%20in%20very%20high%20traffic%20conditions%5Cn%23%20or%20when%20the%20master%20and%20replicas%20are%20many%20hops%20away%2C%20turning%20this%20to%20%5C%22yes%5C%22%20may%5Cn%23%20be%20a%20good%20idea.%5Cnrepl-disable-tcp-nodelay%20no%5Cn%5Cn%23%20Set%20the%20replication%20backlog%20size.%20The%20backlog%20is%20a%20buffer%20that%20accumulates%5Cn%23%20replica%20data%20when%20replicas%20are%20disconnected%20for%20some%20time%2C%20so%20that%20when%20a%5Cn%23%20replica%20wants%20to%20reconnect%20again%2C%20often%20a%20full%20resync%20is%20not%20needed%2C%20but%20a%5Cn%23%20partial%20resync%20is%20enough%2C%20just%20passing%20the%20portion%20of%20data%20the%20replica%5Cn%23%20missed%20while%20disconnected.%5Cn%23%5Cn%23%20The%20bigger%20the%20replication%20backlog%2C%20the%20longer%20the%20replica%20can%20endure%20the%5Cn%23%20disconnect%20and%20later%20be%20able%20to%20perform%20a%20partial%20resynchronization.%5Cn%23%5Cn%23%20The%20backlog%20is%20only%20allocated%20if%20there%20is%20at%20least%20one%20replica%20connected.%5Cn%23%5Cn%23%20repl-backlog-size%201mb%5Cn%5Cn%23%20After%20a%20master%20has%20no%20connected%20replicas%20for%20some%20time%2C%20the%20backlog%20will%20be%5Cn%23%20freed.%20The%20following%20option%20configures%20the%20amount%20of%20seconds%20that%20need%20to%5Cn%23%20elapse%2C%20starting%20from%20the%20time%20the%20last%20replica%20disconnected%2C%20for%20the%20backlog%5Cn%23%20buffer%20to%20be%20freed.%5Cn%23%5Cn%23%20Note%20that%20replicas%20never%20free%20the%20backlog%20for%20timeout%2C%20since%20they%20may%20be%5Cn%23%20promoted%20to%20masters%20later%2C%20and%20should%20be%20able%20to%20correctly%20%5C%22partially%5Cn%23%20resynchronize%5C%22%20with%20other%20replicas%3A%20hence%20they%20should%20always%20accumulate%20backlog.%5Cn%23%5Cn%23%20A%20value%20of%200%20means%20to%20never%20release%20the%20backlog.%5Cn%23%5Cn%23%20repl-backlog-ttl%203600%5Cn%5Cn%23%20The%20replica%20priority%20is%20an%20integer%20number%20published%20by%20Redis%20in%20the%20INFO%5Cn%23%20output.%20It%20is%20used%20by%20Redis%20Sentinel%20in%20order%20to%20select%20a%20replica%20to%20promote%5Cn%23%20into%20a%20master%20if%20the%20master%20is%20no%20longer%20working%20correctly.%5Cn%23%5Cn%23%20A%20replica%20with%20a%20low%20priority%20number%20is%20considered%20better%20for%20promotion%2C%20so%5Cn%23%20for%20instance%20if%20there%20are%20three%20replicas%20with%20priority%2010%2C%20100%2C%2025%20Sentinel%5Cn%23%20will%20pick%20the%20one%20with%20priority%2010%2C%20that%20is%20the%20lowest.%5Cn%23%5Cn%23%20However%20a%20special%20priority%20of%200%20marks%20the%20replica%20as%20not%20able%20to%20perform%20the%5Cn%23%20role%20of%20master%2C%20so%20a%20replica%20with%20priority%20of%200%20will%20never%20be%20selected%20by%5Cn%23%20Redis%20Sentinel%20for%20promotion.%5Cn%23%5Cn%23%20By%20default%20the%20priority%20is%20100.%5Cnreplica-priority%20100%5Cn%5Cn%23%20It%20is%20possible%20for%20a%20master%20to%20stop%20accepting%20writes%20if%20there%20are%20less%20than%5Cn%23%20N%20replicas%20connected%2C%20having%20a%20lag%20less%20or%20equal%20than%20M%20seconds.%5Cn%23%5Cn%23%20The%20N%20replicas%20need%20to%20be%20in%20%5C%22online%5C%22%20state.%5Cn%23%5Cn%23%20The%20lag%20in%20seconds%2C%20that%20must%20be%20%3C%3D%20the%20specified%20value%2C%20is%20calculated%20from%5Cn%23%20the%20last%20ping%20received%20from%20the%20replica%2C%20that%20is%20usually%20sent%20every%20second.%5Cn%23%5Cn%23%20This%20option%20does%20not%20GUARANTEE%20that%20N%20replicas%20will%20accept%20the%20write%2C%20but%5Cn%23%20will%20limit%20the%20window%20of%20exposure%20for%20lost%20writes%20in%20case%20not%20enough%20replicas%5Cn%23%20are%20available%2C%20to%20the%20specified%20number%20of%20seconds.%5Cn%23%5Cn%23%20For%20example%20to%20require%20at%20least%203%20replicas%20with%20a%20lag%20%3C%3D%2010%20seconds%20use%3A%5Cn%23%5Cn%23%20min-replicas-to-write%203%5Cn%23%20min-replicas-max-lag%2010%5Cn%23%5Cn%23%20Setting%20one%20or%20the%20other%20to%200%20disables%20the%20feature.%5Cn%23%5Cn%23%20By%20default%20min-replicas-to-write%20is%20set%20to%200%20(feature%20disabled)%20and%5Cn%23%20min-replicas-max-lag%20is%20set%20to%2010.%5Cn%5Cn%23%20A%20Redis%20master%20is%20able%20to%20list%20the%20address%20and%20port%20of%20the%20attached%5Cn%23%20replicas%20in%20different%20ways.%20For%20example%20the%20%5C%22INFO%20replication%5C%22%20section%5Cn%23%20offers%20this%20information%2C%20which%20is%20used%2C%20among%20other%20tools%2C%20by%5Cn%23%20Redis%20Sentinel%20in%20order%20to%20discover%20replica%20instances.%5Cn%23%20Another%20place%20where%20this%20info%20is%20available%20is%20in%20the%20output%20of%20the%5Cn%23%20%5C%22ROLE%5C%22%20command%20of%20a%20master.%5Cn%23%5Cn%23%20The%20listed%20IP%20address%20and%20port%20normally%20reported%20by%20a%20replica%20is%5Cn%23%20obtained%20in%20the%20following%20way%3A%5Cn%23%5Cn%23%20%20%20IP%3A%20The%20address%20is%20auto%20detected%20by%20checking%20the%20peer%20address%5Cn%23%20%20%20of%20the%20socket%20used%20by%20the%20replica%20to%20connect%20with%20the%20master.%5Cn%23%5Cn%23%20%20%20Port%3A%20The%20port%20is%20communicated%20by%20the%20replica%20during%20the%20replication%5Cn%23%20%20%20handshake%2C%20and%20is%20normally%20the%20port%20that%20the%20replica%20is%20using%20to%5Cn%23%20%20%20listen%20for%20connections.%5Cn%23%5Cn%23%20However%20when%20port%20forwarding%20or%20Network%20Address%20Translation%20(NAT)%20is%5Cn%23%20used%2C%20the%20replica%20may%20actually%20be%20reachable%20via%20different%20IP%20and%20port%5Cn%23%20pairs.%20The%20following%20two%20options%20can%20be%20used%20by%20a%20replica%20in%20order%20to%5Cn%23%20report%20to%20its%20master%20a%20specific%20set%20of%20IP%20and%20port%2C%20so%20that%20both%20INFO%5Cn%23%20and%20ROLE%20will%20report%20those%20values.%5Cn%23%5Cn%23%20There%20is%20no%20need%20to%20use%20both%20the%20options%20if%20you%20need%20to%20override%20just%5Cn%23%20the%20port%20or%20the%20IP%20address.%5Cn%23%5Cn%23%20replica-announce-ip%205.5.5.5%5Cn%23%20replica-announce-port%201234%5Cn%22%7D\"\n          >\n              \n              <div>\n                <div>\n<div><pre><code><span>################################# REPLICATION #################################</span>\n\n<span># Master-Replica replication. Use replicaof to make a Redis instance a copy of</span>\n<span># another Redis server. A few things to understand ASAP about Redis replication.</span>\n<span>#</span>\n<span>#   +------------------+      +---------------+</span>\n<span>#   |      Master      | ---> |    Replica    |</span>\n<span>#   | (receive writes) |      |  (exact copy) |</span>\n<span>#   +------------------+      +---------------+</span>\n<span>#</span>\n<span># 1) Redis replication is asynchronous, but you can configure a master to</span>\n<span>#    stop accepting writes if it appears to be not connected with at least</span>\n<span>#    a given number of replicas.</span>\n<span># 2) Redis replicas are able to perform a partial resynchronization with the</span>\n<span>#    master if the replication link is lost for a relatively small amount of</span>\n<span>#    time. You may want to configure the replication backlog size (see the next</span>\n<span>#    sections of this file) with a sensible value depending on your needs.</span>\n<span># 3) Replication is automatic and does not need user intervention. After a</span>\n<span>#    network partition replicas automatically try to reconnect to masters</span>\n<span>#    and resynchronize with them.</span>\n<span>#</span>\n<span># replicaof &lt;masterip> &lt;masterport></span>\n\n<span># If the master is password protected (using the \"requirepass\" configuration</span>\n<span># directive below) it is possible to tell the replica to authenticate before</span>\n<span># starting the replication synchronization process, otherwise the master will</span>\n<span># refuse the replica request.</span>\n<span>#</span>\n<span># masterauth &lt;master-password></span>\n<span>#</span>\n<span># However this is not enough if you are using Redis ACLs (for Redis version</span>\n<span># 6 or greater), and the default user is not capable of running the PSYNC</span>\n<span># command and/or other commands needed for replication. In this case it's</span>\n<span># better to configure a special user to use with replication, and specify the</span>\n<span># masteruser configuration as such:</span>\n<span>#</span>\n<span># masteruser &lt;username></span>\n<span>#</span>\n<span># When masteruser is specified, the replica will authenticate against its</span>\n<span># master using the new AUTH form: AUTH &lt;username> &lt;password>.</span>\n\n<span># When a replica loses its connection with the master, or when the replication</span>\n<span># is still in progress, the replica can act in two different ways:</span>\n<span>#</span>\n<span># 1) if replica-serve-stale-data is set to 'yes' (the default) the replica will</span>\n<span>#    still reply to client requests, possibly with out of date data, or the</span>\n<span>#    data set may just be empty if this is the first synchronization.</span>\n<span>#</span>\n<span># 2) If replica-serve-stale-data is set to 'no' the replica will reply with</span>\n<span>#    an error \"SYNC with master in progress\" to all commands except:</span>\n<span>#    INFO, REPLICAOF, AUTH, PING, SHUTDOWN, REPLCONF, ROLE, CONFIG, SUBSCRIBE,</span>\n<span>#    UNSUBSCRIBE, PSUBSCRIBE, PUNSUBSCRIBE, PUBLISH, PUBSUB, COMMAND, POST,</span>\n<span>#    HOST and LATENCY.</span>\n<span>#</span>\nreplica-serve-stale-data <span>yes</span>\n\n<span># You can configure a replica instance to accept writes or not. Writing against</span>\n<span># a replica instance may be useful to store some ephemeral data (because data</span>\n<span># written on a replica will be easily deleted after resync with the master) but</span>\n<span># may also cause problems if clients are writing to it because of a</span>\n<span># misconfiguration.</span>\n<span>#</span>\n<span># Since Redis 2.6 by default replicas are read-only.</span>\n<span>#</span>\n<span># Note: read only replicas are not designed to be exposed to untrusted clients</span>\n<span># on the internet. It's just a protection layer against misuse of the instance.</span>\n<span># Still a read only replica exports by default all the administrative commands</span>\n<span># such as CONFIG, DEBUG, and so forth. To a limited extent you can improve</span>\n<span># security of read only replicas using 'rename-command' to shadow all the</span>\n<span># administrative / dangerous commands.</span>\nreplica-read-only <span>yes</span>\n\n<span># Replication SYNC strategy: disk or socket.</span>\n<span>#</span>\n<span># New replicas and reconnecting replicas that are not able to continue the</span>\n<span># replication process just receiving differences, need to do what is called a</span>\n<span># \"full synchronization\". An RDB file is transmitted from the master to the</span>\n<span># replicas.</span>\n<span>#</span>\n<span># The transmission can happen in two different ways:</span>\n<span>#</span>\n<span># 1) Disk-backed: The Redis master creates a new process that writes the RDB</span>\n<span>#                 file on disk. Later the file is transferred by the parent</span>\n<span>#                 process to the replicas incrementally.</span>\n<span># 2) Diskless: The Redis master creates a new process that directly writes the</span>\n<span>#              RDB file to replica sockets, without touching the disk at all.</span>\n<span>#</span>\n<span># With disk-backed replication, while the RDB file is generated, more replicas</span>\n<span># can be queued and served with the RDB file as soon as the current child</span>\n<span># producing the RDB file finishes its work. With diskless replication instead</span>\n<span># once the transfer starts, new replicas arriving will be queued and a new</span>\n<span># transfer will start when the current one terminates.</span>\n<span>#</span>\n<span># When diskless replication is used, the master waits a configurable amount of</span>\n<span># time (in seconds) before starting the transfer in the hope that multiple</span>\n<span># replicas will arrive and the transfer can be parallelized.</span>\n<span>#</span>\n<span># With slow disks and fast (large bandwidth) networks, diskless replication</span>\n<span># works better.</span>\nrepl-diskless-sync no\n\n<span># When diskless replication is enabled, it is possible to configure the delay</span>\n<span># the server waits in order to spawn the child that transfers the RDB via socket</span>\n<span># to the replicas.</span>\n<span>#</span>\n<span># This is important since once the transfer starts, it is not possible to serve</span>\n<span># new replicas arriving, that will be queued for the next RDB transfer, so the</span>\n<span># server waits a delay in order to let more replicas arrive.</span>\n<span>#</span>\n<span># The delay is specified in seconds, and by default is 5 seconds. To disable</span>\n<span># it entirely just set it to 0 seconds and the transfer will start ASAP.</span>\nrepl-diskless-sync-delay <span>5</span>\n\n<span># -----------------------------------------------------------------------------</span>\n<span># WARNING: RDB diskless load is experimental. Since in this setup the replica</span>\n<span># does not immediately store an RDB on disk, it may cause data loss during</span>\n<span># failovers. RDB diskless load + Redis modules not handling I/O reads may also</span>\n<span># cause Redis to abort in case of I/O errors during the initial synchronization</span>\n<span># stage with the master. Use only if your do what you are doing.</span>\n<span># -----------------------------------------------------------------------------</span>\n<span>#</span>\n<span># Replica can load the RDB it reads from the replication link directly from the</span>\n<span># socket, or store the RDB to a file and read that file after it was completely</span>\n<span># received from the master.</span>\n<span>#</span>\n<span># In many cases the disk is slower than the network, and storing and loading</span>\n<span># the RDB file may increase replication time (and even increase the master's</span>\n<span># Copy on Write memory and salve buffers).</span>\n<span># However, parsing the RDB file directly from the socket may mean that we have</span>\n<span># to flush the contents of the current database before the full rdb was</span>\n<span># received. For this reason we have the following options:</span>\n<span>#</span>\n<span># \"disabled\"    - Don't use diskless load (store the rdb file to the disk first)</span>\n<span># \"on-empty-db\" - Use diskless load only when it is completely safe.</span>\n<span># \"swapdb\"      - Keep a copy of the current db contents in RAM while parsing</span>\n<span>#                 the data directly from the socket. note that this requires</span>\n<span>#                 sufficient memory, if you don't have it, you risk an OOM kill.</span>\nrepl-diskless-load disabled\n\n<span># Replicas send PINGs to server in a predefined interval. It's possible to</span>\n<span># change this interval with the repl_ping_replica_period option. The default</span>\n<span># value is 10 seconds.</span>\n<span>#</span>\n<span># repl-ping-replica-period 10</span>\n\n<span># The following option sets the replication timeout for:</span>\n<span>#</span>\n<span># 1) Bulk transfer I/O during SYNC, from the point of view of replica.</span>\n<span># 2) Master timeout from the point of view of replicas (data, pings).</span>\n<span># 3) Replica timeout from the point of view of masters (REPLCONF ACK pings).</span>\n<span>#</span>\n<span># It is important to make sure that this value is greater than the value</span>\n<span># specified for repl-ping-replica-period otherwise a timeout will be detected</span>\n<span># every time there is low traffic between the master and the replica. The default</span>\n<span># value is 60 seconds.</span>\n<span>#</span>\n<span># repl-timeout 60</span>\n\n<span># Disable TCP_NODELAY on the replica socket after SYNC?</span>\n<span>#</span>\n<span># If you select \"yes\" Redis will use a smaller number of TCP packets and</span>\n<span># less bandwidth to send data to replicas. But this can add a delay for</span>\n<span># the data to appear on the replica side, up to 40 milliseconds with</span>\n<span># Linux kernels using a default configuration.</span>\n<span>#</span>\n<span># If you select \"no\" the delay for data to appear on the replica side will</span>\n<span># be reduced but more bandwidth will be used for replication.</span>\n<span>#</span>\n<span># By default we optimize for low latency, but in very high traffic conditions</span>\n<span># or when the master and replicas are many hops away, turning this to \"yes\" may</span>\n<span># be a good idea.</span>\nrepl-disable-tcp-nodelay no\n\n<span># Set the replication backlog size. The backlog is a buffer that accumulates</span>\n<span># replica data when replicas are disconnected for some time, so that when a</span>\n<span># replica wants to reconnect again, often a full resync is not needed, but a</span>\n<span># partial resync is enough, just passing the portion of data the replica</span>\n<span># missed while disconnected.</span>\n<span>#</span>\n<span># The bigger the replication backlog, the longer the replica can endure the</span>\n<span># disconnect and later be able to perform a partial resynchronization.</span>\n<span>#</span>\n<span># The backlog is only allocated if there is at least one replica connected.</span>\n<span>#</span>\n<span># repl-backlog-size 1mb</span>\n\n<span># After a master has no connected replicas for some time, the backlog will be</span>\n<span># freed. The following option configures the amount of seconds that need to</span>\n<span># elapse, starting from the time the last replica disconnected, for the backlog</span>\n<span># buffer to be freed.</span>\n<span>#</span>\n<span># Note that replicas never free the backlog for timeout, since they may be</span>\n<span># promoted to masters later, and should be able to correctly \"partially</span>\n<span># resynchronize\" with other replicas: hence they should always accumulate backlog.</span>\n<span>#</span>\n<span># A value of 0 means to never release the backlog.</span>\n<span>#</span>\n<span># repl-backlog-ttl 3600</span>\n\n<span># The replica priority is an integer number published by Redis in the INFO</span>\n<span># output. It is used by Redis Sentinel in order to select a replica to promote</span>\n<span># into a master if the master is no longer working correctly.</span>\n<span>#</span>\n<span># A replica with a low priority number is considered better for promotion, so</span>\n<span># for instance if there are three replicas with priority 10, 100, 25 Sentinel</span>\n<span># will pick the one with priority 10, that is the lowest.</span>\n<span>#</span>\n<span># However a special priority of 0 marks the replica as not able to perform the</span>\n<span># role of master, so a replica with priority of 0 will never be selected by</span>\n<span># Redis Sentinel for promotion.</span>\n<span>#</span>\n<span># By default the priority is 100.</span>\nreplica-priority <span>100</span>\n\n<span># It is possible for a master to stop accepting writes if there are less than</span>\n<span># N replicas connected, having a lag less or equal than M seconds.</span>\n<span>#</span>\n<span># The N replicas need to be in \"online\" state.</span>\n<span>#</span>\n<span># The lag in seconds, that must be &lt;= the specified value, is calculated from</span>\n<span># the last ping received from the replica, that is usually sent every second.</span>\n<span>#</span>\n<span># This option does not GUARANTEE that N replicas will accept the write, but</span>\n<span># will limit the window of exposure for lost writes in case not enough replicas</span>\n<span># are available, to the specified number of seconds.</span>\n<span>#</span>\n<span># For example to require at least 3 replicas with a lag &lt;= 10 seconds use:</span>\n<span>#</span>\n<span># min-replicas-to-write 3</span>\n<span># min-replicas-max-lag 10</span>\n<span>#</span>\n<span># Setting one or the other to 0 disables the feature.</span>\n<span>#</span>\n<span># By default min-replicas-to-write is set to 0 (feature disabled) and</span>\n<span># min-replicas-max-lag is set to 10.</span>\n\n<span># A Redis master is able to list the address and port of the attached</span>\n<span># replicas in different ways. For example the \"INFO replication\" section</span>\n<span># offers this information, which is used, among other tools, by</span>\n<span># Redis Sentinel in order to discover replica instances.</span>\n<span># Another place where this info is available is in the output of the</span>\n<span># \"ROLE\" command of a master.</span>\n<span>#</span>\n<span># The listed IP address and port normally reported by a replica is</span>\n<span># obtained in the following way:</span>\n<span>#</span>\n<span>#   IP: The address is auto detected by checking the peer address</span>\n<span>#   of the socket used by the replica to connect with the master.</span>\n<span>#</span>\n<span>#   Port: The port is communicated by the replica during the replication</span>\n<span>#   handshake, and is normally the port that the replica is using to</span>\n<span>#   listen for connections.</span>\n<span>#</span>\n<span># However when port forwarding or Network Address Translation (NAT) is</span>\n<span># used, the replica may actually be reachable via different IP and port</span>\n<span># pairs. The following two options can be used by a replica in order to</span>\n<span># report to its master a specific set of IP and port, so that both INFO</span>\n<span># and ROLE will report those values.</span>\n<span>#</span>\n<span># There is no need to use both the options if you need to override just</span>\n<span># the port or the IP address.</span>\n<span>#</span>\n<span># replica-announce-ip 5.5.5.5</span>\n<span># replica-announce-port 1234</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br><span>111</span><br><span>112</span><br><span>113</span><br><span>114</span><br><span>115</span><br><span>116</span><br><span>117</span><br><span>118</span><br><span>119</span><br><span>120</span><br><span>121</span><br><span>122</span><br><span>123</span><br><span>124</span><br><span>125</span><br><span>126</span><br><span>127</span><br><span>128</span><br><span>129</span><br><span>130</span><br><span>131</span><br><span>132</span><br><span>133</span><br><span>134</span><br><span>135</span><br><span>136</span><br><span>137</span><br><span>138</span><br><span>139</span><br><span>140</span><br><span>141</span><br><span>142</span><br><span>143</span><br><span>144</span><br><span>145</span><br><span>146</span><br><span>147</span><br><span>148</span><br><span>149</span><br><span>150</span><br><span>151</span><br><span>152</span><br><span>153</span><br><span>154</span><br><span>155</span><br><span>156</span><br><span>157</span><br><span>158</span><br><span>159</span><br><span>160</span><br><span>161</span><br><span>162</span><br><span>163</span><br><span>164</span><br><span>165</span><br><span>166</span><br><span>167</span><br><span>168</span><br><span>169</span><br><span>170</span><br><span>171</span><br><span>172</span><br><span>173</span><br><span>174</span><br><span>175</span><br><span>176</span><br><span>177</span><br><span>178</span><br><span>179</span><br><span>180</span><br><span>181</span><br><span>182</span><br><span>183</span><br><span>184</span><br><span>185</span><br><span>186</span><br><span>187</span><br><span>188</span><br><span>189</span><br><span>190</span><br><span>191</span><br><span>192</span><br><span>193</span><br><span>194</span><br><span>195</span><br><span>196</span><br><span>197</span><br><span>198</span><br><span>199</span><br><span>200</span><br><span>201</span><br><span>202</span><br><span>203</span><br><span>204</span><br><span>205</span><br><span>206</span><br><span>207</span><br><span>208</span><br><span>209</span><br><span>210</span><br><span>211</span><br><span>212</span><br><span>213</span><br><span>214</span><br><span>215</span><br><span>216</span><br><span>217</span><br><span>218</span><br><span>219</span><br><span>220</span><br><span>221</span><br><span>222</span><br><span>223</span><br><span>224</span><br><span>225</span><br><span>226</span><br><span>227</span><br><span>228</span><br><span>229</span><br><span>230</span><br><span>231</span><br><span>232</span><br><span>233</span><br><span>234</span><br><span>235</span><br><span>236</span><br><span>237</span><br><span>238</span><br><span>239</span><br><span>240</span><br><span>241</span><br><span>242</span><br><span>243</span><br><span>244</span><br><span>245</span><br><span>246</span><br><span>247</span><br><span>248</span><br><span>249</span><br><span>250</span><br><span>251</span><br><span>252</span><br><span>253</span><br><span>254</span><br><span>255</span><br><span>256</span><br><span>257</span><br><span>258</span><br><span>259</span><br><span>260</span><br><span>261</span><br><span>262</span><br><span>263</span><br><span>264</span><br></div></div>\n            </div>\n          </div>\n          \n        </div>\n<h3 id=\"_8-6-安全配置\"> 8.6 安全配置</h3>\n\n          <div\n            id=\"code-demo-58a98611\"\n           \n  \n data-title=\"%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE\"\n\n            data-code=\"%7B%22bash%22%3A%22%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%20SECURITY%20%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%5Cn%5Cn%5Cn%5Cn%23%20IMPORTANT%20NOTE%3A%20starting%20with%20Redis%206%20%5C%22requirepass%5C%22%20is%20just%20a%20compatibility%5Cn%23%20layer%20on%20top%20of%20the%20new%20ACL%20system.%20The%20option%20effect%20will%20be%20just%20setting%5Cn%23%20the%20password%20for%20the%20default%20user.%20Clients%20will%20still%20authenticate%20using%5Cn%23%20AUTH%20%3Cpassword%3E%20as%20usually%2C%20or%20more%20explicitly%20with%20AUTH%20default%20%3Cpassword%3E%5Cn%23%20if%20they%20follow%20the%20new%20protocol%3A%20both%20will%20work.%5Cn%23%5Cn%23%20requirepass%20foobared%5Cn%23%20%E8%AE%BE%E7%BD%AE%E5%AF%86%E7%A0%81%5Cnrequirepass%20123456%5Cn%5Cn%22%7D\"\n          >\n              \n              <div>\n                <div>\n<p>查看密码</p>\n<div><pre><code>//密码为空时获取密码\nconfig get requirepass\n\n//结果\n<span>\"requirepass\"</span>\n<span>\"\"</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>设置密码</p>\n<div><pre><code>config <span>set</span> requirepass <span>\"123456\"</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>密码登录</p>\n<div><pre><code>auth <span>123456</span>\n</code></pre>\n<div><span>1</span><br></div></div><p><code>redis.conf</code>设置密码</p>\n<div><pre><code><span>################################## SECURITY ###################################</span>\n\n\n\n<span># IMPORTANT NOTE: starting with Redis 6 \"requirepass\" is just a compatibility</span>\n<span># layer on top of the new ACL system. The option effect will be just setting</span>\n<span># the password for the default user. Clients will still authenticate using</span>\n<span># AUTH &lt;password> as usually, or more explicitly with AUTH default &lt;password></span>\n<span># if they follow the new protocol: both will work.</span>\n<span>#</span>\n<span># requirepass foobared</span>\n<span># 设置密码</span>\nrequirepass <span>123456</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div>\n            </div>\n          </div>\n          \n        </div>\n<h3 id=\"_8-7-客户端限制\"> 8.7 客户端限制</h3>\n\n          <div\n            id=\"code-demo-3496a55d\"\n           \n  \n data-title=\"%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%99%90%E5%88%B6\"\n\n            data-code=\"%7B%22bash%22%3A%22%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%20CLIENTS%20%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%5Cn%5Cn%23%20Set%20the%20max%20number%20of%20connected%20clients%20at%20the%20same%20time.%20By%20default%5Cn%23%20this%20limit%20is%20set%20to%2010000%20clients%2C%20however%20if%20the%20Redis%20server%20is%20not%5Cn%23%20able%20to%20configure%20the%20process%20file%20limit%20to%20allow%20for%20the%20specified%20limit%5Cn%23%20the%20max%20number%20of%20allowed%20clients%20is%20set%20to%20the%20current%20file%20limit%5Cn%23%20minus%2032%20(as%20Redis%20reserves%20a%20few%20file%20descriptors%20for%20internal%20uses).%5Cn%23%5Cn%23%20Once%20the%20limit%20is%20reached%20Redis%20will%20close%20all%20the%20new%20connections%20sending%5Cn%23%20an%20error%20'max%20number%20of%20clients%20reached'.%5Cn%23%5Cn%23%20IMPORTANT%3A%20When%20Redis%20Cluster%20is%20used%2C%20the%20max%20number%20of%20connections%20is%20also%5Cn%23%20shared%20with%20the%20cluster%20bus%3A%20every%20node%20in%20the%20cluster%20will%20use%20two%5Cn%23%20connections%2C%20one%20incoming%20and%20another%20outgoing.%20It%20is%20important%20to%20size%20the%5Cn%23%20limit%20accordingly%20in%20case%20of%20very%20large%20clusters.%5Cn%23%20%E8%AE%BE%E7%BD%AE%E8%83%BD%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%9C%80%E5%A4%A7%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%95%B0%5Cnmaxclients%2010000%5Cn%22%7D\"\n          >\n              \n              <div>\n                <div>\n<div><pre><code><span>################################### CLIENTS ####################################</span>\n\n<span># Set the max number of connected clients at the same time. By default</span>\n<span># this limit is set to 10000 clients, however if the Redis server is not</span>\n<span># able to configure the process file limit to allow for the specified limit</span>\n<span># the max number of allowed clients is set to the current file limit</span>\n<span># minus 32 (as Redis reserves a few file descriptors for internal uses).</span>\n<span>#</span>\n<span># Once the limit is reached Redis will close all the new connections sending</span>\n<span># an error 'max number of clients reached'.</span>\n<span>#</span>\n<span># IMPORTANT: When Redis Cluster is used, the max number of connections is also</span>\n<span># shared with the cluster bus: every node in the cluster will use two</span>\n<span># connections, one incoming and another outgoing. It is important to size the</span>\n<span># limit accordingly in case of very large clusters.</span>\n<span># 设置能连接的最大客户端数</span>\nmaxclients <span>10000</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div>\n            </div>\n          </div>\n          \n        </div>\n<h3 id=\"_8-8-内存容量配置\"> 8.8 内存容量配置</h3>\n<p>参考</p>\n<blockquote>\n<ul>\n<li><a href=\"http://www.511yj.com/centos-redis-key.html\" target=\"_blank\" rel=\"noopener noreferrer\">redis 设置过期Key 的 maxmemory-policy 六种方式 | 511遇见 (511yj.com)</a></li>\n</ul>\n</blockquote>\n<p>六种方式</p>\n<blockquote>\n<ul>\n<li>volatile-lru：只对设置了过期时间的key进行LRU（默认值）</li>\n<li>allkeys-lru ： 删除lru算法的key</li>\n<li>volatile-random：随机删除即将过期key</li>\n<li>allkeys-random：随机删除</li>\n<li>volatile-ttl ： 删除即将过期的</li>\n<li>noeviction ： 永不过期，返回错误</li>\n</ul>\n</blockquote>\n\n          <div\n            id=\"code-demo-07152435\"\n           \n  \n data-title=\"%E5%86%85%E5%AD%98%E5%AE%B9%E9%87%8F%E9%85%8D%E7%BD%AE\"\n\n            data-code=\"%7B%22bash%22%3A%22%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%20MEMORY%20MANAGEMENT%20%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%5Cn%5Cn%5Cn%23%E6%9C%80%E5%A4%A7%E5%86%85%E5%AD%98%E5%AE%B9%E9%87%8F%5Cnmaxmemory%20%3Cbytes%3E%5Cn%5Cn%23%20MAXMEMORY%20POLICY%3A%20how%20Redis%20will%20select%20what%20to%20remove%20when%20maxmemory%5Cn%23%20is%20reached.%20You%20can%20select%20one%20from%20the%20following%20behaviors%3A%5Cn%23%5Cn%23%20volatile-lru%20-%3E%20Evict%20using%20approximated%20LRU%2C%20only%20keys%20with%20an%20expire%20set.%5Cn%23%20allkeys-lru%20-%3E%20Evict%20any%20key%20using%20approximated%20LRU.%5Cn%23%20volatile-lfu%20-%3E%20Evict%20using%20approximated%20LFU%2C%20only%20keys%20with%20an%20expire%20set.%5Cn%23%20allkeys-lfu%20-%3E%20Evict%20any%20key%20using%20approximated%20LFU.%5Cn%23%20volatile-random%20-%3E%20Remove%20a%20random%20key%20having%20an%20expire%20set.%5Cn%23%20allkeys-random%20-%3E%20Remove%20a%20random%20key%2C%20any%20key.%5Cn%23%20volatile-ttl%20-%3E%20Remove%20the%20key%20with%20the%20nearest%20expire%20time%20(minor%20TTL)%5Cn%23%20noeviction%20-%3E%20Don't%20evict%20anything%2C%20just%20return%20an%20error%20on%20write%20operations.%5Cn%23%5Cn%23%20LRU%20means%20Least%20Recently%20Used%5Cn%23%20LFU%20means%20Least%20Frequently%20Used%5Cn%23%5Cn%23%20Both%20LRU%2C%20LFU%20and%20volatile-ttl%20are%20implemented%20using%20approximated%5Cn%23%20randomized%20algorithms.%5Cn%23%5Cn%23%20Note%3A%20with%20any%20of%20the%20above%20policies%2C%20Redis%20will%20return%20an%20error%20on%20write%5Cn%23%20%20%20%20%20%20%20operations%2C%20when%20there%20are%20no%20suitable%20keys%20for%20eviction.%5Cn%23%5Cn%23%20%20%20%20%20%20%20At%20the%20date%20of%20writing%20these%20commands%20are%3A%20set%20setnx%20setex%20append%5Cn%23%20%20%20%20%20%20%20incr%20decr%20rpush%20lpush%20rpushx%20lpushx%20linsert%20lset%20rpoplpush%20sadd%5Cn%23%20%20%20%20%20%20%20sinter%20sinterstore%20sunion%20sunionstore%20sdiff%20sdiffstore%20zadd%20zincrby%5Cn%23%20%20%20%20%20%20%20zunionstore%20zinterstore%20hset%20hsetnx%20hmset%20hincrby%20incrby%20decrby%5Cn%23%20%20%20%20%20%20%20getset%20mset%20msetnx%20exec%20sort%5Cn%23%5Cn%23%20The%20default%20is%3A%5Cn%23%20%E5%86%85%E5%AD%98%E8%BE%BE%E5%88%B0%E4%B8%8A%E9%99%90%E7%9A%84%E5%A4%84%E7%90%86%E7%AD%96%E7%95%A5%5Cnmaxmemory-policy%20noeviction%5Cn%5Cn%23%20LRU%2C%20LFU%20and%20minimal%20TTL%20algorithms%20are%20not%20precise%20algorithms%20but%20approximated%5Cn%23%20algorithms%20(in%20order%20to%20save%20memory)%2C%20so%20you%20can%20tune%20it%20for%20speed%20or%5Cn%23%20accuracy.%20By%20default%20Redis%20will%20check%20five%20keys%20and%20pick%20the%20one%20that%20was%5Cn%23%20used%20least%20recently%2C%20you%20can%20change%20the%20sample%20size%20using%20the%20following%5Cn%23%20configuration%20directive.%5Cn%23%5Cn%23%20The%20default%20of%205%20produces%20good%20enough%20results.%2010%20Approximates%20very%20closely%5Cn%23%20true%20LRU%20but%20costs%20more%20CPU.%203%20is%20faster%20but%20not%20very%20accurate.%5Cn%23%5Cn%23%20maxmemory-samples%205%5Cn%5Cn%23%20Starting%20from%20Redis%205%2C%20by%20default%20a%20replica%20will%20ignore%20its%20maxmemory%20setting%5Cn%23%20(unless%20it%20is%20promoted%20to%20master%20after%20a%20failover%20or%20manually).%20It%20means%5Cn%23%20that%20the%20eviction%20of%20keys%20will%20be%20just%20handled%20by%20the%20master%2C%20sending%20the%5Cn%23%20DEL%20commands%20to%20the%20replica%20as%20keys%20evict%20in%20the%20master%20side.%5Cn%23%5Cn%23%20This%20behavior%20ensures%20that%20masters%20and%20replicas%20stay%20consistent%2C%20and%20is%20usually%5Cn%23%20what%20you%20want%2C%20however%20if%20your%20replica%20is%20writable%2C%20or%20you%20want%20the%20replica%5Cn%23%20to%20have%20a%20different%20memory%20setting%2C%20and%20you%20are%20sure%20all%20the%20writes%20performed%5Cn%23%20to%20the%20replica%20are%20idempotent%2C%20then%20you%20may%20change%20this%20default%20(but%20be%20sure%5Cn%23%20to%20understand%20what%20you%20are%20doing).%5Cn%23%5Cn%23%20Note%20that%20since%20the%20replica%20by%20default%20does%20not%20evict%2C%20it%20may%20end%20using%20more%5Cn%23%20memory%20than%20the%20one%20set%20via%20maxmemory%20(there%20are%20certain%20buffers%20that%20may%5Cn%23%20be%20larger%20on%20the%20replica%2C%20or%20data%20structures%20may%20sometimes%20take%20more%20memory%5Cn%23%20and%20so%20forth).%20So%20make%20sure%20you%20monitor%20your%20replicas%20and%20make%20sure%20they%5Cn%23%20have%20enough%20memory%20to%20never%20hit%20a%20real%20out-of-memory%20condition%20before%20the%5Cn%23%20master%20hits%20the%20configured%20maxmemory%20setting.%5Cn%23%5Cn%23%20replica-ignore-maxmemory%20yes%5Cn%5Cn%23%20Redis%20reclaims%20expired%20keys%20in%20two%20ways%3A%20upon%20access%20when%20those%20keys%20are%5Cn%23%20found%20to%20be%20expired%2C%20and%20also%20in%20background%2C%20in%20what%20is%20called%20the%5Cn%23%20%5C%22active%20expire%20key%5C%22.%20The%20key%20space%20is%20slowly%20and%20interactively%20scanned%5Cn%23%20looking%20for%20expired%20keys%20to%20reclaim%2C%20so%20that%20it%20is%20possible%20to%20free%20memory%5Cn%23%20of%20keys%20that%20are%20expired%20and%20will%20never%20be%20accessed%20again%20in%20a%20short%20time.%5Cn%23%5Cn%23%20The%20default%20effort%20of%20the%20expire%20cycle%20will%20try%20to%20avoid%20having%20more%20than%5Cn%23%20ten%20percent%20of%20expired%20keys%20still%20in%20memory%2C%20and%20will%20try%20to%20avoid%20consuming%5Cn%23%20more%20than%2025%25%20of%20total%20memory%20and%20to%20add%20latency%20to%20the%20system.%20However%5Cn%23%20it%20is%20possible%20to%20increase%20the%20expire%20%5C%22effort%5C%22%20that%20is%20normally%20set%20to%5Cn%23%20%5C%221%5C%22%2C%20to%20a%20greater%20value%2C%20up%20to%20the%20value%20%5C%2210%5C%22.%20At%20its%20maximum%20value%20the%5Cn%23%20system%20will%20use%20more%20CPU%2C%20longer%20cycles%20(and%20technically%20may%20introduce%5Cn%23%20more%20latency)%2C%20and%20will%20tolerate%20less%20already%20expired%20keys%20still%20present%5Cn%23%20in%20the%20system.%20It's%20a%20tradeoff%20between%20memory%2C%20CPU%20and%20latency.%5Cn%23%5Cn%23%20active-expire-effort%201%5Cn%22%7D\"\n          >\n              \n              <div>\n                <div>\n<div><pre><code><span>############################## MEMORY MANAGEMENT ################################</span>\n\n\n<span>#最大内存容量</span>\nmaxmemory <span>&lt;</span>bytes<span>></span>\n\n<span># MAXMEMORY POLICY: how Redis will select what to remove when maxmemory</span>\n<span># is reached. You can select one from the following behaviors:</span>\n<span>#</span>\n<span># volatile-lru -> Evict using approximated LRU, only keys with an expire set.</span>\n<span># allkeys-lru -> Evict any key using approximated LRU.</span>\n<span># volatile-lfu -> Evict using approximated LFU, only keys with an expire set.</span>\n<span># allkeys-lfu -> Evict any key using approximated LFU.</span>\n<span># volatile-random -> Remove a random key having an expire set.</span>\n<span># allkeys-random -> Remove a random key, any key.</span>\n<span># volatile-ttl -> Remove the key with the nearest expire time (minor TTL)</span>\n<span># noeviction -> Don't evict anything, just return an error on write operations.</span>\n<span>#</span>\n<span># LRU means Least Recently Used</span>\n<span># LFU means Least Frequently Used</span>\n<span>#</span>\n<span># Both LRU, LFU and volatile-ttl are implemented using approximated</span>\n<span># randomized algorithms.</span>\n<span>#</span>\n<span># Note: with any of the above policies, Redis will return an error on write</span>\n<span>#       operations, when there are no suitable keys for eviction.</span>\n<span>#</span>\n<span>#       At the date of writing these commands are: set setnx setex append</span>\n<span>#       incr decr rpush lpush rpushx lpushx linsert lset rpoplpush sadd</span>\n<span>#       sinter sinterstore sunion sunionstore sdiff sdiffstore zadd zincrby</span>\n<span>#       zunionstore zinterstore hset hsetnx hmset hincrby incrby decrby</span>\n<span>#       getset mset msetnx exec sort</span>\n<span>#</span>\n<span># The default is:</span>\n<span># 内存达到上限的处理策略</span>\nmaxmemory-policy noeviction\n\n<span># LRU, LFU and minimal TTL algorithms are not precise algorithms but approximated</span>\n<span># algorithms (in order to save memory), so you can tune it for speed or</span>\n<span># accuracy. By default Redis will check five keys and pick the one that was</span>\n<span># used least recently, you can change the sample size using the following</span>\n<span># configuration directive.</span>\n<span>#</span>\n<span># The default of 5 produces good enough results. 10 Approximates very closely</span>\n<span># true LRU but costs more CPU. 3 is faster but not very accurate.</span>\n<span>#</span>\n<span># maxmemory-samples 5</span>\n\n<span># Starting from Redis 5, by default a replica will ignore its maxmemory setting</span>\n<span># (unless it is promoted to master after a failover or manually). It means</span>\n<span># that the eviction of keys will be just handled by the master, sending the</span>\n<span># DEL commands to the replica as keys evict in the master side.</span>\n<span>#</span>\n<span># This behavior ensures that masters and replicas stay consistent, and is usually</span>\n<span># what you want, however if your replica is writable, or you want the replica</span>\n<span># to have a different memory setting, and you are sure all the writes performed</span>\n<span># to the replica are idempotent, then you may change this default (but be sure</span>\n<span># to understand what you are doing).</span>\n<span>#</span>\n<span># Note that since the replica by default does not evict, it may end using more</span>\n<span># memory than the one set via maxmemory (there are certain buffers that may</span>\n<span># be larger on the replica, or data structures may sometimes take more memory</span>\n<span># and so forth). So make sure you monitor your replicas and make sure they</span>\n<span># have enough memory to never hit a real out-of-memory condition before the</span>\n<span># master hits the configured maxmemory setting.</span>\n<span>#</span>\n<span># replica-ignore-maxmemory yes</span>\n\n<span># Redis reclaims expired keys in two ways: upon access when those keys are</span>\n<span># found to be expired, and also in background, in what is called the</span>\n<span># \"active expire key\". The key space is slowly and interactively scanned</span>\n<span># looking for expired keys to reclaim, so that it is possible to free memory</span>\n<span># of keys that are expired and will never be accessed again in a short time.</span>\n<span>#</span>\n<span># The default effort of the expire cycle will try to avoid having more than</span>\n<span># ten percent of expired keys still in memory, and will try to avoid consuming</span>\n<span># more than 25% of total memory and to add latency to the system. However</span>\n<span># it is possible to increase the expire \"effort\" that is normally set to</span>\n<span># \"1\", to a greater value, up to the value \"10\". At its maximum value the</span>\n<span># system will use more CPU, longer cycles (and technically may introduce</span>\n<span># more latency), and will tolerate less already expired keys still present</span>\n<span># in the system. It's a tradeoff between memory, CPU and latency.</span>\n<span>#</span>\n<span># active-expire-effort 1</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br></div></div>\n            </div>\n          </div>\n          \n        </div>\n<h3 id=\"_8-9-aof配置\"> 8.9 AOF配置</h3>\n<div><pre><code># 是否用AOF，默认为no\nappendonly no：\n\n# 持久化文件的名字\nappendfilename &quot;appendonly.aof&quot;\n\n# 以什么策略执行一次保存\n# appendfsync always , 在每次修改后都会sync，消耗性能\n# appendfsync everysec , 每秒sync一次，可能会丢失1s的数据\nappendfsync everysec\n# appendfsync no ， 不执行sync，速度最快\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div>\n          <div\n            id=\"code-demo-e52c7972\"\n           \n  \n data-title=\"AOF%E9%85%8D%E7%BD%AE\"\n\n            data-code=\"%7B%22bash%22%3A%22%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%20APPEND%20ONLY%20MODE%20%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%5Cn%5Cn%23%20By%20default%20Redis%20asynchronously%20dumps%20the%20dataset%20on%20disk.%20This%20mode%20is%5Cn%23%20good%20enough%20in%20many%20applications%2C%20but%20an%20issue%20with%20the%20Redis%20process%20or%5Cn%23%20a%20power%20outage%20may%20result%20into%20a%20few%20minutes%20of%20writes%20lost%20(depending%20on%5Cn%23%20the%20configured%20save%20points).%5Cn%23%5Cn%23%20The%20Append%20Only%20File%20is%20an%20alternative%20persistence%20mode%20that%20provides%5Cn%23%20much%20better%20durability.%20For%20instance%20using%20the%20default%20data%20fsync%20policy%5Cn%23%20(see%20later%20in%20the%20config%20file)%20Redis%20can%20lose%20just%20one%20second%20of%20writes%20in%20a%5Cn%23%20dramatic%20event%20like%20a%20server%20power%20outage%2C%20or%20a%20single%20write%20if%20something%5Cn%23%20wrong%20with%20the%20Redis%20process%20itself%20happens%2C%20but%20the%20operating%20system%20is%5Cn%23%20still%20running%20correctly.%5Cn%23%5Cn%23%20AOF%20and%20RDB%20persistence%20can%20be%20enabled%20at%20the%20same%20time%20without%20problems.%5Cn%23%20If%20the%20AOF%20is%20enabled%20on%20startup%20Redis%20will%20load%20the%20AOF%2C%20that%20is%20the%20file%5Cn%23%20with%20the%20better%20durability%20guarantees.%5Cn%23%5Cn%23%20Please%20check%20http%3A%2F%2Fredis.io%2Ftopics%2Fpersistence%20for%20more%20information.%5Cn%5Cn%23%20%E6%98%AF%E5%90%A6%E7%94%A8AOF%E9%BB%98%E8%AE%A4%E4%B8%BAno%5Cnappendonly%20no%5Cn%5Cn%23%20The%20name%20of%20the%20append%20only%20file%20(default%3A%20%5C%22appendonly.aof%5C%22)%5Cn%5Cn%23%20%E6%8C%81%E4%B9%85%E5%8C%96%E6%96%87%E4%BB%B6%E7%9A%84%E5%90%8D%E5%AD%97%5Cnappendfilename%20%5C%22appendonly.aof%5C%22%5Cn%5Cn%23%20The%20fsync()%20call%20tells%20the%20Operating%20System%20to%20actually%20write%20data%20on%20disk%5Cn%23%20instead%20of%20waiting%20for%20more%20data%20in%20the%20output%20buffer.%20Some%20OS%20will%20really%20flush%5Cn%23%20data%20on%20disk%2C%20some%20other%20OS%20will%20just%20try%20to%20do%20it%20ASAP.%5Cn%23%5Cn%23%20Redis%20supports%20three%20different%20modes%3A%5Cn%23%5Cn%23%20no%3A%20don't%20fsync%2C%20just%20let%20the%20OS%20flush%20the%20data%20when%20it%20wants.%20Faster.%5Cn%23%20always%3A%20fsync%20after%20every%20write%20to%20the%20append%20only%20log.%20Slow%2C%20Safest.%5Cn%23%20everysec%3A%20fsync%20only%20one%20time%20every%20second.%20Compromise.%5Cn%23%5Cn%23%20The%20default%20is%20%5C%22everysec%5C%22%2C%20as%20that's%20usually%20the%20right%20compromise%20between%5Cn%23%20speed%20and%20data%20safety.%20It's%20up%20to%20you%20to%20understand%20if%20you%20can%20relax%20this%20to%5Cn%23%20%5C%22no%5C%22%20that%20will%20let%20the%20operating%20system%20flush%20the%20output%20buffer%20when%5Cn%23%20it%20wants%2C%20for%20better%20performances%20(but%20if%20you%20can%20live%20with%20the%20idea%20of%5Cn%23%20some%20data%20loss%20consider%20the%20default%20persistence%20mode%20that's%20snapshotting)%2C%5Cn%23%20or%20on%20the%20contrary%2C%20use%20%5C%22always%5C%22%20that's%20very%20slow%20but%20a%20bit%20safer%20than%5Cn%23%20everysec.%5Cn%23%5Cn%23%20More%20details%20please%20check%20the%20following%20article%3A%5Cn%23%20http%3A%2F%2Fantirez.com%2Fpost%2Fredis-persistence-demystified.html%5Cn%23%5Cn%23%20If%20unsure%2C%20use%20%5C%22everysec%5C%22.%5Cn%5Cn%23%20appendfsync%20always%5Cnappendfsync%20everysec%5Cn%23%20appendfsync%20no%5Cn%5Cn%23%20When%20the%20AOF%20fsync%20policy%20is%20set%20to%20always%20or%20everysec%2C%20and%20a%20background%5Cn%23%20saving%20process%20(a%20background%20save%20or%20AOF%20log%20background%20rewriting)%20is%5Cn%23%20performing%20a%20lot%20of%20I%2FO%20against%20the%20disk%2C%20in%20some%20Linux%20configurations%5Cn%23%20Redis%20may%20block%20too%20long%20on%20the%20fsync()%20call.%20Note%20that%20there%20is%20no%20fix%20for%5Cn%23%20this%20currently%2C%20as%20even%20performing%20fsync%20in%20a%20different%20thread%20will%20block%5Cn%23%20our%20synchronous%20write(2)%20call.%5Cn%23%5Cn%23%20In%20order%20to%20mitigate%20this%20problem%20it's%20possible%20to%20use%20the%20following%20option%5Cn%23%20that%20will%20prevent%20fsync()%20from%20being%20called%20in%20the%20main%20process%20while%20a%5Cn%23%20BGSAVE%20or%20BGREWRITEAOF%20is%20in%20progress.%5Cn%23%5Cn%23%20This%20means%20that%20while%20another%20child%20is%20saving%2C%20the%20durability%20of%20Redis%20is%5Cn%23%20the%20same%20as%20%5C%22appendfsync%20none%5C%22.%20In%20practical%20terms%2C%20this%20means%20that%20it%20is%5Cn%23%20possible%20to%20lose%20up%20to%2030%20seconds%20of%20log%20in%20the%20worst%20scenario%20(with%20the%5Cn%23%20default%20Linux%20settings).%5Cn%23%5Cn%23%20If%20you%20have%20latency%20problems%20turn%20this%20to%20%5C%22yes%5C%22.%20Otherwise%20leave%20it%20as%5Cn%23%20%5C%22no%5C%22%20that%20is%20the%20safest%20pick%20from%20the%20point%20of%20view%20of%20durability.%5Cn%5Cnno-appendfsync-on-rewrite%20no%5Cn%5Cn%23%20Automatic%20rewrite%20of%20the%20append%20only%20file.%5Cn%23%20Redis%20is%20able%20to%20automatically%20rewrite%20the%20log%20file%20implicitly%20calling%5Cn%23%20BGREWRITEAOF%20when%20the%20AOF%20log%20size%20grows%20by%20the%20specified%20percentage.%5Cn%23%5Cn%23%20This%20is%20how%20it%20works%3A%20Redis%20remembers%20the%20size%20of%20the%20AOF%20file%20after%20the%5Cn%23%20latest%20rewrite%20(if%20no%20rewrite%20has%20happened%20since%20the%20restart%2C%20the%20size%20of%5Cn%23%20the%20AOF%20at%20startup%20is%20used).%5Cn%23%5Cn%23%20This%20base%20size%20is%20compared%20to%20the%20current%20size.%20If%20the%20current%20size%20is%5Cn%23%20bigger%20than%20the%20specified%20percentage%2C%20the%20rewrite%20is%20triggered.%20Also%5Cn%23%20you%20need%20to%20specify%20a%20minimal%20size%20for%20the%20AOF%20file%20to%20be%20rewritten%2C%20this%5Cn%23%20is%20useful%20to%20avoid%20rewriting%20the%20AOF%20file%20even%20if%20the%20percentage%20increase%5Cn%23%20is%20reached%20but%20it%20is%20still%20pretty%20small.%5Cn%23%5Cn%23%20Specify%20a%20percentage%20of%20zero%20in%20order%20to%20disable%20the%20automatic%20AOF%5Cn%23%20rewrite%20feature.%5Cn%5Cnauto-aof-rewrite-percentage%20100%5Cnauto-aof-rewrite-min-size%2064mb%5Cn%5Cn%23%20An%20AOF%20file%20may%20be%20found%20to%20be%20truncated%20at%20the%20end%20during%20the%20Redis%5Cn%23%20startup%20process%2C%20when%20the%20AOF%20data%20gets%20loaded%20back%20into%20memory.%5Cn%23%20This%20may%20happen%20when%20the%20system%20where%20Redis%20is%20running%5Cn%23%20crashes%2C%20especially%20when%20an%20ext4%20filesystem%20is%20mounted%20without%20the%5Cn%23%20data%3Dordered%20option%20(however%20this%20can't%20happen%20when%20Redis%20itself%5Cn%23%20crashes%20or%20aborts%20but%20the%20operating%20system%20still%20works%20correctly).%5Cn%23%5Cn%23%20Redis%20can%20either%20exit%20with%20an%20error%20when%20this%20happens%2C%20or%20load%20as%20much%5Cn%23%20data%20as%20possible%20(the%20default%20now)%20and%20start%20if%20the%20AOF%20file%20is%20found%5Cn%23%20to%20be%20truncated%20at%20the%20end.%20The%20following%20option%20controls%20this%20behavior.%5Cn%23%5Cn%23%20If%20aof-load-truncated%20is%20set%20to%20yes%2C%20a%20truncated%20AOF%20file%20is%20loaded%20and%5Cn%23%20the%20Redis%20server%20starts%20emitting%20a%20log%20to%20inform%20the%20user%20of%20the%20event.%5Cn%23%20Otherwise%20if%20the%20option%20is%20set%20to%20no%2C%20the%20server%20aborts%20with%20an%20error%5Cn%23%20and%20refuses%20to%20start.%20When%20the%20option%20is%20set%20to%20no%2C%20the%20user%20requires%5Cn%23%20to%20fix%20the%20AOF%20file%20using%20the%20%5C%22redis-check-aof%5C%22%20utility%20before%20to%20restart%5Cn%23%20the%20server.%5Cn%23%5Cn%23%20Note%20that%20if%20the%20AOF%20file%20will%20be%20found%20to%20be%20corrupted%20in%20the%20middle%5Cn%23%20the%20server%20will%20still%20exit%20with%20an%20error.%20This%20option%20only%20applies%20when%5Cn%23%20Redis%20will%20try%20to%20read%20more%20data%20from%20the%20AOF%20file%20but%20not%20enough%20bytes%5Cn%23%20will%20be%20found.%5Cnaof-load-truncated%20yes%5Cn%5Cn%23%20When%20rewriting%20the%20AOF%20file%2C%20Redis%20is%20able%20to%20use%20an%20RDB%20preamble%20in%20the%5Cn%23%20AOF%20file%20for%20faster%20rewrites%20and%20recoveries.%20When%20this%20option%20is%20turned%5Cn%23%20on%20the%20rewritten%20AOF%20file%20is%20composed%20of%20two%20different%20stanzas%3A%5Cn%23%5Cn%23%20%20%20%5BRDB%20file%5D%5BAOF%20tail%5D%5Cn%23%5Cn%23%20When%20loading%2C%20Redis%20recognizes%20that%20the%20AOF%20file%20starts%20with%20the%20%5C%22REDIS%5C%22%5Cn%23%20string%20and%20loads%20the%20prefixed%20RDB%20file%2C%20then%20continues%20loading%20the%20AOF%5Cn%23%20tail.%5Cnaof-use-rdb-preamble%20yes%5Cn%22%7D\"\n          >\n              \n              <div>\n                <div>\n<div><pre><code><span>############################## APPEND ONLY MODE ###############################</span>\n\n<span># By default Redis asynchronously dumps the dataset on disk. This mode is</span>\n<span># good enough in many applications, but an issue with the Redis process or</span>\n<span># a power outage may result into a few minutes of writes lost (depending on</span>\n<span># the configured save points).</span>\n<span>#</span>\n<span># The Append Only File is an alternative persistence mode that provides</span>\n<span># much better durability. For instance using the default data fsync policy</span>\n<span># (see later in the config file) Redis can lose just one second of writes in a</span>\n<span># dramatic event like a server power outage, or a single write if something</span>\n<span># wrong with the Redis process itself happens, but the operating system is</span>\n<span># still running correctly.</span>\n<span>#</span>\n<span># AOF and RDB persistence can be enabled at the same time without problems.</span>\n<span># If the AOF is enabled on startup Redis will load the AOF, that is the file</span>\n<span># with the better durability guarantees.</span>\n<span>#</span>\n<span># Please check http://redis.io/topics/persistence for more information.</span>\n\n<span># 是否用AOF默认为no</span>\nappendonly no\n\n<span># The name of the append only file (default: \"appendonly.aof\")</span>\n\n<span># 持久化文件的名字</span>\nappendfilename <span>\"appendonly.aof\"</span>\n\n<span># The fsync() call tells the Operating System to actually write data on disk</span>\n<span># instead of waiting for more data in the output buffer. Some OS will really flush</span>\n<span># data on disk, some other OS will just try to do it ASAP.</span>\n<span>#</span>\n<span># Redis supports three different modes:</span>\n<span>#</span>\n<span># no: don't fsync, just let the OS flush the data when it wants. Faster.</span>\n<span># always: fsync after every write to the append only log. Slow, Safest.</span>\n<span># everysec: fsync only one time every second. Compromise.</span>\n<span>#</span>\n<span># The default is \"everysec\", as that's usually the right compromise between</span>\n<span># speed and data safety. It's up to you to understand if you can relax this to</span>\n<span># \"no\" that will let the operating system flush the output buffer when</span>\n<span># it wants, for better performances (but if you can live with the idea of</span>\n<span># some data loss consider the default persistence mode that's snapshotting),</span>\n<span># or on the contrary, use \"always\" that's very slow but a bit safer than</span>\n<span># everysec.</span>\n<span>#</span>\n<span># More details please check the following article:</span>\n<span># http://antirez.com/post/redis-persistence-demystified.html</span>\n<span>#</span>\n<span># If unsure, use \"everysec\".</span>\n\n<span># appendfsync always</span>\nappendfsync everysec\n<span># appendfsync no</span>\n\n<span># When the AOF fsync policy is set to always or everysec, and a background</span>\n<span># saving process (a background save or AOF log background rewriting) is</span>\n<span># performing a lot of I/O against the disk, in some Linux configurations</span>\n<span># Redis may block too long on the fsync() call. Note that there is no fix for</span>\n<span># this currently, as even performing fsync in a different thread will block</span>\n<span># our synchronous write(2) call.</span>\n<span>#</span>\n<span># In order to mitigate this problem it's possible to use the following option</span>\n<span># that will prevent fsync() from being called in the main process while a</span>\n<span># BGSAVE or BGREWRITEAOF is in progress.</span>\n<span>#</span>\n<span># This means that while another child is saving, the durability of Redis is</span>\n<span># the same as \"appendfsync none\". In practical terms, this means that it is</span>\n<span># possible to lose up to 30 seconds of log in the worst scenario (with the</span>\n<span># default Linux settings).</span>\n<span>#</span>\n<span># If you have latency problems turn this to \"yes\". Otherwise leave it as</span>\n<span># \"no\" that is the safest pick from the point of view of durability.</span>\n\nno-appendfsync-on-rewrite no\n\n<span># Automatic rewrite of the append only file.</span>\n<span># Redis is able to automatically rewrite the log file implicitly calling</span>\n<span># BGREWRITEAOF when the AOF log size grows by the specified percentage.</span>\n<span>#</span>\n<span># This is how it works: Redis remembers the size of the AOF file after the</span>\n<span># latest rewrite (if no rewrite has happened since the restart, the size of</span>\n<span># the AOF at startup is used).</span>\n<span>#</span>\n<span># This base size is compared to the current size. If the current size is</span>\n<span># bigger than the specified percentage, the rewrite is triggered. Also</span>\n<span># you need to specify a minimal size for the AOF file to be rewritten, this</span>\n<span># is useful to avoid rewriting the AOF file even if the percentage increase</span>\n<span># is reached but it is still pretty small.</span>\n<span>#</span>\n<span># Specify a percentage of zero in order to disable the automatic AOF</span>\n<span># rewrite feature.</span>\n\nauto-aof-rewrite-percentage <span>100</span>\nauto-aof-rewrite-min-size 64mb\n\n<span># An AOF file may be found to be truncated at the end during the Redis</span>\n<span># startup process, when the AOF data gets loaded back into memory.</span>\n<span># This may happen when the system where Redis is running</span>\n<span># crashes, especially when an ext4 filesystem is mounted without the</span>\n<span># data=ordered option (however this can't happen when Redis itself</span>\n<span># crashes or aborts but the operating system still works correctly).</span>\n<span>#</span>\n<span># Redis can either exit with an error when this happens, or load as much</span>\n<span># data as possible (the default now) and start if the AOF file is found</span>\n<span># to be truncated at the end. The following option controls this behavior.</span>\n<span>#</span>\n<span># If aof-load-truncated is set to yes, a truncated AOF file is loaded and</span>\n<span># the Redis server starts emitting a log to inform the user of the event.</span>\n<span># Otherwise if the option is set to no, the server aborts with an error</span>\n<span># and refuses to start. When the option is set to no, the user requires</span>\n<span># to fix the AOF file using the \"redis-check-aof\" utility before to restart</span>\n<span># the server.</span>\n<span>#</span>\n<span># Note that if the AOF file will be found to be corrupted in the middle</span>\n<span># the server will still exit with an error. This option only applies when</span>\n<span># Redis will try to read more data from the AOF file but not enough bytes</span>\n<span># will be found.</span>\naof-load-truncated <span>yes</span>\n\n<span># When rewriting the AOF file, Redis is able to use an RDB preamble in the</span>\n<span># AOF file for faster rewrites and recoveries. When this option is turned</span>\n<span># on the rewritten AOF file is composed of two different stanzas:</span>\n<span>#</span>\n<span>#   [RDB file][AOF tail]</span>\n<span>#</span>\n<span># When loading, Redis recognizes that the AOF file starts with the \"REDIS\"</span>\n<span># string and loads the prefixed RDB file, then continues loading the AOF</span>\n<span># tail.</span>\naof-use-rdb-preamble <span>yes</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br><span>111</span><br><span>112</span><br><span>113</span><br><span>114</span><br><span>115</span><br><span>116</span><br><span>117</span><br><span>118</span><br><span>119</span><br><span>120</span><br><span>121</span><br><span>122</span><br><span>123</span><br><span>124</span><br><span>125</span><br><span>126</span><br><span>127</span><br><span>128</span><br><span>129</span><br><span>130</span><br></div></div>\n            </div>\n          </div>\n          \n        </div>\n<h2 id=\"_9-redis持久化配置\"> 9. Redis持久化配置</h2>\n<p>理论参考</p>\n<blockquote>\n<ul>\n<li><a href=\"https://myblog.lifeisgg.online/static-blog/database/redis/Redis_theory_note/#_8-redis%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6\" target=\"_blank\" rel=\"noopener noreferrer\">Redis-RDB理论学习笔记 | LifeAlsoIsGG's Blog (lifeisgg.online)</a></li>\n</ul>\n</blockquote>\n<p>两种方式</p>\n<blockquote>\n<ul>\n<li>RDB(REDIS DATABASE)</li>\n<li>AOF(APPEND ONLY FILE)</li>\n</ul>\n</blockquote>\n<h3 id=\"rdb-redis-database\"> RDB(Redis Database)</h3>\n<p><code>RDB</code>是<code>Redis</code>默认的持久化方案</p>\n<p>手动触发执行命令<code>save</code>或<code>bgsave</code>即可，设置自动触发则在<code>redis.conf</code>中的快照配置中配置<code>save</code>触发机制</p>\n<p><code>save</code>和<code>bgsave</code>的区别</p>\n<p><img src=\"./images/Redis_deployment&use/The_difference_between_save_and_bgsave.jpg\" alt=\"save和bgsave的区别\" /></p>\n<p>设置自动触发的<code>redis.conf</code>在快照配置里面</p>\n<div><pre><code><span>################################ SNAPSHOTTING  ################################</span>\n<span># 如果900s内,如果至少有一个1个key进行了修改,我们就进行持久化操作</span>\nsave <span>900</span> <span>1</span>\n<span># 如果.00s内,如果至少有一个10个key进行了修改,我们就进行持久化操作</span>\nsave <span>300</span> <span>10</span>\n<span># 如果60s内,如果至少有一个10000个key进行了修改,我们就进行持久化操作</span>\nsave <span>60</span> <span>10000</span>\n\n\n<span># 持久化操作失败是否还继续</span>\nstop-writes-on-bgsave-error <span>yes</span>\n\n\n<span># 是否压缩rdb文件，是的话会消耗一定CPU资源</span>\nrdbcompression <span>yes</span>\n\n\n<span># 保存rdb文件的时候是否校验rdb文件</span>\nrdbchecksum <span>yes</span>\n\n<span># 存储的文件名</span>\ndbfilename dump.rdb\n\n<span># Remove RDB files used by replication in instances without persistence</span>\n<span># enabled. By default this option is disabled, however there are environments</span>\n<span># where for regulations or other security concerns, RDB files persisted on</span>\n<span># disk by masters in order to feed replicas, or stored on disk by replicas</span>\n<span># in order to load them for the initial synchronization, should be deleted</span>\n<span># ASAP. Note that this option ONLY WORKS in instances that have both AOF</span>\n<span># and RDB persistence disabled, otherwise is completely ignored.</span>\n<span>#</span>\n<span># An alternative (and sometimes better) way to obtain the same effect is</span>\n<span># to use diskless replication on both master and replicas instances. However</span>\n<span># in the case of replicas, diskless is not always an option.</span>\nrdb-del-sync-files no\n\n<span># The working directory.</span>\n<span>#</span>\n<span># The DB will be written inside this directory, with the filename specified</span>\n<span># above using the 'dbfilename' configuration directive.</span>\n<span>#</span>\n<span># The Append Only File will also be created inside this directory.</span>\n<span>#</span>\n<span># Note that you must specify a directory here, not a file name.</span>\n<span># rdb文件保存的目录</span>\n<span>dir</span> ./\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br></div></div><h2 id=\"_10-redis发布订阅\"> 10. Redis发布订阅</h2>\n<p>参考</p>\n<blockquote>\n<ul>\n<li><a href=\"https://www.runoob.com/redis/redis-pub-sub.html\" target=\"_blank\" rel=\"noopener noreferrer\">Redis 发布订阅 | 菜鸟教程 (runoob.com)</a></li>\n<li><a href=\"https://redisbook.readthedocs.io/en/latest/feature/pubsub.html\" target=\"_blank\" rel=\"noopener noreferrer\">订阅与发布 — Redis 设计与实现 (redisbook.readthedocs.io)</a></li>\n</ul>\n</blockquote>\n<p>Redis 发布订阅 (pub/sub) 是一种消息通信模式：发送者 (pub) 发送消息，订阅者 (sub) 接收消息。</p>\n<p>Redis 客户端可以订阅任意数量的频道。</p>\n<p>下图展示了频道 channel1 ， 以及订阅这个频道的三个客户端 —— client2 、 client5 和 client1 之间的关系：</p>\n<p><img src=\"./images/Redis_deployment&use/subscribe.png\" alt=\"订阅\" /></p>\n<p>当有新消息通过 PUBLISH 命令发送给频道 channel1 时， 这个消息就会被发送给订阅它的三个客户端：</p>\n<p><img src=\"./images/Redis_deployment&use/publish.png\" alt=\"发布\" /></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">序号</th>\n<th style=\"text-align:left\">命令及描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\">[PSUBSCRIBE pattern <a href=\"https://www.runoob.com/redis/pub-sub-psubscribe.html\" target=\"_blank\" rel=\"noopener noreferrer\">pattern ...]</a> 订阅一个或多个符合给定模式的频道。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">2</td>\n<td style=\"text-align:left\">[PUBSUB subcommand <a href=\"https://www.runoob.com/redis/pub-sub-pubsub.html\" target=\"_blank\" rel=\"noopener noreferrer\">argument [argument ...]]</a> 查看订阅与发布系统状态。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">3</td>\n<td style=\"text-align:left\"><a href=\"https://www.runoob.com/redis/pub-sub-publish.html\" target=\"_blank\" rel=\"noopener noreferrer\">PUBLISH channel message</a> 将信息发送到指定的频道。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">4</td>\n<td style=\"text-align:left\">[PUNSUBSCRIBE <a href=\"https://www.runoob.com/redis/pub-sub-punsubscribe.html\" target=\"_blank\" rel=\"noopener noreferrer\">pattern [pattern ...]]</a> 退订所有给定模式的频道。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">5</td>\n<td style=\"text-align:left\">[SUBSCRIBE channel <a href=\"https://www.runoob.com/redis/pub-sub-subscribe.html\" target=\"_blank\" rel=\"noopener noreferrer\">channel ...]</a> 订阅给定的一个或多个频道的信息。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">6</td>\n<td style=\"text-align:left\">[UNSUBSCRIBE <a href=\"https://www.runoob.com/redis/pub-sub-unsubscribe.html\" target=\"_blank\" rel=\"noopener noreferrer\">channel [channel ...]]</a> 指退订给定的频道。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"订阅端\"> 订阅端</h3>\n<div><pre><code><span>#订阅一个频道</span>\n<span>127.0</span>.0.1:637<span><span>9</span>></span> subscribe channelDemo\nReading messages<span>..</span>. <span>(</span>press Ctrl-C to quit<span>)</span>\n<span>1</span><span>)</span> <span>\"subscribe\"</span>\n<span>2</span><span>)</span> <span>\"channelDemo\"</span>\n\n<span>#等待读取信息</span>\n<span>3</span><span>)</span> <span>(</span>integer<span>)</span> <span>1</span>\n<span>1</span><span>)</span> <span>\"message\"</span>\n<span>2</span><span>)</span> <span>\"channelDemo\"</span>\n<span>3</span><span>)</span> <span>\"message1\"</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h3 id=\"发送端\"> 发送端</h3>\n<div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> publish channelDemo message1\n<span>(</span>integer<span>)</span> <span>1</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>更多请参考</p>\n<blockquote>\n<ul>\n<li><a href=\"https://redisbook.readthedocs.io/en/latest/feature/pubsub.html\" target=\"_blank\" rel=\"noopener noreferrer\">订阅与发布 — Redis 设计与实现 (redisbook.readthedocs.io)</a></li>\n</ul>\n</blockquote>\n<h2 id=\"_11-redis集群配置-主从复制配置\"> 11. Redis集群配置-主从复制配置</h2>\n<h3 id=\"_11-1-查看当前库信息\"> 11.1 查看当前库信息</h3>\n<div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> info replication\n<span># Replication</span>\n\n<span># 角色</span>\nrole:master\n\n<span># 从机数量</span>\nconnected_slaves:0\n\nmaster_replid:a8d691a368c6b581987c7502f0ec91b89edf812f\nmaster_replid2:0000000000000000000000000000000000000000\nmaster_repl_offset:0\nsecond_repl_offset:-1\nrepl_backlog_active:0\nrepl_backlog_size:1048576\nrepl_backlog_first_byte_offset:0\nrepl_backlog_histlen:0\n<span>127.0</span>.0.1:637<span><span>9</span>></span> \n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><h3 id=\"_11-2-redis-conf配置\"> 11.2 <code>redis.conf</code>配置</h3>\n<p>这里以docker创建不同的容器来运行不同的<code>redis.conf</code>为例，<code>redis.conf</code>文件名称不能一样，主要修改以下几项（这里默认不开启<code>appendonly</code>，所以不需要修改生成的<code>appendonly</code>文件名）</p>\n<div><pre><code><span>#端口号</span>\nport <span>6380</span>\n\n<span>#pid文件不能相同</span>\npidfile /var/run/redis_6380.pid\n\n<span>#日志文件不能相同</span>\nlogfile <span>\"/var/log/redis-6380.log\"</span>\n\n<span>#RDB文件名</span>\ndbfilename dumb-6380.rdb\n\n<span>#存放RDB和AOF的文件夹尽量也修改</span>\n<span>dir</span> ./data/redis-6380\n\n<span>#当master设密码时，slave需要设置连接master的密码</span>\nmasterauth <span>123456</span>\n\n<span>#说明它是哪个master的slave，salveof 主IP（必须是真实IP，而不是本地127.0.0.1） 主服务端口</span>\nreplicaof <span>127.0</span>.0.1 <span>6379</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>也可以通过<code>salveof</code>命令让当前redis实例成为某个redis实例的slave</p>\n<div><pre><code>slaveof <span>127.0</span>.0.1 <span>6379</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>从服务器比主服务器多一个<code>slaveof</code>的配置和<code>masterauth</code>密码</p>\n<h3 id=\"_11-3-启动容器\"> 11.3 启动容器</h3>\n<p>启动<code>master</code></p>\n<div><pre><code><span>docker</span> run -p <span>6379</span>:6379 --name redis-6379 -v /usr/local/docker/redis/redis-6379.conf:/etc/redis/redis-6379.conf -v /usr/local/docker/redis/data/redis-6379:/data/redis-6379 -d redis redis-server /etc/redis/redis-6379.conf\n</code></pre>\n<div><span>1</span><br></div></div><p>启动<code>slave-1</code></p>\n<div><pre><code><span>docker</span> run -p <span>6380</span>:6380 --name redis-6380 -v /usr/local/docker/redis/redis-6380.conf:/etc/redis/redis-6380.conf -v /usr/local/docker/redis/data/redis-6380:/data/redis-6380 -d redis redis-server /etc/redis/redis-6380.conf\n</code></pre>\n<div><span>1</span><br></div></div><p>启动<code>slave-2</code></p>\n<div><pre><code><span>docker</span> run -p <span>6381</span>:6381 --name redis-6381 -v /usr/local/docker/redis/redis-6381.conf:/etc/redis/redis-6381.conf -v /usr/local/docker/redis/data/redis-6381:/data/redis-6381 -d redis redis-server /etc/redis/redis-6381.conf\n</code></pre>\n<div><span>1</span><br></div></div><p>启动后在<code>master</code>中再次调用<code>info replication</code>如下</p>\n<div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> info replication\n<span># Replication</span>\nrole:master\nconnected_slaves:2\nslave0:ip<span>=</span><span>127.0</span>.0.1,port<span>=</span><span>6380</span>,state<span>=</span>online,offset<span>=</span><span>3374</span>,lag<span>=</span><span>0</span>\nslave1:ip<span>=</span><span>127.0</span>.0.1,port<span>=</span><span>6381</span>,state<span>=</span>online,offset<span>=</span><span>3374</span>,lag<span>=</span><span>1</span>\nmaster_replid:2f92baa3754bfd24b42113cfabd498396bfa736b\nmaster_replid2:0000000000000000000000000000000000000000\nmaster_repl_offset:3374\nsecond_repl_offset:-1\nrepl_backlog_active:1\nrepl_backlog_size:1048576\nrepl_backlog_first_byte_offset:1\nrepl_backlog_histlen:3374\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>在<code>slave-1</code>中如下</p>\n<div><pre><code><span>127.0</span>.0.1:638<span><span>0</span>></span> info replication\n<span># Replication</span>\nrole:slave\nmaster_host:47.100.59.153\nmaster_port:6379\nmaster_link_status:up\nmaster_last_io_seconds_ago:7\nmaster_sync_in_progress:0\nslave_repl_offset:5008\nslave_priority:100\nslave_read_only:1\nconnected_slaves:0\nmaster_replid:2f92baa3754bfd24b42113cfabd498396bfa736b\nmaster_replid2:0000000000000000000000000000000000000000\nmaster_repl_offset:5008\nsecond_repl_offset:-1\nrepl_backlog_active:1\nrepl_backlog_size:1048576\nrepl_backlog_first_byte_offset:1\nrepl_backlog_histlen:5008\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>在<code>slave-2</code>中如下</p>\n<div><pre><code><span>127.0</span>.0.1:638<span><span>1</span>></span> info replication\n<span># Replication</span>\nrole:slave\nmaster_host:47.100.59.153\nmaster_port:6379\nmaster_link_status:up\nmaster_last_io_seconds_ago:9\nmaster_sync_in_progress:0\nslave_repl_offset:5078\nslave_priority:100\nslave_read_only:1\nconnected_slaves:0\nmaster_replid:2f92baa3754bfd24b42113cfabd498396bfa736b\nmaster_replid2:0000000000000000000000000000000000000000\nmaster_repl_offset:5078\nsecond_repl_offset:-1\nrepl_backlog_active:1\nrepl_backlog_size:1048576\nrepl_backlog_first_byte_offset:771\nrepl_backlog_histlen:4308\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><h3 id=\"_11-4-验证主写从读-主从宕机\"> 11.4 验证主写从读/主从宕机</h3>\n<p><code>master</code>写入数据时，其它<code>slave</code>通过<code>增量复制</code>会同步<code>master</code>中的数据</p>\n<p>当<code>slave</code>写的时候提示只能读</p>\n<div><pre><code><span>127.0</span>.0.1:638<span><span>0</span>></span> <span>set</span> k1 v1\n<span>(</span>error<span>)</span> READONLY You can't <span>write</span> against a <span>read</span> only replica.\n<span>127.0</span>.0.1:638<span><span>0</span>></span> \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>主从宕机</p>\n<blockquote>\n<ul>\n<li>\n<p>如果此时<code>master</code>宕机或断开连接，<code>slave</code>还能继续读；当<code>master</code>上线回来后，<code>slave</code>能继续同步<code>master</code>读的内容</p>\n</li>\n<li>\n<p>如果是<code>slave</code>宕机，那么此时<code>master</code>在期间写，当<code>slave</code>上线回来后会<code>全量复制</code> <code>master</code>的数据</p>\n<blockquote>\n<p>当<code>slave</code>启动后，主动向<code>master</code>发送<code>SYNC</code>命令。<code>master</code>接收到<code>SYNC</code>命令后在后台保存快照（<code>RDB持久化</code>）和缓存保存快照这段时间的命令，然后将保存的快照文件和缓存的命令发送给<code>slave</code>。<code>slave</code>接收到快照文件和命令后加载快照文件和缓存的执行命令。</p>\n<p>复制初始化后，<code>master</code>每次接收到的写命令都会同步发送给<code>slave</code>，保证<code>主从数据一致性</code>。</p>\n</blockquote>\n</li>\n</ul>\n</blockquote>\n<h3 id=\"_11-5-其他注意\"> 11.5 其他注意</h3>\n<p>当把<code>slave</code>从入到另一个<code>slave</code>时，被从入的<code>slave</code>依然不能写</p>\n<p>如果<code>master</code>宕机想要重新推举出新的master，或者说想让<code>slave</code>脱离<code>master</code>，可以通过以下命令</p>\n<div><pre><code>slaveof no one\n</code></pre>\n<div><span>1</span><br></div></div><p>如果需要自动选举，还需要<code>哨兵模式</code></p>\n<h2 id=\"_12-redis集群配置-sentinel-哨兵-模式\"> 12. Redis集群配置-Sentinel（哨兵）模式</h2>\n<div><p>参考</p>\n<ul>\n<li>https://www.cnblogs.com/kingyifan/p/11721422.html</li>\n<li>https://www.cnblogs.com/kevingrace/p/9004460.html</li>\n</ul>\n</div>\n<h3 id=\"_12-1-创建sentinel-conf\"> 12.1 创建<code>sentinel.conf</code></h3>\n<p><code>sentinel.conf</code></p>\n<div><pre><code><span># 哨兵提供对外的端口号</span>\nport <span>26379</span>\ndaemonize no\nlogfile <span>\"sentinel-26379.log\"</span>\n<span>dir</span> <span>\"./data/sentinel-26379\"</span>\nsentinel monitor mymaster <span>127.0</span>.0.1 <span>7000</span> <span>2</span>\nsentinel down-after-milliseconds mymaster <span>30000</span>\nsentinel parallel-syncs mymaster <span>1</span>\nsentinel failover-timeout mymaster <span>15000</span>\nsentinel auth-pass mymaster <span>123</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>配置详解</p>\n<div><pre><code><span># 告诉sentinel去监听地址为ip:port的一个master，这里的master-name可以自定义，quorum是一个数字，</span>\n<span># 指明当有多少个sentinel认为一个master失效时，master才算真正失效，即客观下线</span>\nsentinel monitor <span>&lt;</span>master-name<span>></span> <span>&lt;</span>ip<span>></span> <span>&lt;</span>redis-port<span>></span> <span>&lt;</span>quorum<span>></span>\n\n<span># 设置连接master和slave时的密码，注意的是sentinel不能分别为master和slave设置不同的密码，因此master和slave的密码应该设置相同。</span>\nsentinel auth-pass <span>&lt;</span>master-name<span>></span> <span>&lt;</span>password<span>></span>\n\n<span># 这个配置项指定了需要多少失效时间，一个master才会被这个sentinel主观地认为是不可用的。 单位是毫秒，默认为30秒</span>\nsentinel down-after-milliseconds <span>&lt;</span>master-name<span>></span> <span>&lt;</span>milliseconds<span>></span> \n\n<span># 这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行 同步，这个数字越小，完成failover所需的时间就越长，</span>\n<span># 但是如果这个数字越大，就意味着越 多的slave因为replication而不可用。可以通过将这个值设为 1 来保证每次只有一个slave 处于不能处理命令请求的状态。</span>\nsentinel parallel-syncs <span>&lt;</span>master-name<span>></span> <span>&lt;</span>numslaves<span>></span> \n\n<span># failover-timeout 可以用在以下这些方面：</span>\n<span># 同一个sentinel对同一个master两次failover之间的间隔时间。   </span>\n<span># 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master那里同步数据时。    </span>\n<span># 当想要取消一个正在进行的failover所需要的时间。    </span>\n<span># 当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时，slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则了。</span>\nsentinel failover-timeout <span>&lt;</span>master-name<span>></span> <span>&lt;</span>milliseconds<span>></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><h3 id=\"_12-2-使用docker启动哨兵\"> 12.2 使用Docker启动哨兵</h3>\n<h2 id=\"_13-redis集群配置-集群cluster模式\"> 13. Redis集群配置-集群cluster模式</h2>\n<blockquote>\n<p>通过docker并自定义网络搭建</p>\n</blockquote>\n<div><p>参考</p>\n<ul>\n<li>https://www.cnblogs.com/catelina/p/13630036.html</li>\n<li><a href=\"https://www.jianshu.com/p/813a79ddf932\" target=\"_blank\" rel=\"noopener noreferrer\">Redis-Cluster集群</a></li>\n<li><a href=\"https://www.cnblogs.com/xuchen0117/p/11678931.html\" target=\"_blank\" rel=\"noopener noreferrer\">docker部署redis集群</a></li>\n<li><a href=\"https://blog.csdn.net/x3499633/article/details/88637819\" target=\"_blank\" rel=\"noopener noreferrer\">Redis Cluster 高可用集群（Docker 实现）</a></li>\n</ul>\n</div>\n<p>一般是三主三从</p>\n<h3 id=\"_13-1-创建集群网络\"> 13.1 创建集群网络</h3>\n<div><pre><code><span>docker</span> network create redis_cluster --subnet <span>172.38</span>.0.0/16\n</code></pre>\n<div><span>1</span><br></div></div><blockquote>\n<p><code>--subnet</code>为子网范围</p>\n</blockquote>\n<h3 id=\"_13-2-创建生成redis配置文件脚本\"> 13.2 创建生成redis配置文件脚本</h3>\n<p>用于生成自定义的redis配置<code>redis.conf</code></p>\n<div><pre><code><span># 循环6次</span>\n<span>for</span> <span>port</span> <span>in</span> <span><span>$(</span><span>seq</span> <span>79</span> <span>84</span><span>)</span></span><span>;</span>\n<span>do</span>\n  <span>mkdir</span> -p /data/docker/redis-cluster/node-63<span>${port}</span>/conf\n  <span>touch</span> /data/docker/redis-cluster/node-63<span>${port}</span>/conf/redis.conf\n  <span>cat</span> <span>></span> /data/docker/redis-cluster/node-63<span>${port}</span>/conf/redis.conf <span>&lt;&lt;</span> <span>EOF\nport 6379\nbind 0.0.0.0\nmasterauth 123\nrequirepass 123\ncluster-enabled yes\n# 注意每个集群的cluster-config-file名称不能一样，官网说实例 ID在集群中保持一个独一无二（unique）的名字。\ncluster-config-file nodes-63<span>${port}</span>.conf\ncluster-node-timeout 5000\ncluster-announce-ip 172.38.0.<span>${port}</span>\ncluster-announce-port 6379\nappendonly yes\n# 注意该脚本，结束的EOF前面不能有空格，输出的内容前面也不能留空格\nEOF</span>\n<span>done</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>之后会生成6个配置文件</p>\n<h3 id=\"_13-3-创建脚本通过docker运行\"> 13.3 创建脚本通过docker运行</h3>\n<div><pre><code><span>for</span> <span>port</span> <span>in</span> <span><span>$(</span><span>seq</span> <span>79</span> <span>84</span><span>)</span></span><span>;</span>\n<span>do</span>\n  <span>docker</span> run -p <span>63</span><span>${port}</span>:6379 -p <span>163</span><span>${port}</span>:16379 --name redis-63<span>${port}</span> <span>\\</span>\n  -v /data/docker/redis-cluster/node-63<span>${port}</span>/data:/data <span>\\</span>\n  -v /data/docker/redis-cluster/node-63<span>${port}</span>/conf/redis.conf:/etc/redis/redis.conf <span>\\</span>\n  -d --net redis_cluster --ip <span>172.38</span>.0.<span>${port}</span> redis redis-server /etc/redis/redis.conf\n<span>done</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>查看生成的六个容器</p>\n<div><pre><code><span>[</span>root@izuf6f489inattnq5zpfcxz redis-cluster<span>]</span><span># docker ps</span>\nCONTAINER ID        IMAGE                 COMMAND                  CREATED              STATUS              PORTS                                              NAMES\na6b9f914ece0        redis                 <span>\"docker-entrypoint.s…\"</span>   About a minute ago   Up About a minute   <span>0.0</span>.0.0:6386-<span>></span><span>6379</span>/tcp, <span>0.0</span>.0.0:26386-<span>></span><span>26379</span>/tcp   redis-6\ne8fd78ecb460        redis                 <span>\"docker-entrypoint.s…\"</span>   About a minute ago   Up About a minute   <span>0.0</span>.0.0:6385-<span>></span><span>6379</span>/tcp, <span>0.0</span>.0.0:26385-<span>></span><span>26379</span>/tcp   redis-5\naa236068a616        redis                 <span>\"docker-entrypoint.s…\"</span>   About a minute ago   Up About a minute   <span>0.0</span>.0.0:6384-<span>></span><span>6379</span>/tcp, <span>0.0</span>.0.0:26384-<span>></span><span>26379</span>/tcp   redis-4\nd07e6c6a0e59        redis                 <span>\"docker-entrypoint.s…\"</span>   About a minute ago   Up About a minute   <span>0.0</span>.0.0:6383-<span>></span><span>6379</span>/tcp, <span>0.0</span>.0.0:26383-<span>></span><span>26379</span>/tcp   redis-3\n7404f91d3ec5        redis                 <span>\"docker-entrypoint.s…\"</span>   About a minute ago   Up About a minute   <span>0.0</span>.0.0:6382-<span>></span><span>6379</span>/tcp, <span>0.0</span>.0.0:26382-<span>></span><span>26379</span>/tcp   redis-2\n9b59cc207416        redis                 <span>\"docker-entrypoint.s…\"</span>   About a minute ago   Up About a minute   <span>0.0</span>.0.0:6381-<span>></span><span>6379</span>/tcp, <span>0.0</span>.0.0:26381-<span>></span><span>26379</span>/tcp   redis-1\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id=\"_13-4-启动集群\"> 13.4 启动集群</h3>\n<p>进入某个redis</p>\n<div><pre><code><span>docker</span> <span>exec</span> -it redis-1 /bin/bash\n</code></pre>\n<div><span>1</span><br></div></div><p>启动集群</p>\n<blockquote>\n<p>创建redis集群命令 <code>redis-cli --cluster create</code> 参数 <code>--cluster-replicas 1</code> 表示副本是1</p>\n</blockquote>\n<div><pre><code><span># 创建redis集群命令 redis-cli --cluster create 参数 --cluster-replicas 1 表示副本是1</span>\nredis-cli --cluster create -a <span>123</span> <span>172.38</span>.0.79:6379 <span>172.38</span>.0.80:6379 <span>172.38</span>.0.81:6379 <span>172.38</span>.0.82:6379 <span>172.38</span>.0.83:6379 <span>172.38</span>.0.84:6379 --cluster-replicas <span>1</span> \n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>创建成功</p>\n<div><pre><code>Waiting <span>for</span> the cluster to <span>join</span>\n<span>.</span>\n<span>>></span><span>></span> Performing Cluster Check <span>(</span>using <span>node</span> <span>172.38</span>.0.11:6379<span>)</span>\nM: 2dd15c79a6850e19be1cf503731b21b75c618242 <span>172.38</span>.0.11:6379\n   slots:<span>[</span><span>0</span>-5460<span>]</span> <span>(</span><span>5461</span> slots<span>)</span> master\n   <span>1</span> additional replica<span>(</span>s<span>)</span>\nS: 54169c6085325e041c01812d88c0c4718d427989 <span>172.38</span>.0.15:6379\n   slots: <span>(</span><span>0</span> slots<span>)</span> slave\n   replicates 2dd15c79a6850e19be1cf503731b21b75c618242\nM: 722e27ee6ac3b34416387b56ebae3d69cf54a4d1 <span>172.38</span>.0.13:6379\n   slots:<span>[</span><span>10923</span>-16383<span>]</span> <span>(</span><span>5461</span> slots<span>)</span> master\n   <span>1</span> additional replica<span>(</span>s<span>)</span>\nM: 312454ec0845792a27650f1e237fc8be29d73f52 <span>172.38</span>.0.12:6379\n   slots:<span>[</span><span>5461</span>-10922<span>]</span> <span>(</span><span>5462</span> slots<span>)</span> master\n   <span>1</span> additional replica<span>(</span>s<span>)</span>\nS: f2f92641a484bc2e84a72a7aaeef68d713b1defc <span>172.38</span>.0.16:6379\n   slots: <span>(</span><span>0</span> slots<span>)</span> slave\n   replicates 312454ec0845792a27650f1e237fc8be29d73f52\nS: dbe7035e84422f582ddd475cb822854c6ff57d00 <span>172.38</span>.0.14:6379\n   slots: <span>(</span><span>0</span> slots<span>)</span> slave\n   replicates 722e27ee6ac3b34416387b56ebae3d69cf54a4d1\n<span>[</span>OK<span>]</span> All nodes agree about slots configuration.\n<span>>></span><span>></span> Check <span>for</span> <span>open</span> slots<span>..</span>.\n<span>>></span><span>></span> Check slots coverage<span>..</span>.\n<span>[</span>OK<span>]</span> All <span>16384</span> slots covered.\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><h3 id=\"_13-5-进入集群\"> 13.5 进入集群</h3>\n<div><pre><code>redis-cli -c\n</code></pre>\n<div><span>1</span><br></div></div><p>查看集群信息</p>\n<div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> cluster info\ncluster_state:ok\ncluster_slots_assigned:16384\ncluster_slots_ok:16384\ncluster_slots_pfail:0\ncluster_slots_fail:0\ncluster_known_nodes:6\ncluster_size:3\ncluster_current_epoch:6\ncluster_my_epoch:1\ncluster_stats_messages_ping_sent:509\ncluster_stats_messages_pong_sent:515\ncluster_stats_messages_sent:1024\ncluster_stats_messages_ping_received:510\ncluster_stats_messages_pong_received:509\ncluster_stats_messages_meet_received:5\ncluster_stats_messages_received:1024\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>查看集群nodes</p>\n<div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> cluster nodes\n54169c6085325e041c01812d88c0c4718d427989 <span>172.38</span>.0.15:6379@16379 slave 2dd15c79a6850e19be1cf503731b21b75c618242 <span>0</span> <span>1613875900000</span> <span>1</span> connected\n722e27ee6ac3b34416387b56ebae3d69cf54a4d1 <span>172.38</span>.0.13:6379@16379 master - <span>0</span> <span>1613875900000</span> <span>3</span> connected <span>10923</span>-16383\n312454ec0845792a27650f1e237fc8be29d73f52 <span>172.38</span>.0.12:6379@16379 master - <span>0</span> <span>1613875900000</span> <span>2</span> connected <span>5461</span>-10922\nf2f92641a484bc2e84a72a7aaeef68d713b1defc <span>172.38</span>.0.16:6379@16379 slave 312454ec0845792a27650f1e237fc8be29d73f52 <span>0</span> <span>1613875900847</span> <span>2</span> connected\n2dd15c79a6850e19be1cf503731b21b75c618242 <span>172.38</span>.0.11:6379@16379 myself,master - <span>0</span> <span>1613875899000</span> <span>1</span> connected <span>0</span>-5460\ndbe7035e84422f582ddd475cb822854c6ff57d00 <span>172.38</span>.0.14:6379@16379 slave 722e27ee6ac3b34416387b56ebae3d69cf54a4d1 <span>0</span> <span>1613875899000</span> <span>3</span> connected\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id=\"_13-6-测试\"> 13.6 测试</h3>\n<p>set一个值</p>\n<div><pre><code>root@d0de8a779418:/data<span># redis-cli -c</span>\n<span>127.0</span>.0.1:637<span><span>9</span>></span> <span>set</span> k1 v1\n-<span>></span> Redirected to slot <span>[</span><span>12706</span><span>]</span> located at <span>172.38</span>.0.13:6379\nOK\n<span>172.38</span>.0.13:637<span><span>9</span>></span> \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>可以看到此值通过桶算法被set到另一个节点。当通过get等命令获取值时如果key在其他节点，也会切换到其他主节点</p>\n<blockquote>\n<p>注意从节点不提供服务，只是作为备份和集群入口存在</p>\n</blockquote>\n<h3 id=\"_13-7-测试集群高可用\"> 13.7 测试集群高可用</h3>\n<p>模拟某个节点挂掉，此时他的从节点会顶替成为主节点，当挂掉的节点恢复时，会自动成为新的主节点的从节点</p>\n<p>查看初始节点状态</p>\n<div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> cluster nodes\n54169c6085325e041c01812d88c0c4718d427989 <span>172.38</span>.0.15:6379@16379 slave 2dd15c79a6850e19be1cf503731b21b75c618242 <span>0</span> <span>1613875900000</span> <span>1</span> connected\n722e27ee6ac3b34416387b56ebae3d69cf54a4d1 <span>172.38</span>.0.13:6379@16379 master - <span>0</span> <span>1613875900000</span> <span>3</span> connected <span>10923</span>-16383\n312454ec0845792a27650f1e237fc8be29d73f52 <span>172.38</span>.0.12:6379@16379 master - <span>0</span> <span>1613875900000</span> <span>2</span> connected <span>5461</span>-10922\nf2f92641a484bc2e84a72a7aaeef68d713b1defc <span>172.38</span>.0.16:6379@16379 slave 312454ec0845792a27650f1e237fc8be29d73f52 <span>0</span> <span>1613875900847</span> <span>2</span> connected\n2dd15c79a6850e19be1cf503731b21b75c618242 <span>172.38</span>.0.11:6379@16379 myself,master - <span>0</span> <span>1613875899000</span> <span>1</span> connected <span>0</span>-5460\ndbe7035e84422f582ddd475cb822854c6ff57d00 <span>172.38</span>.0.14:6379@16379 slave 722e27ee6ac3b34416387b56ebae3d69cf54a4d1 <span>0</span> <span>1613875899000</span> <span>3</span> connected\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>挂掉<code>172.38.0.11:6379</code>的主节点后，从节点<code>172.38.0.15:6379</code>自动顶替成为新的主节点</p>\n<div><div><br><br><br><br><div>&nbsp;</div><br><br><br><br><br></div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> cluster nodes\nf2f92641a484bc2e84a72a7aaeef68d713b1defc <span>172.38</span>.0.16:6379@16379 slave 312454ec0845792a27650f1e237fc8be29d73f52 <span>0</span> <span>1613879100375</span> <span>2</span> connected\ndbe7035e84422f582ddd475cb822854c6ff57d00 <span>172.38</span>.0.14:6379@16379 slave 722e27ee6ac3b34416387b56ebae3d69cf54a4d1 <span>0</span> <span>1613879099373</span> <span>3</span> connected\n722e27ee6ac3b34416387b56ebae3d69cf54a4d1 <span>172.38</span>.0.13:6379@16379 master - <span>0</span> <span>1613879100579</span> <span>3</span> connected <span>10923</span>-16383\n<span>#挂掉的主节点</span>\n2dd15c79a6850e19be1cf503731b21b75c618242 <span>172.38</span>.0.11:6379@16379 master,fail - <span>1613879073779</span> <span>1613879071274</span> <span>1</span> connected\n312454ec0845792a27650f1e237fc8be29d73f52 <span>172.38</span>.0.12:6379@16379 myself,master - <span>0</span> <span>1613879099000</span> <span>2</span> connected <span>5461</span>-10922\n<span>#顶替上来的从节点</span>\n54169c6085325e041c01812d88c0c4718d427989 <span>172.38</span>.0.15:6379@16379 master - <span>0</span> <span>1613879100000</span> <span>7</span> connected <span>0</span>-5460\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>此时再恢复挂掉的主节点后</p>\n<div><div><br><br><br><br><div>&nbsp;</div><br><br><br></div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> cluster nodes\nf2f92641a484bc2e84a72a7aaeef68d713b1defc <span>172.38</span>.0.16:6379@16379 slave 312454ec0845792a27650f1e237fc8be29d73f52 <span>0</span> <span>1613879274000</span> <span>2</span> connected\ndbe7035e84422f582ddd475cb822854c6ff57d00 <span>172.38</span>.0.14:6379@16379 slave 722e27ee6ac3b34416387b56ebae3d69cf54a4d1 <span>0</span> <span>1613879273030</span> <span>3</span> connected\n722e27ee6ac3b34416387b56ebae3d69cf54a4d1 <span>172.38</span>.0.13:6379@16379 master - <span>0</span> <span>1613879273000</span> <span>3</span> connected <span>10923</span>-16383\n2dd15c79a6850e19be1cf503731b21b75c618242 <span>172.38</span>.0.11:6379@16379 slave 54169c6085325e041c01812d88c0c4718d427989 <span>0</span> <span>1613879275046</span> <span>7</span> connected\n312454ec0845792a27650f1e237fc8be29d73f52 <span>172.38</span>.0.12:6379@16379 myself,master - <span>0</span> <span>1613879273000</span> <span>2</span> connected <span>5461</span>-10922\n54169c6085325e041c01812d88c0c4718d427989 <span>172.38</span>.0.15:6379@16379 master - <span>0</span> <span>1613879274042</span> <span>7</span> connected <span>0</span>-5460\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><blockquote>\n<p>可以看到此时的<code>172.38.0.11:6379</code>节点已经变为从节点</p>\n</blockquote>\n<p>如果某个主节点和它的从节点一起挂掉，那么此时的redis集群不可用</p>\n<p>我们此时挂掉主节点<code>172.38.0.15:6379</code>以及它的从节点<code>172.38.0.11:6379</code>，之后再从其他节点进入查看集群状态</p>\n<div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> cluster info\n<span>#集群状态为fail不可用</span>\ncluster_state:fail\ncluster_slots_assigned:16384\ncluster_slots_ok:10923\ncluster_slots_pfail:0\ncluster_slots_fail:5461\ncluster_known_nodes:6\ncluster_size:3\ncluster_current_epoch:7\ncluster_my_epoch:2\ncluster_stats_messages_ping_sent:9535\ncluster_stats_messages_pong_sent:9628\ncluster_stats_messages_meet_sent:1\ncluster_stats_messages_fail_sent:5\ncluster_stats_messages_auth-ack_sent:1\ncluster_stats_messages_sent:19170\ncluster_stats_messages_ping_received:9628\ncluster_stats_messages_pong_received:9534\ncluster_stats_messages_fail_received:3\ncluster_stats_messages_auth-req_received:1\ncluster_stats_messages_received:19166\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><p>可以看到<code>cluster_state:fail</code>，说明此时集群已经不可用(fail)</p>\n<p>再尝试set值也报错误</p>\n<div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> <span>set</span> k2 v2\n<span>(</span>error<span>)</span> CLUSTERDOWN The cluster is down\n<span>127.0</span>.0.1:637<span><span>9</span>></span> \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id=\"_13-8-增加节点\"> 13.8 增加节点</h3>\n<p>由于集群已经初始化，我们后续增加节点只用增加就行</p>\n<p>创建两个新的redis容器，配置和创建方式同上</p>\n<blockquote>\n<p>新增两个redis容器<code>redis-7</code>和<code>redis-8</code></p>\n</blockquote>\n<div><pre><code><span>[</span>root@izuf6f489inattnq5zpfcxz ~<span>]</span><span># docker ps</span>\nCONTAINER ID        IMAGE                 COMMAND                  CREATED             STATUS              PORTS                                              NAMES\n56cc93bc0184        redis                 <span>\"docker-entrypoint.s…\"</span>   <span>5</span> seconds ago       Up <span>3</span> seconds        <span>0.0</span>.0.0:6388-<span>></span><span>6379</span>/tcp, <span>0.0</span>.0.0:16388-<span>></span><span>16379</span>/tcp   redis-8\n8c27e66cbe48        redis                 <span>\"docker-entrypoint.s…\"</span>   <span>5</span> seconds ago       Up <span>4</span> seconds        <span>0.0</span>.0.0:6387-<span>></span><span>6379</span>/tcp, <span>0.0</span>.0.0:16387-<span>></span><span>16379</span>/tcp   redis-7\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>从某个节点进入集群并新增节点</p>\n<p>新增了<code>172.38.0.17 6379</code>和<code>172.38.0.18 6379</code></p>\n<div><pre><code><span>172.38</span>.0.15:637<span><span>9</span>></span> cluster meet <span>172.38</span>.0.17 <span>6379</span>\nOK\n<span>172.38</span>.0.15:637<span><span>9</span>></span> cluster meet <span>172.38</span>.0.18 <span>6379</span>\nOK\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>再次查看集群节点信息</p>\n<div><div><br><br><br><div>&nbsp;</div><br><br><br><br><br><br></div><pre><code><span>172.38</span>.0.15:637<span><span>9</span>></span> cluster nodes\n2dd15c79a6850e19be1cf503731b21b75c618242 <span>172.38</span>.0.11:6379@16379 slave 54169c6085325e041c01812d88c0c4718d427989 <span>0</span> <span>1613883611396</span> <span>7</span> connected\n722e27ee6ac3b34416387b56ebae3d69cf54a4d1 <span>172.38</span>.0.13:6379@16379 master - <span>0</span> <span>1613883610594</span> <span>3</span> connected <span>10923</span>-16383\nd1f011036255d7266095b6163b433939722c4acb <span>172.38</span>.0.18:6379@16379 master - <span>0</span> <span>1613883610393</span> <span>9</span> connected\n54169c6085325e041c01812d88c0c4718d427989 <span>172.38</span>.0.15:6379@16379 myself,master - <span>0</span> <span>1613883609000</span> <span>7</span> connected <span>0</span>-5460\nf2f92641a484bc2e84a72a7aaeef68d713b1defc <span>172.38</span>.0.16:6379@16379 master - <span>0</span> <span>1613883611000</span> <span>8</span> connected <span>5461</span>-10922\nf288476630bd43910dff617591ac1521e06f9b72 <span>172.38</span>.0.17:6379@16379 master - <span>0</span> <span>1613883610594</span> <span>0</span> connected\n312454ec0845792a27650f1e237fc8be29d73f52 <span>172.38</span>.0.12:6379@16379 slave f2f92641a484bc2e84a72a7aaeef68d713b1defc <span>0</span> <span>1613883611596</span> <span>8</span> connected\ndbe7035e84422f582ddd475cb822854c6ff57d00 <span>172.38</span>.0.14:6379@16379 slave 722e27ee6ac3b34416387b56ebae3d69cf54a4d1 <span>0</span> <span>1613883610000</span> <span>3</span> connected\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>发现新增的节点进来都是<code>master</code>身份即主节点</p>\n<h3 id=\"_13-9-更换节点身份\"> 13.9 更换节点身份</h3>\n<p>将新增的<code>172.38.0.18 6379</code>节点身份改为<code>172.38.0.17 6379</code>的<code>slave</code></p>\n<div><pre><code>redis-cli -c -h <span>172.38</span>.0.18 -p <span>6379</span> cluster replicate f288476630bd43910dff617591ac1521e06f9b72<span>(</span>主节点node_id<span>)</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>也可以进入集群后让当前节点变为某个节点的从节点</p>\n<div><pre><code><span>172.38</span>.0.18:637<span><span>9</span>></span> CLUSTER REPLICATE f288476630bd43910dff617591ac1521e06f9b72\nOK\n<span>172.38</span>.0.18:637<span><span>9</span>></span> \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>再次查看集群节点信息</p>\n<div><div><br><br><br><br><div>&nbsp;</div><br><br><br><br><br></div><pre><code><span>172.38</span>.0.18:637<span><span>9</span>></span> cluster nodes\n722e27ee6ac3b34416387b56ebae3d69cf54a4d1 <span>172.38</span>.0.13:6379@16379 master - <span>0</span> <span>1613884572000</span> <span>3</span> connected <span>10923</span>-16383\ndbe7035e84422f582ddd475cb822854c6ff57d00 <span>172.38</span>.0.14:6379@16379 slave 722e27ee6ac3b34416387b56ebae3d69cf54a4d1 <span>0</span> <span>1613884572009</span> <span>3</span> connected\nf2f92641a484bc2e84a72a7aaeef68d713b1defc <span>172.38</span>.0.16:6379@16379 master - <span>0</span> <span>1613884570605</span> <span>8</span> connected <span>5461</span>-10922\nd1f011036255d7266095b6163b433939722c4acb <span>172.38</span>.0.18:6379@16379 myself,slave f288476630bd43910dff617591ac1521e06f9b72 <span>0</span> <span>1613884572000</span> <span>0</span> connected\n54169c6085325e041c01812d88c0c4718d427989 <span>172.38</span>.0.15:6379@16379 master - <span>0</span> <span>1613884572910</span> <span>7</span> connected <span>0</span>-5460\n312454ec0845792a27650f1e237fc8be29d73f52 <span>172.38</span>.0.12:6379@16379 slave f2f92641a484bc2e84a72a7aaeef68d713b1defc <span>0</span> <span>1613884571000</span> <span>8</span> connected\nf288476630bd43910dff617591ac1521e06f9b72 <span>172.38</span>.0.17:6379@16379 master - <span>0</span> <span>1613884572409</span> <span>0</span> connected\n2dd15c79a6850e19be1cf503731b21b75c618242 <span>172.38</span>.0.11:6379@16379 slave 54169c6085325e041c01812d88c0c4718d427989 <span>0</span> <span>1613884572000</span> <span>7</span> connected\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>发现已经更改</p>\n<h3 id=\"_13-11-删除节点\"> 13.11 删除节点</h3>\n<div><pre><code><span>192.168</span>.30.130:700<span><span>8</span>></span> CLUSTER FORGET 1a1c7f02fce87530bd5abdfc98df1cffce4f1767\n<span>(</span>error<span>)</span> ERR I tried hard but I can<span>'t forget myself...               #无法删除登录节点\n\n192.168.30.130:7008> CLUSTER FORGET e51ab166bc0f33026887bcf8eba0dff3d5b0bf14\n(error) ERR Can'</span>t forget my master<span>!</span>                 <span>#不能删除自己的master节点</span>\n\n<span>192.168</span>.30.130:700<span><span>8</span>></span> CLUSTER FORGET 6788453ee9a8d7f72b1d45a9093838efd0e501f1\nOK              <span>#可以删除其它的master节点</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id=\"_13-10-其他集群操作\"> 13.10 其他集群操作</h3>\n<div><pre><code><span>172.38</span>.0.18:637<span><span>9</span>></span> cluster <span>help</span>\n <span>1</span><span>)</span> CLUSTER <span>&lt;</span>subcommand<span>></span> arg arg <span>..</span>. arg. Subcommands are:\n <span>2</span><span>)</span> ADDSLOTS <span>&lt;</span>slot<span>></span> <span>[</span>slot <span>..</span>.<span>]</span> -- Assign slots to current node.\n <span>3</span><span>)</span> BUMPEPOCH -- Advance the cluster config epoch.\n <span>4</span><span>)</span> COUNT-failure-reports <span>&lt;</span>node-id<span>></span> -- Return number of failure reports <span>for</span> <span>&lt;</span>node-id<span>></span>.\n <span>5</span><span>)</span> COUNTKEYSINSLOT <span>&lt;</span>slot<span>></span> - Return the number of keys <span>in</span> <span>&lt;</span>slot<span>></span>.\n <span>6</span><span>)</span> DELSLOTS <span>&lt;</span>slot<span>></span> <span>[</span>slot <span>..</span>.<span>]</span> -- Delete slots information from current node.\n <span>7</span><span>)</span> FAILOVER <span>[</span>force<span>|</span>takeover<span>]</span> -- Promote current replica <span>node</span> to being a master.\n <span>8</span><span>)</span> FORGET <span>&lt;</span>node-id<span>></span> -- Remove a <span>node</span> from the cluster.\n <span>9</span><span>)</span> GETKEYSINSLOT <span>&lt;</span>slot<span>></span> <span>&lt;</span>count<span>></span> -- Return key names stored by current <span>node</span> <span>in</span> a slot.\n<span>10</span><span>)</span> FLUSHSLOTS -- Delete current <span>node</span> own slots information.\n<span>11</span><span>)</span> INFO - Return information about the cluster.\n<span>12</span><span>)</span> KEYSLOT <span>&lt;</span>key<span>></span> -- Return the <span>hash</span> slot <span>for</span> <span>&lt;</span>key<span>></span>.\n<span>13</span><span>)</span> MEET <span>&lt;</span>ip<span>></span> <span>&lt;</span>port<span>></span> <span>[</span>bus-port<span>]</span> -- Connect nodes into a working cluster.\n<span>14</span><span>)</span> MYID -- Return the <span>node</span> id.\n<span>15</span><span>)</span> NODES -- Return cluster configuration seen by node. Output format:\n<span>16</span><span>)</span>     <span>&lt;</span>id<span>></span> <span>&lt;</span>ip:port<span>></span> <span>&lt;</span>flags<span>></span> <span>&lt;</span>master<span>></span> <span>&lt;</span>pings<span>></span> <span>&lt;</span>pongs<span>></span> <span>&lt;</span>epoch<span>></span> <span>&lt;</span>link<span>></span> <span>&lt;</span>slot<span>></span> <span>..</span>. <span>&lt;</span>slot<span>></span>\n<span>17</span><span>)</span> REPLICATE <span>&lt;</span>node-id<span>></span> -- Configure current <span>node</span> as replica to <span>&lt;</span>node-id<span>></span>.\n<span>18</span><span>)</span> RESET <span>[</span>hard<span>|</span>soft<span>]</span> -- Reset current <span>node</span> <span>(</span>default: soft<span>)</span>.\n<span>19</span><span>)</span> SET-config-epoch <span>&lt;</span>epoch<span>></span> - Set config epoch of current node.\n<span>20</span><span>)</span> SETSLOT <span>&lt;</span>slot<span>></span> <span>(</span>importing<span>|</span>migrating<span>|</span>stable<span>|</span><span>node</span> <span>&lt;</span>node-id<span>></span><span>)</span> -- Set slot state.\n<span>21</span><span>)</span> REPLICAS <span>&lt;</span>node-id<span>></span> -- Return <span>&lt;</span>node-id<span>></span> replicas.\n<span>22</span><span>)</span> SAVECONFIG - Force saving cluster configuration on disk.\n<span>23</span><span>)</span> SLOTS -- Return information about slots range mappings. Each range is made of:\n<span>24</span><span>)</span>     start, end, master and replicas IP addresses, ports and ids\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div>",
      "date_published": "2020-11-21T15:17:13.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": []
    },
    {
      "title": "Redis应用场景",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/database/redis/Redis_scene/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/database/redis/Redis_scene/",
      "content_html": "<h2 id=\"单点登录-sso\"> 单点登录（SSO）</h2>\n<h3 id=\"参考\"> 参考</h3>\n<div><p>参考</p>\n<ul>\n<li>https://blog.csdn.net/qq_32534441/article/details/90264485</li>\n</ul>\n</div>\n<h2 id=\"redis监听过期队列\"> Redis监听过期队列</h2>\n<p>适用于订单支付超时等场景</p>\n<h3 id=\"参考-2\"> 参考</h3>\n<div><p>参考</p>\n<ul>\n<li><a href=\"https://www.cnblogs.com/fkxuexi/p/10674038.html\" target=\"_blank\" rel=\"noopener noreferrer\">redis 高级功能，过期事件监听</a></li>\n<li><a href=\"https://blog.csdn.net/weixin_37703281/article/details/93358734\" target=\"_blank\" rel=\"noopener noreferrer\">springboot+redisTemplate实现消息队列(pub/sub,list,监听键过期)</a></li>\n<li><a href=\"https://www.cnblogs.com/yuluoxingkong/p/10475355.html\" target=\"_blank\" rel=\"noopener noreferrer\">如何利用redis key过期事件实现过期提醒</a></li>\n</ul>\n</div>\n<h2 id=\"redis实现高并发秒杀系统\"> Redis实现高并发秒杀系统</h2>\n<h3 id=\"参考-3\"> 参考</h3>\n<div><p>参考</p>\n</div>\n",
      "date_published": "2021-05-20T11:19:16.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": []
    },
    {
      "title": "Redis理论学习笔记",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/database/redis/Redis_theory_note/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/database/redis/Redis_theory_note/",
      "content_html": "<h2 id=\"_1-参考\"> 1. 参考</h2>\n<blockquote>\n<ul>\n<li><a href=\"http://doc.redisfans.com/\" target=\"_blank\" rel=\"noopener noreferrer\">Redis 命令参考 — Redis 命令参考 (redisfans.com)</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247484858&amp;idx=1&amp;sn=8e222ea6115e0b69cac91af14d2caf36&amp;chksm=cea24a71f9d5c367148dccec3d5ddecf5ecd8ea096b5c5ec32f22080e66ac3c343e99151c9e0&amp;token=1082669959&amp;lang=zh_CN&amp;scene=21#wechat_redirect\" target=\"_blank\" rel=\"noopener noreferrer\">redis 总结——重构版</a></li>\n<li>https://www.cnblogs.com/jasontec/p/9699242.html</li>\n<li>https://github.com/Snailclimb/JavaGuide</li>\n<li><a href=\"http://redisdoc.com/\" target=\"_blank\" rel=\"noopener noreferrer\">Redis中文文档</a></li>\n<li><a href=\"https://www.bilibili.com/video/BV1S54y1R7SB\" target=\"_blank\" rel=\"noopener noreferrer\">【狂神说Java】Redis最新超详细版教程通俗易懂</a></li>\n</ul>\n</blockquote>\n<h2 id=\"_2-简介\"> 2. 简介</h2>\n<p>Redis的全称是<code>Remote Dictionary Server</code>，即<code>远程字典服务</code>。官方原话如下：</p>\n<p>Redis是一个开源(BSD许可)的,内存中的数据结构存储系统,它可以用作<code>数据库</code>、<code>缓存</code>和<code>消息中间件MQ</code>。它支持多种类型的数据结构,如字符串( strings),散列( hashes),列表( lists),集合(sets),有序集合( sorted sets)与范围查询,bitmaps, hyperloglogs和地理空间( geospatial)索引半径查询。 Redis内置了复制( replication),LUA脚本(Luascripting),LRU驱动事件( LRU eviction),事务( transactions)和不同级别的磁盘持久化( persistence),并通过Reds哨兵( Sentinel)和自动分区( Cluster)提供高可用性( high availability)。</p>\n<h3 id=\"_2-1-优点\"> 2.1 优点</h3>\n<p>因为是<code>纯内存</code>操作, Redis的性能非常出色,每秒可以处理超过<code>10万次读写操作</code>是已知性能最快的<code>Key- Value DB</code>。Redis的出色之处不仅仅是性能, Redis最大的魅力是支持保存<code>多种数据结构</code>,此外<code>单个value</code>的最大限制是<code>1GB</code>,不像 <code>memcached</code>只能保存<code>1MB</code>的数据,因此 Redis可以用来实现很多有用的功能。比方说用他的<code>Lst</code>来做<code>FIFO双向链表</code>,实现一个轻量级的高性能消息队列服务用他的Set可以做高性能的tag系统等等另外 Redis也可以对存入的<code>Key-Vaue</code>设置<code>expire</code>时间,因此也可以被当作一个功能加强版的 memcached来用。</p>\n<h3 id=\"_2-2-缺点\"> 2.2 缺点</h3>\n<p>Redis的主要缺点是<code>数据库容量</code>受到<code>物理内存</code>的限制,不能用作<code>海量数据的高性能读写</code>,因此 Redis适合的场景主要局限在较小数据量的高性能操作和运算上。</p>\n<p>简单来说 redis 就是⼀个数据库，不过与传统数据库不同的是 redis 的数据是存在内存中的，所以读 写速度⾮常快，因此 redis 被⼴泛应⽤于缓存⽅向。另外，redis 也经常⽤来做<code>分布式锁</code>。redis 提 供了多种数据类型来⽀持不同的业务场景。除此之外，redis ⽀持事务 、持久化、LUA脚本、LRU驱动 事件、多种集群⽅案。</p>\n<h2 id=\"_3-为什么要用-redis-为什么要用缓存\"> 3. 为什么要用 redis /为什么要用缓存</h2>\n<p>主要从“<code>高性能</code>”和“<code>高并发</code>”这两点来看待这个问题。</p>\n<h3 id=\"_3-1-高性能\"> 3.1 高性能</h3>\n<p>假如用户第一次访问数据库中的某些数据。这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的数据存在数缓存中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可！</p>\n<p><img src=\"./images/Redis_theory_note/Why_use_redis_high-performance.jpg\" alt=\"为什么使用redis-高性能\" /></p>\n<h3 id=\"_3-2-高并发\"> 3.2 高并发</h3>\n<p>直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。</p>\n<p><img src=\"./images/Redis_theory_note/Why_use_redis_high-concurrency.jpg\" alt=\"为什么使用redis-高并发\" /></p>\n<h3 id=\"_3-3-为什么要用-redis-而不用-map-guava-做缓存\"> 3.3 为什么要⽤ redis ⽽不⽤ map/guava 做缓存?</h3>\n<p>缓存分为本地缓存和分布式缓存。以 Java 为例，使⽤⾃带的 map 或者 guava 实现的是本地缓存，最主要的特点是轻量以及快速，⽣命周期随着 jvm 的销毁⽽结束，并且在多实例的情况下，每个实例都 需要各⾃保存⼀份缓存，缓存不具有⼀致性。 使⽤ redis 或 memcached 之类的称为分布式缓存，在多实例的情况下，各实例共⽤⼀份缓存数据，缓 存具有⼀致性。缺点是需要保持 redis 或 memcached服务的⾼可⽤，整个程序架构上较为复杂。</p>\n<h2 id=\"_4-redis-的线程模型\"> 4. redis 的线程模型</h2>\n<p>参考</p>\n<blockquote>\n<ul>\n<li>https://blog.csdn.net/m0_37524661/article/details/87086267</li>\n<li>https://baijiahao.baidu.com/s?id=1666100733546359034&amp;wfr=spider&amp;for=pc</li>\n</ul>\n</blockquote>\n<p><img src=\"./images/Redis_theory_note/Redis_thread_model.png\" alt=\"Redis线程模型\" /></p>\n<h3 id=\"_4-1-redis单线程模型指的是什么\"> 4.1 redis单线程模型指的是什么</h3>\n<p>Redis基于<code>Reactor</code>模式开发了网络事件处理器，这个处理器被称为<code>文件事件处理器</code>。它的组成结构为4部分：</p>\n<blockquote>\n<ul>\n<li>\n<p>多个套接字</p>\n</li>\n<li>\n<p>IO多路复用程序</p>\n</li>\n<li>\n<p>文件事件分派器</p>\n</li>\n<li>\n<p>事件处理器</p>\n</li>\n</ul>\n</blockquote>\n<p>redis 内部使⽤⽂件事件处理器 <code>file event handler</code> ，这个<code>⽂件事件处理器</code>是<code>单线程</code>的，所以 redis 才叫做<code>单线程模型</code>。它采⽤ <code>IO 多路复⽤机</code>制同时监听多个 <code>socket</code>，根据 <code>socket</code> 上的事件 来选择对应的事件处理器进⾏处理</p>\n<p>Redis客户端对服务端的每次调用都经历了<code>发送命令</code>，<code>执行命令</code>，<code>返回结果</code>三个过程。其中执行命令阶段，由于Redis是<code>单线程</code>来处理命令的，所有每一条到达服务端的命令不会立刻执行，所有的命令都会进入一个队列中，然后逐个被执行。并且多个客户端发送的命令的执行<code>顺序是不确定</code>的。但是可以确定的是不会有两条命令被同时执行，不会产生并发问题，这就是Redis的单线程基本模型。</p>\n<blockquote>\n<p>目前redis的网络处理方面时多线程，但是核心模块方面还是单线程</p>\n</blockquote>\n<h3 id=\"_4-2-redis是单线程模型为什么效率还这么高\"> 4.2 redis是单线程模型为什么效率还这么高？</h3>\n<blockquote>\n<ol>\n<li><strong>纯内存访问</strong>：数据存放在内存中，内存的响应时间大约是100纳秒，这是Redis每秒万亿级别访问的重要基础。</li>\n<li><strong>非阻塞I/O</strong>：Redis采用epoll做为I/O多路复用技术的实现，再加上Redis自身的事件处理模型将epoll中的连接，读写，关闭都转换为了时间，不在I/O上浪费过多的时间。</li>\n<li>单线程避免了线程切换和竞态产生的消耗。</li>\n<li>Redis采用单线程模型，每条命令执行如果占用大量时间，会造成其他线程阻塞，对于Redis这种高性能服务是致命的，所以Redis是面向高速执行的数据库</li>\n</ol>\n</blockquote>\n<h3 id=\"_4-3-rector模式简介\"> 4.3 rector模式简介</h3>\n<p>参考</p>\n<blockquote>\n<ul>\n<li>https://www.cnblogs.com/crazymakercircle/p/9833847.html</li>\n</ul>\n</blockquote>\n<h3 id=\"_4-4-为什么网络处理要引入多线程\"> 4.4 为什么网络处理要引入多线程？</h3>\n<p>之前的段落说了，Redis 的瓶颈并不在 CPU，而在<code>内存</code>和<code>网络I/O</code>。</p>\n<p>内存不够的话，可以加内存或者做数据结构优化和其他优化等，但网络的性能优化才是大头，网络 IO 的读写在 Redis 整个执行期间占用了大部分的 CPU 时间，如果把网络处理这部分做成多线程处理方式，那对整个 Redis 的性能会有很大的提升。</p>\n<p><img src=\"./images/Redis_theory_note/Redis_single_multi-threaded_GET_performance_comparison.jpg\" alt=\"redis单多线程GET性能对比\" /></p>\n<p><img src=\"./images/Redis_theory_note/Redis_single_multi-threaded_SET_performance_comparison.jpg\" alt=\"redis单多线程SET性能对比\" /></p>\n<h2 id=\"_5-常⻅数据结构以及使用场景分析\"> 5.常⻅数据结构以及使⽤场景分析</h2>\n<table>\n<thead>\n<tr>\n<th>数据结构</th>\n<th>常用命令</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>String</td>\n<td>set,get,decr,incr,mget</td>\n</tr>\n<tr>\n<td>Hash</td>\n<td>hget,hset,hgetall</td>\n</tr>\n<tr>\n<td>List</td>\n<td>lpush,rpush,lpop,rpop,lrange</td>\n</tr>\n<tr>\n<td>Set</td>\n<td>sadd,spop,smembers,sunion</td>\n</tr>\n<tr>\n<td>ZSet（Sorted Set）</td>\n<td>zadd,zrange,zrem,zcard</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"_5-1-string\"> 5.1 String</h3>\n<blockquote>\n<p>常⽤命令: set,get,decr,incr,mget 等。</p>\n</blockquote>\n<p>String数据结构是简单的key-value类型，value其实不仅可以是String，也可以是数字。 常规keyvalue缓存应⽤； 常规计数：微博数，粉丝数等。</p>\n<p>string类型是二进制安全的。意思是redis的string可以包含任何数据。比如jpg图片或者序列化的对象 。</p>\n<h3 id=\"_5-2-hash\"> 5.2 Hash</h3>\n<blockquote>\n<p>常⽤命令： hget,hset,hgetall 等。</p>\n</blockquote>\n<p>hash 是⼀个 string 类型的 <code>field</code> 和 <code>value</code> 的映射表，hash 特别适合⽤于存储对象，后续操作的时 候，你可以直接仅仅修改这个对象中的某个字段的值。 ⽐如我们可以 hash 数据结构来存储⽤户信 息，商品信息等等。⽐如下⾯我就⽤ hash 类型存放了我本⼈的⼀些信息：</p>\n<div><pre><code>key=JavaUser293847\nvalue=<span>{</span>\n “id”<span>:</span> <span>1</span><span>,</span>\n “name”<span>:</span> “SnailClimb”<span>,</span>\n “age”<span>:</span> <span>22</span><span>,</span>\n “location”<span>:</span> “Wuhan<span>,</span> Hubei”\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id=\"_5-3-list\"> 5.3 List</h3>\n<blockquote>\n<p>常⽤命令: lpush,rpush,lpop,rpop,lrange等</p>\n</blockquote>\n<p>Redis list 的实现为⼀个<code>双向链表</code>。Redis list 的应⽤场景⾮常多，也是Redis最重要的数据结构之⼀，⽐如微博的关注 列表，粉丝列表，消息列表等功能都可以⽤Redis的 list 结构来实现。 Redis list 的实现为⼀个双向链表，即可以⽀持反向查找和遍历，更⽅便操作，不过带来了部分额外 的内存开销。 另外可以通过 lrange 命令，就是从某个元素开始读取多少个元素，可以基于 list 实现分⻚查询，这 个很棒的⼀个功能，基于 redis 实现简单的⾼性能分⻚，可以做类似微博那种下拉不断分⻚的东⻄ （⼀⻚⼀⻚的往下⾛），性能⾼。</p>\n<p>在 key 对应 list 的头部添加字符串元素</p>\n<div><pre><code>lpush name value\n</code></pre>\n<div><span>1</span><br></div></div><p>在 key 对应 list 的尾部添加字符串元素</p>\n<div><pre><code>rpush name value\n</code></pre>\n<div><span>1</span><br></div></div><p>key 对应 list 中删除 count 个和 value 相同的元素</p>\n<div><pre><code>lrem name index\n</code></pre>\n<div><span>1</span><br></div></div><p>返回 key 对应 list 的长度</p>\n<div><pre><code>llen name \n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"_5-4-set\"> 5.4 Set</h3>\n<blockquote>\n<p>常⽤命令： sadd,spop,smembers,sunion 等</p>\n</blockquote>\n<p>set 对外提供的功能与list类似是⼀个列表的功能，特殊之处在于 set 是可以⾃动排重的。 当你需要存储⼀个列表数据，⼜不希望出现重复数据时，set是⼀个很好的选择，并且set提供了判断某 个成员是否在⼀个set集合内的重要接⼝，这个也是list所不能提供的。可以基于 set 轻易实现交集、 并集、差集的操作。 ⽐如：在微博应⽤中，可以将⼀个⽤户所有的关注⼈存在⼀个集合中，将其所有粉丝存在⼀个集合。 Redis可以⾮常⽅便的实现如共同关注、共同粉丝、共同喜好等功能。这个过程也就是求交集的过程， 具体命令如下：</p>\n<div><pre><code>sinterstore key1 key2 key3 将交集存在key1内\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"_5-5-zset-sorted-set\"> 5.5 ZSet（Sorted Set）</h3>\n<blockquote>\n<p>常⽤命令： zadd,zrange,zrem,zcard等</p>\n</blockquote>\n<p>和set相⽐，sorted set增加了⼀个权重参数score，使得集合中的元素能够按score进⾏有序排列。 举例： 在直播系统中，实时排⾏信息包含直播间在线⽤户列表，各种礼物排⾏榜，弹幕消息（可以理 解为按消息维度的消息排⾏榜）等信息，适合使⽤ Redis 中的 Sorted Set 结构进⾏存储。</p>\n<h3 id=\"_5-6-hyperloglog\"> 5.6 HyperLogLog</h3>\n<h3 id=\"_5-7-bitmap\"> 5.7 Bitmap</h3>\n<p>;:: tips 参考</p>\n<ul>\n<li>https://www.jianshu.com/p/4c8e119f35db</li>\n<li>https://blog.csdn.net/u011957758/article/details/74783347</li>\n</ul>\n<p>:::</p>\n<h3 id=\"_5-8-底层数据结构-重要\"> 5.8 底层数据结构（重要）</h3>\n<p>::: tips 参考</p>\n<ul>\n<li>https://www.cnblogs.com/ysocean/p/9080942.html</li>\n</ul>\n<p>:::</p>\n<h2 id=\"_6-redis过期时间\"> 6. Redis过期时间</h2>\n<p>Redis中有个设置时间过期的功能，即对存储在 redis 数据库中的值可以设置⼀个过期时间。作为⼀个 缓存数据库，这是⾮常实⽤的。如我们⼀般项⽬中的 token 或者⼀些登录信息，尤其是短信验证码都 是有时间限制的，按照传统的数据库处理⽅式，⼀般都是⾃⼰判断过期，这样⽆疑会严重影响项⽬性 能。</p>\n<p>我们 set key 的时候，都可以给⼀个 <code>expire time</code>，就是过期时间，通过过期时间我们可以指定这个 key 可以存活的时间。 也可以在运行时给存在的键设置剩余的生存时间，不设置则默认为<code>-1</code>，设置为-1时表示<code>永久存储</code>。</p>\n<p>如果假设你创建一个 <code>Timer</code>，设置了⼀批 key 只能存活1个⼩时，那么接下来1⼩时后，redis是怎么对这批key进⾏删除 的？</p>\n<blockquote>\n<ul>\n<li><strong>定期删除</strong>：redis默认是每隔 <code>100ms</code> 就随机抽取⼀些设置了过期时间的key，检查其是否过期， 如果过期就删除。注意这⾥是随机抽取的。为什么要随机呢？你想⼀想假如 redis 存了⼏⼗万 个 key ，每隔100ms就遍历所有的设置过期时间的 key 的话，这时候需要的是Cpu处理能力，而不是内存，就会给 CPU 带来很⼤的负载！</li>\n<li><strong>惰性删除</strong> ：定期删除可能会导致很多过期 key 到了时间并没有被删除掉。所以就有了惰性删除。假如你的过期 key，靠定期删除没有被删除掉，还停留在内存⾥，除⾮你的系统去查⼀下那 个 key，才会被redis给删除掉。这就是所谓的惰性删除，也是够懒的哈！ 但是仅仅通过设置过期时间还是有问题的。</li>\n</ul>\n</blockquote>\n<p>但是仅仅通过设置过期时间还是有问题的。我们想⼀下：如果定期删除漏掉了很多过期 key，然后你也 没及时去查，也就没⾛惰性删除，此时会怎么样？如果⼤量过期key堆积在内存⾥，导致redis内存块耗 尽了。怎么解决这个问题呢？ redis 内存淘汰机制。</p>\n<h2 id=\"_7-redis内存淘汰机制\"> 7. Redis内存淘汰机制</h2>\n<p>参考</p>\n<blockquote>\n<ul>\n<li>https://blog.csdn.net/weixin_43184769/article/details/90523923</li>\n<li>https://blog.csdn.net/qq_28018283/article/details/80764518</li>\n<li>配置文件： http://download.redis.io/redis-stable/redis.conf</li>\n</ul>\n</blockquote>\n<p>思考一下，如果定期删除漏掉了很多过期的key，而我们也没有再去访问它，如果不加处理，很可能导致内存耗尽。</p>\n<p>什么时候触发</p>\n<p>Redis配置文件中可以设置<code>maxmemory</code>，内存的最大使用量，到达限度时会执行<code>内存淘汰机制</code></p>\n<h3 id=\"_7-1-内存置换策略\"> 7.1 内存置换策略</h3>\n<p>没有配置时，<code>默认为no-eviction</code></p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>volatile-lru</td>\n<td>从<code>已设置过期时间的数据集</code>中挑选<code>最近最少使用</code>的数据淘汰</td>\n</tr>\n<tr>\n<td>volatile-lfu（4.0版本）</td>\n<td>从<code>已设置过期时间的数据集</code>中挑选<code>最不经常</code>使用的数据淘汰</td>\n</tr>\n<tr>\n<td>volatile-ttl</td>\n<td>从<code>已设置过期时间的数据集</code>中挑选<code>将要过期</code>的数据淘汰</td>\n</tr>\n<tr>\n<td>volatile-random</td>\n<td>从<code>已设置过期时间的数据集</code>中挑选<code>任意数据</code>淘汰</td>\n</tr>\n<tr>\n<td>allkeys-lru</td>\n<td>当<code>内存不足</code>写入新数据时淘汰<code>最近最少</code>使用的Key</td>\n</tr>\n<tr>\n<td>allkeys-random</td>\n<td>当<code>内存不足</code>写入新数据时<code>随机选择</code>key淘汰</td>\n</tr>\n<tr>\n<td>allkeys-lfu（4.0版本）</td>\n<td>当<code>内存不足</code>写入新数据时移除<code>最不经常使用</code>的Key</td>\n</tr>\n<tr>\n<td>no-eviction（禁止驱逐数据）</td>\n<td>当<code>内存不足</code>写入新数据时，写入操作会报错，同时不删除数据</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<ul>\n<li>volatile为前缀的策略都是从已过期的数据集中进行淘汰。</li>\n<li>allkeys为前缀的策略都是面向所有key进行淘汰。</li>\n<li>LRU（least recently used）最少最近用到的。</li>\n<li>LFU（Least Frequently Used）最不常用的。</li>\n<li>TTL（Time To Live）</li>\n<li>它们的触发条件都是Redis使用的内存达到阈值时。</li>\n</ul>\n</blockquote>\n<h3 id=\"_7-2-淘汰机制的实现\"> 7.2 淘汰机制的实现</h3>\n<p>既然是淘汰，那就需要把这些数据给删除，然后保存新的。Redis 删除失效主键的方法主要有两种：</p>\n<h4 id=\"消极方法-passive-way\"> 消极方法( passive way)</h4>\n<p>在主键被访问时如果发现它已经失效,那么就删除它。 redis在实现<code>GET</code>、<code>MGET</code>、<code>HGET</code>、 LRANGE等所有涉及到读取数据的命令时都会调<code>expirelfNeeded</code>,它存在的意义就是在读取数据之前先检查一下它有没有失效,如果失效了就删除</p>\n<p><code>expirelfNeeded</code>函数中调用的另外一个函数 <code>propagateExpire</code>,这个函数用来在正式删除<code>失效主键</code>,并且<code>广播</code>告诉其他地方,目的地有俩</p>\n<blockquote>\n<ul>\n<li><code>AOF</code>文件,将删除失效主键的这一操作以 DEL Key的标准命令格式记录下来</li>\n<li>另一个就是发送到当前 Redis服务器的所有 <code>Slave</code>,同样将删除失效主键的这操作以 <code>DEL Key</code>的标准命令格式告知这些<code>Slave</code>删除各自的失效主键</li>\n</ul>\n</blockquote>\n<h4 id=\"积极方法-active-way\"> 积极方法( active way)</h4>\n<p>周期性地探测,发现失效就删除。消极方法的缺点是,如果keγ迟迟不被访问,就会占用很多内存空间,所以才有积极方式</p>\n<h4 id=\"主动删除\"> 主动删除</h4>\n<p>当內存超过 <code>maxmemoryl</code>限定时,触发主动清理策略,该策略由启动参数的配置决定</p>\n<h2 id=\"_8-redis持久化机制\"> 8. Redis持久化机制</h2>\n<blockquote>\n<p>怎么保证 redis 挂掉之后再重启数据可以进⾏恢复</p>\n</blockquote>\n<p>参考</p>\n<blockquote>\n<ul>\n<li>https://baijiahao.baidu.com/s?id=1654694618189745916&amp;wfr=spider&amp;for=pc</li>\n</ul>\n</blockquote>\n<p>很多时候我们需要持久化数据也就是将内存中的数据写⼊到硬盘⾥⾯，⼤部分原因是为了之后重⽤数据 （⽐如重启机器、机器故障之后恢复数据），或者是为了防⽌系统故障⽽将数据备份到⼀个远程位置。 Redis不同于Memcached的很重⼀点就是，Redis⽀持<code>持久化</code>，⽽且⽀持两种不同的持久化操作。当<code>RDB</code>和<code>AOF</code>文件都存在时，会优先根据<code>AOF</code>文件恢复</p>\n<blockquote>\n<ul>\n<li>RDB（Redis DataBase 快照）</li>\n<li>AOF（Append Only File）</li>\n</ul>\n</blockquote>\n<h3 id=\"_8-1-rdb-redis-database-快照\"> 8.1 RDB（Redis DataBase 快照）</h3>\n<p>Redis可以通过创建快照来获得存储在内存⾥⾯的数据在某个时间点上的副本。Redis创建快照之后，可 以对快照进⾏备份，可以将快照复制到其他服务器从⽽创建具有相同数据的服务器副本（Redis主从结 构，主要⽤来提⾼Redis性能），还可以将快照留在原地以便重启服务器的时候使⽤。</p>\n<p>优点</p>\n<blockquote>\n<ul>\n<li>RDB文件紧凑，全量备份，非常适合用于进行备份和灾难恢复。</li>\n<li>在使用bgsave生成RDB文件的时候，redis主进程会fork()一个子进程来处理所有保存工作，主进程不需要进行任何磁盘IO操作。</li>\n<li>RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。</li>\n</ul>\n</blockquote>\n<p>缺点</p>\n<blockquote>\n<ul>\n<li>RDB快照是一次<code>全量备份</code>，存储的是内存数据的<code>二进制序列化</code>形式，存储上非常紧凑。当进行快照持久化时，会开启一个子进程专门负责快照持久化，子进程会拥有父进程的<code>内存数据</code>，父进程修改内存子进程<code>不会反应</code>出来，所以在<code>快照持久化期间修改的数据不会被保存</code>，可能丢失数据。</li>\n</ul>\n</blockquote>\n<p>快照持久化是Redis<code>默认采⽤</code>的持久化⽅式,触发方式如下：</p>\n<blockquote>\n<ul>\n<li>save</li>\n<li>bgsave</li>\n<li>自动化</li>\n</ul>\n</blockquote>\n<h4 id=\"触发方式-save\"> 触发方式：save</h4>\n<p>该命令会阻塞当前Redis服务器，执行save命令期间，Redis不能处理其他命令，直到RDB过程完成为止。具体流程如下：</p>\n<p><img src=\"./images/Redis_theory_note/save_trigger_mode.jpg\" alt=\"save触发方式\" /></p>\n<p>执行完成时候如果存在老的<code>RDB</code>文件，就把新的替代掉旧的。我们的客户端可能都是几万或者是几十万，这种方式显然不可取。</p>\n<h4 id=\"触发方式-bgsave\"> 触发方式：bgsave</h4>\n<p>执行该命令时，Redis会在后台<code>异步</code>进行快照操作，快照同时还可以<code>响应客户端请求</code>。具体流程如下：</p>\n<p><img src=\"./images/Redis_theory_note/bgsave_trigger_mode.jpg\" alt=\"bgsave触发方式\" /></p>\n<p>具体操作是Redis进程执行<code>fork</code>操作<code>创建子进程</code>，RDB持久化过程由<code>子进程负责</code>，完成后自动结束。阻塞只发生在<code>fork</code>阶段，一般时间很短。基本上 Redis 内部所有的RDB操作都是采用 <code>bgsave</code> 命令。</p>\n<h4 id=\"触发方式-自动触发\"> 触发方式：自动触发</h4>\n<p>自动触发是由我们的配置文件来完成的。在<code>redis.conf</code>配置文件中，里面有如下配置，我们可以去设置：</p>\n<p><strong>①save</strong></p>\n<p>这里是用来配置触发 Redis的 <code>RDB</code> 持久化条件，也就是什么时候将内存中的数据保存到硬盘。比如“save m n”。表示m秒内数据集存在n次修改时，自动触发<code>bgsave</code>。</p>\n<p>默认如下配置：</p>\n<div><pre><code>save m n\n\n#在<span>900</span>秒<span>(</span><span>15</span>分钟<span>)</span>之后，如果⾄少有<span>1</span>个key发⽣变化，<span>Redis</span>就会⾃动触发BGSAVE命令创建快照。\nsave <span>900</span> <span>1</span> \n\n#在<span>300</span>秒<span>(</span><span>5</span>分钟<span>)</span>之后，如果⾄少有<span>10</span>个key发⽣变化，<span>Redis</span>就会⾃动触发BGSAVE命令创建快照。\nsave <span>300</span> <span>10</span> \n  \n#在<span>60</span>秒<span>(</span><span>1</span>分钟<span>)</span>之后，如果⾄少有<span>10000</span>个key发⽣变化，<span>Redis</span>就会⾃动触发BGSAVE命令创建快照。\nsave <span>60</span> <span>10000</span> \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><blockquote>\n<ul>\n<li><code>stop-writes-on-bgsave-error</code> ：默认值为yes。当启用了RDB且最后一次后台保存数据失败，Redis是否停止接收数据。这会让用户意识到数据没有正确持久化到磁盘上，否则没有人会注意到灾难（disaster）发生了。如果Redis重启了，那么又可以重新开始接收数据了</li>\n<li><code>rdbcompression</code> ；默认值是yes。对于存储到磁盘中的快照，可以设置是否进行压缩存储。</li>\n<li><code>rdbchecksum</code> ：默认值是yes。在存储快照后，我们还可以让redis使用CRC64算法来进行数据校验，但是这样做会增加大约10%的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能。</li>\n<li><code>dbfilename</code> ：设置快照的文件名，默认是 <code>dump.rdb</code></li>\n<li><code>dir</code>：设置快照文件的存放路径，这个配置项一定是个目录，而不能是文件名。</li>\n</ul>\n</blockquote>\n<h4 id=\"save和bgsave的区别\"> save和bgsave的区别</h4>\n<p><img src=\"./images/Redis_theory_note/The_difference_between_save_and_bgsave.jpg\" alt=\"save和bgsave的区别\" /></p>\n<h3 id=\"_8-2-aof-append-only-file\"> 8.2 AOF（Append Only File）</h3>\n<p>与<code>快照持久化</code>相⽐，<code>AOF持久化</code> 的<code>实时性</code>更好，因此已成为主流的持久化⽅案。默认情况下Redis没有 开启<code>AOF（append only file）</code>⽅式的持久化。</p>\n<p>可以通过<code>appendonly</code>参数开启：</p>\n<h4 id=\"持久化原理\"> 持久化原理</h4>\n<p><img src=\"./images/Redis_theory_note/AOF_running-principle&creation.jpg\" alt=\"AOF运行原理-创建\" /></p>\n<p>每当有一个<code>写而非读</code>命令过来时，就直接追加保存在我们的<code>AOF</code>文件中，AOF命令以Redis协议追加保存每次写的操作到文件末尾，Redis还能对AOF文件在后台重写，使得单个AOF文件不至于过大</p>\n<h4 id=\"文件重写原理\"> 文件重写原理</h4>\n<p>AOF的方式也同时带来了另一个问题。持久化文件会变的越来越大。为了压缩<code>AOF</code>的持久化文件。redis提供了<code>bgrewriteaof</code>命令。将内存中的数据以命令的方式保存到临时文件中，同时会<code>fork</code>出一条<code>新进程</code>来将文件重写。</p>\n<p><img src=\"./images/Redis_theory_note/Principle_of_bgrewriteaof_file_rewriting.jpg\" alt=\"bgrewriteaof文件重写原理\" /></p>\n<p>重写<code>AOF</code>文件的操作，并没有读取旧的<code>AOF</code>文件，而是将整个内存中的数据库内容用命令的方式重写了一个<code>新的AOF文件</code>，这点和<code>快照</code>有点类似。</p>\n<div><pre><code>appendonly yes\n</code></pre>\n<div><span>1</span><br></div></div><p>开启AOF持久化后每执⾏⼀条会更改Redis中的数据的命令，Redis就会将该命令通过<code>write</code>写⼊硬盘中的<code>AOF</code>⽂件，通俗的理解就是<code>日志记录</code>。 <code>AOF</code>⽂件的保存位置和<code>RDB</code>⽂件的位置相同，都是通过<code>dir</code>参数设置的，默认的⽂件名是 <code>appendonly.aof</code>。</p>\n<div><pre><code>appendfsync always #每次有数据修改发⽣时都会写⼊AOF⽂件<span>,</span>这样会严重降低<span>Redis</span>的速度\n  \nappendfsync everysec #每秒钟同步⼀次，显示地将多个写命令同步到硬盘\n  \nappendfsync no #让操作系统决定何时进⾏同步\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>为了兼顾数据和写⼊性能，⽤户可以考虑 <code>appendfsync everysec</code>选项 ，让Redis每秒同步⼀次AOF⽂ 件，Redis性能⼏乎没受到任何影响。⽽且这样即使出现系统崩溃，⽤户最多只会丢失⼀秒之内产⽣的 数据。当硬盘忙于执⾏写⼊操作的时候，Redis还会优雅的放慢⾃⼰的速度以便适应硬盘的最⼤写⼊速度。</p>\n<h4 id=\"修复aof文件\"> 修复AOF文件</h4>\n<p>可以根据文件<code>redis-check-aof</code>文件修复，它会把AOF文件中错误的命令删去，相关命令</p>\n<div><pre><code>redis-check-aof --fix appendonly.aof\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"_8-3-redis-4-0-对于持久化机制的优化\"> 8.3 Redis 4.0 对于持久化机制的优化</h3>\n<p>Redis 4.0 开始⽀持 <code>RDB</code> 和 <code>AOF</code> 的<code>混合持久化</code>（默认关闭，可以通过配置项开启）</p>\n<div><pre><code>aof-use-rdbpreamble <span>yes</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>如果把混合持久化打开，<code>AOF</code> 重写的时候就直接把 <code>RDB</code> 的内容写到 <code>AOF ⽂件开头</code>。这样做的好处是可 以结合 <code>RDB</code> 和 <code>AOF</code> 的优点, 快速加载同时避免丢失过多的数据。当然缺点也是有的， <code>AOF</code> ⾥⾯的 <code>RDB</code> 部分是压缩格式不再是 <code>AOF</code> 格式，可读性较差。</p>\n<p>通过这种，<code>Redis</code>会优先载入<code>AOF</code>文件，因为通常情况下<code>AOF</code>文件保存的数据要比<code>RDB</code>完整</p>\n<h2 id=\"_9-redis事务\"> 9. Redis事务</h2>\n<p>参考</p>\n<blockquote>\n<ul>\n<li>https://www.runoob.com/redis/redis-transactions.html</li>\n</ul>\n</blockquote>\n<p>Redis 通过 <code>MULTI</code>、<code>EXEC</code>、<code>WATCH</code> 等命令来实现<code>事务(transaction)</code>功能。Redis 事务的本质是一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。</p>\n<h3 id=\"_9-1-特点\"> 9.1 特点</h3>\n<blockquote>\n<ul>\n<li>Redis事务没有隔离级别的概念：批量操作在发送 <code>EXEC</code> 命令前被放入队列缓存，并不会被实际执行，也就不存在事务内的查询要看到事务里的更新，事务外查询不能看到。</li>\n<li>Redis事务不保证原子性：Redis中，<code>单条命令是原子性执行的</code>，但事务不保证<code>原子性</code>，且没有回滚。事务中任意命令执行失败，其余的命令仍会被执行。</li>\n<li>在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中。</li>\n</ul>\n</blockquote>\n<h3 id=\"_9-2-阶段\"> 9.2 阶段</h3>\n<blockquote>\n<ul>\n<li>开始事务。</li>\n<li>命令入队。</li>\n<li>执行事务。</li>\n</ul>\n</blockquote>\n<h3 id=\"_9-3-相关命令参考\"> 9.3 相关命令参考</h3>\n<blockquote>\n<ul>\n<li>https://www.runoob.com/redis/redis-transactions.html</li>\n</ul>\n</blockquote>\n<h2 id=\"_10-缓存雪崩-缓存穿透-缓存击穿\"> 10. 缓存雪崩 | 缓存穿透 | 缓存击穿</h2>\n<p>参考</p>\n<blockquote>\n<ul>\n<li>https://blog.csdn.net/fanrenxiang/article/details/80542580</li>\n<li>https://www.cnblogs.com/xichji/p/11286443.html</li>\n</ul>\n</blockquote>\n<blockquote>\n<ul>\n<li><strong>缓存穿透</strong>：key对应的数据在数据源并不存在，每次针对此key的请求从<code>缓存</code>获取不到，请求都会到<code>数据源</code>，从而可能<code>压垮数据源</code>。举个例⼦：某个⿊客故意制造我们缓存中不存在的 key 发起⼤量请求，导致⼤量请 求落到数据库，若黑客利用此漏洞进行攻击可能压垮数据库。</li>\n<li><strong>缓存击穿</strong>：是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个<code>key</code>在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，这个时候大并发的请求可能会瞬间把后端DB压垮，就像在一个屏障上凿开了一个洞。</li>\n<li><strong>缓存雪崩</strong>：当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，也会给后端系统(比如DB)带来很大压力，所以，后⾯的请求都会落到数据库上，造成数据库短时间内承受⼤量请求⽽崩掉。</li>\n</ul>\n</blockquote>\n<h3 id=\"_10-1-缓存穿透\"> 10.1 缓存穿透</h3>\n<p>缓存穿透说简单点就是⼤量请求的 key 根本不存在于缓存中，导致请求直接到了数据库上，根本没有 经过缓存这⼀层。举个例⼦：某个⿊客故意制造我们缓存中不存在的 key 发起⼤量请求，导致⼤量请 求落到数据库。</p>\n<h4 id=\"原理\"> 原理</h4>\n<p>正常缓存处理流程</p>\n<p><img src=\"./images/Redis_theory_note/Cache_processing_flow.jpg\" alt=\"缓存处理流程\" /></p>\n<p>缓存穿透处理流程</p>\n<p><img src=\"./images/Redis_theory_note/Cache_penetration_processing_flow.jpg\" alt=\"缓存穿透处理流程\" /></p>\n<h4 id=\"解决办法\"> 解决办法</h4>\n<p>一个一定不存在缓存及查询不到的数据，由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。</p>\n<p>最基本的就是⾸先做好<code>参数校验</code>，⼀些<code>不合法的参数</code>请求直接抛出异常信息返回给客户端。⽐如查询的 数据库 id 不能⼩于 0、传⼊的邮箱格式不对的时候直接返回错误消息给客户端等等。</p>\n<p>如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟</p>\n<div><pre><code><span>public</span> <span>Object</span> <span>getObjectInclNullById</span><span>(</span><span>Integer</span> id<span>)</span> <span>{</span>\n <span>// 从缓存中获取数据</span>\n <span>Object</span> cacheValue <span>=</span> cache<span>.</span><span>get</span><span>(</span>id<span>)</span><span>;</span>\n <span>// 缓存为空</span>\n <span>if</span> <span>(</span>cacheValue <span>==</span> <span>null</span><span>)</span> <span>{</span>\n <span>// 从数据库中获取</span>\n <span>Object</span> storageValue <span>=</span> storage<span>.</span><span>get</span><span>(</span>key<span>)</span><span>;</span>\n <span>// 缓存空对象</span>\n cache<span>.</span><span>set</span><span>(</span>key<span>,</span> storageValue<span>)</span><span>;</span>\n <span>// 如果存储数据为空，需要设置⼀个过期时间(300秒)</span>\n <span>if</span> <span>(</span>storageValue <span>==</span> <span>null</span><span>)</span> <span>{</span>\n <span>// 必须设置过期时间，否则有被攻击的⻛险</span>\n cache<span>.</span><span>expire</span><span>(</span>key<span>,</span> <span>60</span> <span>*</span> <span>5</span><span>)</span><span>;</span>\n <span>}</span>\n <span>return</span> storageValue<span>;</span>\n <span>}</span>\n <span>return</span> cacheValue<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h4 id=\"布隆过滤器-bloom-filter\"> 布隆过滤器（bloom filter）</h4>\n<p>参考</p>\n<blockquote>\n<ul>\n<li>https://github.com/Snailclimb/JavaGuide/blob/master/docs/dataStructures-algorithms/data-structure/bloom-filter.md</li>\n</ul>\n</blockquote>\n<p>布隆过滤器是⼀个⾮常神奇的数据结构，通过它我们可以⾮常⽅便地判断⼀个给定数 据是否存在与海量数据中。我们需要的就是判断 <code>key</code> 是否合法，有没有感觉布隆过滤器就是我们想要 找的那个“⼈”。具体是这样做的：把<code>所有可能存在的请求的值</code>都存放在布隆过滤器中，当⽤户请求过来，我会先判断⽤户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信 息给客户端，存在的话才会⾛下⾯的流程。</p>\n<p><img src=\"./images/Redis_theory_note/bloom-filter.jpg\" alt=\"布隆过滤器\" /></p>\n<h3 id=\"_10-2-缓存击穿\"> 10.2 缓存击穿</h3>\n<p>参考</p>\n<blockquote>\n<ul>\n<li>https://www.cnblogs.com/chengege/p/11073166.html</li>\n</ul>\n</blockquote>\n<p>key可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。这个时候，需要考虑一个问题：缓存被“击穿”的问题。</p>\n<h4 id=\"互斥锁-mutex-key\"> 互斥锁(mutex key)</h4>\n<p>业界比较常用的做法，是使用<code>mutex</code>。简单地来说，就是在缓存失效的时候（判断拿出来的值为空），不是立即去<code>load db</code>，而是先使用缓存工具的某些带成功操作返回值的操作（比如<code>Redis</code>的<code>SETNX</code>或者<code>Memcache</code>的<code>ADD</code>）去<code>set</code>一个<code>mutex key</code>，当操作返回成功时，再进行<code>load db</code>的操作并<code>回设缓存</code>；否则，就重试整个<code>get</code>缓存的方法。就是只让一个线程构建<code>缓存</code>，其他线程等待构建缓存的线程执行完，重新从缓存获取数据就可以了。</p>\n<p><img src=\"./images/Redis_theory_note/Cache-breakdown_mutex_key.png\" alt=\"缓存击穿-互斥锁mutex-key\" /></p>\n<h3 id=\"_10-3-缓存雪崩\"> 10.3 缓存雪崩</h3>\n<p>简介：缓存同⼀时间⼤⾯积的失效，所以，后⾯的请求都会落到数据库上，造成数据库短时间内承受⼤ 量请求⽽崩掉。</p>\n<blockquote>\n<ul>\n<li>事前：尽量保证整个 redis 集群的⾼可⽤性，发现机器宕机尽快补上。选择合适的内存淘汰策 略。</li>\n<li>事中：本地ehcache缓存 + hystrix限流&amp;降级，避免MySQL崩掉</li>\n<li>事后：利⽤ redis 持久化机制保存的数据尽快恢复缓存</li>\n</ul>\n</blockquote>\n<blockquote>\n<ul>\n<li>设置key永不失效（热点数据）；</li>\n<li>设置key缓存失效时候尽可能错开；</li>\n<li>使用多级缓存机制，比如同时使用redsi和memcache缓存，请求-&gt;redis-&gt;memcache-&gt;db；</li>\n<li>购买第三方可靠性高的Redis云服务器；</li>\n</ul>\n</blockquote>\n<p><img src=\"./images/Redis_theory_note/Cache_avalanche_solution.jpg\" alt=\"缓存雪崩解决方案\" /></p>\n<h2 id=\"_11-redis发布订阅\"> 11. Redis发布订阅</h2>\n<p>参考</p>\n<blockquote>\n<ul>\n<li><a href=\"https://redisbook.readthedocs.io/en/latest/feature/pubsub.html\" target=\"_blank\" rel=\"noopener noreferrer\">订阅与发布 — Redis 设计与实现 (redisbook.readthedocs.io)</a></li>\n</ul>\n</blockquote>\n<p>使用场景</p>\n<blockquote>\n<ul>\n<li>实时消息</li>\n<li>聊天室（既可以是发送者也可以是订阅者）</li>\n<li>订阅，关注推送</li>\n</ul>\n</blockquote>\n<h2 id=\"_12-redis集群\"> 12. Redis集群</h2>\n<p>参考</p>\n<blockquote>\n<ul>\n<li><a href=\"http://doc.redisfans.com/topic/cluster-tutorial.html#cluster-tutorial\" target=\"_blank\" rel=\"noopener noreferrer\">集群教程 — Redis 命令参考 (redisfans.com)</a></li>\n<li><a href=\"https://blog.csdn.net/miss1181248983/article/details/90056960\" target=\"_blank\" rel=\"noopener noreferrer\">Redis集群详解</a></li>\n</ul>\n</blockquote>\n<p>三种集群模式</p>\n<blockquote>\n<ul>\n<li>主从复制模式</li>\n<li>Sentinel（哨兵）模式</li>\n<li>Cluster（集群）模式</li>\n</ul>\n</blockquote>\n<h2 id=\"_13-redis集群-主从复制模式\"> 13. Redis集群-主从复制模式</h2>\n<p>参考</p>\n<blockquote>\n<ul>\n<li><a href=\"https://www.cnblogs.com/aflyun/p/8495561.html\" target=\"_blank\" rel=\"noopener noreferrer\">Redis集群主从复制（一主两从）搭建配置教程【Windows环境】 - 阿飞云 - 博客园 (cnblogs.com)</a></li>\n</ul>\n</blockquote>\n<p>为了使得集群在一部分节点下线或者无法与集群的大多数节点进行通讯的情况下， 仍然可以正常运作， Redis 集群对节点使用了主从复制功能： 集群中的每个节点都有 1 个至 N 个复制品（replica）， 其中一个复制品为主节点（master）， 而其余的 N-1 个复制品为从节点（slave）。[ <strong>摘自</strong> <a href=\"http://doc.redisfans.com/topic/cluster-tutorial.html#id4\" target=\"_blank\" rel=\"noopener noreferrer\">Redis 集群中的主从复制</a> ]</p>\n<p>那么上面是主从复制呢，简单的来说就是一个主节点master可以拥有一个甚至多个从节点的slave，而一个slave又可以拥有多个slave，如此下去，形成了强大的多级服务器集群架构。</p>\n<p><img src=\"./images/Redis_theory_note/master&slave.png\" alt=\"master&amp;slave\" /></p>\n<h3 id=\"_13-1-特点\"> 13.1 特点</h3>\n<blockquote>\n<ol>\n<li>一个<code>master</code>可以有多个<code>slave</code>，一个<code>slave</code>只能有一个<code>master</code></li>\n<li>除了多个<code>slave</code>连到相同的<code>master</code>外，<code>slave</code>也可以连接其他<code>slave</code>形成图状结构</li>\n<li>主从复制<code>不会阻塞master</code>。也就是说当一个或多个slave与master进行初次同步数据时，master可以继续处理client发来的请求。相反slave在初次同步数据时则会阻塞不能处理client的请求。</li>\n<li>主数据库<code>master</code>对外一般用来<code>写</code>，而从数据库<code>slave</code>对外一般都是<code>只读</code>的，只有接收主数据库同步过来的数据才会<code>写</code>。</li>\n<li>可以在<code>master</code>禁用数据持久化，只需要注释掉<code>master</code> 配置文件中的所有<code>save</code>配置，然后只在<code>slave</code>上配置数据持久化。</li>\n<li><code>slave</code>挂了不影响其他<code>slave</code>的读和<code>master</code>的读和写，重新启动后会将数据从<code>master</code>同步过来，<code>master</code>挂了以后，不影响<code>slave</code>的读，但redis不再提供写服务，<code>master</code>重启后<code>redis</code>将重新对外提供写服务</li>\n<li><code>master</code>挂了以后，不会在<code>slave</code>节点中重新选一个<code>master</code></li>\n</ol>\n</blockquote>\n<h3 id=\"_13-2-作用\"> 13.2 作用</h3>\n<blockquote>\n<ol>\n<li><mark>数据冗余</mark>：主从复制实现了数据的热备份,是<code>持久化</code>之外的一种数据冗余方式。</li>\n<li><mark>故障恢复</mark>：当主节点出现问题时,可以由从节点提供服务,实现快速的故障恢复，实际上是一种服务的冗余</li>\n<li><mark>负载均衡</mark>:在主从复制的基础上,配合<code>读写分离</code>,可以由主节点提供写服务,由从节点提供读服务(即写 Redis数据时应用连接主节点,读 Redis数据时应用连接从节点),分担服务器负载;尤其是在写少读多的场景下,通过多个从节点分担读负载,可以大大提高 Redis服务器的井发量。</li>\n<li><mark>高可用(集群)基石</mark>：除了上述作用以外,主从复制还是<code>哨兵</code>和<code>集群</code>能够实施的基础,因此说<code>主从复制</code>是 Redis高可用的基础</li>\n</ol>\n</blockquote>\n<h3 id=\"_13-3-工作机制\"> 13.3 工作机制</h3>\n<p><img src=\"./images/Redis_theory_note/Full_copy.png\" alt=\"全量复制\" /></p>\n<blockquote>\n<ol>\n<li>当设置好slave服务器后,slave会建立和master的连接，然后发送sync命令。</li>\n<li>Master接到命令启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后，master将传送整个数据文件到slave,以完成一次完全同步。</li>\n<li>全量复制：而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中（第一次全量）。只要是重新连接master,一次完全同步（全量复制)将被自动执行。</li>\n<li>增量复制：Master继续将新的所有收集到的修改命令依次传给slave,完成同步。（之后增量）</li>\n</ol>\n</blockquote>\n<p>当设置好slave服务器后，slave会建立和master的连接，然后发送sync命令。无论是第一次同步建立的连接还是连接断开后的重新连接，master都会启动一个后台进程调用<code>bgsave</code>（相对于<code>save</code>来说不会阻塞客户端），将数据库快照保存到文件中，同时master主进程会开始收集新的写命令并缓存起来。后台进程完成写文件 后，master就发送文件给slave，slave将文件保存到磁盘上，然后加载到内存恢复数据库快照到slave上。接着master就会把缓存的命令转发给slave。而且后续master收到的写命令都会通过开始建立的连接发送给slave。从master到slave的同步数据的命令和从 client发送的命令使用相同的协议格式。当master和slave的连接断开时slave可以自动重新建立连接。如果master同时收到多个 slave发来的同步连接命令，只会使用启动一个进程来写数据库镜像，然后发送给所有slave。</p>\n<h2 id=\"_14-redis集群-sentinel-哨兵-模式\"> 14. Redis集群-Sentinel（哨兵）模式</h2>\n<p>参考</p>\n<blockquote>\n<ul>\n<li><a href=\"https://www.jianshu.com/p/06ab9daf921d\" target=\"_blank\" rel=\"noopener noreferrer\">Redis哨兵（Sentinel）模式 - 简书 (jianshu.com)</a></li>\n<li><a href=\"https://blog.csdn.net/miss1181248983/article/details/90056960\" target=\"_blank\" rel=\"noopener noreferrer\">(23条消息) Redis集群详解_变成习惯-CSDN博客_redis集群</a></li>\n</ul>\n</blockquote>\n<p>主从模式的弊端就是不具备高可用性，当master挂掉以后，Redis将不能再对外提供写入操作，需要手动重新选举master，这就需要人工干预，费事费力，还会造成一段时间内服务不可用，因此sentinel应运而生。</p>\n<p><img src=\"./images/Redis_theory_note/Sentinel_Mode.jpg\" alt=\"哨兵模式\" /></p>\n<p>这里的哨兵有两个作用</p>\n<blockquote>\n<ul>\n<li>通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器。</li>\n<li>当哨兵监测到master宕机，会自动将slave切换成master，然后通过<code>发布订阅模式</code>通知其他的从服务器，修改配置文件，让它们切换主机。</li>\n</ul>\n</blockquote>\n<p>然而一个哨兵进程对Redis服务器进行监控，可能会出现问题，为此，我们可以使用多个哨兵进行监控。各个哨兵之间还会进行监控，这样就形成了多哨兵模式。</p>\n<p>用文字描述一下<strong>故障切换（failover）<strong>的过程。假设主服务器宕机，哨兵1先检测到这个结果，系统并不会马上进行failover过程，仅仅是哨兵1主观的认为主服务器不可用，这个现象成为</strong>主观下线</strong>。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行failover操作。切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为<strong>客观下线</strong>。这样对于客户端而言，一切都是透明的。</p>\n<p><img src=\"./images/Redis_theory_note/Multiple_sentinels.jpg\" alt=\"多哨兵模式\" /></p>\n<h3 id=\"_14-1-特点\"> 14.1 特点</h3>\n<blockquote>\n<ul>\n<li>sentinel模式是建立在主从模式的基础上，如果只有一个Redis节点，sentinel就没有任何意义</li>\n<li>当master挂了以后，sentinel会在slave中选择一个做为master，并修改它们的配置文件，其他slave的配置文件也会被修改，比如slaveof属性会指向新的master</li>\n<li>当master重新启动后，它将不再是master而是做为slave接收新的master的同步数据</li>\n<li>sentinel因为也是一个进程有挂掉的可能，所以sentinel也会启动多个形成一个sentinel集群</li>\n<li>多sentinel配置的时候，sentinel之间也会自动监控</li>\n<li>当主从模式配置密码时，sentinel也会同步将配置信息修改到配置文件中，不需要担心</li>\n<li>一个sentinel或sentinel集群可以管理多个主从Redis，多个sentinel也可以监控同一个redis</li>\n<li>sentinel最好不要和Redis部署在同一台机器，不然Redis的服务器挂了以后，sentinel也挂了</li>\n</ul>\n</blockquote>\n<h3 id=\"_14-2-作用\"> 14.2 作用</h3>\n<blockquote>\n<ul>\n<li><code>监控</code>：不间断的检查主从服务是否如预期一样正常工作</li>\n<li><code>事件通知</code>：对被监视的redis实例的异常，能通知系统管理员，或者以API接口通知其他应用程序。</li>\n<li><code>智能援救</code>：当被监视的主服务异常时，哨兵会智能的把某个从服务提升为主服务，同时其他从服务与新的主服务之间的关系将得到重新的配置。应用程序将通过redis服务端重新得到新的主服务的地址并重新建立连接。</li>\n<li><code>配置服务</code>：客户端可连接哨兵的接口，获得主从服务的相关信息，如果发生改变，哨兵新通知客户端。</li>\n</ul>\n</blockquote>\n<h3 id=\"_14-2-工作机制\"> 14.2 工作机制</h3>\n<p>当使用sentinel模式的时候，客户端就不要直接连接Redis，而是连接sentinel的<code>ip</code>和<code>port</code>，由sentinel来提供具体的可提供服务的Redis实现，这样当master节点挂掉以后，sentinel就会感知并将新的master节点提供给使用者。</p>\n<blockquote>\n<ul>\n<li>每个sentinel以每秒钟一次的频率向它所知的master，slave以及其他sentinel实例发送一个 <code>PING</code> 命令</li>\n<li>如果一个实例距离最后一次有效回复 PING 命令的时间超过 <code>down-after-milliseconds</code> 选项所指定的值， 则这个实例会被sentinel标记为<code>主观下线</code>。</li>\n<li>如果一个master被标记为<code>主观下线</code>，则正在监视这个master的所有sentinel要以每秒一次的频率确认master的确进入了主观下线状态</li>\n<li>当有足够数量的sentinel（大于等于配置文件指定的值）在指定的时间范围内确认master的确进入了主观下线状态， 则master会被标记为客观下线</li>\n<li>在一般情况下， 每个sentinel会以每 10 秒一次的频率向它已知的所有master，slave发送 INFO 命令</li>\n<li>当master被sentinel标记为客观下线时，sentinel向下线的master的所有slave发送 INFO 命令的频率会从 10 秒一次改为 1 秒一次</li>\n<li>若没有足够数量的sentinel同意master已经下线，master的客观下线状态就会被移除；</li>\n<li>若master重新向sentinel的 PING 命令返回有效回复，master的主观下线状态就会被移除</li>\n</ul>\n</blockquote>\n<h2 id=\"_15-redis集群-cluster模式\"> 15. Redis集群-cluster模式</h2>\n<p>::: tips 参考</p>\n<ul>\n<li><a href=\"https://www.jianshu.com/p/813a79ddf932\" target=\"_blank\" rel=\"noopener noreferrer\">Redis-Cluster集群</a></li>\n</ul>\n<p>:::</p>\n<h3 id=\"_15-1-介绍\"> 15.1 介绍</h3>\n<p>redis最开始使用主从模式做集群，若master宕机需要手动配置slave转为master；</p>\n<p>后来为了高可用提出来<strong>哨兵</strong>模式，该模式下有一个哨兵监视master和slave，若master宕机可自动将slave转为master，但它也有一个问题，就是不能动态扩充；</p>\n<p>所以在3.x提出cluster集群模式。</p>\n<h3 id=\"_15-2-设计原理\"> 15.2 设计原理</h3>\n<p>Redis-Cluster采用<code>无中心结构</code>，每个节点保存数据和整个集群状态,每个节点都和其他所有节点连接。</p>\n<p><img src=\"./images/Redis_theory_note/redis_cluster.jpg\" alt=\"redis-cluster\" /></p>\n<h3 id=\"_15-3-特点\"> 15.3 特点</h3>\n<ul>\n<li>所有的redis节点彼此互联(PING-PONG机制),内部使用二进制协议优化传输速度和带宽，数据共享</li>\n<li><code>节点的fail</code>是通过集群中<code>超过半数</code>的节点检测失效时才生效。</li>\n<li>所有的节点都是一主一从（也可以是一主多从），其中从不提供服务，仅作为备用</li>\n<li><code>不支持同时处理多个key</code>（如MSET/MGET），因为redis需要把key均匀分布在各个节点上，\n并发量很高的情况下同时创建key-value会降低性能并导致不可预测的行为</li>\n<li>支持在线增加、删除节点</li>\n<li>客户端与redis节点直连,不需要中间proxy层.客户端不需要连接集群所有节点,连接集群中任何一个可用节点读写即可。</li>\n<li>Redis集群预分好16384个桶，当需要在 Redis 集群中放置一个 key-value 时，根据 CRC16(key) mod 16384的值，决定将一个key放到哪个桶中。</li>\n</ul>\n<h3 id=\"_15-4-redis-cluster节点分配\"> 15.4 redis cluster节点分配</h3>\n<p>现在我们是三个主节点分别是：A, B, C 三个节点，它们可以是一台机器上的三个端口，也可以是三台不同的服务器。那么，采用哈希槽 (hash slot)的方式来分配16384个slot 的话，它们三个节点分别承担的slot 区间是：</p>\n<ul>\n<li>\n<p>节点A覆盖0－5460;</p>\n</li>\n<li>\n<p>节点B覆盖5461－10922;</p>\n</li>\n<li>\n<p>节点C覆盖10923－16383.</p>\n<p>获取数据:\n如果存入一个值，按照redis cluster哈希槽的<a href=\"http://lib.csdn.net/base/datastructure\" target=\"_blank\" rel=\"noopener noreferrer\">算法</a>： CRC16('key')384 = 6782。 那么就会把这个key 的存储分配到 B 上了。同样，当我连接(A,B,C)任何一个节点想获取'key'这个key时，也会这样的算法，然后内部跳转到B节点上获取数据</p>\n<p>新增一个主节点:\n新增一个节点D，redis cluster的这种做法是从各个节点的前面各拿取一部分slot到D上，我会在接下来的实践中实验。大致就会变成这样：</p>\n</li>\n<li>\n<p>节点A覆盖1365-5460</p>\n</li>\n<li>\n<p>节点B覆盖6827-10922</p>\n</li>\n<li>\n<p>节点C覆盖12288-16383</p>\n</li>\n<li>\n<p>节点D覆盖0-1364,5461-6826,10923-12287</p>\n</li>\n</ul>\n<p>同样删除一个节点也是类似，移动完成后就可以删除这个节点了。</p>\n<h3 id=\"_15-5-redis-cluster主从模式\"> 15.5 redis cluster主从模式</h3>\n<p>redis cluster 为了保证数据的高可用性，加入了主从模式，一个主节点对应一个或多个从节点，主节点提供数据存取，从节点则是从主节点拉取数据备份，当这个主节点挂掉后，就会有这个从节点选取一个来充当主节点，从而保证集群不会挂掉</p>\n<p>上面那个例子里, 集群有ABC三个主节点, 如果这3个节点都没有加入从节点，如果B挂掉了，我们就无法访问整个集群了。A和C的slot也无法访问。</p>\n<p>所以我们在集群建立的时候，一定要为每个主节点都添加了从节点, 比如像这样, 集群包含主节点A、B、C, 以及从节点A1、B1、C1, 那么即使B挂掉系统也可以继续正确工作。</p>\n<p>B1节点替代了B节点，所以Redis集群将会选择B1节点作为新的主节点，集群将会继续正确地提供服务。 当B重新开启后，它就会变成B1的从节点。</p>\n<blockquote>\n<p>集群中至少应该有奇数个节点，所以至少有三个节点，每个节点至少有一个备份节点，所以下面使用6节点。不过需要注意，如果节点B和B1同时挂了，Redis集群就无法继续正确地提供服务了。</p>\n</blockquote>\n<h2 id=\"_16-如何解决-redis-的并发竞争-key-问题\"> 16. 如何解决 Redis 的并发竞争 Key 问题</h2>\n<p>参考</p>\n<blockquote>\n<ul>\n<li>https://www.jianshu.com/p/41d3a673425d</li>\n<li>https://blog.csdn.net/qq_42253147/article/details/94446727</li>\n</ul>\n</blockquote>\n<p>这里的并发指的是多个redis的client同时set key引起的并发问题，也就是多个系统同时对⼀个 key 进⾏操作，但是最后执⾏的顺序 和我们期望的顺序不同，这样也就导致了结果的不同！</p>\n<p>方案</p>\n<blockquote>\n<ul>\n<li><strong>分布式锁+时间戳</strong></li>\n<li><strong>消息队列MQ</strong></li>\n</ul>\n</blockquote>\n<h3 id=\"_16-1-分布式锁-时间戳\"> 16.1 分布式锁+时间戳</h3>\n<h4 id=\"如果对这个key操作-不要求顺序\"> 如果对这个key操作，不要求顺序</h4>\n<p>这种情况下，准备一个分布式锁，大家去抢锁，抢到锁就做<code>set</code>操作即可，比较简单。加锁的目的实际上就是把<code>并行读写</code>改成<code>串行读写</code>的方式，从而来避免资源竞争。</p>\n<h4 id=\"如果对这个key操作-要求顺序\"> 如果对这个key操作，要求顺序</h4>\n<p>假设有一个<code>key1</code></p>\n<blockquote>\n<ul>\n<li>系统A需要将key1设置为valueA</li>\n<li>系统B需要将key1设置为valueB</li>\n<li>系统C需要将key1设置为valueC</li>\n</ul>\n</blockquote>\n<p>期望按照key1的value值按照 <code>valueA–&gt;valueB–&gt;valueC</code>的顺序变化。这种时候我们在数据写入数据库的时候，需要保存一个<code>时间戳</code>。假设<code>时间戳</code>如下</p>\n<blockquote>\n<ul>\n<li>系统A key 1 {valueA 3:00}</li>\n<li>系统B key 1 {valueB 3:05}</li>\n<li>系统C key 1 {valueC 3:10}</li>\n</ul>\n</blockquote>\n<p>那么，假设这会<code>系统B</code>先抢到锁，将<code>key1</code>设置为<code>{valueB 3:05}</code>。接下来系统A抢到锁，发现自己的valueA的时间戳早于缓存中的时间戳，那就不做<code>set</code>操作了。以此类推</p>\n<h4 id=\"什么是分布式锁\"> 什么是分布式锁</h4>\n<p>因为传统的加锁的做法（如java的synchronized和Lock）这里没用，只适合单点。因为这是分布式环境，需要的是分布式锁。</p>\n<p>当然，分布式锁可以基于很多种方式实现，比如zookeeper、redis等，</p>\n<p>不管哪种方式实现，基本原理是不变的：<strong>用一个状态值表示锁，对锁的占用和释放通过状态值来标识</strong>。</p>\n<h4 id=\"分布式锁的实现\"> 分布式锁的实现</h4>\n<p>主要用到的redis函数是<code>setnx()</code></p>\n<p>利用<code>SETNX</code>非常简单地实现<code>分布式锁</code>。例如：某客户端要获得一个名字<code>youzhi</code>的锁，客户端使用下面的命令进行获取：</p>\n<div><pre><code>SETNX lock.youzhi<span>&lt;</span>current Unix <span>time</span> + lock <span>timeout</span> + <span><span>1</span>></span>\n</code></pre>\n<div><span>1</span><br></div></div><blockquote>\n<ul>\n<li>如返回1，则该客户端获得锁，把<code>lock.youzhi</code>的键值设置为时间值表示该键已被锁定，该客户端最后可以通过<code>DEL lock.foo</code>来释放该锁。</li>\n<li>如返回0，表明该锁已被其他客户端取得，这时我们可以先返回或进行重试等对方完成或等待锁超时。</li>\n</ul>\n</blockquote>\n<h3 id=\"_16-2-消息队列\"> 16.2 消息队列</h3>\n<p>在并发量过大的情况下,可以通过<code>消息中间件</code>进行处理,把<code>并行读写</code>进行<code>串行化</code>。</p>\n<p>把<code>Redis.set</code>操作放在队列中使其串行化,必须的一个一个执行。</p>\n<p>这种方式在一些高并发的场景中算是一种通用的解决方案。</p>\n<h2 id=\"_17-区别\"> 17. 区别</h2>\n<h3 id=\"_17-1-redis-和-memcached-的区别\"> 17.1 redis 和 memcached 的区别</h3>\n<blockquote>\n<ol>\n<li><strong>redis⽀持更丰富的数据类型（⽀持更复杂的应⽤场景）</strong>：Redis不仅仅⽀持简单的k/v类型的数 据，同时还提供list，set，zset，hash等数据结构的存储。memcache⽀持简单的数据类型， String。</li>\n<li><strong>Redis⽀持数据的持久化</strong>：可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进⾏使 ⽤,⽽Memecache把数据全部存在内存之中。</li>\n<li><strong>集群模式</strong>：memcached没有原⽣的集群模式，需要依靠客户端来实现往集群中分⽚写⼊数据；但 是 redis ⽬前是原⽣⽀持 cluster 模式的.</li>\n<li>Memcached是多线程，⾮阻塞IO复⽤的⽹络模型；Redis使⽤单线程的多路 IO 复⽤模型。</li>\n</ol>\n</blockquote>\n<p><img src=\"./images/Redis_theory_note/difference_between_redis_and_memcached.jpg\" alt=\"\" /></p>\n<h2 id=\"_18-redis命名规则\"> 18. Redis命名规则</h2>\n<p>::: tips 参考</p>\n<ul>\n<li>https://blog.csdn.net/u013521220/article/details/107640977</li>\n</ul>\n<p>::</p>\n",
      "date_published": "2020-10-12T20:45:07.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": []
    },
    {
      "title": "Docker:Install software",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/docker/Docker-Install-software/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/docker/Docker-Install-software/",
      "summary": "Docker:Install software",
      "content_html": "<h2 id=\"_1-概念\"> 1. 概念</h2>\n<blockquote>\n<ul>\n<li>镜像：相当于java中的类,镜像由一层层只读层堆在一起</li>\n<li>容器：镜像只读层+读写层，运行态容器为由一个可读写的文件系统「静态容器」+ 隔离的进程空间和其中的进程构成(可以理解为<strong>虚拟机中的虚拟机</strong>)</li>\n</ul>\n</blockquote>\n<p><img src=\"./images/Docker-install-software/image&container.png\" alt=\"\" /></p>\n<h3 id=\"_1-1-查看镜像\"> 1.1 查看镜像</h3>\n<div><pre><code><span>docker</span> images\n</code></pre>\n<div><span>1</span><br></div></div><p><img src=\"./images/Docker-install-software/Mirror.jpg\" alt=\"镜像\" /></p>\n<h3 id=\"_1-2-查看容器\"> 1.2 查看容器</h3>\n<div><pre><code><span>docker</span> <span>ps</span> -a\n</code></pre>\n<div><span>1</span><br></div></div><p><img src=\"./images/Docker-install-software/container.jpg\" alt=\"容器\" /></p>\n<h2 id=\"_2-安装mysql\"> 2. 安装Mysql</h2>\n<h3 id=\"_2-1-下载mysql5-7的docker镜像\"> 2.1 下载mysql5.7的docker镜像</h3>\n<div><pre><code><span>docker</span> pull mysql:5.7\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"_2-2-使用docker命令启动容器\"> 2.2 使⽤docker命令启动容器</h3>\n<div><pre><code><span>mkdir</span> /mydata/mysql/mysql5.7 <span>#先在根目录创建容器来存放mysql相关</span>\n<span>#将容器的3306端口映射到主机的3307接口，适合主机的3306接口被主机Mysql占用情况下</span>\n<span>docker</span> run -p <span>3307</span>:3306 --name mysql5.7 <span>\\</span>\n-v /usr/local/docker/mysql5.7/data:/var/lib/mysql <span>\\</span>\n-v /usr/local/docker/mysql5.7/log:/var/log <span>\\</span>\n-v /usr/local/docker/mysql5.7/conf:/etc/mysql <span>\\</span>\n-e <span>MYSQL_ROOT_PASSWORD</span><span>=</span>root <span>\\</span>\n-d mysql:5.7\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>参数说明</p>\n<blockquote>\n<ul>\n<li>--restart=always：容器自启动</li>\n<li>-p 3307:3306：将容器的3306端⼝映射到主机的3307端⼝</li>\n<li>-v /usr/local/docker/mysql5.7/conf:/etc/mysql：将配置⽂件夹挂在到主机</li>\n<li>-v /usr/local/docker/mysql5.7/log:/var/log：将⽇志⽂件夹挂载到主机</li>\n<li>-v /usr/local/docker/mysql5.7/data:/var/lib/mysql：将数据⽂件夹挂载到主机</li>\n<li>-e MYSQL_ROOT_PASSWORD=root：初始化root⽤户的密码</li>\n</ul>\n</blockquote>\n<p><img src=\"./images/Docker-install-software/start_mysql_container.jpg\" alt=\"启动mysql容器\" /></p>\n<h3 id=\"_2-3-进入运行mysql的docker容器\"> 2.3 进⼊运⾏mysql的docker容器</h3>\n<div><pre><code><span>docker</span> <span>exec</span> -it mysql5.7 /bin/bash\n</code></pre>\n<div><span>1</span><br></div></div><p><img src=\"./images/Docker-install-software/enter_container.jpg\" alt=\"进入容器\" /></p>\n<h3 id=\"_2-4-使用mysql命令打开客户端\"> 2.4 使⽤Mysql命令打开客户端</h3>\n<div><pre><code>mysql -uroot -proot\n</code></pre>\n<div><span>1</span><br></div></div><p><img src=\"./images/Docker-install-software/enter_mysql.jpg\" alt=\"进入mysql\" /></p>\n<h3 id=\"_2-5-测试连接\"> 2.5 测试连接</h3>\n<p>使用Navicat连接工具</p>\n<p><img src=\"./images/Docker-install-software/navicat_connect_to_mysql_1.jpg\" alt=\"navicat连接mysql1\" /></p>\n<p>连接成功</p>\n<p><img src=\"./images/Docker-install-software/navicat_connect_to_mysql_2.jpg\" alt=\"navicat连接mysql2\" /></p>\n<h2 id=\"_3-安装nginx\"> 3. 安装Nginx</h2>\n<h3 id=\"_3-1-下载nginx1-10的docker镜像\"> 3.1 下载Nginx1.10的docker镜像</h3>\n<div><pre><code><span>docker</span> pull nginx:1.18\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"_3-2-先运行一次容器-为了拷⻉配置文件\"> 3.2 先运⾏⼀次容器（为了拷⻉配置⽂件）</h3>\n<div><pre><code><span>docker</span> run -p <span>81</span>:80 --name nginx1.18 <span>\\</span>\n-v /mydata/nginx1.18/html:/usr/share/nginx1.18/html <span>\\</span>\n-v /mydata/nginx1.18/logs:/var/log/nginx1.18 <span>\\</span>\n-d nginx:1.18\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><blockquote>\n<p>注：加了 -d 参数默认不会进⼊容器，想要进⼊容器需要使⽤指令 <code>docker exec</code>。</p>\n</blockquote>\n<h3 id=\"_3-3-将容器内的配置文件拷⻉到指定目录\"> 3.3 将容器内的配置⽂件拷⻉到指定⽬录</h3>\n<div><pre><code><span>docker</span> container <span>cp</span> nginx1.18:/etc/nginx /mydata/nginx1.18/\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"_3-4-修改文件名称\"> 3.4 修改⽂件名称</h3>\n<div><pre><code><span>cd</span> /mydata/nginx1.18 \n<span>mv</span> nginx conf\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h3 id=\"_3-5-终止并删除容器\"> 3.5 终⽌并删除容器</h3>\n<div><pre><code><span>docker</span> stop nginx1.18\n<span>docker</span> <span>rm</span> nginx1.18\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h3 id=\"_3-6-再次使用docker命令启动\"> 3.6 再次使⽤docker命令启动</h3>\n<div><pre><code><span>docker</span> run -p <span>81</span>:80 --name nginx1.18 <span>\\</span>\n-v /mydata/nginx1.18/html:/usr/share/nginx1.18/html <span>\\</span>\n-v /mydata/nginx1.18/logs:/var/log/nginx1.18 <span>\\</span>\n-v /mydata/nginx1.18/conf:/etc/nginx1.18 <span>\\</span>\n-d nginx:1.18\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id=\"_3-7-启动成功\"> 3.7 启动成功</h3>\n<p><img src=\"./images/Docker-install-software/nginx_start.jpg\" alt=\"nginx启动成功\" /></p>\n",
      "date_published": "2020-05-31T20:47:14.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": []
    },
    {
      "title": "Docker学习笔记",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/docker/Docker-Note/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/docker/Docker-Note/",
      "summary": "Docker学习笔记",
      "content_html": "<h2 id=\"参考\"> 参考</h2>\n<p>参考</p>\n<div><p>参考</p>\n<ul>\n<li><a href=\"http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html\" target=\"_blank\" rel=\"noopener noreferrer\">阮一峰Docker 入门教程</a></li>\n<li>https://www.bilibili.com/read/cv6041687/</li>\n<li><a href=\"https://www.runoob.com/docker/docker-tutorial.html\" target=\"_blank\" rel=\"noopener noreferrer\">菜鸟教程 | Docker 教程</a></li>\n</ul>\n</div>\n<p>官方</p>\n<div><p>官方</p>\n<ul>\n<li><a href=\"https://docs.docker.com/\" target=\"_blank\" rel=\"noopener noreferrer\">官方文档</a></li>\n<li><a href=\"https://hub.docker.com/\" target=\"_blank\" rel=\"noopener noreferrer\">仓库地址</a></li>\n</ul>\n</div>\n<h2 id=\"介绍\"> 介绍</h2>\n<p>Docker 是一个开源的应用容器引擎，基于 Go 语言开发。Docker 可以让开发者打包他们的应用以及依赖包到一个轻 量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互 之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。</p>\n<p>**Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。**它是目前最流行的 Linux 容器解决方案。</p>\n<p>Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker，就不用担心环境问题。</p>\n<p>总体来说，Docker 的接口相当简单，用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。</p>\n<h3 id=\"用途\"> 用途</h3>\n<p>Docker 的主要用途，目前有三大类。</p>\n<div><p>用途</p>\n<ul>\n<li><strong>提供一次性的环境</strong>。比如，本地测试他人的软件、持续集成的时候提供单元测试和构建的环境。</li>\n<li><strong>提供弹性的云服务</strong>。因为 Docker 容器可以随开随关，很适合动态扩容和缩容。</li>\n<li><strong>组建微服务架构</strong>。通过多个容器，一台机器可以跑多个服务，因此在本机就可以模拟出微服务架构。</li>\n<li>Web 应用的自动化打包和发布</li>\n<li>自动化测试和持续集成、发布</li>\n<li>在服务型环境中部署和调整数据库或其他的后台应用</li>\n</ul>\n</div>\n<p>使用Docker可以实现开发人员的开发环境、测试人员的测试环境、运维人员的生产环境的一致性。</p>\n<p><img src=\"./images/Docker-Note/docker_usage.jpg\" alt=\"docker用途\" /></p>\n<h3 id=\"组成\"> 组成</h3>\n<p><img src=\"./images/Docker-Note/docker_composition1.jpg\" alt=\"docker组成1\" /></p>\n<p><img src=\"./images/Docker-Note/docker_composition2.jpg\" alt=\"docker组成2\" /></p>\n<h3 id=\"底层原理\"> 底层原理</h3>\n<h2 id=\"安装\"> 安装</h2>\n<div><p>参考</p>\n<ul>\n<li><a href=\"https://www.runoob.com/docker/centos-docker-install.html\" target=\"_blank\" rel=\"noopener noreferrer\">CentOS Docker 安装</a></li>\n<li><a href=\"https://docs.docker.com/engine/install/centos/\" target=\"_blank\" rel=\"noopener noreferrer\">Install Docker Engine on CentOS</a></li>\n<li><a href=\"https://www.bilibili.com/video/BV1og4y1q7M4?p=6\" target=\"_blank\" rel=\"noopener noreferrer\">视频狂神说</a></li>\n</ul>\n</div>\n<h3 id=\"docker可视化界面\"> docker可视化界面</h3>\n<div><p>参考</p>\n<ul>\n<li>https://www.cnblogs.com/frankdeng/p/9686735.html</li>\n</ul>\n</div>\n<h2 id=\"docker镜像容器原理\"> docker镜像容器原理</h2>\n<div><p>参考</p>\n<ul>\n<li>http://dockone.io/article/783</li>\n<li>https://zhuanlan.zhihu.com/p/93085215</li>\n<li>https://blog.51cto.com/liuleis/2070461</li>\n</ul>\n</div>\n<h2 id=\"常用命令\"> 常用命令</h2>\n<p>参考</p>\n<div><p>参考</p>\n<ul>\n<li><a href=\"https://docs.docker.com/engine/reference/run/\" target=\"_blank\" rel=\"noopener noreferrer\">Docker官网文档</a></li>\n<li>http://dockone.io/article/783</li>\n<li>https://www.bilibili.com/read/cv6041687/</li>\n<li>https://www.cnblogs.com/duanxz/p/7905233.html</li>\n<li>https://jishuin.proginn.com/p/763bfbd2a0a8</li>\n</ul>\n</div>\n<p><img src=\"./images/Docker-Note/docker_command.png\" alt=\"docker常用命令\" /></p>\n<h3 id=\"镜像-images\"> 镜像(images)</h3>\n<p><strong>查看镜像</strong></p>\n<div><pre><code><span>#查看所有本地主机上的镜像</span>\n<span>docker</span> images\n\n<span>#帮助</span>\n<span>[</span>root@VM-151-171-centos ~<span>]</span><span># docker images --help</span>\n\nUsage:  <span>docker</span> images <span>[</span>OPTIONS<span>]</span> <span>[</span>REPOSITORY<span>[</span>:TAG<span>]</span><span>]</span>\n\nList images\n\nOptions:\n  -a, --all             Show all images <span>(</span>default hides intermediate images<span>)</span>\n      --digests         Show digests\n  -f, --filter filter   Filter output based on conditions provided\n      --format string   Pretty-print images using a Go template\n      --no-trunc        Don't truncate output\n  -q, --quiet           Only show numeric IDs\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p><strong>搜索镜像</strong></p>\n<div><pre><code><span>#搜索mysql镜像</span>\n<span>docker</span> search mysql\n\n<span>[</span>root@VM-151-171-centos ~<span>]</span><span># docker search --help</span>\n\nUsage:  <span>docker</span> search <span>[</span>OPTIONS<span>]</span> <span>TERM</span>\n\nSearch the Docker Hub <span>for</span> images\n\nOptions:\n  -f, --filter filter   Filter output based on conditions provided\n      --format string   Pretty-print search using a Go template\n      --limit int       Max number of search results <span>(</span>default <span>25</span><span>)</span>\n      --no-trunc        Don't truncate output\n\n\n<span>#搜索stars大于3000的镜像</span>\n<span>[</span>root@VM-151-171-centos ~<span>]</span><span># docker search mysql --filter=STARS=3000</span>\nNAME                DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED\nmysql               MySQL is a widely used, open-source relation…   <span>10444</span>               <span>[</span>OK<span>]</span>                \nmariadb             MariaDB is a community-developed fork of MyS…   <span>3880</span>                <span>[</span>OK<span>]</span> \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p><strong>下载镜像</strong></p>\n<p><img src=\"./images/Docker-Note/docker_pull.png\" alt=\"docker下载镜像\" /></p>\n<p><img src=\"./images/Docker-Note/docker_pull_2.png\" alt=\"docker下载镜像\" /></p>\n<p>可以看到部分文件已经存在，无需重复下载</p>\n<p><strong>删除镜像</strong></p>\n<div><pre><code><span>#删除镜像，参数可以使镜像名也可以是镜像id</span>\n<span>[</span>root@VM-151-171-centos ~<span>]</span><span># docker rmi --help</span>\n\nUsage:  <span>docker</span> rmi <span>[</span>OPTIONS<span>]</span> IMAGE <span>[</span>IMAGE<span>..</span>.<span>]</span>\n\nRemove one or <span>more</span> images\n\nOptions:\n  -f, --force      Force removal of the image\n      --no-prune   Do not delete untagged parents\n\n\n<span>#删除多个镜像</span>\n<span>docker</span> rmi -f <span>[</span><span>]</span> <span>[</span><span>]</span>\n\n<span>#删除全部镜像</span>\n<span>docker</span> rmi -f <span><span>$(</span><span>docker</span> images -aq<span>)</span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h3 id=\"容器-container\"> 容器(container)</h3>\n<p>参考参考:<a href=\"https://www.bilibili.com/read/cv6041687/\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.bilibili.com/read/cv6041687/</a></p>\n<div><p>注意</p>\n<ul>\n<li>start是启动已创建好的，run是运行一个全新的容器</li>\n<li><code>run</code>的时候<code>--rm</code>代表用完容器自动删除容器</li>\n<li><code>run</code>的时候<code>-P</code>大写的P是随机端口</li>\n</ul>\n</div>\n<h3 id=\"其他\"> 其他</h3>\n<div><pre><code><span>#查看各个容器状态（CPU等）</span>\n<span>docker</span> stats\n<span>#查看指定容器</span>\n<span>docker</span> stats <span>[</span>容器<span>]</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><img src=\"./images/Docker-Note/docker_stats.jpg\" alt=\"docker_stats\" /></p>\n<div><pre><code><span>#7.在使⽤ -d 参数时，容器启动后会进⼊后台。此时想要进⼊容器，可以通过以下指令进⼊</span>\n<span>docker</span> attach 容器名称/id <span>#不推荐使⽤，因为退出时会导致容器的停⽌</span>\n<span>docker</span> <span>exec</span> -it 容器名称/id /bin/bash <span>#在进⼊容器后可使⽤linux命令，退出使⽤exit</span>\n\n<span>#8.导出</span>\n<span>docker</span> <span>export</span> 容器名称/id <span>></span> 名称.tar\n\n<span>#9.导⼊，可以使⽤ docker import 从容器快照⽂件中再导⼊为镜像，以下实例将快照⽂件指定</span>\n路径的tar 导⼊到镜像 test/test:v1:\n<span>cat</span> tar路径 <span>|</span> <span>docker</span> <span>import</span> - test/test:v1\n<span>#也可以通过指定 URL 或者某个⽬录来导⼊</span>\n<span>docker</span> <span>import</span> http://example.com/exampleimage.tgz example/imagerepo\n\n<span>#10.删除容器</span>\n<span>docker</span> <span>rm</span> -f 容器名称/id\n\n<span>#11.启动&amp;停止docker</span>\n<span>service</span> <span>docker</span> start<span>#启动docker</span>\n<span>service</span> <span>docker</span> stop<span>#停止docker</span>\n<span>service</span> <span>docker</span> restart<span>#重启docker</span>\n\n<span>#12.开机自启动docker</span>\nsystemctl <span>enable</span> <span>docker</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><h2 id=\"日志-元数据-文件传输\"> 日志 | 元数据 | 文件传输</h2>\n<h3 id=\"日志\"> 日志</h3>\n<div><pre><code><span>[</span>root@VM-151-171-centos ~<span>]</span><span># docker logs --help</span>\n\nUsage:  <span>docker</span> logs <span>[</span>OPTIONS<span>]</span> CONTAINER\n\nFetch the logs of a container\n\nOptions:\n      --details        Show extra details provided to logs\n  -f, --follow         Follow log output\n      --since string   Show logs since timestamp <span>(</span>e.g. <span>2013</span>-01-02T13:23:37<span>)</span> or relative <span>(</span>e.g. 42m <span>for</span> <span>42</span> minutes<span>)</span>\n      --tail string    Number of lines to show from the end of the logs <span>(</span>default <span>\"all\"</span><span>)</span>\n  -t, --timestamps     Show timestamps\n      --until string   Show logs before a timestamp <span>(</span>e.g. <span>2013</span>-01-02T13:23:37<span>)</span> or relative <span>(</span>e.g. 42m <span>for</span> <span>42</span> minutes<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h3 id=\"元数据\"> 元数据</h3>\n<div><pre><code><span>#查看关于容器的所有信息</span>\n<span>docker</span> inspect <span>[</span>容器id/名<span>]</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h3 id=\"文件传输\"> 文件传输</h3>\n<p>拷贝宿主机文件到容器</p>\n<div><pre><code><span>#将主机文件拷贝到容器中</span>\n<span>docker</span> <span>cp</span> <span>[</span>主机文件<span>]</span> <span>[</span>容器<span>]</span>:<span>[</span>容器路径<span>]</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>拷贝容器中的文件到宿主机</p>\n<div><pre><code><span>#将主机文件拷贝到容器中</span>\n<span>docker</span> <span>cp</span> <span>[</span>容器<span>]</span>:<span>[</span>容器文件<span>]</span> <span>[</span>主机路径<span>]</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h2 id=\"容器数据卷-目录挂载\"> 容器数据卷/目录挂载</h2>\n<div><p>参考</p>\n<ul>\n<li>https://www.cnblogs.com/ruanraun/p/dockervolumes.html</li>\n<li>https://www.cnblogs.com/ivictor/p/4834864.html</li>\n<li>https://www.cnblogs.com/loveyous/p/11372034.html</li>\n</ul>\n</div>\n<p>在容器中管理数据主要有两种方式：</p>\n<ul>\n<li>数据卷(Volumes)</li>\n<li>挂载主机目录(Bind mounts)</li>\n</ul>\n<p><img src=\"./images/Docker-Note/docker_volume.png\" alt=\"docker数据挂载\" /></p>\n<div><p>Note</p>\n<p>Docker中提供了两种挂载方式，<code>-v</code>和<code>-mount</code></p>\n<p>Docker新用户应该选择 --mount参数</p>\n<p>经验丰富的Docker使用者对-v或者--volume已经很熟悉了，但是推荐使用-mount参数。</p>\n</div>\n<h3 id=\"目录挂载\"> 目录挂载</h3>\n<p>持久化容器里面的数据到本地，通过<code>目录挂载</code>的方式</p>\n<p>可以在创建容器的时候，将宿主机的目录与容器内的目录进行映射，这样我们就可以通过修改宿主机某个目录的文件从而去影响容器，也就意味着挂载的目录<code>互相同步</code>。</p>\n<p>创建容器时添加<code>-v</code>参数，后边为<code>宿主机目录:容器目录</code>，例如： docker run -di -v /usr/local/test:/usr/local/test -- name=mycentos3 centos:7</p>\n<p>创建linux宿主机器要挂载的目录</p>\n<div><pre><code><span>mkdir</span> /usr/local/test\n</code></pre>\n<div><span>1</span><br></div></div><p>创建并启动容器mycentos3,并挂载linux中的/usr/local/test目录到容器的/usr/local/test；也就是在</p>\n<p>linux中的/usr/local/test中操作相当于对容器相应目录操作</p>\n<div><pre><code><span>docker</span> run -di -v /usr/local/test:/usr/local/test --name<span>=</span>mycentos3 centos:7\n</code></pre>\n<div><span>1</span><br></div></div><p>在linux下创建文件</p>\n<div><pre><code><span>touch</span> /usr/local/test/def.txt\n</code></pre>\n<div><span>1</span><br></div></div><p>进入容器</p>\n<div><pre><code><span>docker</span> <span>exec</span> -it mycentos3 /bin/bash \n</code></pre>\n<div><span>1</span><br></div></div><p>在容器中查看目录中是否有对应文件def.txt</p>\n<div><pre><code>ll /usr/local/test \n</code></pre>\n<div><span>1</span><br></div></div><p>然后查看容器元数据中的挂载目录信息</p>\n<div><pre><code><span>\"Mounts\"</span><span>:</span> <span>[</span>\n  <span>{</span>\n    <span>\"Type\"</span><span>:</span> <span>\"bind\"</span><span>,</span>\n    <span>\"Source\"</span><span>:</span> <span>\"/usr/local/docker/nginx/html\"</span><span>,</span>\n    <span>\"Destination\"</span><span>:</span> <span>\"/data/html\"</span><span>,</span>\n    <span>\"Mode\"</span><span>:</span> <span>\"rw\"</span><span>,</span>\n    <span>\"RW\"</span><span>:</span> <span>true</span><span>,</span>\n    <span>\"Propagation\"</span><span>:</span> <span>\"rprivate\"</span>\n  <span>}</span><span>,</span>\n  <span>{</span>\n    <span>\"Type\"</span><span>:</span> <span>\"bind\"</span><span>,</span>\n    <span>\"Source\"</span><span>:</span> <span>\"/usr/local/docker/nginx/img\"</span><span>,</span>\n    <span>\"Destination\"</span><span>:</span> <span>\"/data/img\"</span><span>,</span>\n    <span>\"Mode\"</span><span>:</span> <span>\"rw\"</span><span>,</span>\n    <span>\"RW\"</span><span>:</span> <span>true</span><span>,</span>\n    <span>\"Propagation\"</span><span>:</span> <span>\"rprivate\"</span>\n  <span>}</span><span>,</span>\n  <span>{</span>\n    <span>\"Type\"</span><span>:</span> <span>\"bind\"</span><span>,</span>\n    <span>\"Source\"</span><span>:</span> <span>\"/usr/local/docker/nginx/conf.d\"</span><span>,</span>\n    <span>\"Destination\"</span><span>:</span> <span>\"/etc/nginx/conf.d\"</span><span>,</span>\n    <span>\"Mode\"</span><span>:</span> <span>\"rw\"</span><span>,</span>\n    <span>\"RW\"</span><span>:</span> <span>true</span><span>,</span>\n    <span>\"Propagation\"</span><span>:</span> <span>\"rprivate\"</span>\n  <span>}</span>\n<span>]</span><span>,</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><h3 id=\"具名和匿名挂载\"> 具名和匿名挂载</h3>\n<div><pre><code><span># 如何确实是具名/匿名挂载，还是指定路径挂载</span>\n<span>#匿名挂载</span>\n-v 容器内路径\n\n<span>#具名挂载</span>\n-v 卷名:容器内路径\n\n<span>#指定路径挂载</span>\n-v /宿主机路径:容器内路径\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id=\"容器挂载目录权限\"> 容器挂载目录权限</h3>\n<p>在<code>容器内路径</code>后加<code>:ro</code>为可读，加<code>:rw</code>为可读可写</p>\n<div><p>Info</p>\n<ul>\n<li><strong>ro</strong>:宿主机只能读取容器的数据卷内容不能修改</li>\n<li><strong>rw</strong>:默认，即可读可写</li>\n</ul>\n</div>\n<h3 id=\"数据卷容器共享\"> 数据卷容器共享</h3>\n<p>如我我们经常需要多个容器之间进行数据共享我们需要用到命令<code>--volumes-from</code></p>\n<p>具体示例</p>\n<ol>\n<li>我们从仓库拉一个centos的容器镜像</li>\n</ol>\n<div><pre><code>Copy$ <span>docker</span> pull centos\n</code></pre>\n<div><span>1</span><br></div></div><p>2）然后运行这个镜像并创建一个数据卷挂载到/mydata</p>\n<div><pre><code>$ <span>docker</span> run -it -v /mydata --name mycentos centos\n</code></pre>\n<div><span>1</span><br></div></div><ol start=\"2\">\n<li>再运行两个容器，在这两个容器中使用--volumes-from来挂载mycentos容器中的数据卷.</li>\n</ol>\n<div><pre><code>$ <span>docker</span> run -it --volumes-from mycentos --name soncentos1 centos\n\n$ <span>docker</span> run -it --volumes-from mycentos --name soncentos2 centos\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>此时，容器soncentos1和soncentos2都挂载同一个数据卷到相的/mydata目录。三个容器任何一方在该目录下的写入数据，其他容器都可以看到。</p>\n<div><p>注意</p>\n<p>可以多次使用<code>--volumes-**from**</code>参数来从多个容器挂载多个数据卷。还可以从其他已经挂载了容器卷的容器来挂载数据卷。 使用--volumes-<strong>from</strong>参数所挂载数据卷的容器自身并不需要保持在运行状态。</p>\n<p>如果删除了挂载的容器（包括dbdata、db1和db2），数据卷并不会被自动删除。如果要删除一个数据卷，必须在删除最后一个还挂载着它 的容器时显式使用docker rm -v命令来指定同时删除关联的容器。</p>\n</div>\n<h2 id=\"制作镜像\"> 制作镜像</h2>\n<h3 id=\"使用commit命令\"> 使用commit命令</h3>\n<div><pre><code><span># 提交某个容器为镜像</span>\n<span>docker</span> commit <span>[</span>容器<span>]</span>\n\n<span>[</span>root@izuf6f489inattnq5zpfcxz ~<span>]</span><span># docker commit --help</span>\n\nUsage:  <span>docker</span> commit <span>[</span>OPTIONS<span>]</span> CONTAINER <span>[</span>REPOSITORY<span>[</span>:TAG<span>]</span><span>]</span>\n\nCreate a new image from a container's changes\n\nOptions:\n  -a, --author string    Author <span>(</span>e.g., <span>\"John Hannibal Smith &lt;hannibal@a-team.com>\"</span><span>)</span>\n  -c, --change list      Apply Dockerfile instruction to the created image\n  -m, --message string   Commit message\n  -p, --pause            Pause container during commit <span>(</span>default <span>true</span><span>)</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h2 id=\"dockerfile-制作镜像\"> Dockerfile-制作镜像</h2>\n<p>::: tips 参考</p>\n<ul>\n<li><a href=\"https://docs.docker.com/engine/reference/builder/#dockerfile-examples\" target=\"_blank\" rel=\"noopener noreferrer\">Dockerfile reference</a></li>\n<li><a href=\"https://www.runoob.com/docker/docker-dockerfile.html\" target=\"_blank\" rel=\"noopener noreferrer\">菜鸟教程 | Dockerfile</a></li>\n</ul>\n<p>:::</p>\n<h3 id=\"命令\"> 命令</h3>\n<p><img src=\"./images/Docker-Note/dockerfile_command.png\" alt=\"dockerfile命令1\" /></p>\n<p><img src=\"./images/Docker-Note/dockerfile_command2.png\" alt=\"dockerfile命令2\" /></p>\n<p><code>CMD</code>&amp;<code>ENTRYPOINT</code>的区别</p>\n<div><p>CMD&ENTRYPOINT的区别</p>\n<ul>\n<li>CMD：指定这个容器启动的时候要运行的命令，只有最后一个会生效，可被替代</li>\n<li>ENTRYPOINT：指定这个容器启动的时候要运行的命令，可以追加命令</li>\n</ul>\n</div>\n<p>举例通过构建两个不同的dockerfile</p>\n<p><code>dockerfile-cmd</code></p>\n<div><pre><code><span># 构建镜像为centos-cmd</span>\nFROM centos\nCMD <span>[</span><span>\"ls\"</span>, <span>\"-a\"</span><span>]</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><code>dockerfile-entrypoint</code></p>\n<div><pre><code><span># 构建镜像为centos-entrypoint</span>\nFROM centos\nENTRYPOINT <span>[</span><span>\"ls\"</span>, <span>\"-a\"</span><span>]</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>构建镜像再运行</p>\n<p><code>centos-cmd</code></p>\n<div><pre><code>\n<span>[</span>root@izuf6f489inattnq5zpfcxz ~<span>]</span><span># docker run centos-cmd</span>\n<span>.</span>\n<span>..</span>\n.dockerenv\nbin\ndev\netc\nhome\nlib\nlib64\nlost+found\nmedia\nmnt\nopt\nproc\nroot\nrun\nsbin\nsrv\nsys\ntmp\nusr\nvar\n<span>[</span>root@izuf6f489inattnq5zpfcxz ~<span>]</span><span>#</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><p><code>centos-entrypoint</code></p>\n<div><pre><code><span>[</span>root@izuf6f489inattnq5zpfcxz ~<span>]</span><span># docker run centos-entrypoint</span>\n<span>.</span>\n<span>..</span>\n.dockerenv\nbin\ndev\netc\nhome\nlib\nlib64\nlost+found\nmedia\nmnt\nopt\nproc\nroot\nrun\nsbin\nsrv\nsys\ntmp\nusr\nvar\n<span>[</span>root@izuf6f489inattnq5zpfcxz ~<span>]</span><span>#</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><p>此时我们在<code>run</code>时追加命令，由于<code>cmd</code>是替换所以会报错，而<code>entrypoint</code>则不会</p>\n<p><code>centos-cmd</code></p>\n<div><pre><code><span>[</span>root@izuf6f489inattnq5zpfcxz ~<span>]</span><span># docker run centos-cmd -l</span>\ndocker: Error response from daemon: OCI runtime create failed: container_linux.go:349: starting container process caused <span>\"exec: <span title=\"\\&quot;\">\\\"</span>-l<span title=\"\\&quot;\">\\\"</span>: executable file not found in <span>$PATH</span>\"</span><span>:</span> unknown.\n<span>[</span>root@izuf6f489inattnq5zpfcxz ~<span>]</span><span>#</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><code>centos-entrypoint</code></p>\n<div><pre><code>\n<span>[</span>root@izuf6f489inattnq5zpfcxz ~<span>]</span><span># docker run centos-entrypoint -l</span>\ntotal <span>56</span>\ndrwxr-xr-x   <span>1</span> root root <span>4096</span> Feb  <span>8</span> <span>16</span>:19 <span>.</span>\ndrwxr-xr-x   <span>1</span> root root <span>4096</span> Feb  <span>8</span> <span>16</span>:19 <span>..</span>\n-rwxr-xr-x   <span>1</span> root root    <span>0</span> Feb  <span>8</span> <span>16</span>:19 .dockerenv\nlrwxrwxrwx   <span>1</span> root root    <span>7</span> Nov  <span>3</span> <span>15</span>:22 bin -<span>></span> usr/bin\ndrwxr-xr-x   <span>5</span> root root  <span>340</span> Feb  <span>8</span> <span>16</span>:19 dev\ndrwxr-xr-x   <span>1</span> root root <span>4096</span> Feb  <span>8</span> <span>16</span>:19 etc\ndrwxr-xr-x   <span>2</span> root root <span>4096</span> Nov  <span>3</span> <span>15</span>:22 home\nlrwxrwxrwx   <span>1</span> root root    <span>7</span> Nov  <span>3</span> <span>15</span>:22 lib -<span>></span> usr/lib\nlrwxrwxrwx   <span>1</span> root root    <span>9</span> Nov  <span>3</span> <span>15</span>:22 lib64 -<span>></span> usr/lib64\ndrwx------   <span>2</span> root root <span>4096</span> Dec  <span>4</span> <span>17</span>:37 lost+found\ndrwxr-xr-x   <span>2</span> root root <span>4096</span> Nov  <span>3</span> <span>15</span>:22 media\ndrwxr-xr-x   <span>2</span> root root <span>4096</span> Nov  <span>3</span> <span>15</span>:22 mnt\ndrwxr-xr-x   <span>2</span> root root <span>4096</span> Nov  <span>3</span> <span>15</span>:22 opt\ndr-xr-xr-x <span>151</span> root root    <span>0</span> Feb  <span>8</span> <span>16</span>:19 proc\ndr-xr-x---   <span>2</span> root root <span>4096</span> Dec  <span>4</span> <span>17</span>:37 root\ndrwxr-xr-x  <span>11</span> root root <span>4096</span> Dec  <span>4</span> <span>17</span>:37 run\nlrwxrwxrwx   <span>1</span> root root    <span>8</span> Nov  <span>3</span> <span>15</span>:22 sbin -<span>></span> usr/sbin\ndrwxr-xr-x   <span>2</span> root root <span>4096</span> Nov  <span>3</span> <span>15</span>:22 srv\ndr-xr-xr-x  <span>13</span> root root    <span>0</span> Feb  <span>8</span> <span>16</span>:19 sys\ndrwxrwxrwt   <span>7</span> root root <span>4096</span> Dec  <span>4</span> <span>17</span>:37 tmp\ndrwxr-xr-x  <span>12</span> root root <span>4096</span> Dec  <span>4</span> <span>17</span>:37 usr\ndrwxr-xr-x  <span>20</span> root root <span>4096</span> Dec  <span>4</span> <span>17</span>:37 var\n<span>[</span>root@izuf6f489inattnq5zpfcxz ~<span>]</span><span>#</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><p>可以看到此时<code>-l</code>命令被追加到<code>ls -a</code>中，最后执行了<code>ls -a -l</code></p>\n<p>其他</p>\n<div><p>Info</p>\n<ul>\n<li>每个保留关键字都是大写字母</li>\n<li>执行顺序从上到下</li>\n<li>#表示注释</li>\n<li>每一个指令都会创建提交一个<code>新的镜像层</code>，并提交</li>\n</ul>\n</div>\n<h3 id=\"示例-创建自己的centos镜像\"> 示例：创建自己的centos镜像</h3>\n<p>编写<code>dockerfile</code>文件</p>\n<div><pre><code>FROM centos\nMAINTAINER Chen Long\n\nENV MYPATH /usr/local\nWORKDIR <span>$MYPATH</span>\n\nRUN yum -y <span>install</span> <span>vim</span>\nRUN yum -y <span>install</span> tree\nRUN yum -y <span>install</span> net-tools\n\nEXPOSE <span>80</span>\n\nCMD <span>echo</span> <span>$MYPATH</span>\nCMD <span>echo</span> <span>\"---END---\"</span>\nCMD /bin/bash\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>执行build命令</p>\n<div><pre><code>docker build -f [dockerfile文件] -t [镜像名] .\n</code></pre>\n<div><span>1</span><br></div></div><p>构建完毕</p>\n<div><pre><code>Successfully built 0532ada899d9\nSuccessfully tagged mycentos:1.0.0\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>查看镜像</p>\n<div><pre><code><span>[</span>root@izuf6f489inattnq5zpfcxz mydockerfile<span>]</span><span># docker images</span>\nREPOSITORY            TAG                 IMAGE ID            CREATED             SIZE\nmycentos              <span>1.0</span>.0               0532ada899d9        <span>3</span> minutes ago       314MB\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>查看镜像构建历史</p>\n<div><pre><code><span>docker</span> <span>history</span> <span>[</span>镜像<span>]</span>\n</code></pre>\n<div><span>1</span><br></div></div><p><img src=\"./images/Docker-Note/docker_history.jpg\" alt=\"docker_history\" /></p>\n<p>重命名镜像/打标签</p>\n<div><pre><code><span>docker</span> tag <span>[</span>镜像<span>]</span>\n</code></pre>\n<div><span>1</span><br></div></div><h2 id=\"docker-compose\"> docker-compose</h2>\n<h2 id=\"docker网络\"> docker网络</h2>\n<p>::: tips 参考</p>\n<ul>\n<li>https://blog.csdn.net/meltsnow/article/details/94490994</li>\n<li>https://blog.51cto.com/ganbing/2087598</li>\n<li><a href=\"https://www.jianshu.com/p/22a7032bb7bd\" target=\"_blank\" rel=\"noopener noreferrer\">Docker四种网络模式</a></li>\n</ul>\n<p>:::</p>\n<h3 id=\"定义\"> 定义</h3>\n<p>安装Docker时，它会自动创建三个网络:</p>\n<ul>\n<li>bridge（创建容器默认连接到此网络）</li>\n<li>none</li>\n<li>host</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>网络模式</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Host</td>\n<td>容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口。</td>\n</tr>\n<tr>\n<td>Bridge</td>\n<td>此模式会为每一个容器分配、设置IP等，并将容器连接到一个docker0虚拟网桥，通过docker0网桥以及Iptables nat表配置与宿主机通信。</td>\n</tr>\n<tr>\n<td>None</td>\n<td>该模式关闭了容器的网络功能。</td>\n</tr>\n<tr>\n<td>Container</td>\n<td>创建的容器不会创建自己的网卡，配置自己的IP，而是和一个指定的容器共享IP、端口范围。</td>\n</tr>\n<tr>\n<td>自定义网络</td>\n<td>略</td>\n</tr>\n</tbody>\n</table>\n<p>使用<code>docker network ls</code>查看</p>\n<div><pre><code><span>[</span>root@izuf6f489inattnq5zpfcxz ~<span>]</span><span># docker network ls</span>\nNETWORK ID          NAME                DRIVER              SCOPE\ncdd42cba5f27        bridge              bridge              <span>local</span>\n83b40108e61e        <span>host</span>                <span>host</span>                <span>local</span>\n9b24385c4387        nginx_default       bridge              <span>local</span>\na801bf66725a        none                null                <span>local</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><blockquote>\n<p>nginx为自己安装的</p>\n</blockquote>\n<p><strong>Docker内置这三个网络，运行容器时，你可以使用该–network标志来指定容器应连接到哪些网络。</strong></p>\n<p><strong>该bridge网络代表docker0所有Docker安装中存在的网络。除非你使用该docker run --network=选项指定，否则Docker守护程序默认将容器连接到此网络。</strong></p>\n<div><div><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></div><pre><code><span>[</span>root@izuf6f489inattnq5zpfcxz ~<span>]</span><span># ip a</span>\n<span>1</span>: lo: <span>&lt;</span>LOOPBACK,UP,LOWER_UP<span>></span> mtu <span>65536</span> qdisc noqueue state UNKNOWN qlen <span>1</span>\n    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\n    inet <span>127.0</span>.0.1/8 scope <span>host</span> lo\n       valid_lft forever preferred_lft forever\n<span>2</span>: eth0: <span>&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP<span>></span> mtu <span>1500</span> qdisc pfifo_fast state UP qlen <span>1000</span>\n    link/ether 00:16:3e:10:a3:c3 brd ff:ff:ff:ff:ff:ff\n    inet <span>172.17</span>.3.46/18 brd <span>172.17</span>.63.255 scope global eth0\n       valid_lft forever preferred_lft forever\n<span>3</span>: docker0: <span>&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP<span>></span> mtu <span>1500</span> qdisc noqueue state UP\n    link/ether 02:42:22:ac:5e:95 brd ff:ff:ff:ff:ff:ff\n    inet <span>172.18</span>.0.1/16 brd <span>172.18</span>.255.255 scope global docker0\n       valid_lft forever preferred_lft forever\n<span>4</span>: br-9b24385c4387: <span>&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP<span>></span> mtu <span>1500</span> qdisc noqueue state UP\n    link/ether 02:42:ba:48:bd:cc brd ff:ff:ff:ff:ff:ff\n    inet <span>172.23</span>.0.1/16 brd <span>172.23</span>.255.255 scope global br-9b24385c4387\n       valid_lft forever preferred_lft forever\n<span>6</span>: veth76d3b86@if5: <span>&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP<span>></span> mtu <span>1500</span> qdisc noqueue master br-9b24385c4387 state UP\n    link/ether <span>76</span>:09:c0:f5:c0:de brd ff:ff:ff:ff:ff:ff link-netnsid <span>0</span>\n<span>10</span>: veth4a169f6@if9: <span>&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP<span>></span> mtu <span>1500</span> qdisc noqueue master docker0 state UP\n    link/ether <span>56</span>:2a:84:6f:4a:03 brd ff:ff:ff:ff:ff:ff link-netnsid <span>2</span>\n<span>12</span>: veth46c9f96@if11: <span>&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP<span>></span> mtu <span>1500</span> qdisc noqueue master docker0 state UP\n    link/ether 0e:7e:8a:1d:d4:c7 brd ff:ff:ff:ff:ff:ff link-netnsid <span>3</span>\n<span>14</span>: veth6a04666@if13: <span>&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP<span>></span> mtu <span>1500</span> qdisc noqueue master docker0 state UP\n    link/ether <span>72</span>:6a:3a:3c:17:83 brd ff:ff:ff:ff:ff:ff link-netnsid <span>4</span>\n<span>16</span>: vethb692a64@if15: <span>&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP<span>></span> mtu <span>1500</span> qdisc noqueue master docker0 state UP\n    link/ether 6e:82:0e:c2:09:fd brd ff:ff:ff:ff:ff:ff link-netnsid <span>5</span>\n<span>18</span>: veth976aa59@if17: <span>&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP<span>></span> mtu <span>1500</span> qdisc noqueue master docker0 state UP\n    link/ether <span>82</span>:61:29:70:0b:11 brd ff:ff:ff:ff:ff:ff link-netnsid <span>6</span>\n<span>22</span>: vethdc31829@if21: <span>&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP<span>></span> mtu <span>1500</span> qdisc noqueue master docker0 state UP\n    link/ether <span>72</span>:5a:78:af:70:c8 brd ff:ff:ff:ff:ff:ff link-netnsid <span>1</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div><p><strong>我们在使用docker run创建Docker容器时，可以用 --net 选项指定容器的网络模式，Docker可以有以下4种网络模式：</strong></p>\n<div><p>四种网络模式</p>\n<ul>\n<li><strong>host</strong>：使用 --net=host 指定。</li>\n<li><strong>none</strong>：使用 --net=none 指定。</li>\n<li><strong>bridge</strong>：使用 --net=bridge 指定，默认设置。</li>\n<li><strong>container</strong>：使用 --net=container:NAME_or_ID 指定。</li>\n</ul>\n</div>\n<h3 id=\"host\"> Host</h3>\n<p>相当于Vmware中的<code>桥接模式</code>，与宿主机在同一个网络中，但没有独立IP地址。</p>\n<p>众所周知，Docker使用了Linux的<code>Namespaces</code>技术来进行资源隔离，如<code>PID Namespace</code>隔离进程，<code>Mount Namespace</code>隔离文件系统，<code>Network Namespace</code>隔离网络等。</p>\n<p>一个Network Namespace提供了一份独立的网络环境，包括网卡、路由、Iptable规则等都与其他的Network Namespace隔离。一个Docker容器一般会分配一个独立的Network Namespace。但如果启动容器的时候使用host模式，那么这个容器将不会获得一个独立的Network Namespace，而是和宿主机共用一个Network Namespace。容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口。</p>\n<p><strong>例如，我们在172.25.6.1/24的机器上用host模式启动一个ubuntu容器</strong></p>\n<div><pre><code><span>[</span>root@server1 ~<span>]</span><span># docker run -it --network=host ubuntu</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>可以看到，容器的网络使用的时宿主机的网络，但是，容器的其他方面，如<code>文件系统</code>、<code>进程列表</code>等还是和宿主机隔离的。</p>\n<p><img src=\"./images/Docker-Note/docker_network_host.png\" alt=\"dockerfile命令1\" /></p>\n<h3 id=\"container\"> Container</h3>\n<p>在理解了host模式后，这个模式也就好理解了。这个模式指定新创建的容器和已经存在的一个容器共享一个<code>Network Namespace</code>，而不是和宿主机共享。新创建的容器不会创建自己的网卡，配置自己的IP，而是和一个指定的容器共享IP、端口范围等。同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。两个容器的进程可以通过lo网卡设备通信。</p>\n<h3 id=\"none\"> None</h3>\n<p>该模式将容器放置在它自己的网络栈中，但是并不进行任何配置。实际上，该模式关闭了容器的网络功能，在以下两种情况下是有用的：容器并不需要网络（例如只需要写磁盘卷的批处理任务）。</p>\n<div><p>overlay</p>\n<p><strong>在docker1.7代码进行了重构，单独把网络部分独立出来编写，所以在docker1.8新加入的一个overlay网络模式。Docker对于网络访问的控制也是在逐渐完善的。</strong></p>\n</div>\n<h3 id=\"bridge-默认\"> Bridge(默认)</h3>\n<p>相当于Vmware中的<code>Nat模式</code>，容器使用独立<code>network Namespace</code>，并连接到<code>docker0</code>虚拟网卡（默认模式）。通过<code>docker0网桥</code>以及<code>Iptables nat表</code>配置与宿主机通信；</p>\n<p>bridge模式是<code>Docker默认的网络设置</code>，此模式会为每一个容器分配<code>Network Namespace</code>、设置IP等，并将一个主机上的Docker容器连接到一个虚拟网桥上。下面着重介绍一下此模式。</p>\n<p>当Docker server启动时，会在主机上创建一个名为<code>docker0的虚拟网桥</code>，此主机上启动的Docker容器会连接到这个虚拟网桥上。虚拟网桥的工作方式和物理交换机类似，这样主机上的所有容器就通过交换机连在了一个二层网络中。</p>\n<p>接下来就要为容器分配IP了，Docker会从RFC1918所定义的私有IP网段中，选择一个<code>和宿主机不同的IP地址和子网</code>分配给<code>docker0</code>，连接到docker0的容器就从这个子网中选择<code>一个未占用的IP</code>使用。如一般Docker会使用172.17.0.0/16这个网段，并将172.17.0.1/16分配给docker0网桥（在主机上使用ifconfig命令是可以看到docker0的，可以认为它是网桥的管理接口，在宿主机上作为一块虚拟网卡使用）。单机环境下的网络拓扑如下，主机地址为10.10.0.186/24。</p>\n<p><img src=\"./images/Docker-Note/docker_bridge.png\" alt=\"dockerfile命令1\" /></p>\n<h4 id=\"流程\"> 流程</h4>\n<p>Docker完成以上网络配置的过程大致是这样的：</p>\n<ol>\n<li>\n<p>在主机上创建一对虚拟网卡<code>veth pair</code>设备。veth设备总是<code>成对出现</code>的，它们组成了一个数据的通道，数据从一个设备进入，就会从另一个设备出来。因此，veth设备常用来连接两个网络设备。</p>\n</li>\n<li>\n<p>Docker将veth pair设备的一端放在新创建的容器中，并命名为<code>eth0</code>。另一端放在主机中，以veth65f9这样类似的名字命名，并将这个网络设备加入到docker0网桥中，可以通过brctl show命令查看。</p>\n<div><pre><code>brctl show\nbridge name     bridge <span>id</span>               STP enabled     interfaces\ndocker0         <span>8000</span>.02425f21c208       no\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></li>\n<li>\n<p>从<code>docker0子网</code>中分配一个IP给容器使用，并设置<code>docker0的IP地址</code>为容器的<code>默认网关</code>。</p>\n<p>运行容器：</p>\n<div><pre><code><span>docker</span> run --name<span>=</span>nginx_bridge --net<span>=</span>bridge -p <span>80</span>:80 -d nginx        \n9582dbec7981085ab1f159edcc4bf35e2ee8d5a03984d214bce32a30eab4921a\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div></li>\n</ol>\n<h4 id=\"容器的通信\"> 容器的通信</h4>\n<p>在bridge模式下，连在同一网桥上的容器可以相互通信（若出于安全考虑，也可以禁止它们之间通信，方法是在<code>DOCKER_OPTS</code>变量中设置<code>–icc=false</code>，这样只有使用–link才能使两个容器通信）。</p>\n<p>Docker可以开启容器间通信（意味着默认配置–icc=true），也就是说，宿主机上的所有容器可以不受任何限制地相互通信，这可能导致拒绝服务攻击。进一步地，Docker可以通过–ip_forward和–iptables两个选项控制容器间、容器和外部世界的通信。</p>\n<p>容器也可以与外部通信，我们看一下主机上的<code>Iptable</code>规则，可以看到这么一条</p>\n<div><pre><code>-A POSTROUTING -s <span>172.17</span>.0.0/16 <span>!</span> -o docker0 -j MASQUERADE\n</code></pre>\n<div><span>1</span><br></div></div><p>这条规则会将源地址为172.17.0.0/16的包（也就是从Docker容器产生的包），并且不是从docker0网卡发出的，进行源地址转换，转换成主机网卡的地址。这么说可能不太好理解，举一个例子说明一下。假设主机有一块网卡为eth0，IP地址为10.10.101.105/24，网关为10.10.101.254。从主机上一个IP为172.17.0.1/16的容器中ping百度（180.76.3.151）。IP包首先从容器发往自己的默认网关docker0，包到达docker0后，也就到达了主机上。然后会查询主机的路由表，发现包应该从主机的eth0发往主机的网关10.10.105.254/24。接着包会转发给eth0，并从eth0发出去（主机的ip_forward转发应该已经打开）。这时候，上面的Iptable规则就会起作用，对包做SNAT转换，将源地址换为eth0的地址。这样，在外界看来，这个包就是从10.10.101.105上发出来的，Docker容器对外是不可见的。</p>\n<p>那么，外面的机器是如何访问Docker容器的服务呢？我们首先用下面命令创建一个含有web应用的容器，将容器的80端口映射到主机的80端口。</p>\n<div><pre><code><span>docker</span> run --name<span>=</span>nginx_bridge --net<span>=</span>bridge -p <span>80</span>:80 -d nginx\n</code></pre>\n<div><span>1</span><br></div></div><p><strong>此条规则就是对主机eth0收到的目的端口为80的tcp流量进行DNAT转换，将流量发往172.17.0.2:80，也就是我们上面创建的Docker容器。所以，外界只需访问10.10.101.105:80就可以访问到容器中的服务。</strong></p>\n<p><strong>除此之外，我们还可以自定义Docker使用的IP地址、DNS等信息，甚至使用自己定义的网桥，但是其工作方式还是一样的。</strong></p>\n<h3 id=\"自定义网络\"> 自定义网络</h3>\n<p><strong>建议使用自定义的网桥来控制哪些容器可以相互通信，还可以自动DNS解析容器名称到IP地址。Docker提供了创建这些网络的默认网络驱动程序，你可以创建一个新的Bridge网络，Overlay或Macvlan网络。你还可以创建一个网络插件或远程网络进行完整的自定义和控制。</strong></p>\n<p><strong>你可以根据需要创建任意数量的网络，并且可以在任何给定时间将容器连接到这些网络中的零个或多个网络。此外，您可以连接并断开网络中的运行容器，而无需重新启动容器。当容器连接到多个网络时，其外部连接通过第一个非内部网络以词法顺序提供。</strong></p>\n<p>创建网络</p>\n<div><pre><code><span>[</span>root@izuf6f489inattnq5zpfcxz ~<span>]</span><span># docker network create  --help</span>\n\nUsage:  <span>docker</span> network create <span>[</span>OPTIONS<span>]</span> NETWORK\n\nCreate a network\n\nOptions:\n      --attachable           Enable manual container attachment\n      --aux-address map      Auxiliary IPv4 or IPv6 addresses used by Network driver <span>(</span>default map<span>[</span><span>]</span><span>)</span>\n      --config-from string   The network from <span>which</span> copying the configuration\n      --config-only          Create a configuration only network\n  -d, --driver string        Driver to manage the Network <span>(</span>default <span>\"bridge\"</span><span>)</span>\n      --gateway strings      IPv4 or IPv6 Gateway <span>for</span> the master subnet\n      --ingress              Create swarm routing-mesh network\n      --internal             Restrict external access to the network\n      --ip-range strings     Allocate container <span>ip</span> from a sub-range\n      --ipam-driver string   IP Address Management Driver <span>(</span>default <span>\"default\"</span><span>)</span>\n      --ipam-opt map         Set IPAM driver specific options <span>(</span>default map<span>[</span><span>]</span><span>)</span>\n      --ipv6                 Enable IPv6 networking\n      --label list           Set metadata on a network\n  -o, --opt map              Set driver specific options <span>(</span>default map<span>[</span><span>]</span><span>)</span>\n      --scope string         Control the network's scope\n      --subnet strings       Subnet <span>in</span> CIDR <span>format</span> that represents a network segment\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><p>示例</p>\n<div><pre><code><span>docker</span> network create --driver bridge --subnet <span>192.168</span>.0.0/24 --gateway <span>192.168</span>.0.1 mynet\n</code></pre>\n<div><span>1</span><br></div></div><div><p>示例</p>\n<ul>\n<li>--driver bridge：驱动，默认为bridge</li>\n<li>--subnet 192.168.0.0/24：子网</li>\n<li>--gateway 192.168.0.1：网关</li>\n</ul>\n</div>\n<p>查看元数据</p>\n<div><pre><code><span>[</span>root@izuf6f489inattnq5zpfcxz ~<span>]</span><span># docker inspect network mynet</span>\n<span>[</span>\n    <span>{</span>\n        <span>\"Name\"</span><span>:</span> <span>\"mynet\"</span>,\n        <span>\"Id\"</span><span>:</span> <span>\"078e90effc3fef80d9596c14277c5e798dd753e0b5ab77fccb8c5b7b7eb18f40\"</span>,\n        <span>\"Created\"</span><span>:</span> <span>\"2021-02-20T00:55:36.875138453+08:00\"</span>,\n        <span>\"Scope\"</span><span>:</span> <span>\"local\"</span>,\n        <span>\"Driver\"</span><span>:</span> <span>\"bridge\"</span>,\n        <span>\"EnableIPv6\"</span><span>:</span> false,\n        <span>\"IPAM\"</span><span>:</span> <span>{</span>\n            <span>\"Driver\"</span><span>:</span> <span>\"default\"</span>,\n            <span>\"Options\"</span><span>:</span> <span>{</span><span>}</span>,\n            <span>\"Config\"</span><span>:</span> <span>[</span>\n                <span>{</span>\n                    <span>\"Subnet\"</span><span>:</span> <span>\"192.168.0.0/24\"</span>,\n                    <span>\"Gateway\"</span><span>:</span> <span>\"192.168.0.1\"</span>\n                <span>}</span>\n            <span>]</span>\n        <span>}</span>,\n        <span>\"Internal\"</span><span>:</span> false,\n        <span>\"Attachable\"</span><span>:</span> false,\n        <span>\"Ingress\"</span><span>:</span> false,\n        <span>\"ConfigFrom\"</span><span>:</span> <span>{</span>\n            <span>\"Network\"</span><span>:</span> <span>\"\"</span>\n        <span>}</span>,\n        <span>\"ConfigOnly\"</span><span>:</span> false,\n        <span>\"Containers\"</span><span>:</span> <span>{</span><span>}</span>,\n        <span>\"Options\"</span><span>:</span> <span>{</span><span>}</span>,\n        <span>\"Labels\"</span><span>:</span> <span>{</span><span>}</span>\n    <span>}</span>\n<span>]</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br></div></div><p>使用ping命令发现可以互通</p>\n<p>不同网络之间容器互通</p>\n<div><pre><code><span>docker</span> network connect <span>[</span>网络<span>]</span> <span>[</span>容器<span>]</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>其他</p>\n<ul>\n<li>在docker自定义网络部署redis集群(参考Redis部署与基本使用)</li>\n</ul>\n",
      "date_published": "2021-01-28T23:33:05.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": []
    },
    {
      "title": "Docker deployment",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/docker/Docker-deployment/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/docker/Docker-deployment/",
      "summary": "Docker deployment",
      "content_html": "<p>环境</p>\n<p>CentOs 7</p>\n<h2 id=\"_1-docker常用命令\"> 1. Docker常用命令</h2>\n<div><pre><code><span>#0.搜索收藏数不⼩于10的镜像</span>\n<span>docker</span> search -s <span>10</span> 名称\n\n<span>#1.下载镜像</span>\n<span>docker</span> pull 名称:tag\n\n<span>#2.查看下载的镜像</span>\n<span>docker</span> images<span>;</span>\n\n<span>#3.查看正在运⾏的容器</span>\n<span>docker</span> <span>ps</span>\n\n<span>#4.查看所有容器</span>\n<span>docker</span> <span>ps</span> -a\n\n<span>#5.运⾏容器</span>\n<span>docker</span> start/restart 容器名称/id\n\n<span>#6.停⽌容器</span>\n<span>docker</span> stop 容器名称/id\n\n<span>#7.在使⽤ -d 参数时，容器启动后会进⼊后台。此时想要进⼊容器，可以通过以下指令进⼊</span>\n<span>docker</span> attach 容器名称/id <span>#不推荐使⽤，因为退出时会导致容器的停⽌</span>\n<span>docker</span> <span>exec</span> -it 容器名称/id /bin/bash <span>#在进⼊容器后可使⽤linux命令，退出使⽤exit</span>\n\n<span>#8.导出</span>\n<span>docker</span> <span>export</span> 容器名称/id <span>></span> 名称.tar\n\n<span>#9.导⼊，可以使⽤ docker import 从容器快照⽂件中再导⼊为镜像，以下实例将快照⽂件指定</span>\n路径的tar 导⼊到镜像 test/test:v1:\n<span>cat</span> tar路径 <span>|</span> <span>docker</span> <span>import</span> - test/test:v1\n<span>#也可以通过指定 URL 或者某个⽬录来导⼊</span>\n<span>docker</span> <span>import</span> http://example.com/exampleimage.tgz example/imagerepo\n\n<span>#10.删除容器</span>\n<span>docker</span> <span>rm</span> -f 容器名称/id\n\n<span>#11.启动&amp;停止docker</span>\n<span>service</span> <span>docker</span> start<span>#启动docker</span>\n<span>service</span> <span>docker</span> stop<span>#停止docker</span>\n<span>service</span> <span>docker</span> restart<span>#重启docker</span>\n\n<span>#12.开机自启动docker</span>\nsystemctl <span>enable</span> <span>docker</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br></div></div><h2 id=\"_2-卸载旧版本\"> 2. 卸载旧版本</h2>\n<div><pre><code><span>sudo</span> yum remove <span>docker</span> <span>\\</span>\n docker-client <span>\\</span>\n docker-client-latest <span>\\</span>\n docker-common <span>\\</span>\n docker-latest <span>\\</span>\n docker-latest-logrotate <span>\\</span>\n docker-logrotate <span>\\</span>\n docker-engine\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h2 id=\"_3-安装-docker-engine-community\"> 3. 安装 Docker Engine-Community</h2>\n<p>在新主机上⾸次安装Docker Engine-Community之前，需要设置Docker 仓库。之后，您可以从仓库安装和更新 Docker。</p>\n<h3 id=\"_3-1-设置仓库\"> 3.1 设置仓库</h3>\n<p>安装所需的软件包。yum-utils 提供了 yum-config-manager ，并且 device mapper 存储驱动程序需要 device-mapper-persistent-data 和 lvm2。</p>\n<div><pre><code><span>sudo</span> yum <span>install</span> -y yum-utils <span>\\</span>\n device-mapper-persistent-data <span>\\</span>\n lvm2\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><img src=\"./images/Docker-deployment/setup_repository.jpg\" alt=\"\" /></p>\n<p>使⽤以下命令来设置稳定的仓库</p>\n<div><pre><code><span>#官⽅默认下载</span>\n<span>sudo</span> yum-config-manager <span>\\</span>\n --add-repo <span>\\</span>\nhttps://download.docker.com/linux/centos/docker-ce.repo\n\n<span>#阿⾥云下载</span>\n<span>sudo</span> yum-config-manager --add-repo http://mirrors.aliyun.com/dockerce/linux/centos/docker-ce.repo\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id=\"_3-2-安装-docker-engine-community\"> 3.2 安装 Docker Engine-Community</h3>\n<p>安装最新版本</p>\n<div><pre><code><span>sudo</span> yum <span>install</span> docker-ce docker-ce-cli containerd.io\n</code></pre>\n<div><span>1</span><br></div></div><p>要安装特定版本的 Docker Engine-Community，请在存储库中列出可⽤版本，然后选择并安装：</p>\n<ul>\n<li>\n<p>列出并排序您存储库中可⽤的版本。此示例按版本号（从⾼到低）对结果进⾏排序</p>\n<div><pre><code>yum list docker-ce --showduplicates <span>|</span> <span>sort</span> -r\n</code></pre>\n<div><span>1</span><br></div></div></li>\n<li>\n<p>通过其完整的软件包名称安装特定版本，该软件包名称是软件包名称（docker-ce）加上版本字符串 （第⼆列），从第⼀个冒号（:）⼀直到第⼀个连字符，并⽤连字符（-）分隔。例如：docker-ce18.09.1。</p>\n<div><pre><code><span>sudo</span> yum <span>install</span> docker-ce- docker-ce-cli- containerd.io\n</code></pre>\n<div><span>1</span><br></div></div></li>\n</ul>\n<h3 id=\"_3-3-启动docker\"> 3.3 启动Docker</h3>\n<div><pre><code><span>sudo</span> systemctl start <span>docker</span>\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"_3-4-查看docker命令\"> 3.4 查看Docker命令</h3>\n<p><img src=\"./images/Docker-deployment/docker_command.jpg\" alt=\"\" /></p>\n<h3 id=\"_3-5-镜像加速\"> 3.5 镜像加速</h3>\n<div><pre><code><span>vim</span> /etc/docker/daemon.json\n\n<span>{</span> \n\t<span>\"registry-mirrors\"</span><span>:</span> <span>[</span><span>\"http://hub-mirror.c.163.com\"</span><span>]</span> \t\n<span>}</span> \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>推荐使⽤阿⾥云加速，参考教程https://help.aliyun.com/document_detail/60750.html</p>\n<p>更改后重启服务:</p>\n<div><pre><code><span>sudo</span> systemctl daemon-reload\n<span>sudo</span> systemctl restart <span>docker</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h2 id=\"docker-compose\"> Docker-compose</h2>\n<h2 id=\"参考reference\"> 参考Reference</h2>\n<p><a href=\"https://www.runoob.com/docker/centos-docker-install.html\" target=\"_blank\" rel=\"noopener noreferrer\">CentOs Docker Install</a></p>\n",
      "date_published": "2020-05-31T15:39:08.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": []
    },
    {
      "title": "Dubbo笔记",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/dubbo/Dubbo/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/dubbo/Dubbo/",
      "content_html": "<h2 id=\"参考\"> 参考</h2>\n<div><p>Tips</p>\n<ul>\n<li><a href=\"https://blog.csdn.net/qq_41157588/article/details/106737191\" target=\"_blank\" rel=\"noopener noreferrer\">https://blog.csdn.net/qq_41157588/article/details/106737191</a></li>\n</ul>\n</div>\n",
      "date_published": "2021-05-21T15:46:07.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": []
    },
    {
      "title": "ElasticSearch面试",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/elasticSearch/ElasticSearch-Interview/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/elasticSearch/ElasticSearch-Interview/",
      "content_html": "<h2 id=\"参考\"> 参考</h2>\n<div><p>参考</p>\n<ul>\n<li>https://blog.csdn.net/u011863024/article/details/115721328#62_6230</li>\n</ul>\n</div>\n<h2 id=\"为什么要使用-elasticsearch\"> 为什么要使用 Elasticsearch？</h2>\n<p>系统中的数据， 随着业务的发展，时间的推移， 将会非常多， 而业务中往往采用模糊查询进行数据的搜索， 而模糊查询会导致查询引擎放弃索引，导致系统查询数据时都是全表扫描，在百万级别的数据库中，查询效率是非常低下的，而我们使用 ES 做一个全文索引，将经常查询的系统功能的某些字段，比如说电商系统的商品表中商品名，描述、价格还有 id 这些字段我们放入 ES 索引库里，可以提高查询速度。</p>\n<h2 id=\"elasticsearch-的-master-选举流程\"> Elasticsearch 的 master 选举流程？</h2>\n<p>Elasticsearch的选主是ZenDiscovery模块负责的，主要包含Ping（节点之间通过这个RPC来发现彼此）和Unicast（单播模块包含-一个主机列表以控制哪些节点需要ping通）这两部分。\n对所有可以成为master的节点（node master: true）根据nodeId字典排序，每次选举每个节点把自己所知道节点排一次序，然后选出第一个（第0位）节点，暂且认为它是master节点。</p>\n<p>如果对某个节点的投票数达到一定的值（可以成为master节点数n/2+1）并且该节点自己也选举自己，那这个节点就是master。否则重新选举一直到满足上述条件。master节点的职责主要包括群、节点和索引的管理，不负责文档级别的管理；data节点可以关闭http\n功能。</p>\n<h2 id=\"elasticsearch-集群脑裂问题\"> Elasticsearch 集群脑裂问题？</h2>\n<p>“脑裂”问题可能的成因：</p>\n<p>网络问题：集群间的网络延迟导致一些节点访问不到master, 认为master 挂掉了从而选举出新的master,并对master上的分片和副本标红，分配新的主分片。\n节点负载：主节点的角色既为master又为data,访问量较大时可能会导致ES停止响应造成大面积延迟，此时其他节点得不到主节点的响应认为主节点挂掉了，会重新选取主节点。\n内存回收：data 节点上的ES进程占用的内存较大，引发JVM的大规模内存回收，造成ES进程失去响应。</p>\n<h3 id=\"脑裂问题解决方案\"> 脑裂问题解决方案</h3>\n<ul>\n<li>\n<p>减少误判：discovery.zen ping_ timeout 节点状态的响应时间，默认为3s，可以适当调大，如果master在该响应时间的范围内没有做出响应应答，判断该节点已经挂掉了。调大参数（如6s，discovery.zen.ping_timeout:6），可适当减少误判。</p>\n</li>\n<li>\n<p>选举触发：discovery.zen.minimum. <em>master</em> nodes:1，该参數是用于控制选举行为发生的最小集群主节点数量。当备选主节点的个數大于等于该参数的值，且备选主节点中有该参数个节点认为主节点挂了，进行选举。官方建议为(n / 2) +1, n为主节点个数（即有资格成为主节点的节点个数）。</p>\n</li>\n<li>\n<p>角色分离：即master节点与data节点分离，限制角色</p>\n<ul>\n<li>主节点配置为：node master: true，node data: false</li>\n<li>从节点配置为：node master: false，node data: true</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"elasticsearch-索引文档的流程\"> Elasticsearch 索引文档的流程？</h2>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/1bdc6c30d1be9b1bff83a683c64d2ac7.png\" alt=\"img\" /></p>\n<p>协调节点默认使用文档 ID 参与计算（也支持通过 routing），以便为路由提供合适的分片：shard = hash(document_id) % (num_of_primary_shards)当分片所在的节点接收到来自协调节点的请求后，会将请求写入到 Memory Buffer，然后定时（默认是每隔 1 秒）写入到 Filesystem Cache，这个从 Memory Buffer 到 Filesystem Cache 的过程就叫做 refresh；</p>\n<p>当然在某些情况下，存在 Momery Buffer 和 Filesystem Cache 的数据可能会丢失， ES 是通过 translog的机制来保证数据的可靠性的。其实现机制是接收到请求后，同时也会写入到 translog 中，当 Filesystemcache 中的数据写入到磁盘中时，才会清除掉，这个过程叫做 flush；\n在 flush 过程中，内存中的缓冲将被清除，内容被写入一个新段，段的 fsync 将创建一个新的提交点，并将内容刷新到磁盘，旧的 translog 将被删除并开始一个新的 translog。</p>\n<p>flush 触发的时机是定时触发（默认 30 分钟）或者 translog 变得太大（默认为 512M）时；</p>\n<h2 id=\"elasticsearch-更新和删除文档的流程\"> Elasticsearch 更新和删除文档的流程？</h2>\n<p>删除和更新也都是写操作，但是 Elasticsearch 中的文档是不可变的，因此不能被删除或者改动以展示其变更；</p>\n<p>磁盘上的每个段都有一个相应的.del 文件。当删除请求发送后，文档并没有真的被删除，而是在.del文件中被标记为删除。该文档依然能匹配查询，但是会在结果中被过滤掉。当段合并时，在.del 文件中被标记为删除的文档将不会被写入新段。</p>\n<p>在新的文档被创建时， Elasticsearch 会为该文档指定一个版本号，当执行更新时，旧版本的文档在.del文件中被标记为删除，新版本的文档被索引到一个新段。旧版本的文档依然能匹配查询，但是会在结果中被过滤掉。</p>\n<h2 id=\"elasticsearch-搜索的流程\"> Elasticsearch 搜索的流程？</h2>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/053a14eee04ace7b4e5aec0ce53a5284.png\" alt=\"img\" /></p>\n<p>搜索被执行成一个两阶段过程，我们称之为 <code>Query Then Fetch</code>；</p>\n<ul>\n<li>在初始查询阶段时，查询会广播到索引中每一个分片拷贝（主分片或者副本分片）。 每个分片在本地执行搜索并构建一个匹配文档的大小为 <code>from + size</code> 的优先队列。 PS：在搜索的时候是会查询<code>Filesystem Cache</code> 的，但是有部分数据还在 <code>Memory Buffer</code>，所以搜索是近实时的。</li>\n<li>每个分片返回各自优先队列中 所有文档的 ID 和排序值 给协调节点，它合并这些值到自己的优先队列中来产生一个全局排序后的结果列表。</li>\n<li>接下来就是取回阶段， 协调节点辨别出哪些文档需要被取回并向相关的分片提交多个 GET 请求。每个分片加载并丰富文档，如果有需要的话，接着返回文档给协调节点。一旦所有的文档都被取回了，协调节点返回结果给客户端。</li>\n<li>Query Then Fetch 的搜索类型在文档相关性打分的时候参考的是本分片的数据，这样在文档数量较少的时候可能不够准确， DFS Query Then Fetch 增加了一个预查询的处理，询问 Term 和 Document frequency，这个评分更准确，但是性能会变差。</li>\n</ul>\n<h2 id=\"elasticsearch-在部署时-对-linux-的设置有哪些优化方法\"> Elasticsearch 在部署时，对 Linux 的设置有哪些优化方法？</h2>\n<ul>\n<li>\n<p>64 GB 内存的机器是非常理想的， 但是 32 GB 和 16 GB 机器也是很常见的。少于 8 GB 会适得其反。</p>\n</li>\n<li>\n<p>如果你要在更快的 CPUs 和更多的核心之间选择，选择更多的核心更好。多个内核提供的额外并发远胜过稍微快一点点的时钟频率。</p>\n</li>\n<li>\n<p>如果你负担得起 SSD，它将远远超出任何旋转介质。 基于 SSD 的节点，查询和索引性能都有提升。如果你负担得起， SSD 是一个好的选择。</p>\n</li>\n<li>\n<p>即使数据中心们近在咫尺，也要避免集群跨越多个数据中心。绝对要避免集群跨越大的地理距离。</p>\n</li>\n<li>\n<p>请确保运行你应用程序的 JVM 和服务器的 JVM 是完全一样的。 在 Elasticsearch 的几个地方，使用 Java 的本地序列化。</p>\n</li>\n<li>\n<p>通过设置 gateway.recover_after_nodes、 gateway.expected_nodes、 gateway.recover_after_time 可以在集群重启的时候避免过多的分片交换，这可能会让数据恢复从数个小时缩短为几秒钟。</p>\n</li>\n<li>\n<p>Elasticsearch 默认被配置为使用单播发现，以防止节点无意中加入集群。只有在同一台机器上运行的节点才会自动组成集群。最好使用单播代替组播。</p>\n</li>\n<li>\n<p>不要随意修改垃圾回收器（CMS）和各个线程池的大小。</p>\n</li>\n<li>\n<p>把你的内存的（少于）一半给 Lucene（但不要超过 32 GB！），通过 ES_HEAP_SIZE 环境变量设置。</p>\n</li>\n<li>\n<p>内存交换到磁盘对服务器性能来说是致命的。如果内存交换到磁盘上，一个 100 微秒的操作可能变成 10 毫秒。 再想想那么多 10 微秒的操作时延累加起来。 不难看出 swapping 对于性能是多么可怕。</p>\n</li>\n<li>\n<p>Lucene 使用了大量的文件。同时， Elasticsearch 在节点和 HTTP 客户端之间进行通信也使用了大量的套接字。 所有这一切都需要足够的文件描述符。你应该增加你的文件描述符，设置一个很大的值，如 64,000。</p>\n</li>\n</ul>\n<h2 id=\"gc-方面-在使用-elasticsearch-时要注意什么\"> GC 方面，在使用 Elasticsearch 时要注意什么？</h2>\n<ul>\n<li>\n<p>倒排词典的索引需要常驻内存，无法 GC，需要监控 data node 上 segment memory 增长趋势。</p>\n</li>\n<li>\n<p>各类缓存， field cache, filter cache, indexing cache, bulk queue 等等，要设置合理的大小，并且要应该根据最坏的情况来看 heap 是否够用，也就是各类缓存全部占满的时候，还有 heap 空间可以分配给其他任务吗？避免采用 clear cache 等“自欺欺人”的方式来释放内存。</p>\n</li>\n<li>\n<p>避免返回大量结果集的搜索与聚合。确实需要大量拉取数据的场景，可以采用 scan &amp; scroll api 来实现。</p>\n</li>\n<li>\n<p>cluster stats 驻留内存并无法水平扩展，超大规模集群可以考虑分拆成多个集群通过 tribe node 连接。</p>\n</li>\n<li>\n<p>想知道 heap 够不够，必须结合实际应用场景，并对集群的 heap 使用情况做持续的监控。</p>\n</li>\n</ul>\n<h2 id=\"elasticsearch-对于大数据量-上亿量级-的聚合如何实现\"> Elasticsearch 对于大数据量（上亿量级）的聚合如何实现？</h2>\n<p>Elasticsearch 提供的首个近似聚合是 cardinality 度量。它提供一个字段的基数，即该字段的 distinct或者 unique 值的数目。它是基于 HLL 算法的。 HLL 会先对我们的输入作哈希运算，然后根据哈希运算的结果中的 bits 做概率估算从而得到基数。其特点是：可配置的精度，用来控制内存的使用（更精确 ＝ 更多内存）；小的数据集精度是非常高的；我们可以通过配置参数，来设置去重需要的固定内存使用量。无论数千还是数十亿的唯一值，内存使用量只与你配置的精确度相关。</p>\n<h2 id=\"在并发情况下-elasticsearch-如果保证读写一致\"> 在并发情况下， Elasticsearch 如果保证读写一致？</h2>\n<p>可以通过版本号使用乐观锁并发控制，以确保新版本不会被旧版本覆盖，由应用层来处理具体的冲突；</p>\n<ul>\n<li>\n<p>另外对于写操作，一致性级别支持 quorum/one/all，默认为 quorum，即只有当大多数分片可用时才允许写操作。但即使大多数可用，也可能存在因为网络等原因导致写入副本失败，这样该副本被认为故障，分片将会在一个不同的节点上重建。</p>\n</li>\n<li>\n<p>对于读操作，可以设置 replication 为 sync(默认)，这使得操作在主分片和副本分片都完成后才会返回；如果设置 replication 为 async 时，也可以通过设置搜索请求参数_preference 为 primary 来查询主分片，确保文档是最新版本。</p>\n</li>\n</ul>\n<h2 id=\"如何监控-elasticsearch-集群状态\"> 如何监控 Elasticsearch 集群状态？</h2>\n<p>elasticsearch-head 插件。\n通过 Kibana 监控 Elasticsearch。你可以实时查看你的集群健康状态和性能，也可以分析过去的集群、索引和节点指标</p>\n<h2 id=\"是否了解字典树\"> 是否了解字典树？</h2>\n<p>字典树又称单词查找树， Trie 树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高。</p>\n<p>Trie 的核心思想是空间换时间，利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。它有 3 个基本性质：</p>\n<ul>\n<li>根节点不包含字符，除根节点外每一个节点都只包含一个字符。</li>\n<li>从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串。</li>\n<li>每个节点的所有子节点包含的字符都不相同。</li>\n</ul>\n<p>对于中文的字典树，每个节点的子节点用一个哈希表存储，这样就不用浪费太大的空间，而且查询速度上可以保留哈希的复杂度 O(1)。</p>\n<h2 id=\"elasticsearch-中的集群、节点、索引、文档、类型是什么\"> Elasticsearch 中的集群、节点、索引、文档、类型是什么？</h2>\n<ul>\n<li><strong>集群</strong>：是一个或多个节点（服务器）的集合，它们共同保存您的整个数据，并提供跨所有节点的联合索引和搜索功能。群集由唯一名 称标识，默认情况下为&quot;elasticsearch&quot;。此名称很重要，因为如果节点设置为按名称加入群集，则该节点只能是群集的一部分。</li>\n<li><strong>节点</strong>：是属于集群一部分的单个服务器。它存储数据并参与群集索引和搜索功能。</li>\n<li><strong>索引</strong>：就像关系数据库中的“数据库”。它有一个定义多种类型的映射。索引是逻辑名称空间，映射到一个或多个主分片，并且可以有零个或多个副本分片。MySQL =&gt;数据库，Elasticsearch=&gt;索引。</li>\n<li><strong>文档</strong>：类似于关系数据库中的一行。不同之处在于索引中的每个文档可以具有不同的结构(字段)，但是对于通用字段应该具有相同的数据类型。MySQL =&gt; Databases =&gt; Tables =&gt; Columns / Rows，Elasticsearch=&gt; Indices =&gt; Types =&gt;具有属性的文档Doc。</li>\n<li><strong>类型</strong>：是索引的逻辑类别/分区，其语义完全取决于用户。</li>\n</ul>\n<h2 id=\"elasticsearch-中的倒排索引是什么\"> Elasticsearch 中的倒排索引是什么？</h2>\n<p>倒排索引是搜索引擎的核心。搜索引擎的主要目标是在查找发生搜索条件的文档时提供快速搜索。ES中的倒排索引其实就是 <code>lucene</code> 的倒排索引，区别于传统的正向索引， 倒排索引会再存储数据时将关键词和数据进行关联，保存到倒排表中，然后查询时，将查询内容进行分词后在倒排表中进行查询，最后匹配数据即可。</p>\n",
      "image": "https://img-blog.csdnimg.cn/img_convert/1bdc6c30d1be9b1bff83a683c64d2ac7.png",
      "date_published": "2021-05-25T23:13:57.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": []
    },
    {
      "title": "ElasticSearch笔记",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/elasticSearch/ElasticSearch/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/elasticSearch/ElasticSearch/",
      "content_html": "<h2 id=\"参考\"> 参考</h2>\n<div><p>参考</p>\n<ul>\n<li><a href=\"https://www.bilibili.com/video/BV1hh411D7sb?from=search&amp;seid=13278230873440832054\" target=\"_blank\" rel=\"noopener noreferrer\">尚硅谷视频</a></li>\n<li><a href=\"https://blog.csdn.net/u011863024/article/details/115721328\" target=\"_blank\" rel=\"noopener noreferrer\">尚硅谷笔记</a></li>\n<li><a href=\"https://www.elastic.co/guide/cn/elasticsearch/guide/current/index.html\" target=\"_blank\" rel=\"noopener noreferrer\">官方文档</a></li>\n</ul>\n</div>\n<h2 id=\"安装\"> 安装</h2>\n<p>官网：<a href=\"https://www.elastic.co/cn/elasticsearch/\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.elastic.co/cn/elasticsearch/</a></p>\n<h2 id=\"学习路线\"> 学习路线</h2>\n<ul>\n<li>第1章 Elasticsearch概述</li>\n<li>第2章 Elasticsearch入门</li>\n<li>第3章 Elasticsearch环境</li>\n<li>第4章 Elasticsearch进阶</li>\n<li>第5章 Elasticsearch集成</li>\n<li>第6章 Elasticsearch优化</li>\n<li>第7章 Elasticsearch面试题</li>\n</ul>\n<h2 id=\"概述\"> 概述</h2>\n<p>Elaticsearch，简称为 ES， ES 是一个<strong>开源的高扩展的分布式全文搜索引擎</strong>， 是整个 ElasticStack 技术栈的核心。</p>\n<h2 id=\"部署\"> 部署</h2>\n<p>Windows 版的 Elasticsearch 压缩包，解压即安装完毕，解压后的 Elasticsearch 的目录结构如下 ：</p>\n<table>\n<thead>\n<tr>\n<th>目录</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>bin</td>\n<td>可执行脚本目录</td>\n</tr>\n<tr>\n<td>config</td>\n<td>配置目录</td>\n</tr>\n<tr>\n<td>jdk</td>\n<td>内置 JDK 目录</td>\n</tr>\n<tr>\n<td>lib</td>\n<td>类库</td>\n</tr>\n<tr>\n<td>logs</td>\n<td>日志目录</td>\n</tr>\n<tr>\n<td>modules</td>\n<td>模块目录</td>\n</tr>\n<tr>\n<td>plugins</td>\n<td>插件目录</td>\n</tr>\n</tbody>\n</table>\n<p>解压后，进入 bin 文件目录，点击 elasticsearch.bat 文件启动 ES 服务 。</p>\n<p>注意： 9300 端口为 Elasticsearch 集群间组件的通信端口， 9200 端口为浏览器访问的 http协议 RESTful 端口。</p>\n<p>打开浏览器，输入地址： http://localhost:9200，测试返回结果，返回结果如下：</p>\n<div><pre><code><span>{</span>\n  <span>\"name\"</span> <span>:</span> <span>\"DESKTOP-LNJQ0VF\"</span><span>,</span>\n  <span>\"cluster_name\"</span> <span>:</span> <span>\"elasticsearch\"</span><span>,</span>\n  <span>\"cluster_uuid\"</span> <span>:</span> <span>\"nCZqBhfdT1-pw8Yas4QU9w\"</span><span>,</span>\n  <span>\"version\"</span> <span>:</span> <span>{</span>\n    <span>\"number\"</span> <span>:</span> <span>\"7.8.0\"</span><span>,</span>\n    <span>\"build_flavor\"</span> <span>:</span> <span>\"default\"</span><span>,</span>\n    <span>\"build_type\"</span> <span>:</span> <span>\"zip\"</span><span>,</span>\n    <span>\"build_hash\"</span> <span>:</span> <span>\"757314695644ea9a1dc2fecd26d1a43856725e65\"</span><span>,</span>\n    <span>\"build_date\"</span> <span>:</span> <span>\"2020-06-14T19:35:50.234439Z\"</span><span>,</span>\n    <span>\"build_snapshot\"</span> <span>:</span> <span>false</span><span>,</span>\n    <span>\"lucene_version\"</span> <span>:</span> <span>\"8.5.1\"</span><span>,</span>\n    <span>\"minimum_wire_compatibility_version\"</span> <span>:</span> <span>\"6.8.0\"</span><span>,</span>\n    <span>\"minimum_index_compatibility_version\"</span> <span>:</span> <span>\"6.0.0-beta1\"</span>\n  <span>}</span><span>,</span>\n  <span>\"tagline\"</span> <span>:</span> <span>\"You Know, for Search\"</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h2 id=\"倒排索引\"> 倒排索引</h2>\n<p>正排索引（传统）</p>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>content</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1001</td>\n<td>my name is zhang san</td>\n</tr>\n<tr>\n<td>1002</td>\n<td>my name is li si</td>\n</tr>\n</tbody>\n</table>\n<p>倒排索引</p>\n<table>\n<thead>\n<tr>\n<th>keyword</th>\n<th>id</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>name</td>\n<td>1001, 1002</td>\n</tr>\n<tr>\n<td>zhang</td>\n<td>1001</td>\n</tr>\n</tbody>\n</table>\n<p>Elasticsearch 是<strong>面向文档型数据库</strong>，一条数据在这里就是一个文档。 为了方便大家理解，我们将 Elasticsearch 里存储文档数据和关系型数据库 MySQL 存储数据的概念进行一个类比</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/146a779da01f53e7f7a8d53132d3c7cf.png\" alt=\"\" /></p>\n<p>ES 里的 Index 可以看做一个库，而 Types 相当于表， Documents 则相当于表的行。这里 Types 的概念已经被逐渐弱化， Elasticsearch 6.X 中，一个 index 下已经只能包含一个type， Elasticsearch 7.X 中, Type 的概念已经被删除了。</p>\n<h2 id=\"elasticsearch对象\"> ElasticSearch对象</h2>\n<h3 id=\"索引-index\"> 索引（index）</h3>\n<p>​\t一个索引就是一个拥有几分相似特征的文档的集合。比如说，你可以有一个客户数据的索引，另一个产品目录的索引，还有一个订单数据的索引。一个索引由一个名字来标识（必须全部是小写字母），并且当我们要对这个索引中的文档进行索引、搜索、更新和删除（CRUD）的时候，都要使用到这个名字。在一个集群中，可以定义任意多的索引。</p>\n<p>能搜索的数据必须索引，这样的好处是可以提高查询速度，比如：新华字典前面的目录就是索引的意思，目录可以提高查询速度。</p>\n<h3 id=\"类型-type\"> 类型（type）</h3>\n<p>在一个索引中，你可以定义一种或多种类型。</p>\n<p>一个类型是你的索引的一个逻辑上的分类/分区，其语义完全由你来定。通常，会为具有一组共同字段的文档定义一个类型。不同的版本，类型发生了不同的变化。</p>\n<table>\n<thead>\n<tr>\n<th>版本</th>\n<th>Type</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>5.x</td>\n<td>支持多种 type</td>\n</tr>\n<tr>\n<td>6.x</td>\n<td>只能有一种 type</td>\n</tr>\n<tr>\n<td>7.x</td>\n<td>默认不再支持自定义索引类型（默认类型为： _doc）</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"文档-document\"> 文档（Document）</h3>\n<p>一个文档是一个可被索引的基础信息单元，也就是一条数据。</p>\n<p>比如：你可以拥有某一个客户的文档，某一个产品的一个文档，当然，也可以拥有某个订单的一个文档。文档以 JSON（Javascript Object Notation）格式来表示，而 JSON 是一个到处存在的互联网数据交互格式。</p>\n<p>在一个 <code>index/type</code> 里面，你可以存储任意多的文档。</p>\n<h3 id=\"字段-field\"> 字段（Field）</h3>\n<p>相当于是数据表的字段，对文档数据根据不同属性进行的分类标识。</p>\n<h3 id=\"映射-mapping\"> 映射（Mapping）</h3>\n<p>mapping 是处理数据的方式和规则方面做一些限制，如：某个字段的数据类型、默认值、分析器、是否被索引等等。这些都是映射里面可以设置的，其它就是处理 ES 里面数据的一些使用规则设置也叫做映射，按着最优规则处理数据对性能提高很大，因此才需要建立映射，并且需要思考如何建立映射才能对性能更好。</p>\n<h3 id=\"分片-shards\"> 分片（Shards）</h3>\n<p>​\t一个索引可以存储超出单个节点硬件限制的大量数据。比如，一个具有 10 亿文档数据的索引占据 1TB 的磁盘空间，而任一节点都可能没有这样大的磁盘空间。 或者单个节点处理搜索请求，响应太慢。为了解决这个问题，**Elasticsearch 提供了将索引划分成多份的能力，每一份就称之为分片。**当你创建一个索引的时候，你可以指定你想要的分片的数量。每个分片本身也是一个功能完善并且独立的“索引”，这个“索引”可以被放置到集群中的任何节点上。</p>\n<p>分片很重要，主要有两方面的原因：</p>\n<div><p>Info</p>\n<ul>\n<li>允许你水平分割 / 扩展你的内容容量。</li>\n<li>允许你在分片之上进行分布式的、并行的操作，进而提高性能/吞吐量。</li>\n</ul>\n</div>\n<blockquote>\n<p>至于一个分片怎样分布，它的文档怎样聚合和搜索请求，是完全由 Elasticsearch 管理的，对于作为用户的你来说，这些都是透明的，无需过分关心。</p>\n</blockquote>\n<p>被混淆的概念是，一个 <code>Lucene</code> 索引 我们在 Elasticsearch 称作 <code>分片</code> 。 一个Elasticsearch 索引 是分片的集合。 当 Elasticsearch 在索引中搜索的时候， 他发送查询到每一个属于索引的分片（Lucene 索引），然后合并每个分片的结果到一个全局的结果集。</p>\n<p>Lucene 是 Apache 软件基金会 Jakarta 项目组的一个子项目，提供了一个简单却强大的应用程式接口，能够做<code>全文索引和搜寻</code>。在 Java 开发环境里 Lucene 是一个成熟的免费开源工具。就其本身而言， Lucene 是当前以及最近几年最受欢迎的免费 Java 信息检索程序库。但 Lucene 只是一个<code>提供全文搜索功能类库的核心工具包</code>，而真正使用它还需要一个完善的服务框架搭建起来进行应用。</p>\n<p>目前市面上流行的搜索引擎软件，主流的就两款： Elasticsearch 和 Solr,这两款都是基于 Lucene 搭建的，可以独立部署启动的搜索引擎服务软件。由于内核相同，所以两者除了服务器安装、部署、管理、集群以外，对于数据的操作 修改、添加、保存、查询等等都十分类似。</p>\n<h3 id=\"副本-replicas\"> 副本（Replicas）</h3>\n<p>在一个网络 / 云的环境里，失败随时都可能发生，在某个分片/节点不知怎么的就处于离线状态，或者由于任何原因消失了，这种情况下，有一个<code>故障转移机制</code>是非常有用并且是强烈推荐的。为此目的， Elasticsearch 允许你创建分片的一份或多份拷贝，这些拷贝叫做<code>复制分片(副本)</code>。</p>\n<p>复制分片之所以重要，有两个主要原因：</p>\n<div><p>Info</p>\n<ul>\n<li>在分片/节点失败的情况下，提供了高可用性。因为这个原因，注意到复制分片从不与原/主要（original/primary）分片置于同一节点上是非常重要的。</li>\n<li>扩展你的搜索量/吞吐量，因为搜索可以在所有的副本上并行运行。</li>\n</ul>\n</div>\n<p>总之，每个索引可以被分成多个分片。一个索引也可以被复制 0 次（意思是没有复制）或多次。一旦复制了，每个索引就有了主分片（作为复制源的原来的分片）和复制分片（主分片的拷贝）之别。</p>\n<p>分片和复制的数量可以在索引创建的时候指定。在索引创建之后，你可以在任何时候动态地改变<code>复制(副本)</code>的数量，但是你事后不能改变分片的数量。</p>\n<p>默认情况下，Elasticsearch 中的每个索引被分片 1 个主分片和 1 个复制，这意味着，如果你的集群中至少有两个节点，你的索引将会有 1 个主分片和另外 1 个复制分片（1 个完全拷贝），这样的话每个索引总共就有 2 个分片， 我们需要根据索引需要确定分片个数。</p>\n<h3 id=\"分配-allocation\"> 分配（Allocation）</h3>\n<p>将分片分配给某个节点的过程，包括分配主分片或者副本。如果是副本，还包含从主分片复制数据的过程。这个过程是由 master 节点完成的。</p>\n<h2 id=\"操作\"> 操作</h2>\n<h3 id=\"http操作\"> HTTP操作</h3>\n<p>参考笔记</p>\n<h3 id=\"java-api操作\"> Java API操作</h3>\n<p>参考笔记</p>\n<h3 id=\"集群搭建\"> 集群搭建</h3>\n<p>参考笔记</p>\n<h2 id=\"面试题\"> 面试题</h2>\n",
      "image": "https://img-blog.csdnimg.cn/img_convert/146a779da01f53e7f7a8d53132d3c7cf.png",
      "date_published": "2021-05-07T20:06:38.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": []
    },
    {
      "title": "Spring错误笔记",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/error/Springboot-Error/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/error/Springboot-Error/",
      "content_html": "<h2 id=\"解决springboot无法注入service的原因之一testcontroller-required-a-bean-of-type-com-yifeng-study-service-userservice-that-could-not-be-found-报错\"> 解决SpringBoot无法注入service的原因之一TestController required a bean of type ‘com.yifeng.study.service.UserService’ that could not be found.报错</h2>\n<p>参考</p>\n<div><p>Tips</p>\n<p><a href=\"https://blog.csdn.net/xzxToney/article/details/105248704?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1.control\" target=\"_blank\" rel=\"noopener noreferrer\">参考</a></p>\n</div>\n<h4 id=\"原因\"> 原因</h4>\n<h3 id=\"如果此时service上已经加了注解-service或者没有其他基本问题-那么可能是主启动类与被扫描的文件夹不在同一路径下-所以扫描不到。\"> 如果此时service上已经加了注解<code>@Service</code>或者没有其他基本问题，那么可能是<strong>主启动类与被扫描的文件夹不在同一路径</strong>下，所以扫描不到。</h3>\n<h3 id=\"解决办法\"> 解决办法</h3>\n<p>将启动器类放在与扫描包同级即可，一般是和controller包的上一层的包的同一级。例如</p>\n<blockquote>\n<p>我在这里多了一层web,将主启动类放入study文件夹下，和web同级即可。</p>\n</blockquote>\n<h2 id=\"将枚举类型输出时转换为json类型\"> 将枚举类型输出时转换为JSON类型</h2>\n<p>加上注解</p>\n<div><pre><code><span>@JsonFormat</span><span>(</span>shape <span>=</span> <span>JsonFormat<span>.</span>Shape</span><span>.</span>OBJECT<span>)</span>\n</code></pre>\n<div><span>1</span><br></div></div><h2 id=\"nginx在做反向代理时添加一层访问根路径\"> Nginx在做反向代理时添加一层访问根路径</h2>\n<p>修改<code>application.yml</code></p>\n<div><pre><code>server:\n  port: <span>8889</span>\n  servlet:\n    context-path: /api\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>这样访问时底层加一层根路径访问</p>\n",
      "date_published": "2021-03-04T20:29:53.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": []
    },
    {
      "title": "JavaScript面试题",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/front-end/JavaScript-Interview/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/front-end/JavaScript-Interview/",
      "summary": "JavaScript面试题",
      "content_html": "<h2 id=\"js作用域\"> JS作用域</h2>\n<p>参考</p>\n<blockquote>\n<ul>\n<li>\n<p><a href=\"https://blog.csdn.net/weixin_33933118/article/details/91456939?utm_medium=distribute.pc_relevant.none-task-blog-OPENSEARCH-2.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-OPENSEARCH-2.channel_param\" target=\"_blank\" rel=\"noopener noreferrer\">深入理解JavaScript作用域和作用域链</a></p>\n</li>\n<li>\n<p><a href=\"%5Bhttps://blog.csdn.net/qq_37309764/article/details/105659829?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~all~first_rank_v2~rank_v25-1-105659829.nonecase&amp;utm_term=js%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%5D(https://blog.csdn.net/qq_37309764/article/details/105659829?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~all~first_rank_v2~rank_v25-1-105659829.nonecase&amp;utm_term=js%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D)\">什么是作用域？几种常见的作用域详解</a></p>\n</li>\n</ul>\n</blockquote>\n",
      "date_published": "2020-09-20T12:07:36.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": []
    },
    {
      "title": "Promise异步调用",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/front-end/Promise_Asynchronous_call/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/front-end/Promise_Asynchronous_call/",
      "summary": "Promise异步调用",
      "content_html": "<p>官方文档</p>\n<blockquote>\n<p>https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise</p>\n</blockquote>\n<p>阮一峰ES6文档</p>\n<blockquote>\n<p>https://es6.ruanyifeng.com/#docs/promise</p>\n</blockquote>\n<h2 id=\"基本使用\"> 基本使用</h2>\n<h3 id=\"第一种方法\"> 第一种方法</h3>\n<div><pre><code><span><span>&lt;!</span><span>DOCTYPE</span> <span>html</span><span>></span></span>\n<span><span><span>&lt;</span>html</span><span>></span></span>\n\t<span><span><span>&lt;</span>head</span><span>></span></span>\n\t\t<span><span><span>&lt;</span>meta</span> <span>charset</span><span><span>=</span><span>\"</span>utf-8<span>\"</span></span> <span>/></span></span>\n\t\t<span><span><span>&lt;</span>title</span><span>></span></span><span><span><span>&lt;/</span>title</span><span>></span></span>\n\t<span><span><span>&lt;/</span>head</span><span>></span></span>\n\t<span><span><span>&lt;</span>body</span><span>></span></span>\n\t\t<span><span><span>&lt;</span>script</span> <span>src</span><span><span>=</span><span>\"</span>https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js<span>\"</span></span><span>></span></span><span><span>\n\t\t</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>\n\t\t<span><span><span>&lt;</span>script</span> <span>type</span><span><span>=</span><span>\"</span>text/javascript<span>\"</span></span><span>></span></span><span><span>\n\t\t\t<span>$</span><span>(</span>document<span>)</span><span>.</span><span>ready</span><span>(</span><span>function</span><span>(</span><span>)</span> <span>{</span>\n\t\t\t\t<span>var</span> form <span>=</span> <span>{</span>\n\t\t\t\t\t<span>username</span><span>:</span> <span>'admin'</span><span>,</span>\n\t\t\t\t\t<span>password</span><span>:</span> <span>'macro123'</span>\n\t\t\t\t<span>}</span>\n        \n\t\t\t\t<span>/*创建promise对象*/</span>\n\t\t\t\t<span>const</span> promise <span>=</span> <span>new</span> <span>Promise</span><span>(</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>=></span> <span>{</span>\n\t\t\t\t\t$<span>.</span><span>ajax</span><span>(</span><span>{</span>\n\t\t\t\t\t\t<span>type</span><span>:</span> <span>'post'</span><span>,</span>\n\t\t\t\t\t\t<span>url</span><span>:</span> <span>'http://118.89.176.28:8080/admin/login'</span><span>,</span>\n\t\t\t\t\t\t<span>dataType</span><span>:</span> <span>'json'</span><span>,</span>\n\t\t\t\t\t\t<span>contentType</span><span>:</span> <span>'application/json;charset=UTF-8'</span><span>,</span>\n\t\t\t\t\t\t<span>data</span><span>:</span> <span>JSON</span><span>.</span><span>stringify</span><span>(</span>form<span>)</span><span>,</span>\n\t\t\t\t\t\t<span>success</span><span>:</span> <span>function</span><span>(</span><span>res</span><span>)</span> <span>{</span>\n\t\t\t\t\t\t\tconsole<span>.</span><span>log</span><span>(</span>res<span>)</span>\n\t\t\t\t\t\t\t<span>resolve</span><span>(</span>res<span>)</span>\n\t\t\t\t\t\t<span>}</span>\n\t\t\t\t\t<span>}</span><span>)</span><span>;</span>\n\t\t\t\t<span>}</span><span>)</span>\n                \n\t\t\t\t<span>/*使用promise的then方法*/</span>\n\t\t\t\tpromise<span>.</span><span>then</span><span>(</span><span>(</span><span>res</span><span>)</span> <span>=></span> <span>{</span>\n\t\t\t\t\t<span>let</span> token <span>=</span> res<span>.</span>data<span>.</span>tokenHead <span>+</span> res<span>.</span>data<span>.</span>token\n\t\t\t\t\tconsole<span>.</span><span>log</span><span>(</span>token<span>)</span>\n\t\t\t\t\t$<span>.</span><span>ajax</span><span>(</span><span>{</span>\n\t\t\t\t\t\t<span>headers</span><span>:</span> <span>{</span>\n\t\t\t\t\t\t\t<span>\"Authorization\"</span><span>:</span> token\n\t\t\t\t\t\t<span>}</span><span>,</span>\n\t\t\t\t\t\t<span>type</span><span>:</span> <span>'get'</span><span>,</span>\n\t\t\t\t\t\t<span>url</span><span>:</span> <span>'http://118.89.176.28:8080/admin/info'</span><span>,</span>\n\t\t\t\t\t\t<span>success</span><span>:</span> <span>function</span><span>(</span><span>res</span><span>)</span> <span>{</span>\n\t\t\t\t\t\t\tconsole<span>.</span><span>log</span><span>(</span>res<span>)</span><span>;</span>\n\t\t\t\t\t\t<span>}</span>\n\t\t\t\t\t<span>}</span><span>)</span><span>;</span>\n\t\t\t\t<span>}</span><span>)</span>\n\t\t\t<span>}</span><span>)</span><span>;</span>\n\t\t</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>\n\t<span><span><span>&lt;/</span>body</span><span>></span></span>\n<span><span><span>&lt;/</span>html</span><span>></span></span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br></div></div><h3 id=\"第二种方法\"> 第二种方法</h3>\n<div><pre><code><span><span>&lt;!</span><span>DOCTYPE</span> <span>html</span><span>></span></span>\n<span><span><span>&lt;</span>html</span><span>></span></span>\n\t<span><span><span>&lt;</span>head</span><span>></span></span>\n\t\t<span><span><span>&lt;</span>meta</span> <span>charset</span><span><span>=</span><span>\"</span>utf-8<span>\"</span></span> <span>/></span></span>\n\t\t<span><span><span>&lt;</span>title</span><span>></span></span><span><span><span>&lt;/</span>title</span><span>></span></span>\n\t<span><span><span>&lt;/</span>head</span><span>></span></span>\n\t<span><span><span>&lt;</span>body</span><span>></span></span>\n\t\t<span><span><span>&lt;</span>script</span> <span>src</span><span><span>=</span><span>\"</span>https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js<span>\"</span></span><span>></span></span><span><span>\n\t\t</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>\n\t\t<span><span><span>&lt;</span>script</span> <span>type</span><span><span>=</span><span>\"</span>text/javascript<span>\"</span></span><span>></span></span><span><span>\n\t\t\t<span>$</span><span>(</span>document<span>)</span><span>.</span><span>ready</span><span>(</span><span>function</span><span>(</span><span>)</span> <span>{</span>\n\t\t\t\t<span>var</span> form <span>=</span> <span>{</span>\n\t\t\t\t\t<span>username</span><span>:</span> <span>'admin'</span><span>,</span>\n\t\t\t\t\t<span>password</span><span>:</span> <span>'macro123'</span>\n\t\t\t\t<span>}</span>\n\n        <span>/*创建promise对象*/</span>\n\t\t\t\t<span>const</span> promise <span>=</span> <span>new</span> <span>Promise</span><span>(</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>=></span> <span>{</span>\n\t\t\t\t\t$<span>.</span><span>ajax</span><span>(</span><span>{</span>\n\t\t\t\t\t\t<span>type</span><span>:</span> <span>'post'</span><span>,</span>\n\t\t\t\t\t\t<span>url</span><span>:</span> <span>'http://118.89.176.28:8080/admin/login'</span><span>,</span>\n\t\t\t\t\t\t<span>dataType</span><span>:</span> <span>'json'</span><span>,</span>\n\t\t\t\t\t\t<span>contentType</span><span>:</span> <span>'application/json;charset=UTF-8'</span><span>,</span>\n\t\t\t\t\t\t<span>data</span><span>:</span> <span>JSON</span><span>.</span><span>stringify</span><span>(</span>form<span>)</span><span>,</span>\n            \n            <span>/*将结果暴露在then方法里*/</span>\n\t\t\t\t\t<span>}</span><span>)</span><span>.</span><span>then</span><span>(</span><span>(</span><span>res</span><span>)</span> <span>=></span> <span>{</span>\n\t\t\t\t\t\tconsole<span>.</span><span>log</span><span>(</span>res<span>)</span>\n\t\t\t\t\t\t<span>let</span> token <span>=</span> res<span>.</span>data<span>.</span>tokenHead <span>+</span> res<span>.</span>data<span>.</span>token\n\t\t\t\t\t\tconsole<span>.</span><span>log</span><span>(</span>token<span>)</span>\n\t\t\t\t\t\t$<span>.</span><span>ajax</span><span>(</span><span>{</span>\n\t\t\t\t\t\t\t<span>headers</span><span>:</span> <span>{</span>\n\t\t\t\t\t\t\t\t<span>\"Authorization\"</span><span>:</span> token\n\t\t\t\t\t\t\t<span>}</span><span>,</span>\n\t\t\t\t\t\t\t<span>type</span><span>:</span> <span>'get'</span><span>,</span>\n\t\t\t\t\t\t\t<span>url</span><span>:</span> <span>'http://118.89.176.28:8080/admin/info'</span><span>,</span>\n\t\t\t\t\t\t\t<span>success</span><span>:</span> <span>function</span><span>(</span><span>res2</span><span>)</span> <span>{</span>\n\t\t\t\t\t\t\t\tconsole<span>.</span><span>log</span><span>(</span>res2<span>)</span><span>;</span>\n\t\t\t\t\t\t\t<span>}</span>\n\t\t\t\t\t\t<span>}</span><span>)</span><span>;</span>\n\t\t\t\t\t<span>}</span><span>)</span>\n\t\t\t\t<span>}</span><span>)</span>\n\t\t\t<span>}</span><span>)</span><span>;</span>\n\t\t</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>\n\t<span><span><span>&lt;/</span>body</span><span>></span></span>\n<span><span><span>&lt;/</span>html</span><span>></span></span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br></div></div>",
      "date_published": "2020-07-11T22:10:38.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": []
    },
    {
      "title": "前端学习目录",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/front-end/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/front-end/",
      "content_html": "",
      "date_published": "2020-11-24T17:10:27.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": []
    },
    {
      "title": "Golang-介绍和使用",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/golang/Golang-description&use/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/golang/Golang-description&use/",
      "content_html": "<h2 id=\"参考\"> 参考</h2>\n<div><p>Tips</p>\n<ul>\n<li><a href=\"http://golang.iswbm.com/en/latest/index.html\" target=\"_blank\" rel=\"noopener noreferrer\">Go编程时光</a></li>\n<li><a href=\"http://c.biancheng.net/golang/\" target=\"_blank\" rel=\"noopener noreferrer\">Go语言入门教程</a></li>\n<li><a href=\"https://www.runoob.com/go/go-tutorial.html\" target=\"_blank\" rel=\"noopener noreferrer\">菜鸟教程</a></li>\n</ul>\n</div>\n<h2 id=\"介绍\"> 介绍</h2>\n<blockquote>\n<p>Go语言为并发而生。</p>\n</blockquote>\n<h3 id=\"简介\"> 简介</h3>\n<p>Go语言（或 Golang）起源于 2007 年，并在 2009 年正式对外发布。Go 是非常年轻的一门语言，它的主要目标是“兼具 <a href=\"http://c.biancheng.net/python/\" target=\"_blank\" rel=\"noopener noreferrer\">Python</a> 等动态语言的开发速度和 C/<a href=\"http://c.biancheng.net/cplus/\" target=\"_blank\" rel=\"noopener noreferrer\">C++</a> 等编译型语言的性能与安全性”。</p>\n<p>Go语言是编程语言设计的又一次尝试，是对类C语言的重大改进，它不但能让你访问底层操作系统，还提供了强大的网络编程和并发编程支持。Go语言的用途众多，可以进行网络编程、系统编程、并发编程、分布式编程。</p>\n<p>Go语言的推出，旨在不损失应用程序性能的情况下降低代码的复杂性，具有“部署简单、并发性好、语言设计良好、执行性能好”等优势，目前国内诸多 IT 公司均已采用Go语言开发项目。</p>\n<p>Go语言有时候被描述为“C 类似语言”，或者是“21 世纪的C语言”。Go 从C语言继承了相似的表达式语法、控制流结构、基础数据类型、调用参数传值、指针等很多思想，还有C语言一直所看中的编译后机器码的运行效率以及和现有操作系统的无缝适配。</p>\n<p>因为Go语言没有类和继承的概念，所以它和 <a href=\"http://c.biancheng.net/java/\" target=\"_blank\" rel=\"noopener noreferrer\">Java</a> 或 C++ 看起来并不相同。但是它通过接口（interface）的概念来实现多态性。Go语言有一个清晰易懂的轻量级类型系统，在类型之间也没有层级之说。因此可以说Go语言是一门混合型的语言。</p>\n<p>此外，很多重要的开源项目都是使用Go语言开发的，其中包括 <a href=\"http://c.biancheng.net/docker/\" target=\"_blank\" rel=\"noopener noreferrer\">Docker</a>、Go-Ethereum、Thrraform 和 Kubernetes。</p>\n<h3 id=\"用途\"> 用途</h3>\n<p>Go 语言被设计成一门应用于搭载 Web 服务器，存储集群或类似用途的巨型中央服务器的系统编程语言。</p>\n<p>对于高性能分布式系统领域而言，Go 语言无疑比大多数其它语言有着更高的开发效率。它提供了海量并行的支持，这对于游戏服务端的开发而言是再好不过了。</p>\n<h3 id=\"特性\"> 特性</h3>\n<ul>\n<li>自动垃圾回收</li>\n<li>更丰富的内置类型</li>\n<li>函数多返回值</li>\n<li>错误处理</li>\n<li>匿名函数和闭包</li>\n<li>类型和接口</li>\n<li>并发编程</li>\n<li>反射</li>\n<li>语言交互性</li>\n</ul>\n<h2 id=\"安装与使用\"> 安装与使用</h2>\n<div><p>参考</p>\n<p><a href=\"http://golang.iswbm.com/en/latest/c01/c01_01.html\" target=\"_blank\" rel=\"noopener noreferrer\">一文搞定开发环境的搭建</a></p>\n</div>\n<h2 id=\"go命令\"> Go命令</h2>\n<div><p>参考</p>\n<p><a href=\"https://www.cnblogs.com/itogo/p/8645441.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.cnblogs.com/itogo/p/8645441.html</a></p>\n</div>\n<h2 id=\"目录结构\"> 目录结构</h2>\n<p>一个Go语言项目的目录一般包含以下三个子目录：</p>\n<table>\n<thead>\n<tr>\n<th>目录</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>src</td>\n<td>放置项目和库的源文件</td>\n</tr>\n<tr>\n<td>pkg</td>\n<td>放置编译后生成的包/库的归档文件</td>\n</tr>\n<tr>\n<td>bin</td>\n<td>放置编译后生成的可执行文件</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"src\"> src</h3>\n<p>用于以包（package）的形式组织并存放 Go 源文件，这里的包与 src 下的每个子目录是一一对应。例如，若一个源文件被声明属于 log 包，那么它就应当保存在 src/log 目录中。</p>\n<p>并不是说 src 目录下不能存放 Go 源文件，一般在测试或演示的时候也可以把 Go 源文件直接放在 src 目录下，但是这么做的话就只能声明该源文件属于 main 包了。正常开发中还是建议大家把 Go 源文件放入特定的目录中。</p>\n<p>包是Go语言管理代码的重要机制，其作用类似于<a href=\"http://c.biancheng.net/java/\" target=\"_blank\" rel=\"noopener noreferrer\">Java</a>中的 package 和 C/<a href=\"http://c.biancheng.net/cplus/\" target=\"_blank\" rel=\"noopener noreferrer\">C++</a> 的头文件。Go 源文件中第一段有效代码必须是<code>package &lt;包名&gt;</code>的形式，如 package hello。</p>\n<p>另外需要注意的是，Go语言会把通过<code>go get</code>命令获取到的库源文件下载到 src 目录下对应的文件夹当中。</p>\n<h3 id=\"pkg\"> pkg</h3>\n<p>用于存放通过<code>go install</code>命令安装某个包后的归档文件。归档文件是指那些名称以“.a”结尾的文件。</p>\n<p>该目录与 GOROOT 目录（也就是Go语言的安装目录）下的 pkg 目录功能类似，区别在于这里的 pkg 目录专门用来存放项目代码的归档文件。</p>\n<p>编译和安装项目代码的过程一般会以代码包为单位进行，比如 log 包被编译安装后，将生成一个名为 log.a 的归档文件，并存放在当前项目的 pkg 目录下。</p>\n<h3 id=\"bin\"> bin</h3>\n<p>与 pkg 目录类似，在通过<code>go install</code>命令完成安装后，保存由 Go 命令源文件生成的可执行文件。在类 Unix 操作系统下，这个可执行文件的名称与命令源文件的文件名相同。而在 Windows 操作系统下，这个可执行文件的名称则是命令源文件的文件名加 .exe 后缀。</p>\n",
      "date_published": "2021-06-08T20:14:56.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": []
    },
    {
      "title": "Golang-语法基础",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/golang/Golang/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/golang/Golang/",
      "content_html": "<h2 id=\"参考\"> 参考</h2>\n<div><p>Tips</p>\n<ul>\n<li><a href=\"http://golang.iswbm.com/\" target=\"_blank\" rel=\"noopener noreferrer\">Go编程时光</a></li>\n<li><a href=\"http://c.biancheng.net/golang/\" target=\"_blank\" rel=\"noopener noreferrer\">Go语言入门教程</a></li>\n<li><a href=\"https://www.runoob.com/go/go-tutorial.html\" target=\"_blank\" rel=\"noopener noreferrer\">菜鸟教程</a></li>\n</ul>\n</div>\n<h2 id=\"变量创建\"> 变量创建</h2>\n<p>Go 语言是静态类型语言，由于编译时，编译器会检查变量的类型，所以要求所有的变量都要有明确的类型。</p>\n<p><strong>变量在使用前，需要先声明</strong>。声明类型，就约定了你这个变量只能赋该类型的值。</p>\n<p>声明一般有以下四种方法</p>\n<blockquote>\n<p>其中前面两种同样也可用于定义常量，只需把关键字 <code>var</code> 变成 <code>const</code> 即可。</p>\n</blockquote>\n<h3 id=\"第一种-使用var\"> 第一种：使用var</h3>\n<div><pre><code><span>var</span> <span>&lt;</span>name<span>></span> <span>&lt;</span><span>type</span><span>></span>\n</code></pre>\n<div><span>1</span><br></div></div><p>其中 var 是关键字（固定不变），name 是变量名，type 是类型。</p>\n<p>使用 var ，虽然只指定了类型，但是 Go 会对其进行<code>隐式初始化</code>，比如</p>\n<ul>\n<li>string 类型就初始化为空字符串</li>\n<li>int 类型就初始化为0</li>\n<li>float 就初始化为 0.0</li>\n<li>bool类型就初始化为false</li>\n<li>指针类型就初始化为 nil</li>\n</ul>\n<p>若想在声明过程，顺便也初始化，可以这样写</p>\n<div><pre><code><span>var</span> name <span>string</span> <span>=</span> <span>\"字符串\"</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>可以简化为</p>\n<div><pre><code>vat name <span>=</span> <span>\"字符串\"</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>若你的右值带有小数点，在不指定类型的情况下，编译器会将你的这个变量声明为 float64，但是很多情况下，我们并不需要这么高的精度（占用的内存空间更大）</p>\n<p>这种情况下，推荐指定类型，不要偷懒</p>\n<div><pre><code><span>var</span> rate <span>float32</span> <span>=</span> <span>0.89</span>\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"第二种-使用var多个变量声明\"> 第二种：使用var多个变量声明</h3>\n<div><pre><code><span>var</span> <span>(</span>\n    name <span>string</span>\n    age <span>int</span>\n    gender <span>string</span>\n<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id=\"第三种-使用-声明\"> 第三种：使用 := 声明</h3>\n<p>使用 <code>:=</code> （推导声明写法或者短类型声明法：编译器会自动根据右值类型推断出左值的对应类型。），可以声明一个变量，并对其进行（显式）初始化。</p>\n<div><pre><code>name <span>:=</span> <span>\"Go\"</span>\n\n<span>// 等价于</span>\n\n<span>var</span> name <span>string</span> <span>=</span> <span>\"Go\"</span>\n\n<span>// 等价于</span>\n\n<span>var</span> name <span>=</span> <span>\"Go\"</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><div><p>注意</p>\n<p>只能用于函数内部</p>\n</div>\n<h3 id=\"第四种-使用-声明多个\"> 第四种：使用 := 声明多个</h3>\n<div><pre><code>name<span>,</span> age <span>:=</span> <span>\"wangbm\"</span><span>,</span> <span>28</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>这种方法，也经常用于变量的交换</p>\n<div><pre><code><span>var</span> a <span>int</span> <span>=</span> <span>100</span>\n<span>var</span> b <span>int</span> <span>=</span> <span>200</span>\nb<span>,</span> a <span>=</span> a<span>,</span> b\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><blockquote>\n<p>两个变量要同一个类型</p>\n</blockquote>\n<h3 id=\"第五种-new-函数声明一个指针变量\"> 第五种：new 函数声明一个指针变量</h3>\n<p>变量分为两种 <code>普通变量</code> 和 <code>指针变量</code></p>\n<div><p>Info</p>\n<ul>\n<li>普通变量：存放的是数据本身</li>\n<li>指针变量：存放的是数据的地址。</li>\n</ul>\n</div>\n<p>如下代码，age 是一个普通变量，存放的内容是 28，而 ptr 是 存放变量age值的内存地址：0xc000010098</p>\n<div><pre><code><span>package</span> main\n\n<span>import</span> <span>\"fmt\"</span>\n\n<span>func</span> <span>main</span><span>(</span><span>)</span>  <span>{</span>\n    <span>var</span> age <span>int</span> <span>=</span> <span>28</span>\n    <span>var</span> ptr <span>=</span> <span>&amp;</span>age  <span>// &amp;后面接变量名，表示取出该变量的内存地址</span>\n    fmt<span>.</span><span>Println</span><span>(</span><span>\"age: \"</span><span>,</span> age<span>)</span>\n    fmt<span>.</span><span>Println</span><span>(</span><span>\"ptr: \"</span><span>,</span> ptr<span>)</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>输出</p>\n<div><pre><code>age:  28\nptr:  0xc000010098\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>而这里要说的 new 函数，是 Go 里的一个内建函数。</p>\n<p>使用表达式 <code>new(Type)</code> 将创建一个Type类型的匿名变量，初始化为Type类型的零值，然后返回<code>变量地址</code>，返回的指针类型为<code>*Type</code>。</p>\n<p>用new创建变量和普通变量声明语句方式创建变量没有什么区别，除了不需要声明一个临时变量的名字外，我们还可以在表达式中使用new(Type)。换言之，new函数类似是一种语法糖，而不是一个新的基础概念。</p>\n<p>如下两种写法，可以说是等价的</p>\n<div><pre><code><span>// 使用 new</span>\n<span>func</span> <span>newInt</span><span>(</span><span>)</span> <span>*</span><span>int</span> <span>{</span>\n    <span>return</span> <span>new</span><span>(</span><span>int</span><span>)</span>\n<span>}</span>\n\n<span>// 使用传统的方式</span>\n<span>func</span> <span>newInt</span><span>(</span><span>)</span> <span>*</span><span>int</span> <span>{</span>\n    <span>var</span> dummy <span>int</span>\n    <span>return</span> <span>&amp;</span>dummy\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>以上不管哪种方法，变量/常量都只能声明一次，声明多次，编译就会报错。</p>\n<p>但也有例外，这就要说到一个特殊变量：<strong>匿名变量</strong>，也称作占位符，或者空白标识符，用下划线表示。</p>\n<p>匿名变量，优点有三：</p>\n<ul>\n<li>不分配内存，不占用内存空间</li>\n<li>不需要你为命名无用的变量名而纠结</li>\n<li>多次声明不会有任何问题</li>\n</ul>\n<p>通常我们用匿名接收必须接收，但是又不会用到的值。</p>\n<div><pre><code><span>func</span> <span>GetData</span><span>(</span><span>)</span> <span>(</span><span>int</span><span>,</span> <span>int</span><span>)</span> <span>{</span>\n    <span>return</span> <span>100</span><span>,</span> <span>200</span>\n<span>}</span>\n<span>func</span> <span>main</span><span>(</span><span>)</span><span>{</span>\n    a<span>,</span> <span>_</span> <span>:=</span> <span>GetData</span><span>(</span><span>)</span>\n    <span>_</span><span>,</span> b <span>:=</span> <span>GetData</span><span>(</span><span>)</span>\n    fmt<span>.</span><span>Println</span><span>(</span>a<span>,</span> b<span>)</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h2 id=\"数据类型\"> 数据类型</h2>\n<h3 id=\"整型\"> 整型</h3>\n<p>Go 语言中，整数类型可以再细分成10个类型，为了方便大家学习，我将这些类型整理成一张表格。</p>\n<p><img src=\"http://image.iswbm.com/20200120204329.png\" alt=\"image1\" /></p>\n<blockquote>\n<p>int 和 uint 的区别就在于一个 <code>u</code>，有 <code>u</code> 说明是无符号，没有 <code>u</code> 代表有符号。</p>\n</blockquote>\n<h4 id=\"解释这个符号的区别\"> 解释这个符号的区别</h4>\n<p>以 <code>int8</code> 和 <code>uint8</code> 举例，8 代表 8个bit，能表示的数值个数有 <code>2^8 = 256</code>。</p>\n<p>uint8 是无符号，能表示的都是正数，<code>0-255</code>，刚好256个数。</p>\n<p>int8 是有符号，既可以正数，也可以负数，那怎么办？对半分呗，<code>-128-127</code>，也刚好 256个数。</p>\n<p>int8 int16 int32 int64 这几个类型的最后都有一个数值，这表明了它们能表示的数值个数是固定的。</p>\n<p>而 int 并没有指定它的位数，说明它的大小，是可以变化的，那根据什么变化呢？</p>\n<ul>\n<li>当你在32位的系统下，int 和 uint 都占用 4个字节，也就是32位。</li>\n<li>若你在64位的系统下，int 和 uint 都占用 8个字节，也就是64位。</li>\n</ul>\n<p>出于这个原因，在某些场景下，你应当避免使用 int 和 uint ，而使用更加精确的 int32 和 int64，比如在二进制传输、读写文件的结构描述（为了保持文件的结构不会受到不同编译目标平台字节长度的影响）</p>\n<h4 id=\"不同进制的表示方法\"> 不同进制的表示方法</h4>\n<p>出于习惯，在初始化数据类型为整型的变量时，我们会使用10进制的表示法，因为它最直观，比如这样，表示整数10.</p>\n<div><pre><code><span>var</span> num <span>int</span> <span>=</span> <span>10</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>不过，你要清楚，你一样可以使用其他进制来表示一个整数，这里以比较常用的2进制、8进制和16进制举例。</p>\n<p>2进制：以<code>0b</code>或<code>0B</code>为前缀</p>\n<div><pre><code><span>var</span> num01 <span>int</span> <span>=</span> <span>0b1100</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>8进制：以<code>0o</code>或者 <code>0O</code>为前缀</p>\n<div><pre><code><span>var</span> num02 <span>int</span> <span>=</span> <span>0o14</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>16进制：以<code>0x</code> 为前缀</p>\n<div><pre><code><span>var</span> num03 <span>int</span> <span>=</span> <span>0xC</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>下面用一段代码分别使用二进制、8进制、16进制来表示 10 进制的数值：12</p>\n<div><pre><code><span>package</span> main\n\n<span>import</span> <span>(</span>\n    <span>\"fmt\"</span>\n<span>)</span>\n\n<span>func</span> <span>main</span><span>(</span><span>)</span> <span>{</span>\n    <span>var</span> num01 <span>int</span> <span>=</span> <span>0b1100</span>\n    <span>var</span> num02 <span>int</span> <span>=</span> <span>0o14</span>\n    <span>var</span> num03 <span>int</span> <span>=</span> <span>0xC</span>\n\n    fmt<span>.</span><span>Printf</span><span>(</span><span>\"2进制数 %b 表示的是: %d \\n\"</span><span>,</span> num01<span>,</span> num01<span>)</span>\n    fmt<span>.</span><span>Printf</span><span>(</span><span>\"8进制数 %o 表示的是: %d \\n\"</span><span>,</span> num02<span>,</span> num02<span>)</span>\n    fmt<span>.</span><span>Printf</span><span>(</span><span>\"16进制数 %X 表示的是: %d \\n\"</span><span>,</span> num03<span>,</span> num03<span>)</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>输出如下</p>\n<div><pre><code>2进制数 1100 表示的是: 12\n8进制数 14 表示的是: 12\n16进制数 C 表示的是: 12\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>以上代码用过了 fmt 包的格式化功能，你可以参考这里去看上面的代码</p>\n<div><pre><code>%b    表示为二进制\n%c    该值对应的unicode码值\n%d    表示为十进制\n%o    表示为八进制\n%q    该值对应的单引号括起来的go语法字符字面值，必要时会采用安全的转义表示\n%x    表示为十六进制，使用a-f\n%X    表示为十六进制，使用A-F\n%U    表示为Unicode格式：U+1234，等价于&quot;U+%04X&quot;\n%E    用科学计数法表示\n%f    用浮点数表示\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h3 id=\"浮点型\"> 浮点型</h3>\n<p>浮点数类型的值一般由整数部分、小数点“<code>.</code>”和小数部分组成。</p>\n<p>其中，整数部分和小数部分均由10进制表示法表示。不过还有另一种表示方法。那就是在其中加入指数部分。指数部分由“E”或“e”以及一个带正负号的10进制数组成。比如，<code>3.7E-2</code>表示浮点数<code>0.037</code>。又比如，<code>3.7E+1</code>表示浮点数<code>37</code>。</p>\n<p>有时候，浮点数类型值的表示也可以被简化。比如，<code>37.0</code>可以被简化为<code>37</code>。又比如，<code>0.037</code>可以被简化为<code>.037</code>。</p>\n<blockquote>\n<p>有一点需要注意，在Go语言里，浮点数的相关部分只能由10进制表示法表示，而不能由8进制表示法或16进制表示法表示。比如，<code>03.7</code>表示的一定是浮点数<code>3.7</code>。</p>\n</blockquote>\n<h4 id=\"float32-和-float64\"> float32 和 float64</h4>\n<p>Go语言中提供了两种精度的浮点数 float32 和 float64。</p>\n<p><strong>float32</strong>，也即我们常说的单精度，存储占用4个字节，也即4*8=32位，其中1位用来符号，8位用来指数，剩下的23位表示尾数</p>\n<p><img src=\"https://pic4.zhimg.com/80/v2-749cc641eb4d5dafd085e8c23f8826aa_hd.jpg\" alt=\"img\" /></p>\n<p>img</p>\n<p><strong>float64</strong>，也即我们熟悉的双精度，存储占用8个字节，也即8*8=64位，其中1位用来符号，11位用来指数，剩下的52位表示尾数</p>\n<p><img src=\"https://pic2.zhimg.com/80/v2-48240f0e1e0dd33ec89100cbe2d30707_hd.jpg\" alt=\"img\" /></p>\n<h3 id=\"byte、rune与字符串\"> byte、rune与字符串</h3>\n",
      "image": "http://image.iswbm.com/20200120204329.png",
      "date_published": "2021-06-08T20:15:56.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": []
    },
    {
      "title": "Git笔记",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/git/Git/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/git/Git/",
      "content_html": "<h2 id=\"参考\"> 参考</h2>\n<blockquote>\n<ul>\n<li><a href=\"https://www.runoob.com/manual/git-guide/\" target=\"_blank\" rel=\"noopener noreferrer\">git - 简明指南</a></li>\n<li><a href=\"https://www.liaoxuefeng.com/wiki/896043488029600\" target=\"_blank\" rel=\"noopener noreferrer\">廖雪峰git教程</a></li>\n<li><a href=\"https://blog.csdn.net/liuxiaoheng1992/article/details/79108233\" target=\"_blank\" rel=\"noopener noreferrer\">git merge 与 git rebase的区别</a></li>\n<li><a href=\"https://blog.csdn.net/u010312474/article/details/89566787?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-0.base&amp;spm=1001.2101.3001.4242\" target=\"_blank\" rel=\"noopener noreferrer\">git merge 与 git rebase的区别</a></li>\n</ul>\n</blockquote>\n<h2 id=\"git工作机制\"> Git工作机制</h2>\n<p>实体如下</p>\n<ul>\n<li><code>工作目录</code>：它持有实际文件</li>\n<li><code>暂存区（Index）</code>：它像个缓存区域，临时保存你的改动</li>\n<li><code>本地仓库（HEAD）</code>：它指向你最后一次提交的结果</li>\n<li><code>远程仓库（Remote）</code></li>\n</ul>\n<p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/Git/Git工作流.png\" alt=\"img\" /></p>\n<p>总览</p>\n<p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/Git/工作流2.png\" alt=\"img\" /></p>\n<h2 id=\"git常用命令\"> Git常用命令</h2>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>git config</td>\n<td>配置签名等</td>\n</tr>\n<tr>\n<td>git init</td>\n<td>初始化一个本地仓库</td>\n</tr>\n<tr>\n<td>git status</td>\n<td>查看当前仓库状态</td>\n</tr>\n<tr>\n<td>git add</td>\n<td>将新的文件或文件上的改动提交到暂存区</td>\n</tr>\n<tr>\n<td>git rm --cache</td>\n<td>将add的文件从暂存区移除</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"配置签名\"> 配置签名</h2>\n<blockquote>\n<p>仅作为签名使用，区分不同开发人员的身份，不验证，与登录远程的代码托管中心无关</p>\n</blockquote>\n<div><pre><code>//当前仓库\n<span>git</span> config user.name【username】\n<span>git</span> config user.email【email】\n\n//系统级别\n<span>git</span> config --global user.name【username】\n<span>git</span> config --global user.email【email】\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><blockquote>\n<p>可以在仓库目录``.git/config<code>查看，全局则在根目录下</code>~/.gitconfig`文件中查看</p>\n</blockquote>\n<h2 id=\"初始化\"> 初始化</h2>\n<div><pre><code><span>git</span> init\n</code></pre>\n<div><span>1</span><br></div></div><h2 id=\"查看状态-当前分支\"> 查看状态（当前分支）</h2>\n<div><pre><code><span>git</span> status\n</code></pre>\n<div><span>1</span><br></div></div><p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/Git/查看状态.png\" alt=\"image-20210724195553706\" /></p>\n<p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/Git/查看状态2.png\" alt=\"查看状态2\" /></p>\n<h2 id=\"工作流\"> 工作流</h2>\n<h3 id=\"提交改动到暂存区\"> 提交改动到暂存区</h3>\n<div><pre><code><span>git</span> <span>add</span> <span>[</span>filename<span>]</span>\n\n//提交所有\n<span>git</span> <span>add</span> *\n\n//从暂存区中移除\n<span>git</span> <span>rm</span> --cache <span>[</span>filename<span>]</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id=\"暂存区提交到本地仓库\"> 暂存区提交到本地仓库</h3>\n<div><pre><code><span>git</span> commit -m <span>\"提交信息\"</span>\n</code></pre>\n<div><span>1</span><br></div></div><blockquote>\n<p>提交信息存储在当前仓库``./git/COMMIT_EDITMSG`中</p>\n</blockquote>\n<p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/Git/git commit.png\" alt=\"image-20210724201352971\" /></p>\n<p>缩略版的版本号为<code>2b82d69</code></p>\n<h2 id=\"查看日志-当前分支\"> 查看日志（当前分支）</h2>\n<div><pre><code>//可以查看所有分支的所有操作记录（包括commit和reset的操作），包括已经被删除的commit记录\n<span>git</span> reflog\n\n//查看commit记录\n<span>git</span> log\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/Git/查看日志.png\" alt=\"image-20210724203407199\" /></p>\n<h2 id=\"版本穿梭-当前分支\"> 版本穿梭（当前分支）</h2>\n<div><pre><code>//穿梭到某个版本，使HEAD指向该commit\n<span>git</span> reset <span>[</span>version id<span>]</span>\n\n//无视更改，强行穿梭到某个版本\n<span>git</span> reset --hard <span>[</span>version id<span>]</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>例如</p>\n<p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/Git/版本穿梭.png\" alt=\"版本穿梭\" /></p>\n<p>底层原理是将HEAD指针移动</p>\n<h2 id=\"分支\"> 分支</h2>\n<h3 id=\"常用命令\"> 常用命令</h3>\n<table>\n<thead>\n<tr>\n<th>常用命令</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>git branch [branch name]</td>\n<td>创建分支</td>\n</tr>\n<tr>\n<td>git branch -v</td>\n<td>查看分支</td>\n</tr>\n<tr>\n<td>git checkout [branch name]</td>\n<td>切换分支</td>\n</tr>\n<tr>\n<td>git merge [branch name]</td>\n<td>把指定分支合并到当前分支上</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"冲突\"> 冲突</h3>\n<p>当合并分支时，两个分支在同一个文件的同一个位置修改，Git无法决定使用哪个修改</p>\n<h2 id=\"分支合并\"> 分支合并</h2>\n<p>参考</p>\n<ul>\n<li><a href=\"https://www.liaoxuefeng.com/wiki/896043488029600/900003767775424\" target=\"_blank\" rel=\"noopener noreferrer\">创建与合并分支</a></li>\n<li></li>\n</ul>\n<h2 id=\"代码托管协作\"> 代码托管协作</h2>\n<p>生成配置本地SSH到Github上后，在Github创建仓库，然后复制仓库地址用于与本地仓库相关联</p>\n<p>…or create a new repository on the command line</p>\n<div><pre><code><span>git</span> init\n<span>git</span> <span>add</span> README.md\n<span>git</span> commit -m <span>\"first commit\"</span>\n<span>git</span> branch -M main\n<span>git</span> remote <span>add</span> origin git@github.com:LifeAlsoIsGG/git-learn2.git\n<span>git</span> push -u origin main\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>…or push an existing repository from the command line</p>\n<div><pre><code><span>git</span> remote <span>add</span> origin git@github.com:LifeAlsoIsGG/git-learn2.git\n<span>git</span> branch -M main\n<span>git</span> push -u origin main\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id=\"idea集成git使用\"> IDEA集成Git使用</h2>\n<h3 id=\"配置忽略文件\"> 配置忽略文件</h3>\n<p>创建<code>xxx.ignore</code>文件，以.gnore为后缀</p>\n<h3 id=\"文件颜色\"> 文件颜色</h3>\n<p>红色，未加入版本控制</p>\n<p>绿色，已经加入暂缓区但未提交</p>\n<p>蓝色/黄色，加入，已提交，有改动</p>\n<p>白色，加入，已提交，无改动</p>\n<p>灰色：版本控制已忽略文件。</p>\n<h2 id=\"ssh原理\"> SSH原理</h2>\n<div><p>参考</p>\n<ul>\n<li><a href=\"https://www.cnblogs.com/diffx/p/9553587.html\" target=\"_blank\" rel=\"noopener noreferrer\">图解SSH原理</a></li>\n<li>https://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html</li>\n</ul>\n</div>\n<h2 id=\"奇技\"> 奇技</h2>\n<h3 id=\"将修改加入到某次commit中\"> 将修改加入到某次commit中</h3>\n<div><pre><code><span>#保存改动</span>\n<span>git</span> stash\n\n<span>#进入要插入的commit的之前一个commit,在编辑页面将修改的commit的pick修改为edit</span>\n<span>git</span> rebase -i <span>&lt;</span>commit<span>></span>\n\n<span>#拿出改动</span>\n<span>git</span> stash pop\n\n<span>#添加到缓存区</span>\n<span>git</span> <span>add</span> <span>.</span>\n\n<span>#加入到commit</span>\n<span>git</span> commit --amend --no-edit\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div>",
      "image": "https://blog-1300186248.cos.ap-shanghai.myqcloud.com/Git/Git%E5%B7%A5%E4%BD%9C%E6%B5%81.png",
      "date_published": "2021-07-21T22:39:56.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": []
    },
    {
      "title": "Component disabled",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/guide/disable/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/guide/disable/",
      "summary": "<p>You can disable some functions on the page by setting the Frontmatter of the page.</p>\n",
      "content_html": "<p>You can disable some functions on the page by setting the Frontmatter of the page.</p>\n\n<p>These should be disabled on this page:</p>\n<ul>\n<li>Navbar</li>\n<li>Sidebar</li>\n<li>Breadcrumb</li>\n<li>Page information</li>\n<li>Contributors</li>\n<li>Edit link</li>\n<li>Update time</li>\n<li>Prev/Next link</li>\n<li>Comment</li>\n<li>Footer</li>\n<li>Back to top button</li>\n</ul>\n",
      "date_published": "2022-03-06T10:17:18.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": [
        "Guide"
      ]
    },
    {
      "title": "Encryption article",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/guide/encrypt/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/guide/encrypt/",
      "content_html": "<h1 id=\"encryption-article\"> Encryption article</h1>\n<p>The actual article content.</p>\n<p>Paragraph 1 text paragraph 1 text paragraph 1 text paragraph 1 text paragraph 1 text paragraph 1 text paragraph 1 text paragraph 1 text paragraph 1 text paragraph 1 text paragraph 1 text paragraph 1 text.</p>\n<p>Paragraph 2 text paragraph 2 text paragraph 2 text paragraph 2 text paragraph 2 text paragraph 2 text paragraph 2 text paragraph 2 text paragraph 2 text paragraph 2 text paragraph 2 text paragraph 2 text paragraph 2 text paragraph 2 text.</p>\n",
      "date_published": "2022-03-06T10:17:18.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": [
        "Guide"
      ]
    },
    {
      "title": "Markdown Enhance",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/guide/markdown/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/guide/markdown/",
      "summary": "<p><code>vuepress-theme-hope</code> enables more syntax in Markdown via the built-in <a href=\"https://vuepress-theme-hope.github.io/md-enhance\" target=\"_blank\" rel=\"noopener noreferrer\">md-enhance</a> plugin.</p>\n",
      "content_html": "<p><code>vuepress-theme-hope</code> enables more syntax in Markdown via the built-in <a href=\"https://vuepress-theme-hope.github.io/md-enhance\" target=\"_blank\" rel=\"noopener noreferrer\">md-enhance</a> plugin.</p>\n\n<h2 id=\"enable-all\"> Enable all</h2>\n<p>You can set <code>themeconfig.mdEnhance.enableAll</code> to enable all features of the <a href=\"https://vuepress-theme-hope.github.io/md-enhance\" target=\"_blank\" rel=\"noopener noreferrer\">md-enhance</a> plugin.</p>\n<div><div><br><br><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br><br><br></div><pre><code>module<span>.</span>exports <span>=</span> <span>{</span>\n  <span>themeConfig</span><span>:</span> <span>{</span>\n    <span>mdEnhance</span><span>:</span> <span>{</span>\n      <span>enableAll</span><span>:</span> <span>true</span><span>,</span>\n    <span>}</span><span>,</span>\n  <span>}</span><span>,</span>\n<span>}</span><span>;</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id=\"new-feature\"> New Feature</h2>\n<h3 id=\"superscript-and-subscript\"> Superscript and Subscript</h3>\n<p>19<sup>th</sup> H<sub>2</sub>O</p>\n<details><summary>Code</summary>\n<div><pre><code>19^th^ H<span><span>~</span><span>2</span><span>~</span></span>O\n</code></pre>\n<div><span>1</span><br></div></div></details>\n<ul>\n<li><a href=\"https://vuepress-theme-hope.github.io/guide/markdown/sup-sub/\" target=\"_blank\" rel=\"noopener noreferrer\">View Detail</a></li>\n</ul>\n<h3 id=\"align\"> Align</h3>\n<div>\n<p>I am center</p>\n</div>\n<div>\n<p>I am right align</p>\n</div>\n<details><summary>Code</summary>\n<div><pre><code>::: center\n\nI am center\n\n:::\n\n::: right\n\nI am right align\n\n:::\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div></details>\n<ul>\n<li><a href=\"https://vuepress-theme-hope.github.io/guide/markdown/align/\" target=\"_blank\" rel=\"noopener noreferrer\">View Detail</a></li>\n</ul>\n<h3 id=\"footnote\"> Footnote</h3>\n<p>This text has footnote<sup></sup>.</p>\n<details><summary>Code</summary>\n<div><pre><code>This text has footnote[^first].\n\n<span><span>[</span><span>^first</span><span>]</span><span>:</span> This</span> is footnote content\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></details>\n<ul>\n<li><a href=\"https://vuepress-theme-hope.github.io/guide/markdown/footnote/\" target=\"_blank\" rel=\"noopener noreferrer\">View Detail</a></li>\n</ul>\n<h3 id=\"mark\"> Mark</h3>\n<p>You can mark <mark>important words</mark> .</p>\n<details><summary>Code</summary>\n<div><pre><code>You can mark ==important words== .\n</code></pre>\n<div><span>1</span><br></div></div></details>\n<ul>\n<li><a href=\"https://vuepress-theme-hope.github.io/guide/markdown/mark/\" target=\"_blank\" rel=\"noopener noreferrer\">View Detail</a></li>\n</ul>\n<h3 id=\"tasklist\"> Tasklist</h3>\n<ul>\n<li><input type=\"checkbox\" checked=\"checked\" disabled=\"disabled\" id=\"task-item-0\"><label for=\"task-item-0\"> Plan A</label></li>\n<li><input type=\"checkbox\"  disabled=\"disabled\" id=\"task-item-1\"><label for=\"task-item-1\"> Plan B</label></li>\n</ul>\n<details><summary>Code</summary>\n<div><pre><code><span>-</span> [x] Plan A\n<span>-</span> [ ] Plan B\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div></details>\n<ul>\n<li><a href=\"https://vuepress-theme-hope.github.io/guide/markdown/tasklist/\" target=\"_blank\" rel=\"noopener noreferrer\">View Detail</a></li>\n</ul>\n<h3 id=\"flowchart\"> Flowchart</h3>\n<i>Not supported content</i><details><summary>Code</summary>\n<div><pre><code><span><span>```</span><span>flow</span>\n<span>cond=>condition: Process?\nprocess=>operation: Process\ne=>end: End\n\ncond(yes)->process->e\ncond(no)->e</span>\n<span>```</span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div></details>\n<ul>\n<li><a href=\"https://vuepress-theme-hope.github.io/guide/markdown/flowchart/\" target=\"_blank\" rel=\"noopener noreferrer\">View Detail</a></li>\n</ul>\n<h2 id=\"mermaid\"> Mermaid</h2>\n<Mermaid id=\"mermaid-64a57060\" data-code=\"graph%20TD%3B%0A%20%20%20%20A--%3EB%3B%0A%20%20%20%20A--%3EC%3B%0A%20%20%20%20B--%3ED%3B%0A%20%20%20%20C--%3ED%3B%0A\"></Mermaid><details><summary>Code</summary>\n<div><pre><code><span><span>```</span><span>mermaid</span>\n<span>graph TD;\n    A-->B;\n    A-->C;\n    B-->D;\n    C-->D;</span>\n<span>```</span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div></details>\n<ul>\n<li><a href=\"https://vuepress-theme-hope.github.io/guide/markdown/mermaid/\" target=\"_blank\" rel=\"noopener noreferrer\">View Detail</a></li>\n</ul>\n<h3 id=\"tex\"> Tex</h3>\n<p class='katex-block'><span><span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:2.4em;vertical-align:-0.95em;\"></span><span><span></span><span><span><span><span style=\"height:1.3714em;\"><span style=\"top:-2.314em;\"><span style=\"height:3em;\"></span><span><span style=\"margin-right:0.05556em;\">∂</span><span><span style=\"margin-right:0.03588em;\">ω</span><span><span><span><span style=\"height:0.5904em;\"><span style=\"top:-2.989em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span style=\"margin-right:0.02778em;\">r</span></span></span></span></span></span></span></span></span></span><span style=\"top:-3.23em;\"><span style=\"height:3em;\"></span><span style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span style=\"height:3em;\"></span><span><span><span style=\"margin-right:0.05556em;\">∂</span><span><span><span><span style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span style=\"margin-right:0.02778em;\">r</span></span></span></span></span></span></span></span></span></span></span><span>​</span></span><span><span style=\"height:0.686em;\"><span></span></span></span></span></span><span></span></span><span style=\"margin-right:0.1667em;\"></span><span><span style=\"top:0em;\"><span>(</span></span><span><span></span><span><span><span><span style=\"height:1.3414em;\"><span style=\"top:-2.314em;\"><span style=\"height:3em;\"></span><span><span style=\"margin-right:0.03588em;\">ω</span></span></span><span style=\"top:-3.23em;\"><span style=\"height:3em;\"></span><span style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span style=\"height:3em;\"></span><span><span><span style=\"margin-right:0.03588em;\">y</span><span><span><span><span style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span><span style=\"margin-right:0.03588em;\">ω</span></span></span></span></span></span></span></span></span></span></span></span><span>​</span></span><span><span style=\"height:0.686em;\"><span></span></span></span></span></span><span></span></span><span style=\"top:0em;\"><span>)</span></span></span><span style=\"margin-right:0.2778em;\"></span><span>=</span><span style=\"margin-right:0.2778em;\"></span></span><span><span style=\"height:3.0277em;vertical-align:-1.2777em;\"></span><span><span style=\"top:0em;\"><span>(</span></span><span><span></span><span><span><span><span style=\"height:1.3414em;\"><span style=\"top:-2.314em;\"><span style=\"height:3em;\"></span><span><span style=\"margin-right:0.03588em;\">ω</span></span></span><span style=\"top:-3.23em;\"><span style=\"height:3em;\"></span><span style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span style=\"height:3em;\"></span><span><span><span style=\"margin-right:0.03588em;\">y</span><span><span><span><span style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span><span style=\"margin-right:0.03588em;\">ω</span></span></span></span></span></span></span></span></span></span></span></span><span>​</span></span><span><span style=\"height:0.686em;\"><span></span></span></span></span></span><span></span></span><span style=\"top:0em;\"><span>)</span></span></span><span style=\"margin-right:0.1667em;\"></span><span><span style=\"top:0em;\"><span>{</span></span><span>(</span><span>lo<span style=\"margin-right:0.01389em;\">g</span></span><span style=\"margin-right:0.1667em;\"></span><span style=\"margin-right:0.03588em;\">y</span><span><span>)</span><span><span><span><span style=\"height:0.7144em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span style=\"margin-right:0.02778em;\">r</span></span></span></span></span></span></span></span><span style=\"margin-right:0.2222em;\"></span><span>+</span><span style=\"margin-right:0.2222em;\"></span><span><span><span><span style=\"height:1.6514em;\"><span style=\"top:-1.8723em;margin-left:0em;\"><span style=\"height:3.05em;\"></span><span><span><span>i</span><span>=</span><span>1</span></span></span></span><span style=\"top:-3.05em;\"><span style=\"height:3.05em;\"></span><span><span>∑</span></span></span><span style=\"top:-4.3em;margin-left:0em;\"><span style=\"height:3.05em;\"></span><span><span style=\"margin-right:0.02778em;\">r</span></span></span></span><span>​</span></span><span><span style=\"height:1.2777em;\"><span></span></span></span></span></span><span style=\"margin-right:0.1667em;\"></span><span><span></span><span><span><span><span style=\"height:1.5017em;\"><span style=\"top:-2.314em;\"><span style=\"height:3em;\"></span><span><span><span style=\"margin-right:0.03588em;\">ω</span><span><span><span><span style=\"height:0.7507em;\"><span style=\"top:-2.989em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span>i</span></span></span></span></span></span></span></span></span></span><span style=\"top:-3.23em;\"><span style=\"height:3em;\"></span><span style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span style=\"height:3em;\"></span><span><span>(</span><span>−</span><span>1</span><span><span>)</span><span><span><span><span style=\"height:0.8247em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span>i</span></span></span></span></span></span></span></span><span style=\"margin-right:0.02778em;\">r</span><span style=\"margin-right:0.1667em;\"></span><span>⋯</span><span style=\"margin-right:0.1667em;\"></span><span>(</span><span style=\"margin-right:0.02778em;\">r</span><span style=\"margin-right:0.2222em;\"></span><span>−</span><span style=\"margin-right:0.2222em;\"></span><span>i</span><span style=\"margin-right:0.2222em;\"></span><span>+</span><span style=\"margin-right:0.2222em;\"></span><span>1</span><span>)</span><span>(</span><span>lo<span style=\"margin-right:0.01389em;\">g</span></span><span style=\"margin-right:0.1667em;\"></span><span style=\"margin-right:0.03588em;\">y</span><span><span>)</span><span><span><span><span style=\"height:0.8247em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span><span style=\"margin-right:0.02778em;\">r</span><span>−</span><span>i</span></span></span></span></span></span></span></span></span></span></span></span><span>​</span></span><span><span style=\"height:0.686em;\"><span></span></span></span></span></span><span></span></span><span style=\"top:0em;\"><span>}</span></span></span></span></span></span></span></p>\n<details><summary>Code</summary>\n<div><pre><code>$$\n\\frac {\\partial^r} {\\partial \\omega^r} \\left(\\frac {y^{\\omega}} {\\omega}\\right)\n= \\left(\\frac {y^{\\omega}} {\\omega}\\right) \\left\\{(\\log y)^r + \\sum_{i=1}^r \\frac {(-1)^i r \\cdots (r-i+1) (\\log y)^{r-i}} {\\omega^i} \\right\\}\n$$\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div></details>\n<ul>\n<li><a href=\"https://vuepress-theme-hope.github.io/guide/markdown/tex/\" target=\"_blank\" rel=\"noopener noreferrer\">View Detail</a></li>\n</ul>\n<h3 id=\"demo\"> Demo</h3>\n\n          <div\n            id=\"code-demo-688e9568\"\n           \n  \n data-title=\"A%20normal%20demo\"\n\n            data-code=\"%7B%22html%22%3A%22%3Ch1%3EMr.Hope%3C%2Fh1%3E%5Cn%3Cp%3EIs%20%3Cspan%20id%3D%5C%22very%5C%22%3Every%3C%2Fspan%3E%20handsome%3C%2Fp%3E%5Cn%22%2C%22js%22%3A%22document.querySelector(%5C%22%23very%5C%22).addEventListener(%5C%22click%5C%22%2C%20()%20%3D%3E%20%7B%5Cn%20%20alert(%5C%22Very%20handsome!%5C%22)%3B%5Cn%7D)%3B%5Cn%22%2C%22css%22%3A%22span%20%7B%5Cn%20%20color%3A%20red%3B%5Cn%7D%5Cn%22%7D\"\n          >\n              \n              <div>\n                <div>\n<div><pre><code><span><span><span>&lt;</span>h1</span><span>></span></span>Mr.Hope<span><span><span>&lt;/</span>h1</span><span>></span></span>\n<span><span><span>&lt;</span>p</span><span>></span></span>Is <span><span><span>&lt;</span>span</span> <span>id</span><span><span>=</span><span>\"</span>very<span>\"</span></span><span>></span></span>very<span><span><span>&lt;/</span>span</span><span>></span></span> handsome<span><span><span>&lt;/</span>p</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><div><pre><code>document<span>.</span><span>querySelector</span><span>(</span><span>\"#very\"</span><span>)</span><span>.</span><span>addEventListener</span><span>(</span><span>\"click\"</span><span>,</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>\n  <span>alert</span><span>(</span><span>\"Very handsome!\"</span><span>)</span><span>;</span>\n<span>}</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><div><pre><code><span>span</span> <span>{</span>\n  <span>color</span><span>:</span> red<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div>\n            </div>\n          </div>\n          \n        </div>\n<details><summary>Code</summary>\n<div><pre><code>::: demo A normal demo\n\n<span><span>```</span><span>html</span>\n<span><span><span><span>&lt;</span>h1</span><span>></span></span>Mr.Hope<span><span><span>&lt;/</span>h1</span><span>></span></span>\n<span><span><span>&lt;</span>p</span><span>></span></span>Is <span><span><span>&lt;</span>span</span> <span>id</span><span><span>=</span><span>\"</span>very<span>\"</span></span><span>></span></span>very<span><span><span>&lt;/</span>span</span><span>></span></span> handsome<span><span><span>&lt;/</span>p</span><span>></span></span></span>\n<span>```</span></span>\n\n<span><span>```</span><span>js</span>\n<span>document<span>.</span><span>querySelector</span><span>(</span><span>\"#very\"</span><span>)</span><span>.</span><span>addEventListener</span><span>(</span><span>\"click\"</span><span>,</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>\n  <span>alert</span><span>(</span><span>\"Very handsome!\"</span><span>)</span><span>;</span>\n<span>}</span><span>)</span><span>;</span></span>\n<span>```</span></span>\n\n<span><span>```</span><span>css</span>\n<span><span>span</span> <span>{</span>\n  <span>color</span><span>:</span> red<span>;</span>\n<span>}</span></span>\n<span>```</span></span>\n\n:::\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div></details>\n\n          <div\n            id=\"code-demo-4ead1181\"\n           \n  data-type=\"react\"\n data-title=\"A%20react%20demo\"\n\n            data-code=\"%7B%22js%22%3A%22export%20default%20class%20App%20extends%20React.Component%20%7B%5Cn%20%20constructor(props)%20%7B%5Cn%20%20%20%20super(props)%3B%5Cn%20%20%20%20this.state%20%3D%20%7B%20message%3A%20%5C%22very%20handsome%5C%22%20%7D%3B%5Cn%20%20%7D%5Cn%20%20render()%20%7B%5Cn%20%20%20%20return%20(%5Cn%20%20%20%20%20%20%3Cdiv%20className%3D%5C%22box-react%5C%22%3E%5Cn%20%20%20%20%20%20%20%20Mr.Hope%20is%20%3Cspan%3E%7Bthis.state.message%7D%3C%2Fspan%3E%5Cn%20%20%20%20%20%20%3C%2Fdiv%3E%5Cn%20%20%20%20)%3B%5Cn%20%20%7D%5Cn%7D%5Cn%22%2C%22css%22%3A%22.box-react%20span%20%7B%5Cn%20%20color%3A%20red%3B%5Cn%7D%5Cn%22%7D\"\n          >\n              \n              <div>\n                <div>\n<div><pre><code><span>export</span> <span>default</span> <span>class</span> <span>App</span> <span>extends</span> <span>React<span>.</span>Component</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>props</span><span>)</span> <span>{</span>\n    <span>super</span><span>(</span>props<span>)</span><span>;</span>\n    <span>this</span><span>.</span>state <span>=</span> <span>{</span> <span>message</span><span>:</span> <span>\"very handsome\"</span> <span>}</span><span>;</span>\n  <span>}</span>\n  <span>render</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>(</span>\n      <span>&lt;</span>div className<span>=</span><span>\"box-react\"</span><span>></span>\n        Mr<span>.</span>Hope is <span>&lt;</span>span<span>></span><span>{</span><span>this</span><span>.</span>state<span>.</span>message<span>}</span><span>&lt;</span><span>/</span>span<span>></span>\n      <span>&lt;</span><span>/</span>div<span>></span>\n    <span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><div><pre><code><span>.box-react span</span> <span>{</span>\n  <span>color</span><span>:</span> red<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div>\n            </div>\n          </div>\n          \n        </div>\n<details><summary>Code</summary>\n<div><pre><code>::: demo [react] A react demo\n\n<span><span>```</span><span>js</span>\n<span><span>export</span> <span>default</span> <span>class</span> <span>App</span> <span>extends</span> <span>React<span>.</span>Component</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>props</span><span>)</span> <span>{</span>\n    <span>super</span><span>(</span>props<span>)</span><span>;</span>\n    <span>this</span><span>.</span>state <span>=</span> <span>{</span> <span>message</span><span>:</span> <span>\"very handsome\"</span> <span>}</span><span>;</span>\n  <span>}</span>\n  <span>render</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>(</span>\n      <span>&lt;</span>div className<span>=</span><span>\"box-react\"</span><span>></span>\n        Mr<span>.</span>Hope is <span>&lt;</span>span<span>></span><span>{</span><span>this</span><span>.</span>state<span>.</span>message<span>}</span><span>&lt;</span><span>/</span>span<span>></span>\n      <span>&lt;</span><span>/</span>div<span>></span>\n    <span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span></span>\n<span>```</span></span>\n\n<span><span>```</span><span>css</span>\n<span><span>.box-react span</span> <span>{</span>\n  <span>color</span><span>:</span> red<span>;</span>\n<span>}</span></span>\n<span>```</span></span>\n\n:::\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div></details>\n\n          <div\n            id=\"code-demo-4edf655c\"\n           \n  data-type=\"vue\"\n data-title=\"A%20vue%20demo\"\n\n            data-code=\"%7B%22vue%22%3A%22%3Ctemplate%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22box%5C%22%3E%5Cn%20%20%20%20Mr.Hope%20is%20%3Cspan%3E%7B%7B%20message%20%7D%7D%3C%2Fspan%3E%5Cn%20%20%3C%2Fdiv%3E%5Cn%3C%2Ftemplate%3E%5Cn%3Cscript%3E%5Cnexport%20default%20%7B%5Cn%20%20data%3A%20()%20%3D%3E%20(%7B%20message%3A%20%5C%22very%20handsome%5C%22%20%7D)%2C%5Cn%7D%3B%5Cn%3C%2Fscript%3E%5Cn%3Cstyle%3E%5Cn.box%20span%20%7B%5Cn%20%20color%3A%20red%3B%5Cn%7D%5Cn%3C%2Fstyle%3E%5Cn%22%7D\"\n          >\n              \n              <div>\n                <div>\n<div><pre><code><span><span><span>&lt;</span>template</span><span>></span></span>\n  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>\"</span>box<span>\"</span></span><span>></span></span>\n    Mr.Hope is <span><span><span>&lt;</span>span</span><span>></span></span>{{ message }}<span><span><span>&lt;/</span>span</span><span>></span></span>\n  <span><span><span>&lt;/</span>div</span><span>></span></span>\n<span><span><span>&lt;/</span>template</span><span>></span></span>\n<span><span><span>&lt;</span>script</span><span>></span></span><span><span>\n<span>export</span> <span>default</span> <span>{</span>\n  <span>data</span><span>:</span> <span>(</span><span>)</span> <span>=></span> <span>(</span><span>{</span> <span>message</span><span>:</span> <span>\"very handsome\"</span> <span>}</span><span>)</span><span>,</span>\n<span>}</span><span>;</span>\n</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>\n<span><span><span>&lt;</span>style</span><span>></span></span><span><span>\n<span>.box span</span> <span>{</span>\n  <span>color</span><span>:</span> red<span>;</span>\n<span>}</span>\n</span></span><span><span><span>&lt;/</span>style</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div>\n            </div>\n          </div>\n          \n        </div>\n<details><summary>Code</summary>\n<div><pre><code>::: demo [vue] A vue demo\n\n<span><span>```</span><span>vue</span>\n<span>&lt;template>\n  &lt;div>\n    Mr.Hope is &lt;span>{{ message }}&lt;/span>\n  &lt;/div>\n&lt;/template>\n&lt;script>\nexport default {\n  data: () => ({ message: \"very handsome\" }),\n};\n&lt;/script>\n&lt;style>\n.box span {\n  color: red;\n}\n&lt;/style></span>\n<span>```</span></span>\n\n:::\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div></details>\n\n          <div\n            id=\"code-demo-2b1f2266\"\n           \n  \n data-title=\"A%20normal%20demo\"\n\n            data-code=\"%7B%22md%22%3A%22%23%20Title%5Cn%5Cnis%20very%20handsome.%5Cn%22%2C%22ts%22%3A%22const%20message%3A%20string%20%3D%20%5C%22Mr.Hope%5C%22%3B%5Cn%5Cndocument.querySelector(%5C%22h1%5C%22).innerHTML%20%3D%20message%3B%5Cn%22%2C%22scss%22%3A%22h1%20%7B%5Cn%20%20font-style%3A%20italic%3B%5Cn%5Cn%20%20%2B%20p%20%7B%5Cn%20%20%20%20color%3A%20red%3B%5Cn%20%20%7D%5Cn%7D%5Cn%22%7D\"\n          >\n              \n              <div>\n                <div>\n<div><pre><code><span><span>#</span> Title</span>\n\nis very handsome.\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><div><pre><code><span>const</span> message<span>:</span> <span>string</span> <span>=</span> <span>\"Mr.Hope\"</span><span>;</span>\n\ndocument<span>.</span><span>querySelector</span><span>(</span><span>\"h1\"</span><span>)</span><span>.</span>innerHTML <span>=</span> message<span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><div><pre><code><span>h1 </span><span>{</span>\n  <span>font-style</span><span>:</span> italic<span>;</span>\n\n  <span>+ p </span><span>{</span>\n    <span>color</span><span>:</span> red<span>;</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div>\n            </div>\n          </div>\n          \n        </div>\n<details><summary>Code</summary>\n<div><pre><code>::: demo A normal demo\n\n<span><span>```</span><span>md</span>\n<span><span><span>#</span> Title</span>\n\nis very handsome.</span>\n<span>```</span></span>\n\n<span><span>```</span><span>ts</span>\n<span><span>const</span> message<span>:</span> <span>string</span> <span>=</span> <span>\"Mr.Hope\"</span><span>;</span>\n\ndocument<span>.</span><span>querySelector</span><span>(</span><span>\"h1\"</span><span>)</span><span>.</span>innerHTML <span>=</span> message<span>;</span></span>\n<span>```</span></span>\n\n<span><span>```</span><span>scss</span>\n<span><span>h1 </span><span>{</span>\n  <span>font-style</span><span>:</span> italic<span>;</span>\n\n  <span>+ p </span><span>{</span>\n    <span>color</span><span>:</span> red<span>;</span>\n  <span>}</span>\n<span>}</span></span>\n<span>```</span></span>\n\n:::\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div></details>\n<ul>\n<li><a href=\"https://vuepress-theme-hope.github.io/guide/markdown/demo/\" target=\"_blank\" rel=\"noopener noreferrer\">View Detail</a></li>\n</ul>\n<h3 id=\"presentation\"> Presentation</h3>\n<i>Not supported content</i><details><summary>Code</summary>\n<div><pre><code>@slidestart\n\n<span><span>##</span> Slide 1</span>\n\nA paragraph with some text and a <span>[<span>link</span>](<span>https://mrhope.site</span>)</span>\n\n<span>---</span>\n\n<span><span>##</span> Slide 2</span>\n\n<span>-</span> Item 1\n<span>-</span> Item 2\n\n<span>---</span>\n\n<span><span>##</span> Slide 3.1</span>\n\n<span><span>```</span><span>js</span>\n<span><span>const</span> a <span>=</span> <span>1</span><span>;</span></span>\n<span>```</span></span>\n\n--\n\n<span><span>##</span> Slide 3.2</span>\n\n$$\nJ(\\theta_0,\\theta_1) = \\sum_{i=0}\n$$\n\n@slideend\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div></details>\n<ul>\n<li><a href=\"https://vuepress-theme-hope.github.io/guide/markdown/presentation/\" target=\"_blank\" rel=\"noopener noreferrer\">View Detail</a></li>\n</ul>\n<h2 id=\"other-syntax\"> Other Syntax</h2>\n<div><p>custom title</p>\n<p>A custom information container</p>\n</div>\n<div><p>custom title</p>\n<p>A custom tip container</p>\n</div>\n<div><p>custom title</p>\n<p>A custom warning container</p>\n</div>\n<div><p>custom Title</p>\n<p>A custom danger container</p>\n</div>\n<details><summary>custom title</summary>\n<p>A custom details container</p>\n</details>\n<details><summary>Code</summary>\n<div><pre><code>::: info custom title\n\nA custom information container\n\n:::\n\n::: tip custom title\n\nA custom tip container\n\n:::\n\n::: warning custom title\n\nA custom warning container\n\n:::\n\n::: danger custom Title\n\nA custom danger container\n\n:::\n\n::: details custom title\n\nA custom details container\n\n:::\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div></details>\n<hr>\n<section>\n<ol>\n<li id=\"footnote1\"><p>This is footnote content </p>\n</li>\n</ol>\n</section>\n",
      "date_published": "2022-03-06T10:17:18.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": [
        "Guide"
      ]
    },
    {
      "title": "page config",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/guide/page/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/guide/page/",
      "content_html": "<h2 id=\"page-information\"> Page information</h2>\n<p>You can set page information in Markdown’s Frontmatter.</p>\n<ul>\n<li>\n<p>The author is set to Ms.Hope.</p>\n</li>\n<li>\n<p>The writing time should be January 1, 2020</p>\n</li>\n<li>\n<p>Category is &quot;Guide&quot;</p>\n</li>\n<li>\n<p>Tags are &quot;Page Config&quot; and &quot;Guide&quot;</p>\n</li>\n</ul>\n<h2 id=\"page-content\"> Page content</h2>\n<p>You are free to write your Markdown here.</p>\n<div><p>Tips</p>\n<ul>\n<li>\n<p>Please use the relative link <code>./</code> for pictures in the Markdown folder.</p>\n</li>\n<li>\n<p>For pictures in <code>.vuepress/public</code> folder, please use absolute link <code>/</code> for reference</p>\n</li>\n</ul>\n</div>\n<p>The theme contains a custom badge:</p>\n<blockquote>\n<p>A dark blue badge text badge at the end of line. <i>Not supported content</i></p>\n</blockquote>\n<h2 id=\"page-structure\"> Page structure</h2>\n<p>This page should contain:</p>\n<ul>\n<li>Back to top button</li>\n<li>Route navigation</li>\n<li>Comments</li>\n<li>Footer</li>\n</ul>\n",
      "date_published": "2020-01-01T00:00:00.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Ms.Hope"
        }
      ],
      "tags": [
        "Guide"
      ]
    },
    {
      "title": "Guides",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/guide/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/guide/",
      "content_html": "<h1 id=\"guides\"> Guides</h1>\n<ul>\n<li>\n<p><a href=\"./page.html\">Page Config</a></p>\n</li>\n<li>\n<p><a href=\"./markdown.html\">Markdown Enhance</a></p>\n</li>\n<li>\n<p><a href=\"./disable.html\">Function Disable</a></p>\n</li>\n<li>\n<p><a href=\"./encrypt.html\">Encryption Demo</a></p>\n</li>\n</ul>\n",
      "date_published": "2022-03-06T10:17:18.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": [
        "Guide"
      ]
    },
    {
      "title": "计算机网络",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/interview/Computer-network/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/interview/Computer-network/",
      "content_html": "<h2 id=\"osi与tcp-ip各层的结构与功能-都有哪些协议\"> OSI与TCP/IP各层的结构与功能,都有哪些协议?</h2>\n<h2 id=\"http-https\"> Http | Https</h2>\n<p>参考</p>\n<blockquote>\n<ul>\n<li>https://blog.csdn.net/qq_38289815/article/details/80969419</li>\n</ul>\n</blockquote>\n<h3 id=\"http\"> Http</h3>\n<p>​\t\t超文本传输协议，是一个基于请求与响应，无状态的，应用层的协议，常基于TCP/IP协议传输数据，互联网上应用最为广泛的一种网络协议,所有的WWW文件都必须遵守这个标准。设计HTTP的初衷是为了提供一种发布和接收HTML页面的方法。</p>\n<p><strong>原理/过程</strong></p>\n<ul>\n<li>客户端的浏览器首先要通过网络与服务器建立连接，该连接是通过 TCP 来完成的，一般 TCP 连接的端口号是80。 建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是 MIME 信息包括请求修饰符、客户机信息和许可内容。</li>\n<li>服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是 MIME 信息包括服务器信息、实体信息和可能的内容。</li>\n</ul>\n<p><strong>特点</strong></p>\n<ul>\n<li>http协议支持客户端/服务端模式，也是一种请求/响应模式的协议。</li>\n<li>简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。</li>\n<li>灵活：HTTP允许传输任意类型的数据对象。传输的类型由Content-Type加以标记。</li>\n<li>无连接：限制每次连接只处理一个请求。服务器处理完请求，并收到客户的应答后，即断开连接，但是却不利于客户端与服务器保持会话连接，为了弥补这种不足，产生了两项记录http状态的技术，一个叫做Cookie,一个叫做Session。</li>\n<li>无状态：无状态是指协议对于事务处理没有记忆，后续处理需要前面的信息，则必须重传。</li>\n</ul>\n<h3 id=\"http1-http2-http3\"> HTTP1 | HTTP2 | HTTP3</h3>\n<div><p>参考</p>\n<ul>\n<li><a href=\"https://zhuanlan.zhihu.com/p/102561034\" target=\"_blank\" rel=\"noopener noreferrer\">一文读懂 HTTP1/HTTP2/HTTP/3</a></li>\n<li>https://blog.csdn.net/weixin_41205419/article/details/105510318</li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/26559480\" target=\"_blank\" rel=\"noopener noreferrer\">一文读懂 HTTP/2 特性</a></li>\n</ul>\n</div>\n<h4 id=\"http1-0和http1-1的一些区别\"> HTTP1.0和HTTP1.1的一些区别</h4>\n<p>HTTP1.0最早在网页中使用是在1996年，那个时候只是使用一些较为简单的网页上和网络请求上，而HTTP1.1则在1999年才开始广泛应用于现在的各大浏览器网络请求中，同时HTTP1.1也是当前使用最为广泛的HTTP协议。 主要区别主要体现在：</p>\n<ol>\n<li><strong>缓存处理</strong>，在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。</li>\n<li><strong>带宽优化及网络连接的使用</strong>，HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li>\n<li><strong>错误通知的管理</strong>，在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</li>\n<li><strong>Host头处理</strong>，在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web  Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。</li>\n<li><strong>长连接</strong>，HTTP  1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。</li>\n</ol>\n<h3 id=\"https\"> Https</h3>\n<p>​\t\t《图解HTTP》这本书中曾提过HTTPS是身披SSL外壳的HTTP。HTTPS是一种通过计算机网络进行安全通信的传输协议，经由HTTP进行通信，利用SSL/TLS建立全信道，加密数据包。HTTPS使用的主要目的是提供对网站服务器的身份认证，同时保护交换数据的隐私与完整性。基于HTTP协议，通过SSL或TLS提供加密处理数据、验证对方身份以及数据完整性保护</p>\n<p><strong>原理/过程</strong></p>\n<ul>\n<li>首先服务端给客户端传输证书,这个证书就是公钥,只是包含了很多的信息,比如说证书的办法机构,证书的过期时间</li>\n<li>客户端进行证书的解析,比如说验证办法机构,过期时间,如果发现没有任何问题,就生成一个随机值(私钥),然后用证书对这个私钥进行加密,并发送给服务端</li>\n<li>服务端使用私钥将这个信息进行解密,得到客户端的私钥,然后客户端和服务端就可以通过这个私钥进行通信了</li>\n<li>服务端将消息进行对称加密(简单来说就是讲消息和私钥进行混合,除非知道私钥否则服务进行解密),私钥正好只有客户端和服务端知道,所以信息就比较安全了</li>\n<li>服务端将进行对称加密后的消息进行传送</li>\n<li>客户端使用私钥进行信息的解密</li>\n</ul>\n<p><strong>特点</strong></p>\n<ul>\n<li>**数据保密性：**保证数据内容在传输的过程中不会被第三方查看。就像快递员传递包裹一样，都进行了封装，别人无法获知里面装了什么 。</li>\n<li>**数据完整性：**及时发现被第三方篡改的传输内容。就像快递员虽然不知道包裹里装了什么东西，但他有可能中途掉包，数据完整性就是指如果被掉包，我们能轻松发现并拒收 。</li>\n<li>**身份校验安全性：**保证数据到达用户期望的目的地。就像我们邮寄包裹时，虽然是一个封装好的未掉包的包裹，但必须确定这个包裹不会送错地方，通过身份校验来确保送对了地方 。</li>\n</ul>\n<p><strong>缺点</strong></p>\n<ul>\n<li>HTTPS 协议握手阶段比较费时，会使页面的加载时间延长近。</li>\n<li>HTTPS 连接缓存不如 HTTP 高效，会增加数据开销，甚至已有的安全措施也会因此而受到影响。</li>\n<li>HTTPS 协议的安全是有范围的，在黑客攻击、拒绝服务攻击和服务器劫持等方面几乎起不到什么作用。</li>\n<li>SSL 证书通常需要绑定 IP，不能在同一 IP 上绑定多个域名，IPv4 资源不可能支撑这个消耗。</li>\n<li>成本增加。部署 HTTPS 后，因为 HTTPS 协议的工作要增加额外的计算资源消耗，例如 SSL 协议加密算法和 SSL 交互次数将占用一定的计算资源和服务器成本。</li>\n<li>HTTPS 协议的加密范围也比较有限。最关键的，SSL 证书的信用链体系并不安全，特别是在某些国家可以控制 CA 根证书的情况下，中间人攻击一样可行。</li>\n</ul>\n<h3 id=\"http-https的不同\"> Http | Https的不同</h3>\n<p>Http协议运行在TCP之上，明文传输，客户端与服务器端都无法验证对方的身份；Https是身披SSL(Secure Socket Layer)外壳的Http，运行于SSL上，SSL运行于TCP之上，是添加了加密和认证机制的HTTP。HTTP 的连接很简单，是无状态的。HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。(无状态的意思是其数据包的发送、传输和接收都是相互独立的。无连接的意思是指通信双方都不长久的维持对方的任何信息。)</p>\n<ul>\n<li>端口不同：Http与Http使用不同的连接方式，用的端口也不一样，前者是80，后者是443；</li>\n<li>资源消耗：和HTTP通信相比，Https通信会由于加减密处理消耗更多的CPU和内存资源；</li>\n<li>开销：Https通信需要证书，而证书一般需要向认证机构购买；</li>\n</ul>\n<h2 id=\"tcp\"> TCP</h2>\n<h3 id=\"tcp-ip网络模型\"> TCP/IP网络模型</h3>\n<p>​\t\t计算机与网络设备要相互通信，双方就必须基于相同的方法。比如，如何探测到通信目标、由哪一边先发起通信、使用哪种语言进行通信、怎样结束通信等规则都需要事先确定。不同的硬件、操作系统之间的通信，所有的这一切都需要一种规则。而我们就把这种规则称为<strong>协议（protocol）</strong>。</p>\n<p><strong>TCP/IP</strong> 是互联网相关的各类协议族的总称，比如：<strong>TCP，UDP，IP，FTP，HTTP，ICMP，SMTP</strong> 等都属于 TCP/IP 族内的协议。</p>\n<p><strong>TCP/IP</strong>模型是互联网的基础，它是一系列网络协议的总称。这些协议可以划分为四层，分别为<strong>链路层、网络层、传输层和应用层</strong>。</p>\n<ul>\n<li>**链路层：**负责封装和解封装IP报文，发送和接受ARP/RARP报文等。</li>\n<li>**网络层：**负责路由以及把分组报文发送给目标网络或主机。</li>\n<li>**传输层：**负责对报文进行分组和重组，并以TCP或UDP协议格式封装报文。</li>\n<li>**应用层：**负责向用户提供应用程序，比如HTTP、FTP、Telnet、DNS、SMTP等。</li>\n</ul>\n<h3 id=\"tcp连接-三次握手\"> TCP连接：三次握手</h3>\n<p>参考</p>\n<blockquote>\n<ul>\n<li>https://blog.csdn.net/qq_38950316/article/details/81087809</li>\n<li>https://mp.weixin.qq.com/s/u56NcMs68sgi6uDpzJ61yw</li>\n</ul>\n</blockquote>\n<h4 id=\"字段说明\"> 字段说明</h4>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">字段</th>\n<th style=\"text-align:left\">含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">URG</td>\n<td style=\"text-align:left\">紧急指针是否有效。为1，表示某一位需要被优先处理</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ACK</td>\n<td style=\"text-align:left\">确认号是否有效，一般置为1。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">PSH</td>\n<td style=\"text-align:left\">提示接收端应用程序立即从TCP缓冲区把数据读走。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">RST</td>\n<td style=\"text-align:left\">对方要求重新建立连接，复位。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">SYN</td>\n<td style=\"text-align:left\">同步序列编号（Synchronize Sequence Numbers）。请求建立连接，并在其序列号的字段进行序列号的初始值设定。建立连接，设置为1</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">FIN</td>\n<td style=\"text-align:left\">希望断开连接。</td>\n</tr>\n</tbody>\n</table>\n<p>三次握⼿的⽬的是建⽴可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，⽽三次握⼿最主 要的⽬的就是双⽅确认⾃⼰与对⽅的发送与接收是正常的。发送SYN用来请求连接，发送ACK表示发过来的SYN已接收，从发送SYN端到发送ACK端这边的通信正常</p>\n<p><img src=\"./images/Computer-network/TCP_three-way_handshake.png\" alt=\"TCP三次握手\" /></p>\n<ul>\n<li>\n<p><strong>第一次握手：SYN-SENT</strong></p>\n<p>客户端向服务端发送连接请求报文段和<code>SYN=1</code>请求标志。该报文段中包含自身的数据通讯初始序号<code>seq=x</code>。请求发送后，客户端便进入 <code>SYN-SENT</code> 状态。</p>\n</li>\n<li>\n<p><strong>第二次握手：SYN-RECEIVED</strong></p>\n<p>服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，<strong>服务器发送请求标志SYN=1，发送确认标志ACK=1，即SYN+ACK包，然后发送自己的序号seq=y，发送客户端的确认序号ack=x+1</strong>，发送完成后便进入 <code>SYN-RECEIVED</code> 状态。</p>\n</li>\n<li>\n<p><strong>第三次握手：ESTABLISHED</strong></p>\n<p>当客户端收到连接同意的应答后，还要向服务端发送一个确认报文，<strong>客户端发送ACK确认号，发送自己的序号seq=x+1，发送对方的确认号ack=y+1</strong>。客户端发完这个报文段后便进入 ESTABLISHED 状态，服务端收到这个应答后也进入 ESTABLISHED 状态，此时连接建立成功。</p>\n</li>\n</ul>\n<h4 id=\"为什么要传回-syn\"> 为什么要传回 SYN</h4>\n<p>接收端传回发送端所发送的 SYN 是为了告诉发送端，我接收到的信息确实就是你所发送的信号了。</p>\n<blockquote>\n<p>SYN 是 TCP/IP 建⽴连接时使⽤的握⼿信号。在客户机和服务器之间建⽴正常的 TCP ⽹络连接时， 客户机⾸先发出⼀个 SYN 消息，服务器使⽤ <strong>SYN-ACK</strong> 应答表示接收到了这个消息，最后客户机再 以 <strong>ACK(Acknowledgement</strong>[汉译：确认字符 ,在数据通信传输中，接收站发给发送站的⼀种传输控制 字符。它表示确认发来的数据已经接受⽆误。 ]）消息响应。这样在客户机和服务器之间才能建⽴ 起可靠的TCP连接，数据才可以在客户机和服务器之间传递。</p>\n</blockquote>\n<h4 id=\"传了-syn-为啥还要传-ack\"> 传了 SYN,为啥还要传 ACK</h4>\n<p>双⽅通信⽆误必须是两者互相发送信息都⽆误。传了 SYN，证明发送⽅到接收⽅的通道没有问题，但是 接收⽅到发送⽅的通道还需要 ACK 信号来进⾏验证。</p>\n<h3 id=\"tcp断开-四次挥手\"> TCP断开：四次挥手</h3>\n<p><img src=\"./images/Computer-network/TCP_waved_four_times.jpeg\" alt=\"TCP四次挥手\" /></p>\n<ul>\n<li>第一次挥手：客户端发出释放FIN=1，自己序列号seq=u，进入<code>FIN-WAIT-1</code>状态</li>\n<li>第二次挥手：服务器收到客户端的后，发出ACK=1确认标志和客户端的确认号ack=u+1，自己的序列号seq=v，进入CLOSE-WAIT状态</li>\n<li>第三次挥手：客户端收到服务器确认结果后，进入FIN-WAIT-2状态。此时服务器发送释放FIN=1信号，确认标志ACK=1，确认序号ack=u+1，自己序号seq=w，服务器进入LAST-ACK（最后确认态）</li>\n<li>第四次挥手：客户端收到回复后，发送确认ACK=1，ack=w+1，自己的seq=u+1，客户端进入TIME-WAIT（时间等待）。客户端经过2个最长报文段寿命后，客户端CLOSE；服务器收到确认后，立刻进入CLOSE状态。</li>\n</ul>\n<h4 id=\"为什么-tcp-建立连接需要三次握手-而不是两次\"> 为什么 TCP 建立连接需要三次握手，而不是两次？</h4>\n<ul>\n<li>为了实现可靠数据传输， TCP 协议的通信双方， 都必须维护一个序列号， 以标识发送出去的数据包中， 哪些是已经被对方收到的。 三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤</li>\n<li>如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认</li>\n</ul>\n<h4 id=\"为什么连接的时候是三次握手-关闭的时候却是四次握手\"> 为什么连接的时候是三次握手，关闭的时候却是四次握手？</h4>\n<p>因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，&quot;你发的FIN报文我收到了&quot;。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。</p>\n<h4 id=\"为什么time-wait状态需要经过2msl-最大报文段生存时间-才能返回到close状态\"> 为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？</h4>\n<p>虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。</p>\n<h4 id=\"如果已经建立了连接-但是客户端突然出现故障了怎么办\"> 如果已经建立了连接，但是客户端突然出现故障了怎么办？</h4>\n<p>TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p>\n<h4 id=\"tcp协议如何保证可靠传输\"> TCP协议如何保证可靠传输</h4>\n<div><p>参考</p>\n<ul>\n<li>https://juejin.cn/post/6916073832335802382</li>\n<li>https://zhuanlan.zhihu.com/p/112317245</li>\n</ul>\n</div>\n<ul>\n<li>\n<p>1）校验和 Checksum（稍作了解即可）</p>\n</li>\n<li>\n<p>2）序列号和确认应答机制（重要）</p>\n</li>\n<li>\n<p>3）重传机制（重要）</p>\n</li>\n<li>\n<p>4）流量控制（滑动窗口协议）（非常重要）</p>\n</li>\n<li>\n<p>5）拥塞控制（重要）</p>\n</li>\n<li>\n<p>超时重传：当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</p>\n</li>\n<li>\n<p>TCP给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。</p>\n</li>\n<li>\n<p>校验和：TCP将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段。</p>\n</li>\n<li>\n<p>TCP的接收端会丢弃重复的数据。</p>\n</li>\n<li>\n<p>流量控制：TCP连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的我数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP使用的流量控制协议是可变大小的滑动窗口协议。</p>\n</li>\n<li>\n<p>拥塞控制：当网络拥塞时，减少数据的发送。</p>\n</li>\n</ul>\n<h4 id=\"tcp滑动窗口和流量控制\"> TCP滑动窗口和流量控制</h4>\n<p>参考</p>\n<blockquote>\n<ul>\n<li>https://blog.csdn.net/qq_37653144/article/details/82765098</li>\n</ul>\n</blockquote>\n<p>TCP 利⽤滑动窗⼝实现流量控制。流量控制是为了控制发送⽅发送速率，保证接收⽅来得及接收。 接收方发送的确认报⽂中的窗⼝字段可以⽤来控制发送⽅窗⼝⼤⼩，从⽽影响发送⽅的发送速率。将窗⼝ 字段设置为 0，则发送⽅不能发送数据。</p>\n<h4 id=\"tcp拥塞控制\"> TCP拥塞控制</h4>\n<p>在某段时间，若对⽹络中某⼀资源的需求超过了该资源所能提供的可⽤部分，⽹络的性能就要变坏。这 种情况就叫拥塞。拥塞控制就是为了防⽌过多的数据注⼊到⽹络中，这样就可以使⽹络中的路由器或链 路不致过载。</p>\n<p>拥塞控制所要做的都有⼀个前提，就是⽹络能够承受现有的⽹络负荷。拥塞控制是⼀个全 局性的过程，涉及到所有的主机，所有的路由器，以及与降低⽹络传输性能有关的所有因素。相反，流 量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据 的速率，以便使接收端来得及接收。</p>\n<p>为了进⾏拥塞控制，TCP 发送⽅要维持⼀个 拥塞窗⼝(cwnd) 的状态变量。拥塞控制窗⼝的⼤⼩取决于 ⽹络的拥塞程度，并且动态变化。发送⽅让⾃⼰的发送窗⼝取为拥塞窗⼝和接收⽅的接受窗⼝中᫾⼩的 ⼀个。</p>\n<p>TCP的拥塞控制采⽤了四种算法，即 慢开始 、 拥塞避免 、快重传 和 快恢复。在⽹络层也可以使路 由器采⽤适当的分组丢弃策略（如主动队列管理 AQM），以减少⽹络拥塞的发⽣。</p>\n<blockquote>\n<ul>\n<li>慢开始： 慢开始算法的思路是当主机开始发送数据时，如果⽴即把⼤量数据字节注⼊到⽹络， 那么可能会引起⽹络阻塞，因为现在还不知道⽹络的符合情况。经验表明，᫾好的⽅法是先探测 ⼀下，即由⼩到⼤逐渐增⼤发送窗⼝，也就是由⼩到⼤逐渐增⼤拥塞窗⼝数值。cwnd初始值为 1，每经过⼀个传播轮次，cwnd加倍。</li>\n<li>拥塞避免： 拥塞避免算法的思路是让拥塞窗⼝cwnd缓慢增⼤，即每经过⼀个往返时间RTT就把发 送放的cwnd加1.</li>\n<li>快重传与快恢复： 在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是 ⼀种拥塞控制算法，它能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了，TCP 将会使⽤ 定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如 果接收机接收到⼀个不按顺序的数据段，它会⽴即给发送机发送⼀个重复确认。如果发送机接收 到三个重复确认，它会假定确认件指出的数据段丢失了，并⽴即重传这些丢失的数据段。有了 FRR，就不会因为重传时要求的暂停被耽误。 　当有单独的数据包丢失时，快速重传和恢复 （FRR）能最有效地⼯作。当有多个数据信息包在某⼀段很短的时间内丢失时，它则不能很有效 地⼯作。</li>\n</ul>\n</blockquote>\n<h2 id=\"udp\"> UDP</h2>\n<p>​\t\tUDP协议全称是<strong>用户数据报协议</strong>，在网络中它与TCP协议一样用于处理数据包，是一种无连接的协议。<strong>在OSI模型中，在第四层——传输层，处于IP协议的上一层</strong>。<strong>UDP有不提供数据包分组、组装和不能对数据包进行排序的缺点</strong>，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。</p>\n<h3 id=\"特点\"> 特点</h3>\n<ol>\n<li><strong>面向无连接</strong></li>\n</ol>\n<p>首先 UDP 是不需要和 TCP一样在发送数据前进行三次握手建立连接的，想发数据就可以开始发送了。并且也只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作。</p>\n<p>具体来说就是：</p>\n<ul>\n<li>在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了</li>\n<li>在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作</li>\n</ul>\n<ol start=\"2\">\n<li><strong>有单播，多播，广播的功能</strong></li>\n</ol>\n<p>UDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能。</p>\n<ol start=\"3\">\n<li><strong>UDP是面向报文的</strong></li>\n</ol>\n<p>发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。因此，应用程序必须选择合适大小的报文</p>\n<ol start=\"4\">\n<li><strong>不可靠性</strong></li>\n</ol>\n<p>首先不可靠性体现在无连接上，通信都不需要建立连接，想发就发，这样的情况肯定不可靠。</p>\n<p>并且收到什么数据就传递什么数据，并且也不会备份数据，发送数据也不会关心对方是否已经正确接收到数据了。</p>\n<p>再者网络环境时好时坏，但是 UDP 因为没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。</p>\n<ol start=\"5\">\n<li><strong>头部开销小，传输数据报文时是很高效的。</strong></li>\n</ol>\n<h2 id=\"tcp-udp-区别\"> TCP | UDP 区别</h2>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"></th>\n<th style=\"text-align:center\">UDP</th>\n<th style=\"text-align:center\">TCP</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">是否连接</td>\n<td style=\"text-align:center\">无连接</td>\n<td style=\"text-align:center\">面向连接</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">是否可靠</td>\n<td style=\"text-align:center\">不可靠传输，不使用流量控制和拥塞控制</td>\n<td style=\"text-align:center\">可靠传输，使用流量控制和拥塞控制</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">连接对象个数</td>\n<td style=\"text-align:center\">支持一对一，一对多，多对一和多对多交互通信</td>\n<td style=\"text-align:center\">只能是一对一通信</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">传输方式</td>\n<td style=\"text-align:center\">面向报文</td>\n<td style=\"text-align:center\">面向字节流</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">首部开销</td>\n<td style=\"text-align:center\">首部开销小，仅8字节</td>\n<td style=\"text-align:center\">首部最小20字节，最大60字节</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">适用场景</td>\n<td style=\"text-align:center\">适用于实时应用（IP电话、视频会议、直播等）</td>\n<td style=\"text-align:center\">适用于要求可靠传输的应用，例如文件传输</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>TCP向上层提供面向连接的可靠服务 ，UDP向上层提供无连接不可靠服务。</li>\n<li>虽然 UDP 并没有 TCP 传输来的准确，但是也能在很多实时性要求高的地方有所作为</li>\n<li>对数据准确性要求高，速度可以相对较慢的，可以选用TCP</li>\n</ul>\n<h2 id=\"ssl握手协议\"> SSL握手协议</h2>\n<p>参考</p>\n<blockquote>\n<ul>\n<li>http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html</li>\n<li>https://www.cnblogs.com/sunfb/p/3443221.html</li>\n</ul>\n</blockquote>\n<p>SSL的握手过程严格说是SSL协议的子协议，RFC5246(SSL V1.2）分为三个子协议，握手协议，记录协议（加密传输数据）和告警协议（用于告警和关闭连接）。握手过程实际就是握手协议的内容。</p>\n<ol>\n<li>客户端与服务器需要就一组用于保护数据的算法达成一致；</li>\n<li>它们需要确立一组由那些算法所使用的加密密钥；</li>\n<li>握手还可以选择对客户端进行认证。</li>\n</ol>\n<h3 id=\"_1-client-hello\"> 1. Client Hello</h3>\n<p>客户端发起会话，里面有以下两个信息最为重要</p>\n<ol>\n<li>客户端随机数，用于生成主密钥；</li>\n<li>客户端支持的密码套件列表，具体不展开，提供很多内容，关键看服务器端选哪个组合。</li>\n</ol>\n<h3 id=\"_2-server-hello\"> 2. Server Hello</h3>\n<p>服务端产生第一次应答，里面同样有两个信息很重要</p>\n<ol>\n<li>服务端随机数，用于生成主密钥；</li>\n<li>确定密码套件（下图红框所示），这里就看出服务器将使用DH算法作为密钥交换算法，这在握手过程中会和RSA有所区别，注意这不是加密算法，AES_128_GCM才是，不在本文讨论范围内。</li>\n</ol>\n<h3 id=\"_3-certificate\"> 3. Certificate</h3>\n<p>服务端向客户端发送自己的证书，当前显示这是一个自签的证书（keytool工具生成）证书更多的是验证身份，其中包含了公钥，可用于RSA密钥交换算法的加密。</p>\n<h2 id=\"浏览器输入url到展示到浏览器页面渲染过程\"> 浏览器输入URL到展示到浏览器页面渲染过程</h2>\n<p>参考</p>\n<blockquote>\n<ul>\n<li>https://blog.csdn.net/weixin_30693683/article/details/100092946</li>\n<li>https://segmentfault.com/a/1190000006879700</li>\n</ul>\n</blockquote>\n<h2 id=\"arp协议\"> ARP协议</h2>\n<div><p>参考</p>\n<ul>\n<li>https://blog.csdn.net/ever_peng/article/details/80008638</li>\n</ul>\n</div>\n<h2 id=\"socket\"> Socket</h2>\n<h3 id=\"使用的函数\"> 使用的函数</h3>\n<p>参考</p>\n<blockquote>\n<ul>\n<li>https://blog.csdn.net/wy1550365215/article/details/76376875</li>\n</ul>\n</blockquote>\n<h2 id=\"常见的http状态码以及其代表的含义\"> 常见的HTTP状态码以及其代表的含义</h2>\n<p><img src=\"./images/Computer-network/status_code.png\" alt=\"状态码\" /></p>\n<p>参考</p>\n<blockquote>\n<ul>\n<li>https://www.cnblogs.com/wpf1913/articles/http-state.html</li>\n</ul>\n</blockquote>\n<h3 id=\"成功2××-成功处理了请求的状态码。\"> 成功2××：成功处理了请求的状态码。</h3>\n<p>200            服务器已成功处理了请求并提供了请求的网页。\n204            服务器成功处理了请求，但没有返回任何内容。</p>\n<p>​</p>\n<h3 id=\"重定向3××-每次请求中使用重定向不要超过-5-次。\"> 重定向3××：每次请求中使用重定向不要超过 5 次。</h3>\n<p>301            请求的网页已永久移动到新位置。当URLs发生变化时，使用301代码。搜索引擎索引中保存新的URL。\n302            请求的网页临时移动到新位置。搜索引擎索引中保存原来的URL。\n304            如果网页自请求者上次请求后没有更新，则用304代码告诉搜索引擎机器人，可节省带宽和开销。</p>\n<h3 id=\"客户端错误4××-表示请求可能出错-妨碍了服务器的处理。\"> 客户端错误4××：表示请求可能出错，妨碍了服务器的处理。</h3>\n<p>400             服务器不理解请求的语法。\n403             服务器拒绝请求。\n404             服务器找不到请求的网页。服务器上不存在的网页经常会返回此代码。\n410             请求的资源永久删除后，服务器返回此响应。该代码与 404（未找到）代码相似，但在资源以前存在而现在不存在的情况下，有时用来替代404 代码。如果资源已永久删除，应当使用 301 指定资源的新位置。</p>\n<h3 id=\"服务器错误5××-表示服务器在处理请求时发生内部错误。这些错误可能是服务器本身的错误-而不是请求出错。\"> 服务器错误5××：表示服务器在处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错。</h3>\n<p>500              服务器遇到错误，无法完成请求。\n503              服务器目前无法使用（由于超载或停机维护）。通常，这只是暂时状态。</p>\n",
      "date_published": "2021-03-21T15:13:00.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": []
    },
    {
      "title": "Java面试整理",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/interview/Java-Interview/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/interview/Java-Interview/",
      "content_html": "<h1 id=\"学习路线\"> 学习路线</h1>\n<p><img src=\"./images/Java_learning_roadmap.png\" alt=\"Java学习路线图\" /></p>\n<h2 id=\"java\"> Java</h2>\n<blockquote>\n<ul>\n<li>\n<p><a href=\"https://wiki.lifeisgg.online/archives/Java-JVM/\" target=\"_blank\" rel=\"noopener noreferrer\">Java-JVM</a></p>\n</li>\n<li>\n<p><a href=\"https://wiki.lifeisgg.online/archives/Java-%E5%AE%B9%E5%99%A8\" target=\"_blank\" rel=\"noopener noreferrer\">Java-容器</a></p>\n</li>\n<li>\n<p><a href=\"https://wiki.lifeisgg.online/archives/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91/\" target=\"_blank\" rel=\"noopener noreferrer\">Java-多线程并发</a></p>\n</li>\n<li>\n<p><a href=\"https://wiki.lifeisgg.online/archives/Java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/\" target=\"_blank\" rel=\"noopener noreferrer\">Java-设计模式</a></p>\n</li>\n<li>\n<p><a href=\"https://wiki.lifeisgg.online/archives/Java-%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB/\" target=\"_blank\" rel=\"noopener noreferrer\">Java-方法汇总</a></p>\n</li>\n<li>\n<p><a href=\"https://wiki.lifeisgg.online/archives/Java-%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/\" target=\"_blank\" rel=\"noopener noreferrer\">Java-基础面试题</a></p>\n</li>\n<li>\n<p><a href=\"https://wiki.lifeisgg.online/archives/Java-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0/\" target=\"_blank\" rel=\"noopener noreferrer\">Java-基础知识笔记</a></p>\n</li>\n</ul>\n</blockquote>\n<h2 id=\"数据结构算法\"> 数据结构算法</h2>\n<blockquote>\n<ul>\n<li><a href=\"https://wiki.lifeisgg.online/archives/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&amp;%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/\" target=\"_blank\" rel=\"noopener noreferrer\">数据结构&amp;算法笔记</a></li>\n<li><a href=\"https://wiki.lifeisgg.online/archives/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&amp;%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE%E5%90%88%E9%9B%86/\" target=\"_blank\" rel=\"noopener noreferrer\">数据结构&amp;算法题目合集</a></li>\n</ul>\n</blockquote>\n<h2 id=\"mysql\"> Mysql</h2>\n<blockquote>\n<ul>\n<li><a href=\"https://wiki.lifeisgg.online/archives/Mysql%E9%9D%A2%E8%AF%95%E9%A2%98/\" target=\"_blank\" rel=\"noopener noreferrer\">Mysql面试题</a></li>\n</ul>\n</blockquote>\n<h2 id=\"spring\"> Spring</h2>\n<blockquote>\n<ul>\n<li><a href=\"https://wiki.lifeisgg.online/archives/Spring%E9%9D%A2%E8%AF%95%E9%A2%98/\" target=\"_blank\" rel=\"noopener noreferrer\">Spring面试题</a></li>\n<li><a href=\"https://wiki.lifeisgg.online/archives/SpringMVC%E9%9D%A2%E8%AF%95%E9%A2%98/\" target=\"_blank\" rel=\"noopener noreferrer\">SpringMVC面试题</a></li>\n</ul>\n</blockquote>\n<h2 id=\"其它面试题\"> 其它面试题</h2>\n<blockquote>\n<ul>\n<li><a href=\"https://wiki.lifeisgg.online/archives/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%85%B6%E5%AE%83%E9%9D%A2%E8%AF%95%E9%A2%98/\" target=\"_blank\" rel=\"noopener noreferrer\">计算机其它面试题</a></li>\n</ul>\n</blockquote>\n",
      "date_published": "2020-09-16T18:12:23.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": []
    },
    {
      "title": "操作系统",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/interview/OperatingSystem/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/interview/OperatingSystem/",
      "content_html": "<h2 id=\"参考\"> 参考</h2>\n<blockquote>\n<ul>\n<li>https://www.cnblogs.com/inception6-lxc/p/9073983.html</li>\n</ul>\n</blockquote>\n<h2 id=\"进程和线程\"> 进程和线程</h2>\n<ul>\n<li>进程是对运行时程序的封装，是系统进行资源调度和分配的的基本单位，实现了操作系统的并发；</li>\n<li>线程是进程的子任务，是CPU调度和分派的基本单位，用于保证程序的 实时性，实现进程内部的并发；</li>\n<li>一个程序至少有一个进程，一个进程至少有一个线程，线程依赖于进程而存在；</li>\n<li>进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存。</li>\n</ul>\n<p>线程是进程划分成的更⼩的运⾏单位,⼀个进程在其执⾏的过程中可以产⽣多个线程。线程和进 程最⼤的不同在于基本上各进程是独⽴的，⽽各线程则不⼀定，因为同⼀进程中的线程极有可能会相互 影响。线程执⾏开销⼩，但不利于资源的管理和保护；⽽进程正相反</p>\n<h3 id=\"进程\"> 进程</h3>\n<h4 id=\"进程的状态\"> 进程的状态</h4>\n<ul>\n<li>创建状态(new) ：进程正在被创建，尚未到就绪状态。</li>\n<li>就绪状态(ready) ：进程已处于准备运⾏状态，即进程获得了除了处理器之外的⼀切所需资源， ⼀旦得到处理器资源(处理器分配的时间⽚)即可运⾏。</li>\n<li>运⾏状态(running) ：进程正在处理器上上运⾏(单核 CPU 下任意时刻只有⼀个进程处于运⾏状 态)。</li>\n<li>阻塞状态(waiting) ：⼜称为等待状态，进程正在等待某⼀事件⽽暂停运⾏如等待某资源为可⽤ 或等待 IO 操作完成。即使处理器空闲，该进程也不能运⾏。</li>\n<li>结束状态(terminated) ：进程正在从系统中消失。可能是进程正常结束或其他原因中断退出运 ⾏。</li>\n</ul>\n<p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/OperatingSustem/进程的五种状态.png\" alt=\"Aryfbt\" /></p>\n<h4 id=\"进程的七种通信方式\"> 进程的七种通信方式</h4>\n<p>参考</p>\n<blockquote>\n<ul>\n<li><a href=\"https://www.jianshu.com/p/c1015f5ffa74\" target=\"_blank\" rel=\"noopener noreferrer\">进程间通信IPC (InterProcess Communication)</a></li>\n</ul>\n</blockquote>\n<ol>\n<li>**管道/匿名管道(Pipes) ：**⽤于具有亲缘关系的⽗⼦进程间或者兄弟进程之间的通信。</li>\n<li><strong>有名管道(Names Pipes) :</strong> 匿名管道由于没有名字，只能⽤于亲缘关系的进程间通信。为了克服 这个缺点，提出了有名管道。有名管道严格遵循先进先出(first in first out)。有名管道以磁 盘⽂件的⽅式存在，可以实现本机任意两个进程通信。</li>\n<li>**信号(Signal) ：**信号是⼀种⽐较复杂的通信⽅式，⽤于通知接收进程某个事件已经发⽣；</li>\n<li><strong>消息队列(Message Queuing) ：<strong>消息队列是消息的链表,具有特定的格式,存放在内存中并由消息 队列标识符标识。管道和消息队列的通信数据都是先进先出</strong>的</strong>原则。与管道（⽆名管道：只存在 于内存中的⽂件；命名管道：存在于实际的磁盘介质或者⽂件系统）不同的是消息队列存放在内 核中，只有在内核重启(即，操作系统重启)或者显示地删除⼀个消息队列时，该消息队列才会被 真正的删除。消息队列可以实现消息的随机查询,消息不⼀定要以先进先出的次序读取,也可以按 消息的类型读取.⽐ FIFO 更有优势。消息队列克服了信号承载信息量少，管道只能承载⽆格式 字 节流以及缓冲区⼤⼩受限等缺。</li>\n<li>**信号量(Semaphores) ：**信号量是⼀个计数器，⽤于多进程对共享数据的访问，信号量的意图在 于进程间同步。这种通信⽅式主要⽤于解决与同步相关的问题并避免竞争条件。</li>\n<li>**共享内存(Shared memory) ：**使得多个进程可以访问同⼀块内存空间，不同进程可以及时看到对 ⽅进程中对共享内存中数据的更新。这种⽅式需要依靠某种同步操作，如互斥锁和信号量等。可 以说这是最有⽤的进程间通信⽅式。</li>\n<li><strong>套接字(Sockets) :</strong> 此⽅法主要⽤于在客户端和服务器之间通过⽹络进⾏通信。套接字是⽀持 TCP/IP 的⽹络通信的基本操作单元，可以看做是不同主机之间的进程进⾏双向通信的端点，简 单的说就是通信的两⽅的⼀种约定，⽤套接字中的相关函数来完成通信过程。</li>\n</ol>\n<h4 id=\"进程的调度算法\"> 进程的调度算法</h4>\n<ul>\n<li><strong>先到先服务(FCFS)调度算法 :</strong> 从就绪队列中选择⼀个最先进⼊该队列的进程为之分配资源，使 它⽴即执⾏并⼀直执⾏到完成或发⽣某事件⽽被阻塞放弃占⽤ CPU 时再重新调度。</li>\n<li><strong>短作业优先(SJF)的调度算法 :</strong> 从就绪队列中选出⼀个估计运⾏时间最短的进程为之分配资源， 使它⽴即执⾏并⼀直执⾏到完成或发⽣某事件⽽被阻塞放弃占⽤ CPU 时再重新调度。</li>\n<li><strong>时间⽚轮转调度算法 :</strong> 时间⽚轮转调度是⼀种最古⽼，最简单，最公平且使⽤最⼴的算法，⼜ 称 RR(Round robin)调度。每个进程被分配⼀个时间段，称作它的时间⽚，即该进程允许运⾏的 时间。</li>\n<li>**多级反馈队列调度算法 ：**前⾯介绍的⼏种进程调度的算法都有⼀定的局限性。如短进程优先的 调度算法，仅照顾了短进程⽽忽略了⻓进程 。多级反馈队列调度算法既能使⾼优先级的作业得 到响应⼜能使短作业（进程）迅速完成。，因⽽它是⽬前被公认的⼀种较好的进程调度算法， UNIX 操作系统采取的便是这种调度算法。</li>\n<li><strong>优先级调度 ：</strong> 为每个流程分配优先级，⾸先执⾏具有最⾼优先级的进程，依此类推。具有相同 优先级的进程以 FCFS ⽅式执⾏。可以根据内存要求，时间要求或任何其他资源要求来确定优先 级。</li>\n</ul>\n<h3 id=\"线程\"> 线程</h3>\n<h4 id=\"线程的状态-生命周期和状态\"> 线程的状态/⽣命周期和状态</h4>\n<p>![线程生命周期]</p>\n<p>线程在⽣命周期中并不是固定处于某⼀个状态⽽是随着代码的执⾏在不同状态之间切换。Java 线程状 态变迁如下图所示（图源《Java 并发编程艺术》4.1.4 节）：</p>\n<p>![线程生命周期2]</p>\n<p>由上图可以看出：线程创建之后它将处于 NEW（新建） 状态，调⽤ start() ⽅法后开始运⾏，线程 这时候处于 READY（可运⾏） 状态。可运⾏状态的线程获得了 CPU 时间⽚（timeslice）后就处于 RUNNING（运⾏） 状态。</p>\n<p>​\t\t当线程执⾏ <strong>wait()</strong> ⽅法之后，线程进⼊ <strong>WAITING（等待）</strong> 状态。进⼊等待状态的线程需要依靠其他 线程的通知才能够返回到运⾏状态，⽽ TIME_WAITING(超时等待) 状态相当于在等待状态的基础上增加 了超时限制，⽐如通过 sleep（long millis） ⽅法或 wait（long millis） ⽅法可以将 Java 线程置于 TIMED WAITING 状态。当超时时间到达后 Java 线程将会返回到 RUNNABLE 状态。当线程调 ⽤同步⽅法时，在没有获取到锁的情况下，线程将会进⼊到 BLOCKED（阻塞） 状态。线程在执⾏ Runnable 的 run() ⽅法之后将会进⼊到 TERMINATED（终⽌） 状态。</p>\n<h4 id=\"线程等待的两种方法\"> 线程等待的两种方法</h4>\n<ul>\n<li>sleep()</li>\n<li>wait()</li>\n</ul>\n<h5 id=\"相同不同点\"> 相同不同点</h5>\n<p>两者最主要的区别在于：sleep ⽅法没有释放锁，⽽ wait ⽅法释放了锁 。</p>\n<p>两者都可以暂停线程的执⾏。 Wait 通常被⽤于线程间交互/通信，sleep 通常被⽤于暂停执⾏。</p>\n<p>wait() ⽅法被调⽤后，线程不会⾃动苏醒，需要别的线程调⽤同⼀个对象上的 notify() 或者 notifyAll() ⽅法。</p>\n<p>sleep() ⽅法执⾏完成后，线程会⾃动苏醒。或者可以使⽤ wait(long timeout)超时后线程会⾃动苏醒。</p>\n<h4 id=\"线程间的同步的方式\"> 线程间的同步的⽅式</h4>\n<p>线程同步是两个或多个共享关键资源的线程的并发执⾏。应该同步线程以避免关键的资源使 ⽤冲突。操作系统⼀般有下⾯三种线程同步的⽅式：</p>\n<ol>\n<li>**互斥量(Mutex)：**采⽤互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为 互斥对象只有⼀个，所以可以保证公共资源不会被多个线程同时访问。⽐如 Java 中的 synchronized 关键词和各种 Lock 都是这种机制。</li>\n<li>**信号量(Semphares) ：**它允许同⼀时刻多个线程访问同⼀资源，但是需要控制同⼀时刻访问此资 源的最⼤线程数量</li>\n<li>**事件(Event) :Wait/Notify：**通过通知操作的⽅式来保持多线程同步，还可以⽅便的实现多线程 优先级的⽐᫾操</li>\n</ol>\n<h3 id=\"多进程和多线程\"> 多进程和多线程</h3>\n<table>\n<thead>\n<tr>\n<th>维度</th>\n<th>多进程</th>\n<th>多线程</th>\n<th>总结</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>数据共享丶同步</td>\n<td>数据是分开的:共享复杂，需要用IPC;同步简单</td>\n<td>多线程共享进程数据：共享简单；同步复杂</td>\n<td>各有优势</td>\n</tr>\n<tr>\n<td>内存、CPU</td>\n<td>占用内存多，切换复杂，CPU利用率低</td>\n<td>占用内存少，切换简单，CPU利用率高</td>\n<td>线程占优</td>\n</tr>\n<tr>\n<td>创建销毁、切换</td>\n<td>创建销毁、切换复杂，速度慢</td>\n<td>创建销毁、切换简单，速度快</td>\n<td>线程占优</td>\n</tr>\n<tr>\n<td>编程调试</td>\n<td>编程简单，调试简单</td>\n<td>编程复杂，调试复杂</td>\n<td>进程占优</td>\n</tr>\n<tr>\n<td>可靠性</td>\n<td>进程间不会相互影响</td>\n<td>一个线程挂掉导致整个进程挂掉，守护线程除外</td>\n<td>进程占优</td>\n</tr>\n<tr>\n<td>分布式</td>\n<td>适应于多核、多机分布 ；如果一台机器不够，扩展到多台机器比较简单</td>\n<td>适应于多核分布</td>\n<td>进程占优</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>IO密集型，大部分时间在处理I/O请求，不需要CPU提供多大算力，这是后频繁切换可以提高并发性，所以I/O密集型的处理，希望在高并发下进行，多线程并发消耗资源少。</li>\n<li>CPU密集型，占用CPU算力大，希望能获得更长的时间轮片而不是经常切换；这样使用进程较好，进程本身优于线程，只是切换调度消耗的资源多。</li>\n</ul>\n",
      "image": "https://blog-1300186248.cos.ap-shanghai.myqcloud.com/OperatingSustem/%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%BA%94%E7%A7%8D%E7%8A%B6%E6%80%81.png",
      "date_published": "2021-03-21T15:26:08.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": []
    },
    {
      "title": "字节测开面经",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/interview/cekai/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/interview/cekai/",
      "content_html": "<h2 id=\"算法\"> 算法</h2>\n<h3 id=\"最长回文子串\"> 最长回文子串</h3>\n<p><code>中心扩展</code></p>\n<div><pre><code><span>/*中心扩展*/</span>\n<span>public</span> <span>static</span> <span>String</span> <span>longestPalindrome_expandCenter</span><span>(</span><span>String</span> s<span>)</span> <span>{</span>\n    <span>int</span> maxLen <span>=</span> <span>0</span><span>;</span>\n    <span>int</span> begin <span>=</span> <span>0</span><span>;</span>\n    <span>if</span> <span>(</span>s<span>.</span><span>length</span><span>(</span><span>)</span> <span>&lt;</span> <span>2</span><span>)</span> <span>{</span>\n        <span>return</span> s<span>;</span>\n    <span>}</span>\n    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> s<span>.</span><span>length</span><span>(</span><span>)</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>\n        <span>//比较两种方式的最大值</span>\n        <span>int</span> len <span>=</span> <span>Math</span><span>.</span><span>max</span><span>(</span><span>expandAroundCenter</span><span>(</span>s<span>,</span> i<span>,</span> i<span>)</span><span>,</span> <span>expandAroundCenter</span><span>(</span>s<span>,</span> i<span>,</span> i <span>+</span> <span>1</span><span>)</span><span>)</span><span>;</span>\n        <span>if</span> <span>(</span>len <span>></span> maxLen<span>)</span> <span>{</span>\n            <span>//赋值给索引begin</span>\n            begin <span>=</span> i <span>-</span> <span>(</span>len <span>-</span> <span>1</span><span>)</span> <span>/</span> <span>2</span><span>;</span>\n            <span>//赋值给回文串最大长度</span>\n            maxLen <span>=</span> len<span>;</span>\n        <span>}</span>\n    <span>}</span>\n    <span>return</span> s<span>.</span><span>substring</span><span>(</span>begin<span>,</span> begin <span>+</span> maxLen<span>)</span><span>;</span>\n<span>}</span>\n\n<span>public</span> <span>static</span> <span>int</span> <span>expandAroundCenter</span><span>(</span><span>String</span> s<span>,</span> <span>int</span> left<span>,</span> <span>int</span> right<span>)</span> <span>{</span>\n    <span>while</span> <span>(</span>left <span>>=</span> <span>0</span> <span>&amp;&amp;</span> right <span>&lt;</span> s<span>.</span><span>length</span><span>(</span><span>)</span> <span>&amp;&amp;</span> s<span>.</span><span>charAt</span><span>(</span>left<span>)</span> <span>==</span> s<span>.</span><span>charAt</span><span>(</span>right<span>)</span><span>)</span> <span>{</span>\n        left<span>--</span><span>;</span>\n        right<span>++</span><span>;</span>\n    <span>}</span>\n    <span>return</span> right <span>-</span> left <span>-</span> <span>1</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><p><code>动态规划</code></p>\n<div><pre><code>    <span>/*动态规划*/</span>\n    <span>public</span> <span>static</span> <span>String</span> <span>longestPalindrome2</span><span>(</span><span>String</span> s<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>s <span>==</span> <span>null</span> <span>||</span> s<span>.</span><span>length</span><span>(</span><span>)</span> <span>&lt;</span> <span>2</span><span>)</span> <span>{</span>\n            <span>return</span> s<span>;</span>\n        <span>}</span>\n        <span>int</span> strLen <span>=</span> s<span>.</span><span>length</span><span>(</span><span>)</span><span>;</span>\n        <span>//最长回文串的起点</span>\n        <span>int</span> maxStart <span>=</span> <span>0</span><span>;</span>\n        <span>//最长回文串的终点</span>\n        <span>int</span> maxEnd <span>=</span> <span>0</span><span>;</span>\n        <span>//最长回文串的长度</span>\n        <span>int</span> maxLen <span>=</span> <span>1</span><span>;</span>\n\n        <span>boolean</span><span>[</span><span>]</span><span>[</span><span>]</span> dp <span>=</span> <span>new</span> <span>boolean</span><span>[</span>strLen<span>]</span><span>[</span>strLen<span>]</span><span>;</span>\n\n        <span>for</span> <span>(</span><span>int</span> r <span>=</span> <span>1</span><span>;</span> r <span>&lt;</span> strLen<span>;</span> r<span>++</span><span>)</span> <span>{</span>\n            <span>for</span> <span>(</span><span>int</span> l <span>=</span> <span>0</span><span>;</span> l <span>&lt;</span> r<span>;</span> l<span>++</span><span>)</span> <span>{</span>\n                <span>if</span> <span>(</span>s<span>.</span><span>charAt</span><span>(</span>l<span>)</span> <span>==</span> s<span>.</span><span>charAt</span><span>(</span>r<span>)</span> <span>&amp;&amp;</span> <span>(</span>r <span>-</span> l <span>&lt;=</span> <span>2</span> <span>||</span> dp<span>[</span>l <span>+</span> <span>1</span><span>]</span><span>[</span>r <span>-</span> <span>1</span><span>]</span><span>)</span><span>)</span> <span>{</span>\n                    dp<span>[</span>l<span>]</span><span>[</span>r<span>]</span> <span>=</span> <span>true</span><span>;</span>\n                    <span>if</span> <span>(</span>r <span>-</span> l <span>+</span> <span>1</span> <span>></span> maxLen<span>)</span> <span>{</span>\n                        maxLen <span>=</span> r <span>-</span> l <span>+</span> <span>1</span><span>;</span>\n                        maxStart <span>=</span> l<span>;</span>\n                        maxEnd <span>=</span> r<span>;</span>\n                    <span>}</span>\n                <span>}</span>\n            <span>}</span>\n        <span>}</span>\n        <span>return</span> s<span>.</span><span>substring</span><span>(</span>maxStart<span>,</span> maxEnd <span>+</span> <span>1</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><h3 id=\"最长无重复子串\"> 最长无重复子串</h3>\n<p><code>滑动窗口</code></p>\n<div><pre><code><span>//滑动窗口</span>\n<span>public</span> <span>static</span> <span>int</span> <span>lengthOfLongestSubstring</span><span>(</span><span>String</span> s<span>)</span> <span>{</span>\n    <span>Map</span><span><span>&lt;</span><span>Character</span><span>,</span> <span>Integer</span><span>></span></span> map <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n    <span>String</span> maxStr <span>=</span> <span>\"\"</span><span>;</span>\n    <span>int</span> max <span>=</span> <span>0</span><span>,</span> start <span>=</span> <span>0</span><span>;</span>\n    <span>for</span> <span>(</span><span>int</span> end <span>=</span> <span>0</span><span>;</span> end <span>&lt;</span> s<span>.</span><span>length</span><span>(</span><span>)</span><span>;</span> end<span>++</span><span>)</span> <span>{</span>\n        <span>char</span> ch <span>=</span> s<span>.</span><span>charAt</span><span>(</span>end<span>)</span><span>;</span>\n        <span>//找到上一次该字符被遍历时的下标的后一个位置，与现在的start作比较</span>\n        <span>//如果map.get(ch)+1 &lt; start,在窗口之前，则还是原来的start</span>\n        <span>//如果map.get(ch)+1 = start,则说明在start的前一个，则还是start还是不变</span>\n        <span>//如果map.get(ch)+1 > start,则说明在start的后面，那么窗口就得左边收缩到遍历到的该位置即</span>\n        <span>if</span> <span>(</span>map<span>.</span><span>containsKey</span><span>(</span>ch<span>)</span><span>)</span><span>{</span>\n            start <span>=</span> <span>Math</span><span>.</span><span>max</span><span>(</span>map<span>.</span><span>get</span><span>(</span>ch<span>)</span><span>+</span><span>1</span><span>,</span> start<span>)</span><span>;</span>\n        <span>}</span>\n\n        <span>if</span><span>(</span>max <span>&lt;</span> end <span>-</span> start <span>+</span> <span>1</span><span>)</span><span>{</span>\n            max <span>=</span> end <span>-</span> start <span>+</span> <span>1</span><span>;</span>\n            maxStr <span>=</span> s<span>.</span><span>substring</span><span>(</span>start<span>,</span> end <span>+</span> <span>1</span><span>)</span><span>;</span>\n        <span>}</span>\n        map<span>.</span><span>put</span><span>(</span>ch<span>,</span>end<span>)</span><span>;</span>\n    <span>}</span>\n    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"最长无重复字符最长子串：\"</span> <span>+</span> maxStr<span>)</span><span>;</span>\n    <span>return</span> max<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><h3 id=\"k个一组翻转链表\"> K个一组翻转链表</h3>\n<div><p>Tips</p>\n<p>https://leetcode-cn.com/problems/reverse-nodes-in-k-group/solution/tu-jie-kge-yi-zu-fan-zhuan-lian-biao-by-user7208t/</p>\n</div>\n<ul>\n<li>链表分区为已翻转部分+待翻转部分+未翻转部分</li>\n<li>每次翻转前，要确定翻转链表的范围，这个必须通过 k 此循环来确定</li>\n<li>需记录翻转链表前驱和后继，方便翻转完成后把已翻转部分和未翻转部分连接起来</li>\n<li>初始需要两个变量 pre 和 end，pre 代表待翻转链表的前驱，end 代表待翻转链表的末尾</li>\n<li>经过k此循环，end 到达末尾，记录待翻转链表的后继 next = end.next</li>\n<li>翻转链表，然后将三部分链表连接起来，然后重置 pre 和 end 指针，然后进入下一次循环</li>\n<li>特殊情况，当翻转部分长度不足 k 时，在定位 end 完成后，end==null，已经到达末尾，说明题目已完成，直接返回即可</li>\n<li>时间复杂度为 O(n*K)O(n∗K) 最好的情况为 O(n)O(n) 最差的情况未 O(n^2)O(n2)</li>\n<li>空间复杂度为 O(1)O(1) 除了几个必须的节点指针外，我们并没有占用其他空间</li>\n</ul>\n<div><pre><code><span>public</span> <span>ListNode</span> <span>reverseKGroup</span><span>(</span><span>ListNode</span> head<span>,</span> <span>int</span> k<span>)</span> <span>{</span>\n    <span>ListNode</span> dummy <span>=</span> <span>new</span> <span>ListNode</span><span>(</span><span>0</span><span>)</span><span>;</span>\n    dummy<span>.</span>next <span>=</span> head<span>;</span>\n\n    <span>ListNode</span> pre <span>=</span> dummy<span>;</span>\n    <span>ListNode</span> end <span>=</span> dummy<span>;</span>\n\n    <span>while</span> <span>(</span>end<span>.</span>next <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> k <span>&amp;&amp;</span> end <span>!=</span> <span>null</span><span>;</span> i<span>++</span><span>)</span><span>{</span>\n            end <span>=</span> end<span>.</span>next<span>;</span>\n        <span>}</span>\n        <span>if</span> <span>(</span>end <span>==</span> <span>null</span><span>)</span><span>{</span>\n            <span>break</span><span>;</span>\n        <span>}</span>\n        <span>ListNode</span> start <span>=</span> pre<span>.</span>next<span>;</span>\n        <span>ListNode</span> next <span>=</span> end<span>.</span>next<span>;</span>\n        end<span>.</span>next <span>=</span> <span>null</span><span>;</span>\n        pre<span>.</span>next <span>=</span> <span>reverse</span><span>(</span>start<span>)</span><span>;</span>\n        start<span>.</span>next <span>=</span> next<span>;</span>\n        pre <span>=</span> start<span>;</span>\n        end <span>=</span> pre<span>;</span>\n    <span>}</span>\n    <span>return</span> dummy<span>.</span>next<span>;</span>\n<span>}</span>\n\n<span>private</span> <span>ListNode</span> <span>reverse</span><span>(</span><span>ListNode</span> head<span>)</span> <span>{</span>\n    <span>ListNode</span> pre <span>=</span> <span>null</span><span>;</span>\n    <span>ListNode</span> curr <span>=</span> head<span>;</span>\n    <span>while</span> <span>(</span>curr <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n        <span>ListNode</span> next <span>=</span> curr<span>.</span>next<span>;</span>\n        curr<span>.</span>next <span>=</span> pre<span>;</span>\n        pre <span>=</span> curr<span>;</span>\n        curr <span>=</span> next<span>;</span>\n    <span>}</span>\n    <span>return</span> pre<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br></div></div><h3 id=\"反转链表\"> 反转链表</h3>\n<div><pre><code><span>public</span> <span>static</span> <span>ListNode</span> <span>reverseLinkList_doublePointer</span><span>(</span><span>ListNode</span> head<span>)</span> <span>{</span>\n    <span>ListNode</span> listNode <span>=</span> <span>null</span><span>;</span>\n    <span>while</span> <span>(</span>head <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n        <span>/*先保存head的next结点*/</span>\n        <span>ListNode</span> next <span>=</span> head<span>.</span>next<span>;</span>\n        <span>/*将head的next指向新链表listNode，使head成为新链表的头结点*/</span>\n        head<span>.</span>next <span>=</span> listNode<span>;</span>\n        <span>/*最后使新链表listNode指向head，这样listNode就包含head了，后续加入的结点会成为新链表的头结点最终完成反转*/</span>\n        listNode <span>=</span> head<span>;</span>\n        <span>/*将head指向一开始保存的head的next，开始下一步循环*/</span>\n        head <span>=</span> next<span>;</span>\n    <span>}</span>\n    <span>return</span> listNode<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h3 id=\"买卖股票的最佳时刻\"> 买卖股票的最佳时刻</h3>\n<div><pre><code><span>public</span> <span>class</span> <span>Solution</span> <span>{</span>\n\n    <span>public</span> <span>int</span> <span>maxProfit</span><span>(</span><span>int</span><span>[</span><span>]</span> prices<span>)</span> <span>{</span>\n        <span>int</span> len <span>=</span> prices<span>.</span>length<span>;</span>\n        <span>// 特殊判断</span>\n        <span>if</span> <span>(</span>len <span>&lt;</span> <span>2</span><span>)</span> <span>{</span>\n            <span>return</span> <span>0</span><span>;</span>\n        <span>}</span>\n        <span>int</span><span>[</span><span>]</span><span>[</span><span>]</span> dp <span>=</span> <span>new</span> <span>int</span><span>[</span>len<span>]</span><span>[</span><span>2</span><span>]</span><span>;</span>\n\n        <span>// dp[i][0] 下标为 i 这天结束的时候，不持股，手上拥有的现金数</span>\n        <span>// dp[i][1] 下标为 i 这天结束的时候，持股，手上拥有的现金数</span>\n\n        <span>// 初始化：不持股显然为 0，持股就需要减去第 1 天（下标为 0）的股价</span>\n        dp<span>[</span><span>0</span><span>]</span><span>[</span><span>0</span><span>]</span> <span>=</span> <span>0</span><span>;</span>\n        dp<span>[</span><span>0</span><span>]</span><span>[</span><span>1</span><span>]</span> <span>=</span> <span>-</span>prices<span>[</span><span>0</span><span>]</span><span>;</span>\n\n        <span>// 从第 2 天开始遍历</span>\n        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;</span> len<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n            dp<span>[</span>i<span>]</span><span>[</span><span>0</span><span>]</span> <span>=</span> <span>Math</span><span>.</span><span>max</span><span>(</span>dp<span>[</span>i <span>-</span> <span>1</span><span>]</span><span>[</span><span>0</span><span>]</span><span>,</span> dp<span>[</span>i <span>-</span> <span>1</span><span>]</span><span>[</span><span>1</span><span>]</span> <span>+</span> prices<span>[</span>i<span>]</span><span>)</span><span>;</span>\n            dp<span>[</span>i<span>]</span><span>[</span><span>1</span><span>]</span> <span>=</span> <span>Math</span><span>.</span><span>max</span><span>(</span>dp<span>[</span>i <span>-</span> <span>1</span><span>]</span><span>[</span><span>1</span><span>]</span><span>,</span> <span>-</span>prices<span>[</span>i<span>]</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>return</span> dp<span>[</span>len <span>-</span> <span>1</span><span>]</span><span>[</span><span>0</span><span>]</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><h3 id=\"三数之和\"> 三数之和</h3>\n<div><pre><code><span>class</span> <span>Solution</span> <span>{</span>\n    <span>public</span> <span>List</span><span><span>&lt;</span><span>List</span><span>&lt;</span><span>Integer</span><span>></span><span>></span></span> <span>threeSum</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>\n        <span>int</span> n <span>=</span> nums<span>.</span>length<span>;</span>\n        <span>Arrays</span><span>.</span><span>sort</span><span>(</span>nums<span>)</span><span>;</span>\n        <span>List</span><span><span>&lt;</span><span>List</span><span>&lt;</span><span>Integer</span><span>></span><span>></span></span> ans <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>List</span><span>&lt;</span><span>Integer</span><span>></span><span>></span></span><span>(</span><span>)</span><span>;</span>\n        <span>// 枚举 a</span>\n        <span>for</span> <span>(</span><span>int</span> first <span>=</span> <span>0</span><span>;</span> first <span>&lt;</span> n<span>;</span> <span>++</span>first<span>)</span> <span>{</span>\n            <span>// 需要和上一次枚举的数不相同</span>\n            <span>if</span> <span>(</span>first <span>></span> <span>0</span> <span>&amp;&amp;</span> nums<span>[</span>first<span>]</span> <span>==</span> nums<span>[</span>first <span>-</span> <span>1</span><span>]</span><span>)</span> <span>{</span>\n                <span>continue</span><span>;</span>\n            <span>}</span>\n            <span>// c 对应的指针初始指向数组的最右端</span>\n            <span>int</span> third <span>=</span> n <span>-</span> <span>1</span><span>;</span>\n            <span>int</span> target <span>=</span> <span>-</span>nums<span>[</span>first<span>]</span><span>;</span>\n            <span>// 枚举 b</span>\n            <span>for</span> <span>(</span><span>int</span> second <span>=</span> first <span>+</span> <span>1</span><span>;</span> second <span>&lt;</span> n<span>;</span> <span>++</span>second<span>)</span> <span>{</span>\n                <span>// 需要和上一次枚举的数不相同</span>\n                <span>if</span> <span>(</span>second <span>></span> first <span>+</span> <span>1</span> <span>&amp;&amp;</span> nums<span>[</span>second<span>]</span> <span>==</span> nums<span>[</span>second <span>-</span> <span>1</span><span>]</span><span>)</span> <span>{</span>\n                    <span>continue</span><span>;</span>\n                <span>}</span>\n                <span>// 需要保证 b 的指针在 c 的指针的左侧</span>\n                <span>while</span> <span>(</span>second <span>&lt;</span> third <span>&amp;&amp;</span> nums<span>[</span>second<span>]</span> <span>+</span> nums<span>[</span>third<span>]</span> <span>></span> target<span>)</span> <span>{</span>\n                    <span>--</span>third<span>;</span>\n                <span>}</span>\n                <span>// 如果指针重合，随着 b 后续的增加</span>\n                <span>// 就不会有满足 a+b+c=0 并且 b&lt;c 的 c 了，可以退出循环</span>\n                <span>if</span> <span>(</span>second <span>==</span> third<span>)</span> <span>{</span>\n                    <span>break</span><span>;</span>\n                <span>}</span>\n                <span>if</span> <span>(</span>nums<span>[</span>second<span>]</span> <span>+</span> nums<span>[</span>third<span>]</span> <span>==</span> target<span>)</span> <span>{</span>\n                    <span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> list <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>Integer</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n                    list<span>.</span><span>add</span><span>(</span>nums<span>[</span>first<span>]</span><span>)</span><span>;</span>\n                    list<span>.</span><span>add</span><span>(</span>nums<span>[</span>second<span>]</span><span>)</span><span>;</span>\n                    list<span>.</span><span>add</span><span>(</span>nums<span>[</span>third<span>]</span><span>)</span><span>;</span>\n                    ans<span>.</span><span>add</span><span>(</span>list<span>)</span><span>;</span>\n                <span>}</span>\n            <span>}</span>\n        <span>}</span>\n        <span>return</span> ans<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br></div></div><h3 id=\"环形链表\"> 环形链表</h3>\n<div><pre><code><span>public</span> <span>class</span> <span>Solution</span> <span>{</span>\n    <span>public</span> <span>boolean</span> <span>hasCycle</span><span>(</span><span>ListNode</span> head<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>head <span>==</span> <span>null</span> <span>||</span> head<span>.</span>next <span>==</span> <span>null</span><span>)</span> <span>{</span>\n            <span>return</span> <span>false</span><span>;</span>\n        <span>}</span>\n        <span>ListNode</span> slow <span>=</span> head<span>;</span>\n        <span>ListNode</span> fast <span>=</span> head<span>.</span>next<span>;</span>\n        <span>while</span> <span>(</span>slow <span>!=</span> fast<span>)</span> <span>{</span>\n            <span>if</span> <span>(</span>fast <span>==</span> <span>null</span> <span>||</span> fast<span>.</span>next <span>==</span> <span>null</span><span>)</span> <span>{</span>\n                <span>return</span> <span>false</span><span>;</span>\n            <span>}</span>\n            slow <span>=</span> slow<span>.</span>next<span>;</span>\n            fast <span>=</span> fast<span>.</span>next<span>.</span>next<span>;</span>\n        <span>}</span>\n        <span>return</span> <span>true</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n\n\n<span>public</span> <span>ListNode</span> <span>getIntersectionNode</span><span>(</span><span>ListNode</span> headA<span>,</span> <span>ListNode</span> headB<span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>headA <span>==</span> <span>null</span> <span>||</span> headB <span>==</span> <span>null</span><span>)</span> <span>return</span> <span>null</span><span>;</span>\n    <span>ListNode</span> pA <span>=</span> headA<span>,</span> pB <span>=</span> headB<span>;</span>\n    <span>while</span> <span>(</span>pA <span>!=</span> pB<span>)</span> <span>{</span>\n        pA <span>=</span> pA <span>==</span> <span>null</span> <span>?</span> headB <span>:</span> pA<span>.</span>next<span>;</span>\n        pB <span>=</span> pB <span>==</span> <span>null</span> <span>?</span> headA <span>:</span> pB<span>.</span>next<span>;</span>\n    <span>}</span>\n    <span>return</span> pA<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><h3 id=\"验证ip地址\"> 验证IP地址</h3>\n<div><pre><code></code></pre>\n<div></div></div><h3 id=\"lru缓存结构\"> LRU缓存结构</h3>\n<h3 id=\"下一个更大元素\"> 下一个更大元素</h3>\n<div><pre><code><span>class</span> <span>Solution</span> <span>{</span>\n    <span>public</span> <span>void</span> <span>nextPermutation</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>\n        <span>int</span> i <span>=</span> nums<span>.</span>length <span>-</span> <span>2</span><span>;</span>\n        <span>while</span> <span>(</span>i <span>>=</span> <span>0</span> <span>&amp;&amp;</span> nums<span>[</span>i<span>]</span> <span>>=</span> nums<span>[</span>i <span>+</span> <span>1</span><span>]</span><span>)</span> <span>{</span>\n            i<span>--</span><span>;</span>\n        <span>}</span>\n        <span>if</span> <span>(</span>i <span>>=</span> <span>0</span><span>)</span> <span>{</span>\n            <span>int</span> j <span>=</span> nums<span>.</span>length <span>-</span> <span>1</span><span>;</span>\n            <span>while</span> <span>(</span>j <span>>=</span> <span>0</span> <span>&amp;&amp;</span> nums<span>[</span>i<span>]</span> <span>>=</span> nums<span>[</span>j<span>]</span><span>)</span> <span>{</span>\n                j<span>--</span><span>;</span>\n            <span>}</span>\n            <span>swap</span><span>(</span>nums<span>,</span> i<span>,</span> j<span>)</span><span>;</span>\n        <span>}</span>\n        <span>reverse</span><span>(</span>nums<span>,</span> i <span>+</span> <span>1</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>void</span> <span>swap</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>,</span> <span>int</span> i<span>,</span> <span>int</span> j<span>)</span> <span>{</span>\n        <span>int</span> temp <span>=</span> nums<span>[</span>i<span>]</span><span>;</span>\n        nums<span>[</span>i<span>]</span> <span>=</span> nums<span>[</span>j<span>]</span><span>;</span>\n        nums<span>[</span>j<span>]</span> <span>=</span> temp<span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>void</span> <span>reverse</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>,</span> <span>int</span> start<span>)</span> <span>{</span>\n        <span>int</span> left <span>=</span> start<span>,</span> right <span>=</span> nums<span>.</span>length <span>-</span> <span>1</span><span>;</span>\n        <span>while</span> <span>(</span>left <span>&lt;</span> right<span>)</span> <span>{</span>\n            <span>swap</span><span>(</span>nums<span>,</span> left<span>,</span> right<span>)</span><span>;</span>\n            left<span>++</span><span>;</span>\n            right<span>--</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div><h3 id=\"相交链表\"> 相交链表</h3>\n<p><code>使用Set</code></p>\n<div><pre><code><span>public</span> <span>class</span> <span>Solution</span> <span>{</span>\n    <span>public</span> <span>ListNode</span> <span>getIntersectionNode</span><span>(</span><span>ListNode</span> headA<span>,</span> <span>ListNode</span> headB<span>)</span> <span>{</span>\n        <span>Set</span><span><span>&lt;</span><span>ListNode</span><span>></span></span> visited <span>=</span> <span>new</span> <span>HashSet</span><span><span>&lt;</span><span>ListNode</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n        <span>ListNode</span> temp <span>=</span> headA<span>;</span>\n        <span>while</span> <span>(</span>temp <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n            visited<span>.</span><span>add</span><span>(</span>temp<span>)</span><span>;</span>\n            temp <span>=</span> temp<span>.</span>next<span>;</span>\n        <span>}</span>\n        temp <span>=</span> headB<span>;</span>\n        <span>while</span> <span>(</span>temp <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n            <span>if</span> <span>(</span>visited<span>.</span><span>contains</span><span>(</span>temp<span>)</span><span>)</span> <span>{</span>\n                <span>return</span> temp<span>;</span>\n            <span>}</span>\n            temp <span>=</span> temp<span>.</span>next<span>;</span>\n        <span>}</span>\n        <span>return</span> <span>null</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p><code>使用双指针</code></p>\n<div><pre><code><span>public</span> <span>class</span> <span>Solution</span> <span>{</span>\n    <span>public</span> <span>ListNode</span> <span>getIntersectionNode</span><span>(</span><span>ListNode</span> headA<span>,</span> <span>ListNode</span> headB<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>headA <span>==</span> <span>null</span> <span>||</span> headB <span>==</span> <span>null</span><span>)</span> <span>{</span>\n            <span>return</span> <span>null</span><span>;</span>\n        <span>}</span>\n        <span>ListNode</span> pA <span>=</span> headA<span>,</span> pB <span>=</span> headB<span>;</span>\n        <span>while</span> <span>(</span>pA <span>!=</span> pB<span>)</span> <span>{</span>\n            pA <span>=</span> pA <span>==</span> <span>null</span> <span>?</span> headB <span>:</span> pA<span>.</span>next<span>;</span>\n            pB <span>=</span> pB <span>==</span> <span>null</span> <span>?</span> headA <span>:</span> pB<span>.</span>next<span>;</span>\n        <span>}</span>\n        <span>return</span> pA<span>;</span>\n    <span>}</span>\n<span>}</span>\n\n作者：<span>LeetCode</span><span>-</span><span>Solution</span>\n链接：https<span>:</span><span>/</span><span>/</span>leetcode<span>-</span>cn<span>.</span>com<span>/</span>problems<span>/</span>intersection<span>-</span>of<span>-</span>two<span>-</span>linked<span>-</span>lists<span>/</span>solution<span>/</span>xiang<span>-</span>jiao<span>-</span>lian<span>-</span>biao<span>-</span>by<span>-</span>leetcode<span>-</span>solutio<span>-</span>a8jn<span>/</span>\n来源：力扣（<span>LeetCode</span>）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h3 id=\"z字遍历二叉树\"> Z字遍历二叉树</h3>\n<div><pre><code><span>public</span> <span>List</span><span><span>&lt;</span><span>List</span><span>&lt;</span><span>Integer</span><span>></span><span>></span></span> <span>zigzagLevelOrder</span><span>(</span><span>TreeNode</span> root<span>)</span> <span>{</span>\n    <span>List</span><span><span>&lt;</span><span>List</span><span>&lt;</span><span>Integer</span><span>></span><span>></span></span> lists <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n    <span>zigzagLevelOrder</span><span>(</span>lists<span>,</span> root<span>,</span> <span>0</span><span>)</span><span>;</span>\n    <span>return</span> lists<span>;</span>\n<span>}</span>\n\n<span>public</span> <span>void</span> <span>zigzagLevelOrder</span><span>(</span><span>List</span><span><span>&lt;</span><span>List</span><span>&lt;</span><span>Integer</span><span>></span><span>></span></span> lists<span>,</span> <span>TreeNode</span> node<span>,</span> <span>int</span> floor<span>)</span><span>{</span>\n    <span>if</span><span>(</span><span>Objects</span><span>.</span><span>isNull</span><span>(</span>node<span>)</span><span>)</span><span>{</span>\n        <span>return</span> <span>;</span>\n    <span>}</span>\n    <span>//传递过来floor（从0开始）值等于链表个数（层数）时，说明是还未开始遍历的层，就新添加一个链表</span>\n    <span>//否则，说明已经创建好该层的链表，直接插入即可</span>\n    <span>//这里不能用小于等于，因为进入左节点后增加一个链表后，同层的右结点的floor小于size会又创建一个链表</span>\n    <span>if</span><span>(</span>floor <span>==</span> lists<span>.</span><span>size</span><span>(</span><span>)</span><span>)</span><span>{</span>\n        lists<span>.</span><span>add</span><span>(</span><span>new</span> <span>LinkedList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>//使用链表来添加每层的元素</span>\n    <span>LinkedList</span><span><span>&lt;</span><span>Integer</span><span>></span></span> subList <span>=</span> <span>(</span><span>LinkedList</span><span><span>&lt;</span><span>Integer</span><span>></span></span><span>)</span> lists<span>.</span><span>get</span><span>(</span>floor<span>)</span><span>;</span>\n\n    <span>//从层数0开始，如果奇数层（从右往左遍历）则该层每个元素使用头插法，如果是偶数层则相反</span>\n    <span>if</span><span>(</span>floor <span>%</span> <span>2</span>  <span>==</span> <span>1</span><span>)</span><span>{</span>\n        subList<span>.</span><span>addFirst</span><span>(</span>node<span>.</span>val<span>)</span><span>;</span>\n    <span>}</span><span>else</span> <span>{</span>\n        subList<span>.</span><span>addLast</span><span>(</span>node<span>.</span>val<span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>//递归继续遍历左节点</span>\n    <span>zigzagLevelOrder</span><span>(</span>lists<span>,</span> node<span>.</span>left<span>,</span> floor <span>+</span> <span>1</span><span>)</span><span>;</span>\n    <span>//递归继续遍历右结点</span>\n    <span>zigzagLevelOrder</span><span>(</span>lists<span>,</span> node<span>.</span>right<span>,</span> floor <span>+</span> <span>1</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br></div></div><h3 id=\"构建-反转-层序遍历-二叉树\"> 构建 | 反转 | 层序遍历 二叉树</h3>\n<div><pre><code><span>public</span> <span>class</span> <span>TreeTest</span> <span>{</span>\n\n    <span>//递归反转二叉树</span>\n    <span>public</span> <span>static</span> <span>TreeNode</span> <span>treeReserve</span><span>(</span><span>TreeNode</span> root<span>)</span><span>{</span>\n        <span>if</span><span>(</span><span>Objects</span><span>.</span><span>isNull</span><span>(</span>root<span>)</span><span>)</span><span>{</span>\n            <span>return</span> root<span>;</span>\n        <span>}</span>\n\n        <span>TreeNode</span> temp <span>=</span> root<span>.</span>left<span>;</span>\n        root<span>.</span>left <span>=</span> <span>treeReserve</span><span>(</span>root<span>.</span>right<span>)</span><span>;</span>\n        root<span>.</span>right <span>=</span> <span>treeReserve</span><span>(</span>temp<span>)</span><span>;</span>\n\n        <span>return</span> root<span>;</span>\n    <span>}</span>\n\n    <span>//数组 -> 二叉树 [1, 2, 3, 4, 5, 6, 7] -></span>\n    <span>public</span> <span>static</span> <span>TreeNode</span> <span>arrToTree</span><span>(</span><span>int</span><span>[</span><span>]</span> arr<span>,</span> <span>int</span> index<span>)</span><span>{</span>\n\n        <span>if</span><span>(</span>index <span>>=</span> arr<span>.</span>length<span>)</span><span>{</span>\n            <span>return</span> <span>null</span><span>;</span>\n        <span>}</span>\n\n        <span>TreeNode</span> root <span>=</span> <span>null</span><span>;</span>\n        <span>int</span> value <span>=</span> arr<span>[</span>index<span>]</span><span>;</span>\n        root <span>=</span> <span>new</span> <span>TreeNode</span><span>(</span>value<span>)</span><span>;</span>\n\n        root<span>.</span>left <span>=</span> <span>arrToTree</span><span>(</span>arr<span>,</span> <span>2</span> <span>*</span> index <span>+</span> <span>1</span><span>)</span><span>;</span>\n        root<span>.</span>right <span>=</span> <span>arrToTree</span><span>(</span>arr<span>,</span> <span>2</span> <span>*</span> index <span>+</span> <span>2</span><span>)</span><span>;</span>\n\n\n        <span>return</span> root<span>;</span>\n    <span>}</span>\n\n    <span>//二叉树转数组</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>treeToArr</span><span>(</span><span>TreeNode</span> root<span>)</span><span>{</span>\n\n        <span>if</span><span>(</span><span>Objects</span><span>.</span><span>isNull</span><span>(</span>root<span>)</span><span>)</span><span>{</span>\n            <span>return</span><span>;</span>\n        <span>}</span>\n\n        <span>Queue</span><span><span>&lt;</span><span>TreeNode</span><span>></span></span> queue <span>=</span> <span>new</span> <span>LinkedList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n        queue<span>.</span><span>offer</span><span>(</span>root<span>)</span><span>;</span>\n        <span>while</span> <span>(</span><span>!</span>queue<span>.</span><span>isEmpty</span><span>(</span><span>)</span><span>)</span><span>{</span>\n            <span>TreeNode</span> treeNode <span>=</span> queue<span>.</span><span>poll</span><span>(</span><span>)</span><span>;</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>treeNode<span>.</span>val<span>)</span><span>;</span>\n            <span>if</span><span>(</span><span>!</span><span>Objects</span><span>.</span><span>isNull</span><span>(</span>treeNode<span>.</span>left<span>)</span><span>)</span><span>{</span>\n                queue<span>.</span><span>offer</span><span>(</span>treeNode<span>.</span>left<span>)</span><span>;</span>\n            <span>}</span>\n\n            <span>if</span><span>(</span><span>!</span><span>Objects</span><span>.</span><span>isNull</span><span>(</span>treeNode<span>.</span>right<span>)</span><span>)</span><span>{</span>\n                queue<span>.</span><span>offer</span><span>(</span>treeNode<span>.</span>right<span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>//数组构建二叉树</span>\n        <span>int</span><span>[</span><span>]</span> arr <span>=</span> <span>{</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>5</span><span>,</span> <span>6</span><span>,</span> <span>7</span><span>}</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"构建二叉树\"</span><span>)</span><span>;</span>\n        <span>TreeNode</span> treeNode <span>=</span> <span>arrToTree</span><span>(</span>arr<span>,</span> <span>0</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>treeNode<span>)</span><span>;</span>\n\n\n\n        <span>//反转二叉树</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"反转二叉树\"</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>treeReserve</span><span>(</span>treeNode<span>)</span><span>)</span><span>;</span>\n\n\n        <span>//层序遍历</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"层序遍历\"</span><span>)</span><span>;</span>\n        <span>treeToArr</span><span>(</span>treeNode<span>)</span><span>;</span>\n\n    <span>}</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br></div></div><h3 id=\"合并二叉树\"> 合并二叉树</h3>\n<p>可以使用深度优先搜索合并两个二叉树。从根节点开始同时遍历两个二叉树，并将对应的节点进行合并。</p>\n<p>两个二叉树的对应节点可能存在以下三种情况，对于每种情况使用不同的合并方式。</p>\n<p>如果两个二叉树的对应节点都为空，则合并后的二叉树的对应节点也为空；</p>\n<p>如果两个二叉树的对应节点只有一个为空，则合并后的二叉树的对应节点为其中的非空节点；</p>\n<p>如果两个二叉树的对应节点都不为空，则合并后的二叉树的对应节点的值为两个二叉树的对应节点的值之和，此时需要显性合并两个节点。</p>\n<p>对一个节点进行合并之后，还要对该节点的左右子树分别进行合并。这是一个递归的过程。</p>\n<div><pre><code><span>class</span> <span>Solution</span> <span>{</span>\n    <span>public</span> <span>TreeNode</span> <span>mergeTrees</span><span>(</span><span>TreeNode</span> t1<span>,</span> <span>TreeNode</span> t2<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>t1 <span>==</span> <span>null</span><span>)</span> <span>{</span>\n            <span>return</span> t2<span>;</span>\n        <span>}</span>\n        <span>if</span> <span>(</span>t2 <span>==</span> <span>null</span><span>)</span> <span>{</span>\n            <span>return</span> t1<span>;</span>\n        <span>}</span>\n        <span>TreeNode</span> merged <span>=</span> <span>new</span> <span>TreeNode</span><span>(</span>t1<span>.</span>val <span>+</span> t2<span>.</span>val<span>)</span><span>;</span>\n        merged<span>.</span>left <span>=</span> <span>mergeTrees</span><span>(</span>t1<span>.</span>left<span>,</span> t2<span>.</span>left<span>)</span><span>;</span>\n        merged<span>.</span>right <span>=</span> <span>mergeTrees</span><span>(</span>t1<span>.</span>right<span>,</span> t2<span>.</span>right<span>)</span><span>;</span>\n        <span>return</span> merged<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h3 id=\"回文链表\"> 回文链表</h3>\n<div><pre><code><span>//2. 使用递归遍历到最后一个时，和递归外的从头开始的指针不断比较，相当于前后比较</span>\n<span>public</span> <span>Boolean</span> <span>isPalindrome_recursion</span><span>(</span><span>ListNode</span> listNode<span>)</span><span>{</span>\n    <span>ListNode</span> front <span>=</span> listNode<span>;</span>\n    <span>return</span> <span>checkPalindrome</span><span>(</span>listNode<span>,</span> front<span>)</span><span>;</span>\n<span>}</span>\n\n<span>//递归</span>\n<span>public</span> <span>Boolean</span> <span>checkPalindrome</span><span>(</span><span>ListNode</span> listNode<span>,</span> <span>ListNode</span> front<span>)</span><span>{</span>\n    <span>if</span><span>(</span><span>!</span><span>Objects</span><span>.</span><span>isNull</span><span>(</span>listNode<span>)</span><span>)</span><span>{</span>\n        <span>//如果有一个不符合就不断返回false</span>\n        <span>if</span><span>(</span><span>!</span><span>checkPalindrome</span><span>(</span>listNode<span>.</span>next<span>,</span> front<span>)</span><span>)</span><span>{</span>\n            <span>return</span> <span>false</span><span>;</span>\n        <span>}</span>\n        <span>if</span><span>(</span>front<span>.</span>val <span>!=</span> listNode<span>.</span>val<span>)</span><span>{</span>\n            <span>return</span> <span>false</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n    front <span>=</span> front<span>.</span>next<span>;</span>\n    <span>return</span> <span>true</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><h3 id=\"前序和后续遍历构建二叉树\"> 前序和后续遍历构建二叉树</h3>\n<div><p>参考</p>\n<p><a href=\"https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/solution/mian-shi-ti-07-zhong-jian-er-cha-shu-di-gui-fa-qin/\" target=\"_blank\" rel=\"noopener noreferrer\">参考</a></p>\n</div>\n<div><pre><code><span>public</span> <span>class</span> 剑指<span>Offer07_</span>重建二叉树 <span>{</span>\n    <span>static</span> <span>int</span><span>[</span><span>]</span> preorder <span>=</span> <span>{</span><span>3</span><span>,</span> <span>9</span><span>,</span> <span>20</span><span>,</span> <span>15</span><span>,</span> <span>7</span><span>}</span><span>;</span>\n    <span>static</span> <span>int</span><span>[</span><span>]</span> inorder <span>=</span> <span>{</span><span>9</span><span>,</span> <span>3</span><span>,</span> <span>15</span><span>,</span> <span>20</span><span>,</span> <span>7</span><span>}</span><span>;</span>\n    <span>static</span> <span>HashMap</span><span><span>&lt;</span><span>Integer</span><span>,</span> <span>Integer</span><span>></span></span> map <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n\n\n    <span>static</span> <span>class</span> <span>TreeNode</span> <span>{</span>\n        <span>int</span> val<span>;</span>\n        <span>TreeNode</span> left <span>=</span> <span>null</span><span>;</span>\n        <span>TreeNode</span> right <span>=</span> <span>null</span><span>;</span>\n\n        <span>TreeNode</span><span>(</span><span>int</span> x<span>)</span> <span>{</span>\n            val <span>=</span> x<span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n\n    <span>public</span> <span>static</span> <span>TreeNode</span> <span>rebuilderTree</span><span>(</span><span>)</span> <span>{</span>\n\n        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> inorder<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n            map<span>.</span><span>put</span><span>(</span>inorder<span>[</span>i<span>]</span><span>,</span> i<span>)</span><span>;</span>\n        <span>}</span>\n        <span>return</span> <span>recur</span><span>(</span><span>0</span><span>,</span> <span>0</span><span>,</span> inorder<span>.</span>length <span>-</span> <span>1</span><span>)</span><span>;</span>\n\n    <span>}</span>\n\n    <span>public</span> <span>static</span> <span>TreeNode</span> <span>recur</span><span>(</span><span>int</span> pre_root<span>,</span> <span>int</span> in_left<span>,</span> <span>int</span> in_right<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>in_left <span>></span> in_right<span>)</span> <span>{</span>\n            <span>return</span> <span>null</span><span>;</span>\n        <span>}</span>\n\n        <span>TreeNode</span> treeNode <span>=</span> <span>new</span> <span>TreeNode</span><span>(</span>preorder<span>[</span>pre_root<span>]</span><span>)</span><span>;</span>\n        <span>int</span> in_idx <span>=</span> map<span>.</span><span>get</span><span>(</span>preorder<span>[</span>pre_root<span>]</span><span>)</span><span>;</span>\n        treeNode<span>.</span>left <span>=</span> <span>recur</span><span>(</span>pre_root <span>+</span> <span>1</span><span>,</span> in_left<span>,</span> in_idx <span>-</span> <span>1</span><span>)</span><span>;</span>\n        treeNode<span>.</span>right <span>=</span> <span>recur</span><span>(</span>pre_root <span>+</span> <span>(</span>in_idx <span>-</span> in_left<span>)</span> <span>+</span> <span>1</span><span>,</span> in_idx <span>+</span> <span>1</span><span>,</span> in_right<span>)</span><span>;</span>\n        <span>return</span> treeNode<span>;</span>\n\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br></div></div><h3 id=\"全排列\"> 全排列</h3>\n<div><pre><code><span>class</span> <span>Solution</span> <span>{</span>\n    <span>public</span> <span>List</span><span><span>&lt;</span><span>List</span><span>&lt;</span><span>Integer</span><span>></span><span>></span></span> <span>permute</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>\n\n        <span>List</span><span><span>&lt;</span><span>List</span><span>&lt;</span><span>Integer</span><span>></span><span>></span></span> res <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n        <span>int</span><span>[</span><span>]</span> visited <span>=</span> <span>new</span> <span>int</span><span>[</span>nums<span>.</span>length<span>]</span><span>;</span>\n        <span>backtrack</span><span>(</span>res<span>,</span> nums<span>,</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>Integer</span><span>></span></span><span>(</span><span>)</span><span>,</span> visited<span>)</span><span>;</span>\n        <span>return</span> res<span>;</span>\n\n    <span>}</span>\n\n    <span>private</span> <span>void</span> <span>backtrack</span><span>(</span><span>List</span><span><span>&lt;</span><span>List</span><span>&lt;</span><span>Integer</span><span>></span><span>></span></span> res<span>,</span> <span>int</span><span>[</span><span>]</span> nums<span>,</span> <span>ArrayList</span><span><span>&lt;</span><span>Integer</span><span>></span></span> tmp<span>,</span> <span>int</span><span>[</span><span>]</span> visited<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>tmp<span>.</span><span>size</span><span>(</span><span>)</span> <span>==</span> nums<span>.</span>length<span>)</span> <span>{</span>\n            res<span>.</span><span>add</span><span>(</span><span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span>tmp<span>)</span><span>)</span><span>;</span>\n            <span>return</span><span>;</span>\n        <span>}</span>\n        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> nums<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n            <span>if</span> <span>(</span>visited<span>[</span>i<span>]</span> <span>==</span> <span>1</span><span>)</span> <span>continue</span><span>;</span>\n            visited<span>[</span>i<span>]</span> <span>=</span> <span>1</span><span>;</span>\n            tmp<span>.</span><span>add</span><span>(</span>nums<span>[</span>i<span>]</span><span>)</span><span>;</span>\n            <span>backtrack</span><span>(</span>res<span>,</span> nums<span>,</span> tmp<span>,</span> visited<span>)</span><span>;</span>\n            visited<span>[</span>i<span>]</span> <span>=</span> <span>0</span><span>;</span>\n            tmp<span>.</span><span>remove</span><span>(</span>tmp<span>.</span><span>size</span><span>(</span><span>)</span> <span>-</span> <span>1</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><h3 id=\"排序链表\"> 排序链表</h3>\n<div><pre><code><span>class</span> <span>Solution</span> <span>{</span>\n    <span>public</span> <span>ListNode</span> <span>sortList</span><span>(</span><span>ListNode</span> head<span>)</span> <span>{</span>\n        <span>return</span> <span>sortList</span><span>(</span>head<span>,</span> <span>null</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>ListNode</span> <span>sortList</span><span>(</span><span>ListNode</span> head<span>,</span> <span>ListNode</span> tail<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>head <span>==</span> <span>null</span><span>)</span> <span>{</span>\n            <span>return</span> head<span>;</span>\n        <span>}</span>\n        <span>if</span> <span>(</span>head<span>.</span>next <span>==</span> tail<span>)</span> <span>{</span>\n            head<span>.</span>next <span>=</span> <span>null</span><span>;</span>\n            <span>return</span> head<span>;</span>\n        <span>}</span>\n        <span>ListNode</span> slow <span>=</span> head<span>,</span> fast <span>=</span> head<span>;</span>\n        <span>while</span> <span>(</span>fast <span>!=</span> tail<span>)</span> <span>{</span>\n            slow <span>=</span> slow<span>.</span>next<span>;</span>\n            fast <span>=</span> fast<span>.</span>next<span>;</span>\n            <span>if</span> <span>(</span>fast <span>!=</span> tail<span>)</span> <span>{</span>\n                fast <span>=</span> fast<span>.</span>next<span>;</span>\n            <span>}</span>\n        <span>}</span>\n        <span>ListNode</span> mid <span>=</span> slow<span>;</span>\n        <span>ListNode</span> list1 <span>=</span> <span>sortList</span><span>(</span>head<span>,</span> mid<span>)</span><span>;</span>\n        <span>ListNode</span> list2 <span>=</span> <span>sortList</span><span>(</span>mid<span>,</span> tail<span>)</span><span>;</span>\n        <span>ListNode</span> sorted <span>=</span> <span>merge</span><span>(</span>list1<span>,</span> list2<span>)</span><span>;</span>\n        <span>return</span> sorted<span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>ListNode</span> <span>merge</span><span>(</span><span>ListNode</span> head1<span>,</span> <span>ListNode</span> head2<span>)</span> <span>{</span>\n        <span>ListNode</span> dummyHead <span>=</span> <span>new</span> <span>ListNode</span><span>(</span><span>0</span><span>)</span><span>;</span>\n        <span>ListNode</span> temp <span>=</span> dummyHead<span>,</span> temp1 <span>=</span> head1<span>,</span> temp2 <span>=</span> head2<span>;</span>\n        <span>while</span> <span>(</span>temp1 <span>!=</span> <span>null</span> <span>&amp;&amp;</span> temp2 <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n            <span>if</span> <span>(</span>temp1<span>.</span>val <span>&lt;=</span> temp2<span>.</span>val<span>)</span> <span>{</span>\n                temp<span>.</span>next <span>=</span> temp1<span>;</span>\n                temp1 <span>=</span> temp1<span>.</span>next<span>;</span>\n            <span>}</span> <span>else</span> <span>{</span>\n                temp<span>.</span>next <span>=</span> temp2<span>;</span>\n                temp2 <span>=</span> temp2<span>.</span>next<span>;</span>\n            <span>}</span>\n            temp <span>=</span> temp<span>.</span>next<span>;</span>\n        <span>}</span>\n        <span>if</span> <span>(</span>temp1 <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n            temp<span>.</span>next <span>=</span> temp1<span>;</span>\n        <span>}</span> <span>else</span> <span>if</span> <span>(</span>temp2 <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n            temp<span>.</span>next <span>=</span> temp2<span>;</span>\n        <span>}</span>\n        <span>return</span> dummyHead<span>.</span>next<span>;</span>\n    <span>}</span>\n<span>}</span>\n\n作者：<span>LeetCode</span><span>-</span><span>Solution</span>\n链接：https<span>:</span><span>/</span><span>/</span>leetcode<span>-</span>cn<span>.</span>com<span>/</span>problems<span>/</span>sort<span>-</span>list<span>/</span>solution<span>/</span>pai<span>-</span>xu<span>-</span>lian<span>-</span>biao<span>-</span>by<span>-</span>leetcode<span>-</span>solution<span>/</span>\n来源：力扣（<span>LeetCode</span>）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br></div></div><ul>\n<li>判断一棵树是否是二叉树</li>\n<li>leetcode26</li>\n<li>翻转字符串（网址的翻转）</li>\n<li>leetcode496</li>\n<li>双向链表构建二叉树，构建平衡二叉树</li>\n<li>编程题：链表向右移动K次</li>\n<li>两个字符串最长公共子串</li>\n<li><a href=\"https://www.nowcoder.com/jump/super-jump/word?word=%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA\" target=\"_blank\" rel=\"noopener noreferrer\">买卖股票的最佳时机</a></li>\n</ul>\n<h2 id=\"操作系统\"> 操作系统</h2>\n<h3 id=\"分页和分段区别\"> 分页和分段区别</h3>\n<p><strong>1.目的</strong></p>\n<ul>\n<li>\n<p>页是信息的物理单位，分页是为实现离散分配方式，以消减内存的外零头，提高内存的利用率。或者说，分页是出于系统管理的需要而不是用户需要。</p>\n</li>\n<li>\n<p>段是信息的逻辑单位，它含有一组其意义相对完整的信息。分段的目的是为了更好地满足用户的需要。</p>\n</li>\n</ul>\n<p><strong>2.长度</strong></p>\n<ul>\n<li>\n<p>页的大小固定而且由系统决定，由系统把逻辑地址划分为页号和页内地址两部分，是由机器硬件实现的，因而在系统中只能有一种大小的页面。</p>\n</li>\n<li>\n<p>段的长度不固定，决定于用户所编写的程序，通常由编译程序在对程序进行编译时，根据信息的性质来划分。</p>\n</li>\n</ul>\n<p><strong>3.地址空间</strong></p>\n<ul>\n<li>\n<p>页的地址空间是一维的，即单一的线形地址空间，程序员只要利用一个记忆符就可以表示一个地址。</p>\n</li>\n<li>\n<p>段的作业地址空间是二维的，程序员在标识一个地址时，既需要给出段名，又需给出段内地址。</p>\n</li>\n</ul>\n<p><strong>4.碎片</strong></p>\n<ul>\n<li>\n<p>分页有内部碎片无外部碎片</p>\n</li>\n<li>\n<p>分段有外部碎片无内部碎片</p>\n</li>\n</ul>\n<p><strong>5.绝对地址</strong></p>\n<ul>\n<li>\n<p>处理器使用页号和偏移量计算绝对地址</p>\n</li>\n<li>\n<p>处理器使用段号和偏移量计算绝对地址</p>\n</li>\n</ul>\n<p><strong>6.管理方式</strong></p>\n<ul>\n<li>\n<p>对于分页，操作系统必须为每个进程维护一个页表，以说明每个页对应的的页框。当进程运行时，它的所有页都必须在内存中，除非使用覆盖技术或虚拟技术，另外操作系统需要维护一个空闲页框列表。</p>\n</li>\n<li>\n<p>对于分段，操作系统必须为每个进程维护一个段表，以说明每个段的加载地址和长度。当进程运行时，它的所有短都必须在内存中，除非使用覆盖技术或虚拟技术，另外操作系统需要维护一个内存中的空闲的空洞列表。</p>\n</li>\n<li>\n<p>特别的，当使用虚拟技术是，把一页或一段写入内存时可能需要把一页或几个段写入磁盘。</p>\n</li>\n</ul>\n<p><strong>7.共享和动态链接</strong></p>\n<ul>\n<li>分页不容易实现，分段容易实现</li>\n</ul>\n<h2 id=\"计算机网络\"> 计算机网络</h2>\n<h3 id=\"应用层协议\"> 应用层协议</h3>\n<p>TCP支持的应用协议主要有：Telnet、FTP、SMTP等；</p>\n<p>UDP支持的应用层协议主要有：NFS（网络文件系统）、SNMP（简单网络管理协议）、DNS（主域名称系统）、TFTP（通用文件传输协议）等。</p>\n<p><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019/7/七层体系结构图.png\" alt=\"七层体系结构图\" /></p>\n<h3 id=\"osi七层模型和作用\"> OSI七层模型和作用</h3>\n<table>\n<thead>\n<tr>\n<th>OSI七层模型</th>\n<th>功能</th>\n<th>对应的网络协议</th>\n<th>TCP/IP四层概念模型</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>应用层</td>\n<td>文件传输，文件管理，电子邮件的信息处理——apdu</td>\n<td>HTTP、TFTP, FTP, NFS, WAIS、SMTP</td>\n<td>应用层</td>\n</tr>\n<tr>\n<td>表示层</td>\n<td>确保一个系统的应用层发送的消息可以被另一个系统的应用层读取，编码转换，数据解析，管理数据的解密和加密，最小单位——ppdu</td>\n<td>Telnet, Rlogin, SNMP, Gopher</td>\n<td></td>\n</tr>\n<tr>\n<td>会话层</td>\n<td>负责在网络中的两节点建立，维持和终止通信，在一层协议中，可以解决节点连接的协调和管理问题。包括通信连接的建立，保持会话过程通信连接的畅通，两节点之间的对话，决定通信是否被终端一斤通信终端是决定从何处重新发送，最小单位——spdu</td>\n<td>SMTP, DNS</td>\n<td></td>\n</tr>\n<tr>\n<td>传输层</td>\n<td>定义一些传输数据的协议和端口。传输协议同时进行流量控制，或是根据接收方接收数据的快慢程度，规定适当的发送速率，解决传输效率及能力的问题——tpdu</td>\n<td>TCP, UDP</td>\n<td>传输层</td>\n</tr>\n<tr>\n<td>网络层</td>\n<td>控制子网的运行，如逻辑编址，分组传输，路由选择最小单位——分组（包）报文</td>\n<td>IP, ICMP, ARP, RARP, AKP, UUCP</td>\n<td>网络层</td>\n</tr>\n<tr>\n<td>数据链路层</td>\n<td>主要是对物理层传输的比特流包装，检测保证数据传输的可靠性，将物理层接收的数据进行MAC（媒体访问控制）地址的封装和解封装，也可以简单的理解为物理寻址。交换机就处在这一层，最小的传输单位——帧</td>\n<td>FDDI, Ethernet, Arpanet, PDN, SLIP, PPP，STP。HDLC,SDLC,帧中继</td>\n<td>数据链路层</td>\n</tr>\n<tr>\n<td>物理层</td>\n<td>定义物理设备的标准，主要对物理连接方式，电气特性，机械特性等制定统一标准，传输比特流，因此最小的传输单位——位（比特流）</td>\n<td>IEEE 802.1A, IEEE 802.2到IEEE 802.</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"tcp-http中的keep-alive机制\"> TCP/HTTP中的keep-alive机制</h3>\n<p>https://blog.csdn.net/oceanperfect/article/details/51064574</p>\n<h3 id=\"http请求包含哪些部分\"> HTTP请求包含哪些部分</h3>\n<p>http协议报文</p>\n<p>1.请求报文(请求行/请求头/请求数据/空行)</p>\n<p>​    请求行</p>\n<p>​      求方法字段、URL字段和HTTP协议版本</p>\n<p>​      例如：GET /index.html HTTP/1.1</p>\n<p>​        get方法将数据拼接在url后面，传递参数受限</p>\n<p>​      请求方法：</p>\n<p>​        GET、POST、HEAD、PUT、DELETE、OPTIONS、TRACE、CONNECT</p>\n<p>​    请求头(key value形式)</p>\n<p>​      User-Agent：产生请求的浏览器类型。</p>\n<p>​      Accept：客户端可识别的内容类型列表。</p>\n<p>​      Host：主机地址</p>\n<p>​    请求数据</p>\n<p>​      post方法中，会把数据以key value形式发送请求</p>\n<p>​    空行</p>\n<p>​      发送回车符和换行符，通知服务器以下不再有请求头</p>\n<p>2.响应报文(状态行、消息报头、响应正文)</p>\n<p>​    状态行</p>\n<p>​    消息报头</p>\n<p>​    响应正文</p>\n<h3 id=\"url重写\"> URL重写</h3>\n<p>如果浏览器不支持Cookie或用户阻止了所有Cookie，可以把会话ID附加在HTML页面中所有的URL上，这些页面作为响应发送给客户。这样，当用户单击URL时，会话ID被自动作为请求行的一部分而不是作为头行发送回服务器。这种方法称为URL重写(URL rewriting)。</p>\n<h3 id=\"url输入地址栏后的流程\"> URL输入地址栏后的流程</h3>\n<h3 id=\"rip是什么\"> RIP是什么</h3>\n<h2 id=\"测试开发\"> 测试开发</h2>\n<h3 id=\"编写测试用例有哪些方法\"> 编写测试用例有哪些方法</h3>\n<p>1.<strong>等价类划分</strong></p>\n<p>等价类是指某个输入域的子集合.在该子集合中,各个输入数据对于揭露程序中的错误都是等效的.并合理地假定:测试某等价类的代表值就等于对这一类其它值的测试.因此,可以把全部输入数据合理划分为若干等价类,在每一个等价类中取一个数据作为测试的输入条件,就可以用少量代表性的测试数据.取得较好的测试结果.等价类划分可有两种不同的情况:有效等价类和无效等价类.</p>\n<p>2.<strong>边界值分析法</strong></p>\n<p>边界值分析方法是对等价类划分方法的补充。大量的错误是发生在输入或输出范围的边界上,而不是发生在输入输出范围的内部.因此针对各种边界情况设计测试用例,可以查出更多的错误.</p>\n<p>使用边界值分析方法设计测试用例,首先应确定边界情况.通常输入和输出等价类的边界,就是应着重测试的边界情况.应当选取正好等于,刚刚大于或刚刚小于边界的值作为测试数据,而不是选取等价类中的典型值或任意值作为测试数据</p>\n<p>3.<strong>错误推测法</strong></p>\n<p>基于经验和直觉推测程序中所有可能存在的各种错误,从而有针对性的设计测试用例的方法.错误推测方法的基本思想:列举出程序中所有可能有的错误和容易发生错误的特殊情况,根据他们选择测试用例.例如,在单元测试时曾列出的许多在模块中常见的错误.以前产品测试中曾经发现的错误等,这些就是经验的总结。还有,输入数据和输出数据为0的情况。输入表格为空格或输入表格只有一行.这些都是容易发生错误的情况。可选择这些情况下的例子作为测试用例.</p>\n<p>4.<strong>因果图方法</strong></p>\n<p>前面介绍的等价类划分方法和边界值分析方法,都是着重考虑输入条件,但未考虑输入条件之间的联系,相互组合等.考虑输入条件之间的相互组合,可能会产生一些新的情况.但要检查输入条件的组合不是一件容易的事情,即使把所有输入条件划分成等价类,他们之间的组合情况也相当多.因此必须考虑采用一种适合于描述对于多种条件的组合,相应产生多个动作的形式来考虑设计测试用例.这就需要利用因果图（逻辑模型）.因果图方法最终生成的就是判定表.它适合于检查程序输入条件的各种组合情况.</p>\n<p>5.<strong>正交表分析法</strong></p>\n<p>有时候，可能因为大量的参数的组合而引起测试用例数量上的激增，同时，这些测试用例并没有明显的优先级上的差距，而测试人员又无法完成这么多数量的测试，就可以通过正交表来进行缩减一些用例，从而达到尽量少的用例覆盖尽量大的范围的可能性。</p>\n<p>6.<strong>场景分析方法</strong></p>\n<p>指根据用户场景来模拟用户的操作步骤，这个比较类似因果图，但是可能执行的深度和可行性更好。</p>\n<h3 id=\"测试发现bug而开发不认为是bug-你怎么办\"> 测试发现bug而开发不认为是bug 你怎么办？</h3>\n<ol>\n<li>\n<p>找到需求文档或者是原型图进行匹对</p>\n</li>\n<li>\n<p>尝试多种<code>测试环境</code>和<code>多种测试方式</code>来确认是否为bug</p>\n</li>\n<li>\n<p>整理bug的复现的步骤和出现的频率</p>\n</li>\n<li>\n<p>开发坚持不认为是bug的时候找项目经理测试经理进行沟通来确认是否为bug</p>\n</li>\n<li>\n<p>将客户经理 测试 测试经理和项目经理进行开确认会来判定是否为bug</p>\n</li>\n<li>\n<p>测试人员需要将bug整理并写入测试总结中</p>\n</li>\n</ol>\n<h3 id=\"登录功能测试用例\"> 登录功能测试用例</h3>\n<p><img src=\"https://images2017.cnblogs.com/blog/1206554/201801/1206554-20180109141310551-861992986.png\" alt=\"img\" /></p>\n<h2 id=\"其他\"> 其他</h2>\n<h3 id=\"转发和重定向区别\"> 转发和重定向区别</h3>\n<div><p>Tips</p>\n<ul>\n<li><a href=\"https://blog.csdn.net/weixin_40001125/article/details/88663468\" target=\"_blank\" rel=\"noopener noreferrer\">转发和重定向区别</a></li>\n</ul>\n</div>\n<h3 id=\"cookie和session区别\"> cookie和session区别</h3>\n",
      "image": "https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019/7/%E4%B8%83%E5%B1%82%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%9B%BE.png",
      "date_published": "2021-05-23T14:41:16.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": []
    },
    {
      "title": "面试大纲",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/interview/interview/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/interview/interview/",
      "content_html": "<h2 id=\"java\"> Java</h2>\n<ul>\n<li>集合</li>\n<li>多线程（sychronized, volatile）</li>\n<li>JVM</li>\n</ul>\n<h2 id=\"golang\"> Golang</h2>\n<ul>\n<li>协程</li>\n</ul>\n<h2 id=\"mysql\"> Mysql</h2>\n<h2 id=\"spring\"> Spring</h2>\n<h3 id=\"springboot\"> springboot</h3>\n<h3 id=\"springcloud\"> springcloud</h3>\n<h2 id=\"计算机网络\"> 计算机网络</h2>\n<h2 id=\"算法\"> 算法</h2>\n<ul>\n<li>排序算法</li>\n</ul>\n<h2 id=\"redis\"> Redis</h2>\n<h2 id=\"rabbitmq\"> RabbitMQ</h2>\n<h2 id=\"elasticsearch\"> ElasticSearch</h2>\n",
      "date_published": "2020-09-16T18:11:23.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": []
    },
    {
      "title": "腾讯云学习笔记",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/interview/tencent-cloud-note/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/interview/tencent-cloud-note/",
      "content_html": "<p>参考</p>\n<blockquote>\n<ul>\n<li><a href=\"https://wiki.lifeisgg.online/archives/%E8%85%BE%E8%AE%AF%E4%BA%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/\" target=\"_blank\" rel=\"noopener noreferrer\">腾讯云学习笔记 - LifeAlsoIsGG-Wiki (lifeisgg.online)</a></li>\n</ul>\n</blockquote>\n",
      "date_published": "2020-10-20T16:12:14.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": []
    },
    {
      "title": "Java-基础知识笔记",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/java/Java-BasicNotes/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/java/Java-BasicNotes/",
      "summary": "Java-基础知识笔记",
      "content_html": "<h2 id=\"参考\"> 参考</h2>\n<blockquote>\n<ul>\n<li><a href=\"http://www.51gjie.com/\" target=\"_blank\" rel=\"noopener noreferrer\">JavaSchool</a></li>\n<li><a href=\"https://www.liaoxuefeng.com/wiki/1252599548343744\" target=\"_blank\" rel=\"noopener noreferrer\">廖雪峰Java教程</a></li>\n</ul>\n</blockquote>\n<h2 id=\"_1-数据类型\"> 1 数据类型</h2>\n<p>Java的数据类型分为两大类：</p>\n<ul>\n<li>\n<p><strong>基本数据类型</strong>：包括 整数 、 浮点数 、 字符 、 布尔 。</p>\n</li>\n<li>\n<p><strong>引用数据类型</strong>：包括 类 、 数组 、 接口 。</p>\n</li>\n</ul>\n<p><img src=\"./images/Java-BasicNotes/dataType.jpg\" alt=\"\" /></p>\n<p><img src=\"./images/Java-BasicNotes/data_type_exercise.jpg\" alt=\"\" /></p>\n<h3 id=\"_1-1-整型\"> 1.1 整型</h3>\n<p>整型用于表示没有小数部分的数值， 它允许是负数。Java 提供了 4 种整型，具体内容如下</p>\n<p><img src=\"./images/Java-BasicNotes/Java_Integer.jpg\" alt=\"xx\" /></p>\n<h4 id=\"注意\"> 注意</h4>\n<p>int类型声明为L时会报错，需要向下转型。long类型声明时可以加或不加<code>L或l</code></p>\n<div><pre><code><span>int</span> a <span>=</span> <span>10L</span><span>;</span><span>//报错</span>\n<span>int</span> b <span>=</span> <span>(</span><span>int</span><span>)</span><span>10L</span><span>;</span><span>//正确</span>\n<span>long</span> c <span>=</span> <span>10L</span><span>;</span><span>//正确</span>\n<span>long</span> d <span>=</span> <span>10</span><span>;</span><span>//正确,相当于向上转型</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id=\"_1-2-浮点类型\"> 1.2 浮点类型</h3>\n<p>浮点类型用于表示有小数部分的数值。在 Java 中有两种浮点类型</p>\n<p><img src=\"./images/Java-BasicNotes/float.jpg\" alt=\"\" /></p>\n<p>​\t\tdouble 表示这种类型的数值精度是 float 类型的两倍（有人称之为双精度数值)。<strong>绝大部分应用程序都采用 double 类型</strong>。在很多情况下，<strong>float 类型的精度很难满足需求</strong>。实际上，只有很少的情况适合使用 float 类型，例如，需要单精度数据的库， 或者需要存储大量数据。 float 类型的数值有一个后缀 F 或 f (例如，3.14F。) 没有后缀 F 的浮点数值（如 3.14 ) 默 认为 double 类型。当然，也可以在浮点数值后面添加后缀 D 或 d (例如，3.14D) 。</p>\n<h4 id=\"注意-2\"> 注意</h4>\n<p>声明<code>float</code>时必须要加<code>F或f</code>，但是如果是整数则不用</p>\n<div><pre><code><span>float</span> a <span>=</span> <span>10</span><span>;</span><span>//正确</span>\n<span>float</span> b <span>=</span> <span>10.5F</span><span>;</span><span>//正确</span>\n<span>float</span> c <span>=</span> <span>10.5</span><span>;</span><span>//报错</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><code>double</code>类型可加可不加D或d，因为声明为小数时，小数默认是double类型</p>\n<div><pre><code><span>double</span> a <span>=</span> <span>10</span><span>;</span><span>//正确</span>\n<span>double</span> b <span>=</span> <span>10.5</span><span>;</span><span>//正确</span>\n<span>double</span> c <span>=</span> <span>10.5D</span><span>;</span><span>//正确,D可加可不加</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id=\"_1-3-char类型\"> 1.3 char类型</h3>\n<p>​\t\tchar 类型原本用于表示单个字符。不过，现在情况已经有所变化。 如今，有些 Unicode 字符可以用一个 chai•值描述，另外一些 Unicode 字符则需要两个 char 值。有关的详细信息请 阅读下一节。 char 类型的字面量值要用单引号括起来。例如：W 是编码值为 65 所对应的字符常量。 它与 &quot;A&quot; 不同，&quot;A&quot; 是包含一个字符 A 的字符串, char 类型的值可以表示为十六进制值，其 范围从 \\u0000 到 \\Uffff。例如：W2122 表示注册符号 ( ), \\u03C0 表示希腊字母 it。 除了转义序列 \\u 之外， 还有一些用于表示特殊字符的转义序列， 请参看表 3-3。所有这 些转义序列都可以出现在加引号的字符字面量或字符串中。例如，’ \\02丨22' 或 &quot;1 110\\11”。转 义序列 \\u还可以出现在加引号的字符常量或字符串之外（而其他所有转义序列不可以）。例 如： public static void main(String\\u005B\\ u00SD args) 就完全符合语法规则， \\u005B 和 \\u005D 是 [ 和 ] 的编码</p>\n<p><img src=\"./images/Java-BasicNotes/escape_sequence_for_special_characters.jpg\" alt=\"特殊字符的转义序列\" /></p>\n<h3 id=\"_1-4-boolean类型\"> 1.4 boolean类型</h3>\n<p>boolean (布尔）类型有两个值：false 和 true, 用来判定逻辑条件 整型值和布尔值之间 不能进行相互转换。</p>\n<h2 id=\"_2-访问修饰符\"> 2. 访问修饰符</h2>\n<p><img src=\"https://img-blog.csdn.net/2018031609431326?watermark/2/text/Ly9ibG9nLmNzZG4ubmV0L2d4MTc4NjQzNzM4MjI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"\" /></p>\n<ul>\n<li><strong>private</strong>\n被private修饰的属性和方法，不能被其他类访问，子类不能继承也不能访问。只能在所在类内部访问。</li>\n<li><strong>default</strong>\n变量或者方法前没有访问修饰符时，可以被所在类访问，可以被同一包内的其他类访问 或者继承。但是不能被其他包访问。</li>\n<li><strong>protected</strong>\n被protected修饰的方法和属性，在同一包内可被访问和继承。不同包内，子类可继承，非子类不能访问。</li>\n<li><strong>public</strong>\n方法和属性前有public修饰，可以被任意包内的类访问。\n另外，类要想被其他包导入，必须声明为public。被public修饰的类，类名必须与文件名相同。</li>\n</ul>\n<h2 id=\"_2-运算符\"> 2 运算符</h2>\n<h3 id=\"_2-1-算术运算符\"> 2.1 算术运算符</h3>\n<p><img src=\"./images/Java-BasicNotes/arithmetic_operator_1.jpg\" alt=\"\" /></p>\n<p>Java中，整数使用以上运算符，无论怎么计算，也不会得到小数。</p>\n<p><img src=\"./images/Java-BasicNotes/arithmetic_operator_2.jpg\" alt=\"\" /></p>\n<p>++ 运算，变量自己增长1。反之， -- 运算，变量自己减少1，用法与 ++ 一致。</p>\n<ul>\n<li>\n<p>独立运算：</p>\n<ul>\n<li>变量在独立运算时， 前++ 和 后++ 没有区别 。</li>\n<li>变量 前++ ：例如 ++i 。</li>\n<li>变量 后++ ：例如 i++ 。</li>\n</ul>\n</li>\n<li>\n<p>混合运算：</p>\n<ul>\n<li>\n<p>和其他变量放在一起， 前++ 和 后++ 就产生了不同。</p>\n<p><img src=\"./images/Java-BasicNotes/++Calculation_1.jpg\" alt=\"\" /></p>\n</li>\n<li>\n<p>变量 前++ ：变量a自己加1，将加1后的结果赋值给b，也就是说a先计算。a和b的结果都是2。</p>\n<p><img src=\"./images/Java-BasicNotes/++Calculation_2.jpg\" alt=\"\" /></p>\n</li>\n</ul>\n</li>\n</ul>\n<p>在 Java 中，使用算术运算符 + 、-、 * 、/ 表示加、减、 乘、除运算。 <strong>当参与 / 运算的两个 操作数都是整数时， 表示整数除法；否则， 表示浮点除法</strong>。 整数的求余操作（有时称为取模) 用 ％ 表示。例如，15/2 等于 ，7 15%2 等于 1 , 15.0/2 等于 7.50 需要注意， 整数被 0 除将会产生一个异常， 而浮点数被 0 除将会得到无穷大或 NaN 结果。</p>\n<h3 id=\"_2-2-赋值运算符\"> 2.2 赋值运算符</h3>\n<p><img src=\"./images/Java-BasicNotes/assignment_operator_1.jpg\" alt=\"\" /></p>\n<p><img src=\"./images/Java-BasicNotes/assignment_operator_2.jpg\" alt=\"\" /></p>\n<h3 id=\"_2-3-比较运算符\"> 2.3 比较运算符</h3>\n<p><img src=\"./images/Java-BasicNotes/Comparison_operator_1.jpg\" alt=\"\" /></p>\n<p><img src=\"./images/Java-BasicNotes/Comparison_operator_2.jpg\" alt=\"\" /></p>\n<h4 id=\"instanceof-比较一个对象是否为一个类的实例-或某个接口的实现类\"> instanceof：比较一个对象是否为一个类的实例/或某个接口的实现类</h4>\n<p>参考</p>\n<blockquote>\n<ul>\n<li>https://www.cnblogs.com/ysocean/p/8486500.html</li>\n</ul>\n</blockquote>\n<p>基础用法</p>\n<div><pre><code><span>boolean</span> result <span>=</span> obj <span>instanceof</span> <span>Class</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>其中 <code>obj</code> 为一个对象，<code>Class</code> 表示一个类或者一个接口，当 <code>obj</code> 为 <code>Class</code> 的对象，或者是其直接或间接子类，或者是其接口的实现类，结果result 都返回 true，否则返回false。</p>\n<p>原理：</p>\n<blockquote>\n<p><strong>编译器会检查 <code>obj</code> 是否能转换成右边的<code>class</code>类型，如果不能转换则直接报错，如果不能确定类型，则通过编译，具体看运行时定。</strong></p>\n</blockquote>\n<h5 id=\"其他情况\"> 其他情况</h5>\n<ul>\n<li>\n<p>obj 必须为引用类型，不能是基本类型</p>\n<div><pre><code><span>int</span> i <span>=</span> <span>0</span><span>;</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>i <span>instanceof</span> <span>Integer</span><span>)</span><span>;</span><span>//编译不通过</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>i <span>instanceof</span> <span>Object</span><span>)</span><span>;</span><span>//编译不通过</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></li>\n<li>\n<p>obj 为 null</p>\n<div><pre><code><span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>null</span> <span>instanceof</span> <span>Object</span><span>)</span><span>;</span><span>//false</span>\n</code></pre>\n<div><span>1</span><br></div></div></li>\n<li>\n<p>obj 为 class 接口的实现类</p>\n<div><pre><code>\n</code></pre>\n<div><span>1</span><br></div></div></li>\n<li>\n<p>我们可以用 <code>instanceof</code> 运算符判断 某个对象是否是 <code>List</code> 接口的实现类，如果是返回 true，否则返回 false</p>\n<div><pre><code><span>ArrayList</span> arrayList <span>=</span> <span>new</span> <span>ArrayList</span><span>(</span><span>)</span><span>;</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>arrayList <span>instanceof</span> <span>List</span><span>)</span><span>;</span><span>//true</span>\n\n<span>List</span> list <span>=</span> <span>new</span> <span>ArrayList</span><span>(</span><span>)</span><span>;</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>list <span>instanceof</span> <span>ArrayList</span><span>)</span><span>;</span><span>//true</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div></li>\n<li>\n<p>obj 为 class 类的直接或间接子类</p>\n<div><pre><code><span>public</span> <span>class</span> <span>Person</span> <span>{</span>\n \n<span>}</span>\n\n<span>public</span> <span>class</span> <span>Man</span> <span>extends</span> <span>Person</span><span>{</span>\n     \n<span>}</span>\n\n<span>Person</span> p1 <span>=</span> <span>new</span> <span>Person</span><span>(</span><span>)</span><span>;</span>\n<span>Person</span> p2 <span>=</span> <span>new</span> <span>Man</span><span>(</span><span>)</span><span>;</span>\n<span>Man</span> m1 <span>=</span> <span>new</span> <span>Man</span><span>(</span><span>)</span><span>;</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>p1 <span>instanceof</span> <span>Man</span><span>)</span><span>;</span><span>//false</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>p2 <span>instanceof</span> <span>Man</span><span>)</span><span>;</span><span>//true</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>m1 <span>instanceof</span> <span>Man</span><span>)</span><span>;</span><span>//true</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div></li>\n</ul>\n<h5 id=\"原理\"> 原理</h5>\n<p>参考</p>\n<blockquote>\n<ul>\n<li>https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.20.2</li>\n</ul>\n</blockquote>\n<p>伪代码描述</p>\n<div><pre><code><span>boolean</span> result<span>;</span>\n<span>if</span> <span>(</span>obj <span>==</span> <span>null</span><span>)</span> <span>{</span>\n  result <span>=</span> <span>false</span><span>;</span>\n<span>}</span> <span>else</span> <span>{</span>\n  <span>try</span> <span>{</span>\n      <span>T</span> temp <span>=</span> <span>(</span><span>T</span><span>)</span> obj<span>;</span> <span>// checkcast</span>\n      result <span>=</span> <span>true</span><span>;</span>\n  <span>}</span> <span>catch</span> <span>(</span><span>ClassCastException</span> e<span>)</span> <span>{</span>\n      result <span>=</span> <span>false</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>所以</p>\n<div><pre><code><span>Person</span> p1 <span>=</span> <span>new</span> <span>Person</span><span>(</span><span>)</span><span>;</span>\n \n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>p1 <span>instanceof</span> <span>String</span><span>)</span><span>;</span><span>//编译报错</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>p1 <span>instanceof</span> <span>List</span><span>)</span><span>;</span><span>//false</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>p1 <span>instanceof</span> <span>List</span><span><span>&lt;</span><span>?</span><span>></span></span><span>)</span><span>;</span><span>//false</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>p1 <span>instanceof</span> <span>List</span><span><span>&lt;</span><span>Person</span><span>></span></span><span>)</span><span>;</span><span>//编译报错</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>也就是说有表达式 obj instanceof T，instanceof 运算符的 obj 操作数的类型必须是引用类型或空类型; 否则，会发生编译时错误。</p>\n<p>如果 obj 强制转换为 T 时发生编译错误，则关系表达式的 instanceof 同样会产生编译时错误。 在这种情况下，表达式实例的结果永远为false。</p>\n<p>在运行时，如果 T 的值不为null，并且 obj 可以转换为 T 而不引发ClassCastException，则instanceof运算符的结果为true。 否则结果是错误的</p>\n<p>简单来说就是：<strong>如果 obj 不为 null 并且 (T) obj 不抛 ClassCastException 异常则该表达式值为 true ，否则值为 false 。</strong></p>\n<p>总结</p>\n<blockquote>\n<ul>\n<li>https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.instanceof</li>\n</ul>\n</blockquote>\n<h3 id=\"_2-4-逻辑运算符\"> 2.4 逻辑运算符</h3>\n<p><img src=\"./images/Java-BasicNotes/logical_operators_1.jpg\" alt=\"\" /></p>\n<p><img src=\"./images/Java-BasicNotes/logical_operators_2.jpg\" alt=\"\" /></p>\n<h3 id=\"_2-5-三元运算符\"> 2.5 三元运算符</h3>\n<p><strong>三元运算符格式：</strong></p>\n<div><pre><code>数据类型 变量名 = 布尔类型表达式？结果1：结果2\n</code></pre>\n<div><span>1</span><br></div></div><p><strong>三元运算符计算方式：</strong></p>\n<ul>\n<li>布尔类型表达式结果是true，三元运算符整体结果为结果1，赋值给变量。</li>\n<li>布尔类型表达式结果是false，三元运算符整体结果为结果2，赋值给变量。</li>\n</ul>\n<p><img src=\"./images/Java-BasicNotes/ternary_operator.jpg\" alt=\"\" /></p>\n<h3 id=\"_2-6-位运算符\"> 2.6 位运算符</h3>\n<ul>\n<li>&amp;：按位与。当两位同时为1时才返回1。</li>\n<li>|：按位或。只要有一位为1即可返回1。</li>\n<li>~：按位非。单目运算符，将操作数的每个位（包括符号位）全部取反。</li>\n<li>^：按位异或。当两位相同时返回0，不同时返回1。</li>\n<li>&lt;&lt;：左移运算符。</li>\n<li>&gt;&gt;：右移运算符。</li>\n<li>&gt;&gt;&gt;：无符号右移运算符。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">符号</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">&amp;：按位与</td>\n<td>当两位同时为1时才返回1，否则返回0</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">|：按位或</td>\n<td>只要有一位为1即可返回1</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">~：按位非</td>\n<td>单目运算符，将操作数的每个位（包括符号位）全部取反</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">^：按位异或</td>\n<td>当两位相同时返回0，不同时返回1</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">&lt;&lt;：左移运算符</td>\n<td>左移运算符</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">&gt;&gt;：右移运算符</td>\n<td>右移运算符，例如 &gt;&gt; 2则代表除于2</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">&gt;&gt;&gt;：无符号右移运算符</td>\n<td>无符号右移运算符</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"_2-7-数学函数与常量math\"> 2.7 数学函数与常量Math</h3>\n<p>在 Math类中，包含了各种各样的数学函数。在编写不同类别的程序时，可能需要的函数也不同。</p>\n<p><img src=\"./images/Java-BasicNotes/math_methods_1.jpg\" alt=\"\" /></p>\n<p><img src=\"./images/Java-BasicNotes/math_methods_2.jpg\" alt=\"\" /></p>\n<div><pre><code><span>/**\n         *Math.sqrt()//计算平方根\n         *Math.cbrt()//计算立方根\n         *Math.pow(a, b)//计算a的b次方\n         *Math.max( , );//计算最大值\n         *Math.min( , );//计算最小值\n         */</span>\n \n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Math</span><span>.</span><span>sqrt</span><span>(</span><span>16</span><span>)</span><span>)</span><span>;</span>   <span>//4.0</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Math</span><span>.</span><span>cbrt</span><span>(</span><span>8</span><span>)</span><span>)</span><span>;</span>    <span>//2.0</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Math</span><span>.</span><span>pow</span><span>(</span><span>3</span><span>,</span><span>2</span><span>)</span><span>)</span><span>;</span>     <span>//9.0</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Math</span><span>.</span><span>max</span><span>(</span><span>2.3</span><span>,</span><span>4.5</span><span>)</span><span>)</span><span>;</span><span>//4.5</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Math</span><span>.</span><span>min</span><span>(</span><span>2.3</span><span>,</span><span>4.5</span><span>)</span><span>)</span><span>;</span><span>//2.3</span>\n \n        <span>/**\n         * abs求绝对值\n         */</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Math</span><span>.</span><span>abs</span><span>(</span><span>-</span><span>10.4</span><span>)</span><span>)</span><span>;</span>    <span>//10.4</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Math</span><span>.</span><span>abs</span><span>(</span><span>10.1</span><span>)</span><span>)</span><span>;</span>     <span>//10.1</span>\n \n        <span>/**\n         * ceil天花板的意思，就是返回大的值\n         */</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Math</span><span>.</span><span>ceil</span><span>(</span><span>-</span><span>10.1</span><span>)</span><span>)</span><span>;</span>   <span>//-10.0</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Math</span><span>.</span><span>ceil</span><span>(</span><span>10.7</span><span>)</span><span>)</span><span>;</span>    <span>//11.0</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Math</span><span>.</span><span>ceil</span><span>(</span><span>-</span><span>0.7</span><span>)</span><span>)</span><span>;</span>    <span>//-0.0</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Math</span><span>.</span><span>ceil</span><span>(</span><span>0.0</span><span>)</span><span>)</span><span>;</span>     <span>//0.0</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Math</span><span>.</span><span>ceil</span><span>(</span><span>-</span><span>0.0</span><span>)</span><span>)</span><span>;</span>    <span>//-0.0</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Math</span><span>.</span><span>ceil</span><span>(</span><span>-</span><span>1.7</span><span>)</span><span>)</span><span>;</span>    <span>//-1.0</span>\n \n        <span>/**\n         * floor地板的意思，就是返回小的值\n         */</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Math</span><span>.</span><span>floor</span><span>(</span><span>-</span><span>10.1</span><span>)</span><span>)</span><span>;</span>  <span>//-11.0</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Math</span><span>.</span><span>floor</span><span>(</span><span>10.7</span><span>)</span><span>)</span><span>;</span>   <span>//10.0</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Math</span><span>.</span><span>floor</span><span>(</span><span>-</span><span>0.7</span><span>)</span><span>)</span><span>;</span>   <span>//-1.0</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Math</span><span>.</span><span>floor</span><span>(</span><span>0.0</span><span>)</span><span>)</span><span>;</span>    <span>//0.0</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Math</span><span>.</span><span>floor</span><span>(</span><span>-</span><span>0.0</span><span>)</span><span>)</span><span>;</span>   <span>//-0.0</span>\n \n        <span>/**\n         * random 取得一个大于或者等于0.0小于不等于1.0的随机数\n         */</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Math</span><span>.</span><span>random</span><span>(</span><span>)</span><span>)</span><span>;</span>  <span>//小于1大于0的double类型的数</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Math</span><span>.</span><span>random</span><span>(</span><span>)</span><span>*</span><span>2</span><span>)</span><span>;</span><span>//大于0小于1的double类型的数</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Math</span><span>.</span><span>random</span><span>(</span><span>)</span><span>*</span><span>2</span><span>+</span><span>1</span><span>)</span><span>;</span><span>//大于1小于2的double类型的数</span>\n \n        <span>/**\n         * rint 四舍五入，返回double值\n         * 注意.5的时候会取偶数    异常的尴尬=。=\n         */</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Math</span><span>.</span><span>rint</span><span>(</span><span>10.1</span><span>)</span><span>)</span><span>;</span>    <span>//10.0</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Math</span><span>.</span><span>rint</span><span>(</span><span>10.7</span><span>)</span><span>)</span><span>;</span>    <span>//11.0</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Math</span><span>.</span><span>rint</span><span>(</span><span>11.5</span><span>)</span><span>)</span><span>;</span>    <span>//12.0</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Math</span><span>.</span><span>rint</span><span>(</span><span>10.5</span><span>)</span><span>)</span><span>;</span>    <span>//10.0</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Math</span><span>.</span><span>rint</span><span>(</span><span>10.51</span><span>)</span><span>)</span><span>;</span>   <span>//11.0</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Math</span><span>.</span><span>rint</span><span>(</span><span>-</span><span>10.5</span><span>)</span><span>)</span><span>;</span>   <span>//-10.0</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Math</span><span>.</span><span>rint</span><span>(</span><span>-</span><span>11.5</span><span>)</span><span>)</span><span>;</span>   <span>//-12.0</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Math</span><span>.</span><span>rint</span><span>(</span><span>-</span><span>10.51</span><span>)</span><span>)</span><span>;</span>  <span>//-11.0</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Math</span><span>.</span><span>rint</span><span>(</span><span>-</span><span>10.6</span><span>)</span><span>)</span><span>;</span>   <span>//-11.0</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Math</span><span>.</span><span>rint</span><span>(</span><span>-</span><span>10.2</span><span>)</span><span>)</span><span>;</span>   <span>//-10.0</span>\n \n        <span>/**\n         * round 四舍五入，float时返回int值，double时返回long值\n         */</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Math</span><span>.</span><span>round</span><span>(</span><span>10.1</span><span>)</span><span>)</span><span>;</span>   <span>//10</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Math</span><span>.</span><span>round</span><span>(</span><span>10.7</span><span>)</span><span>)</span><span>;</span>   <span>//11</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Math</span><span>.</span><span>round</span><span>(</span><span>10.5</span><span>)</span><span>)</span><span>;</span>   <span>//11</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Math</span><span>.</span><span>round</span><span>(</span><span>10.51</span><span>)</span><span>)</span><span>;</span>  <span>//11</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Math</span><span>.</span><span>round</span><span>(</span><span>-</span><span>10.5</span><span>)</span><span>)</span><span>;</span>  <span>//-10</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Math</span><span>.</span><span>round</span><span>(</span><span>-</span><span>10.51</span><span>)</span><span>)</span><span>;</span> <span>//-11</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Math</span><span>.</span><span>round</span><span>(</span><span>-</span><span>10.6</span><span>)</span><span>)</span><span>;</span>  <span>//-11</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Math</span><span>.</span><span>round</span><span>(</span><span>-</span><span>10.2</span><span>)</span><span>)</span><span>;</span>  <span>//-10</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br></div></div><h2 id=\"_3-数据类型转换\"> 3 数据类型转换</h2>\n<p>Java程序中要求参与的计算的数据，必须要保证数据类型的一致性，如果数据类型不一致将发生类型的转换。</p>\n<ul>\n<li>自动（隐式）类型转换：从小类型到大类型，不需要强制转换符</li>\n<li>强制类型转换：从大类型到小类型，需要强制转换符实现强制转换，强制转换符：（需要转换成的类型）变量</li>\n</ul>\n<h3 id=\"_3-1-自动-隐式-转换\"> 3.1 自动（隐式）转换</h3>\n<p><strong>从小类型到大类型，不需要强制转换符</strong></p>\n<p><img src=\"./images/Java-BasicNotes/automatic_conversion.jpg\" alt=\"自动转换\" /></p>\n<p><strong>转换原理图解</strong></p>\n<p>​\tbyte 类型内存占有1个字节，在和 int 类型运算时会提升为 int 类型 ，自动补充3个字节，因此计算后的结果还是 int 类 型。</p>\n<p><img src=\"./images/Java-BasicNotes/principle_of_automatic_conversion.jpg\" alt=\"自动转换原理\" /></p>\n<p><strong>转换规则</strong></p>\n<p>​\t\t范围小的类型向范围大的类型提升， byte、short、char 运算时直接提升为 int 。</p>\n<p><img src=\"./images/Java-BasicNotes/rule_of_automatic_conversion.jpg\" alt=\"自动转换规则\" /></p>\n<h3 id=\"_3-2-强制-显示-转换\"> 3.2 强制（显示）转换</h3>\n<p><img src=\"./images/Java-BasicNotes/forced_conversion.jpg\" alt=\"强制转换\" /></p>\n<p><strong>转换原理图解</strong></p>\n<p><img src=\"./images/Java-BasicNotes/forced_conversion_principle.jpg\" alt=\"强制转换原理\" /></p>\n<p><strong>强烈注意</strong></p>\n<p><img src=\"./images/Java-BasicNotes/forced_conversion_notice.jpg\" alt=\"强制转换注意\" /></p>\n<p><strong>关于+=运算</strong></p>\n<div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span><span>{</span>\n\t<span>short</span> s <span>=</span> <span>1</span><span>;</span>\n\ts<span>+=</span><span>1</span><span>;</span>\n\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>s<span>)</span><span>;</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>分析： <strong>s += 1</strong> 逻辑上看作是 <strong>s = s + 1</strong> 计算结果被提升为int类型，再向short类型赋值时发生错误，因为不能将取值范围大的类型赋值到取值范围小的类型。但是， <strong>s=s+1进行两次运算 ， += 是一个运算符，只运算一次，并带有强制转换的特点</strong>， 也就是说 <strong>s += 1 就是 s = (short)(s + 1)</strong> ，因此程序没有问题编译通过，运行结果是2.</p>\n<h4 id=\"关于常量变量的计算\"> 关于常量变量的计算</h4>\n<div><pre><code><span>public</span> classMain <span>{</span>\n     <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n     <span>byte</span> a <span>=</span><span>4</span><span>;</span>\n     <span>byte</span> b <span>=</span><span>6</span><span>;</span>\n     <span>byte</span> c <span>=</span> a <span>+</span> b<span>;</span>\n\t<span>}</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><ul>\n<li>\n<p><strong>为什么byte a = 4；就不会报错？</strong></p>\n<blockquote>\n<p>因为byte是一个字节，八个二进制位，此时其范围为-128 ~ +127，所以4在其范围内，所以可以被赋值。一旦这个数值超过了127，那么编译就会报错了。</p>\n</blockquote>\n</li>\n<li>\n<p><strong>为什么byte c = a + b;就报错呢？</strong></p>\n<blockquote>\n<p>这是java的机制导致的，java在对byte这种类型进行“运算”时，会将其转换为int类型，两个int类型相加，赋值给byte类型肯定会报错的。</p>\n</blockquote>\n</li>\n<li>\n<p><strong>为什么byte = 3 + 4；又不会报错呢？</strong></p>\n<blockquote>\n<p>跟<strong>byte a = 4</strong>一样，3+4是常量的计算，会优先执行，执行结果再赋值给byte，此时判断数值是否满足该类型范围，满足就直接赋值了。</p>\n</blockquote>\n</li>\n</ul>\n<p>总结</p>\n<blockquote>\n<ul>\n<li>**两个变量相加，先对类型进行提升，然后运算，再将运算结果赋值。**b1和b2是两个变量，变量存储的值是变化的，在编译的时候无法判断里面具体的值，相加有可能会超出byte的取值范围。</li>\n<li><strong>两个常量相加，先计算常量数值，然后判断是否满足类型范围，再赋值</strong>。Java编译器有常量优化机制，在编译的时候就将常量的运算值计算出来了，而且常量运算的结果值在小数据类型的取值范围内，所以通过，如果不在小数据类型的取值范围内，编译就无法通过。</li>\n</ul>\n</blockquote>\n<h3 id=\"_3-3-ascii编码表\"> 3.3 ASCII编码表</h3>\n<div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n\t<span>//字符类型变量</span>\n\t<span>char</span> c <span>=</span> <span>'a'</span><span>;</span>\n\t<span>int</span> i <span>=</span> <span>1</span><span>;</span>\n\t<span>//字符类型和int类型计算</span>\n\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>c<span>+</span>i<span>)</span><span>;</span><span>//输出结果是98</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p><img src=\"./images/Java-BasicNotes/ASCII.jpg\" alt=\"ASCII\" /></p>\n<h2 id=\"_4-方法\"> 4 方法</h2>\n<h3 id=\"jshell工具\"> JShell工具</h3>\n<p>​\t\t什么时候会用到 JShell 工具呢，当我们编写的代码非常少的时候，而又不愿意编写类，main方法，也不愿意去编译和运 行，这个时候可以使用JShell工具。 启动JShell工具，在DOS命令行直接输入JShell命令。</p>\n<p>接下来可以编写Java代码，无需写类和方法，直接写方法中的代码即可，同时无需编译和运行，直接回车即可</p>\n<p><img src=\"./images/Java-BasicNotes/JShell.jpg\" alt=\"JShell\" /></p>\n<h2 id=\"_5-流程控制语句\"> 5 流程控制语句</h2>\n<h3 id=\"_5-1-判断语句\"> 5.1 判断语句</h3>\n<p><img src=\"./images/Java-BasicNotes/multiple_if-else.jpg\" alt=\"多重if-else\" /></p>\n<h3 id=\"_5-2-循环语句\"> 5.2 循环语句</h3>\n<h4 id=\"_5-2-1-for循环\"> 5.2.1 for循环</h4>\n<div><pre><code><span>for</span><span>(</span>初始化表达式①<span>;</span> 布尔表达式②<span>;</span> 步进表达式④<span>)</span><span>{</span>\n\t循环体③\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>执行流程</strong></p>\n<p>执行顺序①②③④&gt;②③④&gt;②③④…②不满足为止。</p>\n<blockquote>\n<ul>\n<li>①负责完成循环变量初始化</li>\n<li>②负责判断是否满足循环条件，不满足则跳出循环</li>\n<li>③具体执行的语句</li>\n<li>④循环后，循环条件所涉及变量的变化情况</li>\n</ul>\n</blockquote>\n<h4 id=\"_5-2-2-while循环\"> 5.2.2 while循环</h4>\n<div><pre><code>初始化表达式①\n<span>while</span><span>(</span>布尔表达式②<span>)</span><span>{</span>\n循环体③\n步进表达式④\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>执行流程 执行顺序：①②③④&gt;②③④&gt;②③④…②不满足为止。</p>\n<blockquote>\n<ul>\n<li>①负责完成循环变量初始化。</li>\n<li>②负责判断是否满足循环条件，不满足则跳出循环。</li>\n<li>③具体执行的语句。</li>\n<li>④循环后，循环变量的变化情况。</li>\n</ul>\n</blockquote>\n<h4 id=\"_5-2-3-其它循环\"> 5.2.3 其它循环</h4>\n<div><pre><code><span>for</span><span>(</span><span>Object</span> x <span>:</span> <span>ArrayList</span><span>)</span><span>{</span>\n\t循环体\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id=\"_5-3-选择语句\"> 5.3 选择语句</h3>\n<h4 id=\"switch语句\"> switch语句</h4>\n<div><pre><code><span>switch</span><span>(</span>表达式<span>)</span> <span>{</span>\n<span>case</span> 常量值<span>1</span><span>:</span>\n语句体<span>1</span><span>;</span>\n<span>break</span><span>;</span>\n<span>case</span> 常量值<span>2</span><span>:</span>\n语句体<span>2</span><span>;</span>\n<span>break</span><span>;</span>\n<span>.</span><span>.</span><span>.</span>\n<span>default</span><span>:</span>\n语句体n<span>+</span><span>1</span><span>;</span>\n<span>break</span><span>;</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>执行流程</p>\n<blockquote>\n<ol>\n<li>首先计算出表达式的值</li>\n<li>其次，和case依次比较，一旦有对应的值，就会执行相应的语句，在执行的过程中，遇到break就会结 束。</li>\n<li>最后，如果所有的case都和表达式的值不匹配，就会执行default语句体部分，然后程序结束掉。</li>\n</ol>\n</blockquote>\n<p>在switch语句中，如果case的后面不写break，将出现<code>穿透</code>现象，也就是不会在判断下一个case的值，直接向后运 行，直到遇到break，或者整体switch结束。</p>\n<div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n<span>int</span> i <span>=</span> <span>5</span><span>;</span>\n<span>switch</span> <span>(</span>i<span>)</span><span>{</span>\n<span>case</span> <span>0</span><span>:</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"执行case0\"</span><span>)</span><span>;</span>\n<span>break</span><span>;</span>\n<span>case</span> <span>5</span><span>:</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"执行case5\"</span><span>)</span><span>;</span>\n<span>case</span> <span>10</span><span>:</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"执行case10\"</span><span>)</span><span>;</span>\n<span>default</span><span>:</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"执行default\"</span><span>)</span><span>;</span>\n<span>}</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>上述程序中，执行case5后，由于没有break语句，程序会一直向后走，不会在判断case，也不会理会break，直接 运行完整体switch。</p>\n<h3 id=\"_5-4-跳出语句\"> 5.4 跳出语句</h3>\n<h4 id=\"break-终止switch或者循环\"> break：终止switch或者循环</h4>\n<ul>\n<li>在选择结构switch语句中</li>\n<li>在循环语句中</li>\n<li>离开使用场景的存在是没有意义的</li>\n</ul>\n<h4 id=\"continue-结束本次循环-继续下一次的循环\"> continue：结束本次循环，继续下一次的循环</h4>\n",
      "date_published": "2020-08-08T12:39:22.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": []
    },
    {
      "title": "Java-集合容器",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/java/Java-Collections/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/java/Java-Collections/",
      "content_html": "<h2 id=\"容器总览\"> 容器总览</h2>\n<p>注</p>\n<blockquote>\n<ul>\n<li>虚线空心三角：继承，例如<code>AbstractList</code>继承<code>List</code></li>\n<li>实线空心三角：实现，例如<code>ArrayList</code>实现<code>AbstractList</code></li>\n</ul>\n</blockquote>\n<blockquote>\n<ul>\n<li>小虚线：接口</li>\n<li>长虚线：抽象类</li>\n<li>实现：实现类</li>\n</ul>\n</blockquote>\n<p><img src=\"./images/Java-Collections/Java_Collections_diagram_1.jpg\" alt=\"Java集合图\" /></p>\n<p><img src=\"./images/Java-Collections/Java_Collections_diagram_2.jpg\" alt=\"Java集合图\" /></p>\n<p><img src=\"./images/Java-Collections/Java_Collections_Framework_System.png\" alt=\"Java集合框架体系\" /></p>\n<p><img src=\"./images/Java-Collections/summary_of_data_structure_of_the_Collections.png\" alt=\"集合底层数据结构\" /></p>\n<p><img src=\"./images/Java-Collections/difference_between_List_Set_and_Map.png\" alt=\"List,Set,Map三者的区别\" /></p>\n<h3 id=\"常用集合方\"> 常用集合方</h3>\n<p>参考</p>\n<blockquote>\n<p>https://wiki.lifeisgg.online/archives/Java%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB</p>\n</blockquote>\n<h2 id=\"_1-list-arraylist\"> 1. List | ArrayList</h2>\n<p>参考</p>\n<blockquote>\n<p>ArrayList方法原理：https://www.cnblogs.com/lierabbit/p/8383683.html</p>\n</blockquote>\n<h3 id=\"构造方法\"> 构造方法</h3>\n<ul>\n<li>无参构造方法</li>\n<li>有参构造方法</li>\n<li>指定集合</li>\n</ul>\n<div><pre><code><span>public</span> <span>ArrayList</span><span>(</span><span>)</span><span>//无参构造方法</span>\n<span>public</span> <span>ArrayList</span><span>(</span><span>int</span> initialCapacity<span>)</span>；<span>//有参构造方法</span>\n<span>public</span> <span>ArrayList</span><span>(</span><span>Collection</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>E</span><span>></span></span> c<span>)</span><span>//指定集合</span>\n  \n<span>/**\n* 默认初始容量大小为10\n*/</span>\n<span>private</span> <span>static</span> <span>final</span> <span>int</span> DEFAULT_CAPACITY <span>=</span> <span>10</span><span>;</span>\n    \n<span>/**默认空数组*/</span>\n<span>private</span> <span>static</span> <span>final</span> <span>Object</span><span>[</span><span>]</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA <span>=</span> <span>{</span><span>}</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p><strong>无参构造方法</strong></p>\n<p><strong>以无参数构造方法创建 ArrayList 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为10。</strong></p>\n<div><pre><code><span>/**\n     * Shared empty array instance used for default sized empty instances. We\n     * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when\n     * first element is added.\n     */</span>\n    <span>private</span> <span>static</span> <span>final</span> <span>Object</span><span>[</span><span>]</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA <span>=</span> <span>{</span><span>}</span><span>;</span>\n    <span>/**\n     * Constructs an empty list with an initial capacity of ten.\n     */</span>\n    <span>public</span> <span>ArrayList</span><span>(</span><span>)</span> <span>{</span>\n        <span>this</span><span>.</span>elementData <span>=</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA<span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p><strong>有参指定大小构造方法</strong></p>\n<ul>\n<li>当指定的初始容量大于0，初始化指定大小的数组</li>\n<li>当指定的初始容量等于0，初始化空数组</li>\n<li>当指定的初始容量小于0，抛出IllegalArgumentException异常</li>\n</ul>\n<div><pre><code><span>/**\n     * Shared empty array instance used for empty instances.\n     */</span>\n    <span>private</span> <span>static</span> <span>final</span> <span>Object</span><span>[</span><span>]</span> EMPTY_ELEMENTDATA <span>=</span> <span>{</span><span>}</span><span>;</span>\n    <span>/**\n     * Constructs an empty list with the specified initial capacity.\n     *\n     * @param  initialCapacity  the initial capacity of the list\n     * @throws IllegalArgumentException if the specified initial capacity\n     *         is negative\n     */</span>\n\n\n    <span>public</span> <span>ArrayList</span><span>(</span><span>int</span> initialCapacity<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>initialCapacity <span>></span> <span>0</span><span>)</span> <span>{</span>\n            <span>this</span><span>.</span>elementData <span>=</span> <span>new</span> <span>Object</span><span>[</span>initialCapacity<span>]</span><span>;</span>\n        <span>}</span> <span>else</span> <span>if</span> <span>(</span>initialCapacity <span>==</span> <span>0</span><span>)</span> <span>{</span>\n            <span>this</span><span>.</span>elementData <span>=</span> EMPTY_ELEMENTDATA<span>;</span>\n        <span>}</span> <span>else</span> <span>{</span>\n            <span>throw</span> <span>new</span> <span>IllegalArgumentException</span><span>(</span><span>\"Illegal Capacity: \"</span><span>+</span>\n                                               initialCapacity<span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p><strong>指定集合</strong></p>\n<p>当指定集合不为空即长度不为0，则复制该集合，否则初始化一个空数组</p>\n<div><pre><code><span>/**\n     * Constructs a list containing the elements of the specified\n     * collection, in the order they are returned by the collection's\n     * iterator.\n     *\n     * @param c the collection whose elements are to be placed into this list\n     * @throws NullPointerException if the specified collection is null\n     */</span>\n    <span>public</span> <span>ArrayList</span><span>(</span><span>Collection</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>E</span><span>></span></span> c<span>)</span> <span>{</span>\n        elementData <span>=</span> c<span>.</span><span>toArray</span><span>(</span><span>)</span><span>;</span>\n        <span>if</span> <span>(</span><span>(</span>size <span>=</span> elementData<span>.</span>length<span>)</span> <span>!=</span> <span>0</span><span>)</span> <span>{</span>\n            <span>// c.toArray might (incorrectly) not return Object[] (see 6260652)</span>\n            <span>if</span> <span>(</span>elementData<span>.</span><span>getClass</span><span>(</span><span>)</span> <span>!=</span> <span>Object</span><span>[</span><span>]</span><span>.</span><span>class</span><span>)</span>\n                elementData <span>=</span> <span>Arrays</span><span>.</span><span>copyOf</span><span>(</span>elementData<span>,</span> size<span>,</span> <span>Object</span><span>[</span><span>]</span><span>.</span><span>class</span><span>)</span><span>;</span>\n        <span>}</span> <span>else</span> <span>{</span>\n            <span>// replace with empty array.</span>\n            <span>this</span><span>.</span>elementData <span>=</span> EMPTY_ELEMENTDATA<span>;</span>\n        <span>}</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><h3 id=\"e-get-int-index-获取index位置的元素\"> E get(int index) ：获取index位置的元素</h3>\n<p>首先判断index是否越界，这里并没有判断是否小于0，因为下标小于0时数组会抛出异常。越界则抛出IndexOutOfBoundsException异常，反之返回数组对应index位置的元素</p>\n<div><pre><code><span>// Positional Access Operations</span>\n    <span>// 返回index下标的元素且强制转化为E（List&lt;E>中的E）类型</span>\n    <span>@SuppressWarnings</span><span>(</span><span>\"unchecked\"</span><span>)</span>\n    <span>E</span> <span>elementData</span><span>(</span><span>int</span> index<span>)</span> <span>{</span>\n        <span>return</span> <span>(</span><span>E</span><span>)</span> elementData<span>[</span>index<span>]</span><span>;</span>\n    <span>}</span>\n\n    <span>/**\n     * Returns the element at the specified position in this list.\n     *\n     * @param  index index of the element to return\n     * @return the element at the specified position in this list\n     * @throws IndexOutOfBoundsException {@inheritDoc}\n     */</span>\n    <span>public</span> <span>E</span> <span>get</span><span>(</span><span>int</span> index<span>)</span> <span>{</span>\n        <span>// 检查index是否越界</span>\n        <span>rangeCheck</span><span>(</span>index<span>)</span><span>;</span>\n        <span>// 返回index下标的元素</span>\n        <span>return</span> <span>elementData</span><span>(</span>index<span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>/**\n     * Checks if the given index is in range.  If not, throws an appropriate\n     * runtime exception.  This method does *not* check if the index is\n     * negative: It is always used immediately prior to an array access,\n     * which throws an ArrayIndexOutOfBoundsException if index is negative.\n     */</span>\n    <span>private</span> <span>void</span> <span>rangeCheck</span><span>(</span><span>int</span> index<span>)</span> <span>{</span>\n        <span>// 检查index是否大于等于size（数组的元素数量），因为数组下标从0开始计算，所以也不能等于元素数量</span>\n        <span>// 这里没有检查index &lt; 0的情况，因为index &lt; 0时数组会自动抛出异常，所以并未检查index&lt;0的情况</span>\n        <span>if</span> <span>(</span>index <span>>=</span> size<span>)</span>\n            <span>throw</span> <span>new</span> <span>IndexOutOfBoundsException</span><span>(</span><span>outOfBoundsMsg</span><span>(</span>index<span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>/**\n     * Constructs an IndexOutOfBoundsException detail message.\n     * Of the many possible refactorings of the error handling code,\n     * this \"outlining\" performs best with both server and client VMs.\n     */</span>\n    <span>private</span> <span>String</span> <span>outOfBoundsMsg</span><span>(</span><span>int</span> index<span>)</span> <span>{</span>\n        <span>return</span> <span>\"Index: \"</span><span>+</span>index<span>+</span><span>\", Size: \"</span><span>+</span>size<span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br></div></div><h3 id=\"e-set-int-index-e-element-设置-覆盖-index位置的元素\"> E set(int index, E element)  ：设置（覆盖）index位置的元素</h3>\n<p>和get一样先判断index（下标）是否越界，不越界则先获取原来index位置上的元素，接着设置（覆盖）index位置上的元素，然后返回原来的元素，反之抛出IndexOutOfBoundsException异常</p>\n<div><pre><code><span>/**\n     * Replaces the element at the specified position in this list with\n     * the specified element.\n     *\n     * @param index index of the element to replace\n     * @param element element to be stored at the specified position\n     * @return the element previously at the specified position\n     * @throws IndexOutOfBoundsException {@inheritDoc}\n     */</span>\n    <span>public</span> <span>E</span> <span>set</span><span>(</span><span>int</span> index<span>,</span> <span>E</span> element<span>)</span> <span>{</span>\n        <span>rangeCheck</span><span>(</span>index<span>)</span><span>;</span>\n\n        <span>E</span> oldValue <span>=</span> <span>elementData</span><span>(</span>index<span>)</span><span>;</span>\n        elementData<span>[</span>index<span>]</span> <span>=</span> element<span>;</span>\n        <span>return</span> oldValue<span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h3 id=\"boolean-add-e-e-添加一个元素到列表尾-扩容机制\"> boolean add(E e)  ：添加一个元素到列表尾/扩容机制</h3>\n<p><strong>参考</strong></p>\n<blockquote>\n<ul>\n<li>https://www.cnblogs.com/dengrongzhang/p/9371551.html</li>\n<li>https://blog.csdn.net/zymx14/article/details/78324464</li>\n<li>https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/collection/ArrayList-Grow.md</li>\n</ul>\n</blockquote>\n<p>添加一个元素到列表尾，当列表容量不足时自动扩容（通常是扩容至原来的1.5倍），添加成功返回true 。如果是新创建的对象且调用的无参构造方法，初始化时是将空数组<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>赋给elementData，在第一次调用add方法时才会扩容，一般是默认值<code>DEFAULT_CAPACITY = 10</code></p>\n<h4 id=\"流程\"> 流程</h4>\n<ul>\n<li>第一步：调用<code>ensureCapacityInternal(size + 1)</code>方法</li>\n<li>第二步：调用 <code>calculateCapacity(elementData, minCapacity)</code> 方法计算返回需要扩容的最小值</li>\n<li>第三步：调用<code>ensureExplicitCapacity()</code>方法判断扩容的最小值是否大于数组的长度，此时<code>minCapacity</code>为调用<code>calculateCapacity</code>传过来的最后计算得出的最小容量。大于则继续调用**grow(minCapacity)**方法，否则直接 <code>elementData[size++] = e</code>;</li>\n<li>第四步：调用<code>grow()</code>方法进行扩容。先<code>newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1)</code>;计算扩容<code>1.5倍</code>后再与<code>minCapacity</code>对比，如果还是比<code>minCapacity</code>小就直接<code>newCapacity = minCapacity</code>; 之后再将<code>newCapacity</code>与<code>MAX_ARRAY_SIZE</code>对比，如果比<code>MAX_ARRAY_SIZE</code>大那就调用<code>hugeCapacity(minCapacity)</code>;重新计算大小，最后<code>elementData = Arrays.copyOf(elementData, newCapacity)</code>;完成扩容，最后再将加的对象赋值给<code>elementData[size] , size++</code></li>\n</ul>\n<h4 id=\"第一步-调用ensurecapacityinternal-size-1-方法\"> 第一步：调用<code>ensureCapacityInternal(size + 1)</code>方法</h4>\n<p><code>minCapacity = size + 1</code>即为所需最小容量，调用此方法时会先调用<code>calculateCapacity(elementData, minCapacity)</code>去计算所需最小容量，之后作为参数去调用<code>ensureExplicitCapacity</code>去与当前elementdata数组的长度<code>elementdata.length</code>比较看是否需要调用<code>grow()</code>去扩容。</p>\n<div><pre><code><span>/**\n     * Appends the specified element to the end of this list.\n     *\n     * @param e element to be appended to this list\n     * @return &lt;tt>true&lt;/tt> (as specified by {@link Collection#add})\n     */</span>\n    <span>public</span> <span>boolean</span> <span>add</span><span>(</span><span>E</span> e<span>)</span> <span>{</span>\n        <span>// 检查当前容量是否还可以容纳一个元素，不够则扩容</span>\n        <span>ensureCapacityInternal</span><span>(</span>size <span>+</span> <span>1</span><span>)</span><span>;</span>  <span>// Increments modCount!!</span>\n        <span>// 添加到数组末尾</span>\n        <span>// 这个语句可以分解为</span>\n        <span>// elementData[size] = e;</span>\n        <span>// size += 1;</span>\n        elementData<span>[</span>size<span>++</span><span>]</span> <span>=</span> e<span>;</span>\n        <span>return</span> <span>true</span><span>;</span>\n    <span>}</span>\n\n\t\t<span>private</span> <span>void</span> <span>ensureCapacityInternal</span><span>(</span><span>int</span> minCapacity<span>)</span> <span>{</span>\n        <span>ensureExplicitCapacity</span><span>(</span><span>calculateCapacity</span><span>(</span>elementData<span>,</span> minCapacity<span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><blockquote>\n<p><strong>注意</strong> ：JDK11 移除了 <code>ensureCapacityInternal()</code> 和 <code>ensureExplicitCapacity()</code> 方法</p>\n</blockquote>\n<h4 id=\"第二步-调用-calculatecapacity-elementdata-mincapacity-方法\"> 第二步：调用 <code>calculateCapacity(elementData, minCapacity)</code> 方法</h4>\n<p>计算默认容量<code>DEFAULT_CAPACITY = 10</code>和当前<code>minCapacity = size + 1</code>的最大值。当 要 add 进第1个元素时，minCapacity为1，在Math.max()方法比较后，minCapacity 为10。</p>\n<div><pre><code>\n\n    <span>/**\n     * Default initial capacity.\n     */</span>\n    <span>private</span> <span>static</span> <span>final</span> <span>int</span> DEFAULT_CAPACITY <span>=</span> <span>10</span><span>;</span>  <span>// 默认容量为10</span>\n\n <span>// 如果数据等于默认数据，返回默认容量和minCapacity（所需容量最小值）的最大值，反之返回所需容量最小值</span>\n    <span>private</span> <span>static</span> <span>int</span> <span>calculateCapacity</span><span>(</span><span>Object</span><span>[</span><span>]</span> elementData<span>,</span> <span>int</span> minCapacity<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>elementData <span>==</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA<span>)</span> <span>{</span>\n            <span>return</span> <span>Math</span><span>.</span><span>max</span><span>(</span>DEFAULT_CAPACITY<span>,</span> minCapacity<span>)</span><span>;</span>\n        <span>}</span>\n        <span>return</span> minCapacity<span>;</span>\n    <span>}</span>\n\n\n    <span>/**\n     * The maximum size of array to allocate.\n     * Some VMs reserve some header words in an array.\n     * Attempts to allocate larger arrays may result in\n     * OutOfMemoryError: Requested array size exceeds VM limit\n     */</span>\n   \n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><h4 id=\"第三步-调用ensureexplicitcapacity-方法看是否需要扩容\"> 第三步：调用<code>ensureExplicitCapacity()</code>方法看是否需要扩容</h4>\n<ul>\n<li>当我们要 add 进第1个元素到 ArrayList 时，<code>elementData.length</code> 为0 （因为还是一个空的 list），因为执行了 <code>ensureCapacityInternal()</code> 方法 ，所以 minCapacity 此时为10。此时，<code>minCapacity - elementData.length &gt; 0</code>成立，所以会进入 <code>grow(minCapacity为10)</code> 方法。</li>\n<li>当add第2个元素时，<code>minCapacity</code> 为2，此时<code>elementData.length</code>(容量)在添加第一个元素后扩容成 10 了。此时，<code>minCapacity - elementData.length &gt; 0</code>不成立，所以不会进入 （执行）<code>grow(minCapacity)</code> 方法。</li>\n<li>添加第3、4···到第10个元素时，依然不会执行grow方法，数组容量都为10。直到添加第11个元素，<code>minCapacity(为11)</code>比<code>elementData.length（为10）</code>要大。进入<code>grow(minCapacity为11)</code>方法进行扩容</li>\n</ul>\n<div><pre><code>    <span>private</span> <span>void</span> <span>ensureExplicitCapacity</span><span>(</span><span>int</span> minCapacity<span>)</span> <span>{</span>\n        modCount<span>++</span><span>;</span>  <span>// 操作数+1</span>\n\n        <span>// overflow-conscious code</span>\n        <span>// 如果所需容量最小值大于实际数组的长度就扩大实际数组容量</span>\n        <span>if</span> <span>(</span>minCapacity <span>-</span> elementData<span>.</span>length <span>></span> <span>0</span><span>)</span>\n            <span>grow</span><span>(</span>minCapacity<span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h4 id=\"第四步-调用grow-方法进行扩容\"> 第四步：调用<code>grow()</code>方法进行扩容</h4>\n<ul>\n<li>当add第1个元素时，oldCapacity 为0，经比较后第一个if判断成立，newCapacity = minCapacity(为10)。但是第二个if判断不会成立，即newCapacity 不比 MAX_ARRAY_SIZE大，则不会进入 <code>hugeCapacity</code> 方法。数组容量为10，add方法中 return true,size增为1。</li>\n<li>当add第11个元素进入grow方法时，newCapacity为15，比minCapacity（为11）大，第一个if判断不成立。新容量没有大于数组最大size，不会进入hugeCapacity方法。数组容量扩为15，add方法中return true,size增为11。</li>\n<li>以此类推······</li>\n</ul>\n<p>之所以每次扩容原来的<code>1.5倍</code>，是为了不让每次调用<code>add()</code>方法都去扩容然后复制数组</p>\n<div><pre><code>\n    <span>/**\n     * Increases the capacity to ensure that it can hold at least the\n     * number of elements specified by the minimum capacity argument.\n     *\n     * @param minCapacity the desired minimum capacity\n     */</span>\n    <span>private</span> <span>void</span> <span>grow</span><span>(</span><span>int</span> minCapacity<span>)</span> <span>{</span>\n        <span>// overflow-conscious code</span>\n        <span>int</span> oldCapacity <span>=</span> elementData<span>.</span>length<span>;</span>\n        <span>// 新的容量为旧的容量的1.5倍</span>\n        <span>int</span> newCapacity <span>=</span> oldCapacity <span>+</span> <span>(</span>oldCapacity <span>>></span> <span>1</span><span>)</span><span>;</span>\n        <span>// 如果扩充容量后还是不够，则新的容量等于所需容量最小值（一般就是数组实际元素个数）</span>\n        <span>if</span> <span>(</span>newCapacity <span>-</span> minCapacity <span>&lt;</span> <span>0</span><span>)</span>\n            newCapacity <span>=</span> minCapacity<span>;</span>\n        <span>// 如果新的容量大于数组最大容量，再调用hugeCapacity计算新的容量</span>\n        <span>if</span> <span>(</span>newCapacity <span>-</span> MAX_ARRAY_SIZE <span>></span> <span>0</span><span>)</span>\n            newCapacity <span>=</span> <span>hugeCapacity</span><span>(</span>minCapacity<span>)</span><span>;</span>\n        <span>// minCapacity is usually close to size, so this is a win:</span>\n        <span>// 复制原来的数据到新的数组，数组容量为新的容量</span>\n        elementData <span>=</span> <span>Arrays</span><span>.</span><span>copyOf</span><span>(</span>elementData<span>,</span> newCapacity<span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>private</span> <span>static</span> <span>int</span> <span>hugeCapacity</span><span>(</span><span>int</span> minCapacity<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>minCapacity <span>&lt;</span> <span>0</span><span>)</span> <span>// overflow</span>\n            <span>throw</span> <span>new</span> <span>OutOfMemoryError</span><span>(</span><span>)</span><span>;</span>\n        <span>// 大于数组最大容量返回Integer最大值，反之返回数组最大容量</span>\n        <span>return</span> <span>(</span>minCapacity <span>></span> MAX_ARRAY_SIZE<span>)</span> <span>?</span>\n                <span>Integer</span><span>.</span>MAX_VALUE <span>:</span>\n                MAX_ARRAY_SIZE<span>;</span>\n    <span>}</span>\n\n <span>private</span> <span>static</span> <span>final</span> <span>int</span> MAX_ARRAY_SIZE <span>=</span> <span>Integer</span><span>.</span>MAX_VALUE <span>-</span> <span>8</span><span>;</span>  <span>// 数组最大容量为Integer最大值再减8</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div><h3 id=\"void-add-int-index-e-element-在index处放置元素\"> void add(int index, E element) ：在index处放置元素</h3>\n<p>将elementData数组从index开始后面的元素往后移一位，接着在index处放置元素</p>\n<p><strong>模拟添加数据(lierabbit)到index=4过程如下：</strong></p>\n<p><img src=\"./images/Java-Collections/ArrayList_simulates_adding_data_based_on_index.jpg\" alt=\"ArrayList根据索引模拟添加数据\" /></p>\n<ul>\n<li>在此列表中的指定位置插入指定的元素。</li>\n<li>先调用 <code>rangeCheckForAdd</code> 对index进行界限检查；然后调用 <code>ensureCapacityInternal</code> 方法保证<code>capacity</code>足够大；</li>\n<li>再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。</li>\n</ul>\n<div><pre><code><span>/**\n     * Inserts the specified element at the specified position in this\n     * list. Shifts the element currently at that position (if any) and\n     * any subsequent elements to the right (adds one to their indices).\n     *\n     * @param index index at which the specified element is to be inserted\n     * @param element element to be inserted\n     * @throws IndexOutOfBoundsException {@inheritDoc}\n     */</span>\n    <span>public</span> <span>void</span> <span>add</span><span>(</span><span>int</span> index<span>,</span> <span>E</span> element<span>)</span> <span>{</span>\n        <span>// 检查下标是否越界</span>\n        <span>rangeCheckForAdd</span><span>(</span>index<span>)</span><span>;</span>\n        <span>// 检查当前容量是否还可以在容纳一个元素，不够则扩容</span>\n        <span>ensureCapacityInternal</span><span>(</span>size <span>+</span> <span>1</span><span>)</span><span>;</span>  <span>// Increments modCount!!</span>\n        <span>// 将elementData从index开始后面的元素往后移一位</span>\n        <span>System</span><span>.</span><span>arraycopy</span><span>(</span>elementData<span>,</span> index<span>,</span> elementData<span>,</span> index <span>+</span> <span>1</span><span>,</span>\n                size <span>-</span> index<span>)</span><span>;</span>\n        elementData<span>[</span>index<span>]</span> <span>=</span> element<span>;</span>\n        size<span>++</span><span>;</span>\n    <span>}</span>\n\n    <span>/**\n     * A version of rangeCheck used by add and addAll.\n     */</span>\n    <span>private</span> <span>void</span> <span>rangeCheckForAdd</span><span>(</span><span>int</span> index<span>)</span> <span>{</span>\n        <span>// 当index等于size时相当于添加元素到列表尾</span>\n        <span>if</span> <span>(</span>index <span>></span> size <span>||</span> index <span>&lt;</span> <span>0</span><span>)</span>\n            <span>throw</span> <span>new</span> <span>IndexOutOfBoundsException</span><span>(</span><span>outOfBoundsMsg</span><span>(</span>index<span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><h3 id=\"ensurecapacity-int-mincapacity-自主扩增容量\"> ensureCapacity(int minCapacity)：自主扩增容量</h3>\n<p>在使用add()方法增加新的元素时，如果要增加的数据量很大，应该使用<code>ensureCapacity()</code>方法，该方法的作用是预先设置Arraylist的大小，这样可以大大提高初始化速度。</p>\n<div><pre><code><span>/**\n    如有必要，增加此 ArrayList 实例的容量，以确保它至少可以容纳由minimum capacity参数指定的元素数。\n     *\n     * @param   minCapacity   所需的最小容量\n     */</span>\n    <span>public</span> <span>void</span> <span>ensureCapacity</span><span>(</span><span>int</span> minCapacity<span>)</span> <span>{</span>\n        <span>int</span> minExpand <span>=</span> <span>(</span>elementData <span>!=</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA<span>)</span><span>?</span> <span>0</span><span>:</span> DEFAULT_CAPACITY<span>;</span>\n            <span>// any size if not default element table            </span>\n            <span>// larger than default for default empty table. It's already</span>\n            <span>// supposed to be at default size.</span>\n            \n        <span>if</span> <span>(</span>minCapacity <span>></span> minExpand<span>)</span> <span>{</span>\n            <span>ensureExplicitCapacity</span><span>(</span>minCapacity<span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>最好在 add 大量元素之前用 <code>ensureCapacity</code> 方法，以减少增量重新分配的次数。例如：</p>\n<p>未提前使用 <code>ensureCapacity</code> 前</p>\n<div><pre><code><span>public</span> <span>class</span> <span>EnsureCapacityTest</span> <span>{</span>\n\t<span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n\t\t<span>ArrayList</span><span><span>&lt;</span><span>Object</span><span>></span></span> list <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>Object</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n\t\t<span>final</span> <span>int</span> <span>N</span> <span>=</span> <span>10000000</span><span>;</span>\n\t\t<span>long</span> startTime <span>=</span> <span>System</span><span>.</span><span>currentTimeMillis</span><span>(</span><span>)</span><span>;</span>\n\t\t<span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>N</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>\n\t\t\tlist<span>.</span><span>add</span><span>(</span>i<span>)</span><span>;</span>\n\t\t<span>}</span>\n\t\t<span>long</span> endTime <span>=</span> <span>System</span><span>.</span><span>currentTimeMillis</span><span>(</span><span>)</span><span>;</span>\n\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"使用ensureCapacity方法前：\"</span><span>+</span><span>(</span>endTime <span>-</span> startTime<span>)</span><span>)</span><span>;</span>\n\n\t<span>}</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>结果：使用<code>ensureCapacity</code>方法前：2158</p>\n<p>使用 <code>ensureCapacity</code> 后</p>\n<div><pre><code><span>public</span> <span>class</span> <span>EnsureCapacityTest</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>ArrayList</span><span><span>&lt;</span><span>Object</span><span>></span></span> list <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>Object</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n        <span>final</span> <span>int</span> <span>N</span> <span>=</span> <span>10000000</span><span>;</span>\n        list <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>Object</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n        <span>long</span> startTime1 <span>=</span> <span>System</span><span>.</span><span>currentTimeMillis</span><span>(</span><span>)</span><span>;</span>\n        list<span>.</span><span>ensureCapacity</span><span>(</span><span>N</span><span>)</span><span>;</span><span>//此处调用后</span>\n        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>N</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>\n            list<span>.</span><span>add</span><span>(</span>i<span>)</span><span>;</span>\n        <span>}</span>\n        <span>long</span> endTime1 <span>=</span> <span>System</span><span>.</span><span>currentTimeMillis</span><span>(</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"使用ensureCapacity方法后：\"</span><span>+</span><span>(</span>endTime1 <span>-</span> startTime1<span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>结果：使用<code>ensureCapacity</code>方法后：1773</p>\n<h3 id=\"数组复制-扩容的两个方法\"> 数组复制/扩容的两个方法</h3>\n<h4 id=\"system-arraycopy-object-src-int-srcpos-object-dest-int-destpos-int-length\"> System.arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</h4>\n<p>将数组<code>src</code>从<code>srcPos</code>后的元素复制到目标数组<code>dest</code>的<code>destPos</code>起点开始，复制<code>length</code>个</p>\n<blockquote>\n<ul>\n<li><code>src</code> -这是源数组.</li>\n<li><code>srcPos</code> -这是源数组中的起始位置。</li>\n<li><code>dest</code> -这是目标数组。</li>\n<li><code>destPos</code> -这是目标数据中的起始位置。</li>\n<li><code>length</code> -- 这是一个要复制的数组元素的数目。</li>\n</ul>\n</blockquote>\n<h4 id=\"arrays-copyof\"> Arrays.copyOf()</h4>\n<div><pre><code>elementData <span>=</span> <span>Arrays</span><span>.</span><span>copyOf</span><span>(</span>elementData<span>,</span> newCapacity<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"区别\"> 区别</h4>\n<p>看两者源代码可以发现 copyOf() 内部实际调用了 <code>System.arraycopy()</code> 方法</p>\n<p><code>arraycopy()</code> 需要目标数组，将原数组拷贝到你自己定义的数组里或者原数组，而且可以选择拷贝的起点和长度以及放入新数组中的位置 <code>copyOf()</code> 是系统自动在内部新建一个数组，并返回该数组。</p>\n<h3 id=\"boolean-addall-collection-extends-e-c-添加一个集合里的所有元素到列表尾\"> boolean addAll(Collection&lt;? extends E&gt; c) : 添加一个集合里的所有元素到列表尾</h3>\n<p>将要添加的集合变为数组，然后将其复制到elementData数组末尾</p>\n<div><pre><code><span>/**\n     * Appends all of the elements in the specified collection to the end of\n     * this list, in the order that they are returned by the\n     * specified collection's Iterator.  The behavior of this operation is\n     * undefined if the specified collection is modified while the operation\n     * is in progress.  (This implies that the behavior of this call is\n     * undefined if the specified collection is this list, and this\n     * list is nonempty.)\n     *\n     * @param c collection containing elements to be added to this list\n     * @return &lt;tt>true&lt;/tt> if this list changed as a result of the call\n     * @throws NullPointerException if the specified collection is null\n     */</span>\n    <span>public</span> <span>boolean</span> <span>addAll</span><span>(</span><span>Collection</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>E</span><span>></span></span> c<span>)</span> <span>{</span>\n        <span>Object</span><span>[</span><span>]</span> a <span>=</span> c<span>.</span><span>toArray</span><span>(</span><span>)</span><span>;</span>\n        <span>int</span> numNew <span>=</span> a<span>.</span>length<span>;</span>\n        <span>// 检查当前容量是否还可以在容纳a数组的元素，不够则扩容</span>\n        <span>ensureCapacityInternal</span><span>(</span>size <span>+</span> numNew<span>)</span><span>;</span>  <span>// Increments modCount</span>\n        <span>// 将a数组里的元素添加到elementData末尾</span>\n        <span>System</span><span>.</span><span>arraycopy</span><span>(</span>a<span>,</span> <span>0</span><span>,</span> elementData<span>,</span> size<span>,</span> numNew<span>)</span><span>;</span>\n        size <span>+=</span> numNew<span>;</span>\n        <span>// a数组不为空（长度不为0）时返回true，反之false</span>\n        <span>return</span> numNew <span>!=</span> <span>0</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><h3 id=\"int-indexof-object-o-查找o元素在列表第一次出现的位置\"> int indexOf(Object o)  ：查找o元素在列表第一次出现的位置</h3>\n<p>ArrayList中可以存放null元素，indexof是返回elementData数组中值相同的首个元素的下标，indexof中比较方法是equals而equals是比较元素的值，如果使用**null.equals(Object o)**会报错空指针，因此必须对null单独查找。如果未找到该元素则返回-1</p>\n<div><pre><code><span>/**\n     * Returns the index of the first occurrence of the specified element\n     * in this list, or -1 if this list does not contain the element.\n     * More formally, returns the lowest index &lt;tt>i&lt;/tt> such that\n     * &lt;tt>(o==null ? get(i)==null : o.equals(get(i)))&lt;/tt>,\n     * or -1 if there is no such index.\n     */</span>\n    <span>public</span> <span>int</span> <span>indexOf</span><span>(</span><span>Object</span> o<span>)</span> <span>{</span>\n        <span>//元素可以为null，如果为null返回null的下标</span>\n        <span>if</span> <span>(</span>o <span>==</span> <span>null</span><span>)</span> <span>{</span>\n            <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> size<span>;</span> i<span>++</span><span>)</span>\n                <span>if</span> <span>(</span>elementData<span>[</span>i<span>]</span><span>==</span><span>null</span><span>)</span>\n                    <span>return</span> i<span>;</span>\n        <span>}</span> <span>else</span> <span>{</span>\n            <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> size<span>;</span> i<span>++</span><span>)</span>\n                <span>if</span> <span>(</span>o<span>.</span><span>equals</span><span>(</span>elementData<span>[</span>i<span>]</span><span>)</span><span>)</span>\n                    <span>return</span> i<span>;</span>\n        <span>}</span>\n        <span>// 没有找到对应的元素返回-1</span>\n        <span>return</span> <span>-</span><span>1</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><h3 id=\"e-remove-int-index-删除index位置上的元素\"> E remove(int index)  ：删除index位置上的元素</h3>\n<p>模拟删除index=4（值为lierabbit）过程如下</p>\n<p><img src=\"./images/Java-Collections/ArrayList_deletes_elements_based_on_index.jpg\" alt=\"ArrayList根据索引删除元素\" /></p>\n<div><pre><code><span>/**\n     * Removes the element at the specified position in this list.\n     * Shifts any subsequent elements to the left (subtracts one from their\n     * indices).\n     *\n     * @param index the index of the element to be removed\n     * @return the element that was removed from the list\n     * @throws IndexOutOfBoundsException {@inheritDoc}\n     */</span>\n    <span>public</span> <span>E</span> <span>remove</span><span>(</span><span>int</span> index<span>)</span> <span>{</span>\n        <span>// 检查下标是否越界</span>\n        <span>rangeCheck</span><span>(</span>index<span>)</span><span>;</span>\n\n        modCount<span>++</span><span>;</span>  <span>// 操作数+1</span>\n        <span>E</span> oldValue <span>=</span> <span>elementData</span><span>(</span>index<span>)</span><span>;</span>  <span>// 获取index位置上的元素</span>\n\n        <span>int</span> numMoved <span>=</span> size <span>-</span> index <span>-</span> <span>1</span><span>;</span>  <span>// 需要往前移动几个位置</span>\n        <span>if</span> <span>(</span>numMoved <span>></span> <span>0</span><span>)</span>\n            <span>// 从index + 1开始，往后的元素向前移动1个位置</span>\n            <span>System</span><span>.</span><span>arraycopy</span><span>(</span>elementData<span>,</span> index<span>+</span><span>1</span><span>,</span> elementData<span>,</span> index<span>,</span>\n                    numMoved<span>)</span><span>;</span>\n        <span>// 将数组末尾元素置空</span>\n        elementData<span>[</span><span>--</span>size<span>]</span> <span>=</span> <span>null</span><span>;</span> <span>// clear to let GC do its work</span>\n\n        <span>return</span> oldValue<span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><h3 id=\"boolean-remove-object-o-删除o元素\"> boolean remove(Object o)  ：删除o元素</h3>\n<p>通过寻找o元素，可以获得其下标，再根据下标删除o元素</p>\n<div><pre><code><span>/**\n     * Removes the first occurrence of the specified element from this list,\n     * if it is present.  If the list does not contain the element, it is\n     * unchanged.  More formally, removes the element with the lowest index\n     * &lt;tt>i&lt;/tt> such that\n     * &lt;tt>(o==null ? get(i)==null : o.equals(get(i)))&lt;/tt>\n     * (if such an element exists).  Returns &lt;tt>true&lt;/tt> if this list\n     * contained the specified element (or equivalently, if this list\n     * changed as a result of the call).\n     *\n     * @param o element to be removed from this list, if present\n     * @return &lt;tt>true&lt;/tt> if this list contained the specified element\n     */</span>\n    <span>public</span> <span>boolean</span> <span>remove</span><span>(</span><span>Object</span> o<span>)</span> <span>{</span>\n        <span>// 元素可以为null，分开搜索o</span>\n        <span>if</span> <span>(</span>o <span>==</span> <span>null</span><span>)</span> <span>{</span>\n            <span>for</span> <span>(</span><span>int</span> index <span>=</span> <span>0</span><span>;</span> index <span>&lt;</span> size<span>;</span> index<span>++</span><span>)</span>\n                <span>if</span> <span>(</span>elementData<span>[</span>index<span>]</span> <span>==</span> <span>null</span><span>)</span> <span>{</span>\n                    <span>fastRemove</span><span>(</span>index<span>)</span><span>;</span>\n                    <span>return</span> <span>true</span><span>;</span>\n                <span>}</span>\n        <span>}</span> <span>else</span> <span>{</span>\n            <span>for</span> <span>(</span><span>int</span> index <span>=</span> <span>0</span><span>;</span> index <span>&lt;</span> size<span>;</span> index<span>++</span><span>)</span>\n                <span>if</span> <span>(</span>o<span>.</span><span>equals</span><span>(</span>elementData<span>[</span>index<span>]</span><span>)</span><span>)</span> <span>{</span>\n                    <span>fastRemove</span><span>(</span>index<span>)</span><span>;</span>\n                    <span>return</span> <span>true</span><span>;</span>\n                <span>}</span>\n        <span>}</span>\n        <span>// 没有找到返回false</span>\n        <span>return</span> <span>false</span><span>;</span>\n    <span>}</span>\n\n    <span>/*\n     * Private remove method that skips bounds checking and does not\n     * return the value removed.\n     */</span>\n    <span>// 由于已经找到元素，则元素必定存在，则index必定合理，所以不需要在检查index是否越界</span>\n    <span>private</span> <span>void</span> <span>fastRemove</span><span>(</span><span>int</span> index<span>)</span> <span>{</span>\n        modCount<span>++</span><span>;</span>\n        <span>int</span> numMoved <span>=</span> size <span>-</span> index <span>-</span> <span>1</span><span>;</span>\n        <span>if</span> <span>(</span>numMoved <span>></span> <span>0</span><span>)</span>\n            <span>System</span><span>.</span><span>arraycopy</span><span>(</span>elementData<span>,</span> index<span>+</span><span>1</span><span>,</span> elementData<span>,</span> index<span>,</span>\n                    numMoved<span>)</span><span>;</span>\n        elementData<span>[</span><span>--</span>size<span>]</span> <span>=</span> <span>null</span><span>;</span> <span>// clear to let GC do its work</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br></div></div><h3 id=\"foreach-consumer-super-e-action-遍历列表\"> forEach(Consumer&lt;? super E&gt; action) ：遍历列表</h3>\n<p>这里可以看到<strong>modCount</strong>的用处，当<strong>modCount</strong>发生改变后，立刻抛出<strong>ConcurrentModificationException</strong>异常。通过之前的分析可以知道当列表内容被修改时<strong>modCount</strong>会增加。也就是说如果在遍历<strong>ArrayList</strong>的过程中有其他线程修改了<strong>ArrayList</strong>，那么将抛出<strong>ConcurrentModificationException</strong>异常</p>\n<div><pre><code>\n    <span>protected</span> <span>transient</span> <span>int</span> modCount <span>=</span> <span>0</span><span>;</span><span>//操作数</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>forEach</span><span>(</span><span>Consumer</span><span><span>&lt;</span><span>?</span> <span>super</span> <span>E</span><span>></span></span> action<span>)</span> <span>{</span>\n        <span>// 确保不为空</span>\n        <span>Objects</span><span>.</span><span>requireNonNull</span><span>(</span>action<span>)</span><span>;</span>\n        <span>final</span> <span>int</span> expectedModCount <span>=</span> modCount<span>;</span>\n        <span>@SuppressWarnings</span><span>(</span><span>\"unchecked\"</span><span>)</span>\n        <span>final</span> <span>E</span><span>[</span><span>]</span> elementData <span>=</span> <span>(</span><span>E</span><span>[</span><span>]</span><span>)</span> <span>this</span><span>.</span>elementData<span>;</span>\n        <span>final</span> <span>int</span> size <span>=</span> <span>this</span><span>.</span>size<span>;</span>\n        <span>for</span> <span>(</span><span>int</span> i<span>=</span><span>0</span><span>;</span> modCount <span>==</span> expectedModCount <span>&amp;&amp;</span> i <span>&lt;</span> size<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n            action<span>.</span><span>accept</span><span>(</span>elementData<span>[</span>i<span>]</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>if</span> <span>(</span>modCount <span>!=</span> expectedModCount<span>)</span> <span>{</span>\n            <span>throw</span> <span>new</span> <span>ConcurrentModificationException</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n\n    <span>public</span> <span>static</span> <span><span>&lt;</span><span>T</span><span>></span></span> <span>T</span> <span>requireNonNull</span><span>(</span><span>T</span> obj<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>obj <span>==</span> <span>null</span><span>)</span>\n            <span>throw</span> <span>new</span> <span>NullPointerException</span><span>(</span><span>)</span><span>;</span>\n        <span>return</span> obj<span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><h3 id=\"comparable接口重写排序规则\"> Comparable接口重写排序规则</h3>\n<p>::: tips 参考</p>\n<ul>\n<li>https://blog.csdn.net/nanhuaibeian/article/details/104169002</li>\n</ul>\n<p>:::</p>\n<h2 id=\"_2-list-linkedlist\"> 2. List | LinkedList</h2>\n<h2 id=\"_3-list-区别\"> 3. List | 区别</h2>\n<h3 id=\"arraylist与list的区别\"> ArrayList与List的区别</h3>\n<p>参考</p>\n<blockquote>\n<ul>\n<li>https://www.cnblogs.com/zcscnn/p/7743507.html</li>\n</ul>\n</blockquote>\n<p>List是一个接口，而ListArray是一个类。ArrayList继承并实现了List。</p>\n<p>因此，List接口不能被构造，也就是我们说的不能创建实例对象，但是我们可以像下面那样为List接口创建一个指向自己的对象引用，而ArrayList实现类的实例对象就在这充当了这个指向List接口的对象引用。</p>\n<div><pre><code><span>List</span> list <span>=</span> <span>new</span> <span>List</span><span>(</span><span>)</span><span>;</span><span>//是错误的用法</span>\n<span>List</span> list <span>=</span> <span>new</span> <span>ArrayList</span><span>(</span><span>)</span><span>;</span><span>//正确</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>这句创建了一个ArrayList实现类的对象后把它上溯到了List接口。此时它就是一个List对象了，它有些ArrayList类具有的，但是List接口没有的属性和方法，它就不能再用了。 而ArrayList list=newArrayList();</p>\n<p>创建一对象则保留了ArrayList的所有属性和方法。</p>\n<h3 id=\"arraylist-与-linkedlist-区别\"> Arraylist 与 LinkedList 区别?</h3>\n<p><img src=\"./images/Java-Collections/difference_between_Arraylist_and_LinkedList.png\" alt=\"ArrayList与LinkedList区别\" /></p>\n<h3 id=\"arraylist-与-vector-区别呢-为什么要用arraylist取代vector呢\"> ArrayList 与 Vector 区别呢?为什么要⽤Arraylist取代Vector呢？</h3>\n<p><img src=\"./images/Java-Collections/difference_between_ArrayList_and_Vector.png\" alt=\"ArrayList与Vector区别\" /></p>\n<h2 id=\"_4-set-hashset\"> 4. Set | HashSet</h2>\n<p><strong>HashSet</strong>实现<strong>Set</strong>接口，由哈希表（实际上是一个<strong>HashMap</strong>实例）支持。它不保证set 的迭代顺序；特别是它不保证该顺序恒久不变。此类允许使用null元素。对于<strong>HashSet</strong>而言，它是基于<strong>HashMap</strong>实现的，HashSet底层使用<strong>HashMap</strong>来保存所有元素，因此<strong>HashSet</strong> 的实现比较简单，相关<strong>HashSet</strong>的操作，基本上都是直接调用底层<strong>HashMap</strong>的相关方法来完成， <strong>HashSet</strong>的源代码如下：</p>\n<h3 id=\"hashset与hashmap区别\"> HashSet与HashMap区别</h3>\n<p><img src=\"./images/Java-Collections/difference_between_HashMap_and_HashSet.png\" alt=\"HashMap 和 HashSet区别\" /></p>\n<h3 id=\"构造器\"> 构造器</h3>\n<div><pre><code><span>public</span> <span>class</span> <span>HashSet</span><span><span>&lt;</span><span>E</span><span>></span></span>  \n    <span>extends</span> <span>AbstractSet</span><span><span>&lt;</span><span>E</span><span>></span></span>  \n    <span>implements</span> <span>Set</span><span><span>&lt;</span><span>E</span><span>></span></span><span>,</span> <span>Cloneable</span><span>,</span> <span><span>java<span>.</span>io<span>.</span></span>Serializable</span>  \n<span>{</span>  \n    <span>static</span> <span>final</span> <span>long</span> serialVersionUID <span>=</span> <span>-</span><span>5024744406713321676L</span><span>;</span>  \n  \n    <span>// 底层使用HashMap来保存HashSet中所有元素。  </span>\n    <span>private</span> <span>transient</span> <span>HashMap</span><span><span>&lt;</span><span>E</span><span>,</span><span>Object</span><span>></span></span> map<span>;</span>  \n      \n    <span>// 定义一个虚拟的Object对象作为HashMap的value，将此对象定义为static final。  </span>\n    <span>private</span> <span>static</span> <span>final</span> <span>Object</span> PRESENT <span>=</span> <span>new</span> <span>Object</span><span>(</span><span>)</span><span>;</span>  \n  \n    <span>/** \n     * 默认的无参构造器，构造一个空的HashSet。 \n     *  \n     * 实际底层会初始化一个空的HashMap，并使用默认初始容量为16和加载因子0.75。 \n     */</span>  \n    <span>public</span> <span>HashSet</span><span>(</span><span>)</span> <span>{</span>  \n    map <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>E</span><span>,</span><span>Object</span><span>></span></span><span>(</span><span>)</span><span>;</span>  \n    <span>}</span>  \n  \n    <span>/** \n     * 构造一个包含指定collection中的元素的新set。 \n     * \n     * 实际底层使用默认的加载因子0.75和足以包含指定 \n     * collection中所有元素的初始容量来创建一个HashMap。 \n     * @param c 其中的元素将存放在此set中的collection。 \n     */</span>  \n    <span>public</span> <span>HashSet</span><span>(</span><span>Collection</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>E</span><span>></span></span> c<span>)</span> <span>{</span>  \n    map <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>E</span><span>,</span><span>Object</span><span>></span></span><span>(</span><span>Math</span><span>.</span><span>max</span><span>(</span><span>(</span><span>int</span><span>)</span> <span>(</span>c<span>.</span><span>size</span><span>(</span><span>)</span><span>/</span><span>.75f</span><span>)</span> <span>+</span> <span>1</span><span>,</span> <span>16</span><span>)</span><span>)</span><span>;</span>  \n    <span>addAll</span><span>(</span>c<span>)</span><span>;</span>  \n    <span>}</span>  \n  \n    <span>/** \n     * 以指定的initialCapacity和loadFactor构造一个空的HashSet。 \n     * \n     * 实际底层以相应的参数构造一个空的HashMap。 \n     * @param initialCapacity 初始容量。 \n     * @param loadFactor 加载因子。 \n     */</span>  \n    <span>public</span> <span>HashSet</span><span>(</span><span>int</span> initialCapacity<span>,</span> <span>float</span> loadFactor<span>)</span> <span>{</span>  \n    map <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>E</span><span>,</span><span>Object</span><span>></span></span><span>(</span>initialCapacity<span>,</span> loadFactor<span>)</span><span>;</span>  \n    <span>}</span>  \n  \n    <span>/** \n     * 以指定的initialCapacity构造一个空的HashSet。 \n     * \n     * 实际底层以相应的参数及加载因子loadFactor为0.75构造一个空的HashMap。 \n     * @param initialCapacity 初始容量。 \n     */</span>  \n    <span>public</span> <span>HashSet</span><span>(</span><span>int</span> initialCapacity<span>)</span> <span>{</span>  \n    map <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>E</span><span>,</span><span>Object</span><span>></span></span><span>(</span>initialCapacity<span>)</span><span>;</span>  \n    <span>}</span>  \n  \n    <span>/** \n     * 以指定的initialCapacity和loadFactor构造一个新的空链接哈希集合。 \n     * 此构造函数为包访问权限，不对外公开，实际只是是对LinkedHashSet的支持。 \n     * \n     * 实际底层会以指定的参数构造一个空LinkedHashMap实例来实现。 \n     * @param initialCapacity 初始容量。 \n     * @param loadFactor 加载因子。 \n     * @param dummy 标记。 \n     */</span>  \n    <span>HashSet</span><span>(</span><span>int</span> initialCapacity<span>,</span> <span>float</span> loadFactor<span>,</span> <span>boolean</span> dummy<span>)</span> <span>{</span>  \n    map <span>=</span> <span>new</span> <span>LinkedHashMap</span><span><span>&lt;</span><span>E</span><span>,</span><span>Object</span><span>></span></span><span>(</span>initialCapacity<span>,</span> loadFactor<span>)</span><span>;</span>  \n    <span>}</span>  \n  \n\n  \n    <span>/** \n     * 返回此HashSet实例的浅表副本：并没有复制这些元素本身。 \n     * \n     * 底层实际调用HashMap的clone()方法，获取HashMap的浅表副本，并设置到HashSet中。 \n     */</span>  \n    <span>public</span> <span>Object</span> <span>clone</span><span>(</span><span>)</span> <span>{</span>  \n        <span>try</span> <span>{</span>  \n            <span>HashSet</span><span><span>&lt;</span><span>E</span><span>></span></span> newSet <span>=</span> <span>(</span><span>HashSet</span><span><span>&lt;</span><span>E</span><span>></span></span><span>)</span> <span>super</span><span>.</span><span>clone</span><span>(</span><span>)</span><span>;</span>  \n            newSet<span>.</span>map <span>=</span> <span>(</span><span>HashMap</span><span><span>&lt;</span><span>E</span><span>,</span> <span>Object</span><span>></span></span><span>)</span> map<span>.</span><span>clone</span><span>(</span><span>)</span><span>;</span>  \n            <span>return</span> newSet<span>;</span>  \n        <span>}</span> <span>catch</span> <span>(</span><span>CloneNotSupportedException</span> e<span>)</span> <span>{</span>  \n            <span>throw</span> <span>new</span> <span>InternalError</span><span>(</span><span>)</span><span>;</span>  \n        <span>}</span>  \n    <span>}</span>  \n<span>}</span>  \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br></div></div><h3 id=\"调用add方法-如何去重\"> 调用add方法/如何去重</h3>\n<p>当你把对象加⼊ HashSet 时，HashSet会先计算对象的 hashcode 值来判断对象加⼊的位置，同时也会 与其他加⼊的对象的hashcode值作⽐᫾，如果没有相符的hashcode，HashSet会假设对象没有重复出 现。但是如果发现有相同hashcode值的对象，这时会调⽤ equals（） ⽅法来检查hashcode相等的对 象是否真的相同。如果两者相同，HashSet就不会让加⼊操作成功。（摘⾃我的Java启蒙书《Head fist java》第⼆版）</p>\n<ul>\n<li>如果此set中尚未包含指定元素，则添加指定元素。</li>\n<li>更确切地讲，如果此 set 没有包含满足(e==null ? e2==null : e.equals(e2)) 的元素e2，则向此set 添加指定的元素e。</li>\n<li>如果此set已包含该元素，则该调用不更改set并返回false。</li>\n<li>底层实际将将该元素作为key放入HashMap。</li>\n<li>由于HashMap的put()方法添加key-value对时，当新放入HashMap的Entry中key 与集合中原有Entry的key相同（hashCode()返回值相等，通过equals比较也返回true）。新添加的Entry的value会将覆盖原来Entry的value，但key不会有任何改变，</li>\n<li>因此如果向HashSet中添加一个已经存在的元素时，新添加的集合元素将不会被放入HashMap中，</li>\n<li>原来的元素也不会有任何改变，这也就满足了Set中元素不重复的特性。</li>\n</ul>\n<div><pre><code>    <span>/**  \n     * @param e 将添加到此set中的元素。 \n     * @return 如果此set尚未包含指定元素，则返回true。 \n     */</span>  \n    <span>public</span> <span>boolean</span> <span>add</span><span>(</span><span>E</span> e<span>)</span> <span>{</span>  \n    <span>return</span> map<span>.</span><span>put</span><span>(</span>e<span>,</span> PRESENT<span>)</span><span>==</span><span>null</span><span>;</span>  \n    <span>}</span>  \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id=\"调用remove方法\"> 调用remove方法</h3>\n<div><pre><code> <span>/** \n     * 如果指定元素存在于此set中，则将其移除。 \n     * 更确切地讲，如果此set包含一个满足(o==null ? e==null : o.equals(e))的元素e， \n     * 则将其移除。如果此set已包含该元素，则返回true \n     * （或者：如果此set因调用而发生更改，则返回true）。（一旦调用返回，则此set不再包含该元素）。 \n     * \n     * 底层实际调用HashMap的remove方法删除指定Entry。 \n     * @param o 如果存在于此set中则需要将其移除的对象。 \n     * @return 如果set包含指定元素，则返回true。 \n     */</span>  \n    <span>public</span> <span>boolean</span> <span>remove</span><span>(</span><span>Object</span> o<span>)</span> <span>{</span>  \n    <span>return</span> map<span>.</span><span>remove</span><span>(</span>o<span>)</span><span>==</span>PRESENT<span>;</span>\n    <span>}</span>  \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h3 id=\"调用clear方法\"> 调用clear方法</h3>\n<div><pre><code>    <span>/** \n     * 从此set中移除所有元素。此调用返回后，该set将为空。 \n     * \n     * 底层实际调用HashMap的clear方法清空Entry中所有元素。 \n     */</span>  \n    <span>public</span> <span>void</span> <span>clear</span><span>(</span><span>)</span> <span>{</span>  \n    map<span>.</span><span>clear</span><span>(</span><span>)</span><span>;</span>  \n    <span>}</span>  \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id=\"迭代器遍历\"> 迭代器遍历</h3>\n<p>底层实际调用底层<strong>HashMap</strong>的<strong>keySet</strong>来返回所有的key。</p>\n<div><pre><code><span>/** \n     * 返回对此set中元素进行迭代的迭代器。返回元素的顺序并不是特定的。 \n     *  \n     * 底层实际调用底层HashMap的keySet来返回所有的key。 \n     * 可见HashSet中的元素，只是存放在了底层HashMap的key上， \n     * value使用一个static final的Object对象标识。 \n     * @return 对此set中元素进行迭代的Iterator。 \n     */</span>  \n    <span>public</span> <span>Iterator</span><span><span>&lt;</span><span>E</span><span>></span></span> <span>iterator</span><span>(</span><span>)</span> <span>{</span>  \n    <span>return</span> map<span>.</span><span>keySet</span><span>(</span><span>)</span><span>.</span><span>iterator</span><span>(</span><span>)</span><span>;</span>  \n    <span>}</span>  \n  \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>也可以使用<code>for(Object obj : set)</code>的方式进行遍历</p>\n<h3 id=\"size大小\"> size大小</h3>\n<p>底层实际调用<strong>HashMap</strong>的**size()**方法返回Entry的数量，就得到该Set中元素的个数</p>\n<div><pre><code><span>/** \n     * 返回此set中的元素的数量（set的容量）。 \n     * \n     * 底层实际调用HashMap的size()方法返回Entry的数量，就得到该Set中元素的个数。 \n     * @return 此set中的元素的数量（set的容量）。 \n     */</span>  \n    <span>public</span> <span>int</span> <span>size</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> map<span>.</span><span>size</span><span>(</span><span>)</span><span>;</span>  \n    <span>}</span>  \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id=\"判断空\"> 判断空</h3>\n<div><pre><code>    <span>/** \n     * 如果此set不包含任何元素，则返回true。 \n     * \n     * 底层实际调用HashMap的isEmpty()判断该HashSet是否为空。 \n     * @return 如果此set不包含任何元素，则返回true。 \n     */</span>  \n    <span>public</span> <span>boolean</span> <span>isEmpty</span><span>(</span><span>)</span> <span>{</span>  \n    <span>return</span> map<span>.</span><span>isEmpty</span><span>(</span><span>)</span><span>;</span>  \n    <span>}</span>  \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id=\"判断是否存在某个对象\"> 判断是否存在某个对象</h3>\n<div><pre><code>\n    <span>/** \n     * 如果此set包含指定元素，则返回true。 \n     * 更确切地讲，当且仅当此set包含一个满足(o==null ? e==null : o.equals(e)) \n     * 的e元素时，返回true。 \n     * \n     * 底层实际调用HashMap的containsKey判断是否包含指定key。 \n     * @param o 在此set中的存在已得到测试的元素。 \n     * @return 如果此set包含指定元素，则返回true。 \n     */</span>  \n    <span>public</span> <span>boolean</span> <span>contains</span><span>(</span><span>Object</span> o<span>)</span> <span>{</span>  \n    <span>return</span> map<span>.</span><span>containsKey</span><span>(</span>o<span>)</span><span>;</span>  \n    <span>}</span>  \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h2 id=\"_5-map-hashmap\"> 5. Map | HashMap</h2>\n<p><img src=\"./images/Java-Collections/Map_Collections_diagram.png\" alt=\"Map集合图\" /></p>\n<h3 id=\"参考\"> 参考</h3>\n<blockquote>\n<ul>\n<li>https://www.cnblogs.com/chentang/p/12670462.html</li>\n<li>https://www.cnblogs.com/wytiger/p/10731082.html</li>\n<li>https://www.cnblogs.com/yuanblog/p/4441017.html</li>\n<li><a href=\"https://blog.csdn.net/v123411739/article/details/78996181?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param\" target=\"_blank\" rel=\"noopener noreferrer\">最全源码解析</a></li>\n</ul>\n</blockquote>\n<h3 id=\"哈希表-哈希冲突\"> 哈希表&amp;哈希冲突</h3>\n<p>​\t在数组中根据下标查找某个元素，一次定位就可以达到，哈希表利用了这种特性，<strong>哈希表的主干就是数组</strong>。比如我们要新增或查找某个元素，我们通过把当前元素的关键字 通过某个函数映射到数组中的某个位置，通过数组下标一次定位就可完成操作。</p>\n<blockquote>\n<p><strong>存储位置 = f(关键字)</strong></p>\n</blockquote>\n<p>其中，这个函数f一般称为<strong>哈希函数</strong>，这个函数的设计好坏会直接影响到哈希表的优劣。举个例子，比如我们要在哈希表中执行插入操作：</p>\n<p><img src=\"./images/Java-Collections/Hash_table_diagram.jpg\" alt=\"哈希表图解\" /></p>\n<p>查找操作同理，先通过哈希函数计算出实际存储地址，然后从数组中对应地址取出即可。</p>\n<p>然而万事无完美，如果两个不同的元素，通过哈希函数得出的实际存储地址相同怎么办？也就是说，当我们对某个元素进行哈希运算，得到一个存储地址，然后要进行插入的时候，发现已经被其他元素占用了，其实这就是所谓的<strong>哈希冲突</strong>，也叫哈希碰撞。前面我们提到过，哈希函数的设计至关重要，好的哈希函数会尽可能地保证 <strong>计算简单</strong>和**散列地址分布均匀,**但是，我们需要清楚的是，数组是一块连续的固定长度的内存空间，再好的哈希函数也不能保证得到的存储地址绝对不发生冲突。那么哈希冲突如何解决呢？</p>\n<ul>\n<li>**链地址法：**将哈希表的每个单元作为链表的头结点，所有哈希地址为 i 的元素构成一个同义词链表。即发生冲突时就把该关键字链在以该单元为头结点的链表的尾部。</li>\n</ul>\n<h3 id=\"hashmap数据结构\"> HashMap数据结构</h3>\n<p><strong>HashMap</strong>的主干是一个变量名为<strong>table</strong>的<strong>Entry/Node数组</strong>。<strong>Entry/Node</strong>是<strong>HashMap</strong>的基本组成单元，每一个<strong>Entry/Node</strong>包含一个<strong>key-value</strong>键值对。</p>\n<div><pre><code><span>//HashMap的主干数组，可以看到就是一个Entry数组，初始值为空数组{}，主干数组的长度一定是2的次幂</span>\n<span>transient</span> <span>Entry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>[</span><span>]</span> table <span>=</span> <span>(</span><span>Entry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>[</span><span>]</span><span>)</span> EMPTY_TABLE<span>;</span>\n\n    <span>static</span> <span>class</span> <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> <span>implements</span> <span>Map<span>.</span>Entry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> <span>{</span>\n        <span>final</span> <span>int</span> hash<span>;</span>\n        <span>final</span> <span>K</span> key<span>;</span>\n        <span>V</span> value<span>;</span>\n        <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> next<span>;</span>\n\n        <span>Node</span><span>(</span><span>int</span> hash<span>,</span> <span>K</span> key<span>,</span> <span>V</span> value<span>,</span> <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> next<span>)</span> <span>{</span>\n            <span>this</span><span>.</span>hash <span>=</span> hash<span>;</span>\n            <span>this</span><span>.</span>key <span>=</span> key<span>;</span>\n            <span>this</span><span>.</span>value <span>=</span> value<span>;</span>\n            <span>this</span><span>.</span>next <span>=</span> next<span>;</span>\n        <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><ul>\n<li><strong>简单来说，HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的。</strong></li>\n<li><strong>如果定位到的数组位置不含链表（当前entry的next指向null）：那么对于查找，添加等操作很快，仅需一次寻址即可；</strong></li>\n<li><strong>如果定位到的数组包含链表：对于添加操作，其时间复杂度为O(n)，首先遍历链表，存在即覆盖，否则新增；对于查找操作来讲，仍需遍历链表，然后通过key对象的equals方法逐一比对查找。</strong></li>\n</ul>\n<p><img src=\"./images/Java-Collections/HashMap_data_structure_1.png\" alt=\"HashMap数据结构\" /></p>\n<p><img src=\"./images/Java-Collections/HashMap_data_structure_2.png\" alt=\"HashMap数据结构2\" /></p>\n<h3 id=\"hashmap属性\"> HashMap属性</h3>\n<ul>\n<li>**initialCapacity：**初始容量。指的是 HashMap 集合初始化的时候自身的容量。可以在构造方法中指定；如果不指定的话，总容量默认值是 <strong>16</strong> 。需要注意的是初始容量必须是 2 的幂次方。</li>\n<li>**size：**当前 HashMap 中已经存储着的键值对数量，即 HashMap.size()</li>\n<li>**loadFactor：**加载因子。所谓的加载因子就是 HashMap (当前的容量/总容量) 到达一定值的时候，HashMap 会实施扩容。加载因子也可以通过构造方法中指定，默认的值是 0.75 。举个例子，假设有一个 HashMap 的初始容量为 16 ，那么扩容的阀值就是 0.75 * 16 = 12 。也就是说，在你打算存入第 13 个值的时候，HashMap 会先执行扩容。</li>\n<li>**threshold：**扩容阀值。即 扩容阀值 = HashMap 总容量 * 加载因子。当前 HashMap 的容量大于或等于扩容阀值的时候就会去执行扩容。扩容的容量为当前 HashMap 总容量的两倍。比如，当前 HashMap 的总容量为 16 ，那么扩容之后为 32 。</li>\n<li>**table：**1.8之前为Entry 数组，1.8之后为Node数组。我们都知道 HashMap 内部存储 key/value 是通过 Entry/Node 这个介质来实现的。</li>\n</ul>\n<div><pre><code><span>implements</span> <span>Map</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>,</span> <span>Cloneable</span><span>,</span> <span>Serializable</span> <span>{</span>\n    <span>//序列号，序列化的时候使用。</span>\n    <span>private</span> <span>static</span> <span>final</span> <span>long</span> serialVersionUID <span>=</span> <span>362498820763181265L</span><span>;</span>\n    <span>/**默认容量，1向左移位4个，00000001变成00010000，也就是2的4次方为16，使用移位是因为移位是计算机基础运算，效率比加减乘除快。**/</span>\n    <span>static</span> <span>final</span> <span>int</span> DEFAULT_INITIAL_CAPACITY <span>=</span> <span>1</span> <span>&lt;&lt;</span> <span>4</span><span>;</span>\n    <span>//最大容量，2的30次方。</span>\n    <span>static</span> <span>final</span> <span>int</span> MAXIMUM_CAPACITY <span>=</span> <span>1</span> <span>&lt;&lt;</span> <span>30</span><span>;</span>\n    <span>//加载因子，用于扩容使用。</span>\n    <span>static</span> <span>final</span> <span>float</span> DEFAULT_LOAD_FACTOR <span>=</span> <span>0.75f</span><span>;</span>\n    <span>//当某个桶节点数量大于8时，会转换为红黑树。</span>\n    <span>static</span> <span>final</span> <span>int</span> TREEIFY_THRESHOLD <span>=</span> <span>8</span><span>;</span>\n    <span>//当某个桶节点数量小于6时，会转换为链表，前提是它当前是红黑树结构。</span>\n    <span>static</span> <span>final</span> <span>int</span> UNTREEIFY_THRESHOLD <span>=</span> <span>6</span><span>;</span>\n    <span>//当整个hashMap中元素数量大于64时，也会进行转为红黑树结构。</span>\n    <span>static</span> <span>final</span> <span>int</span> MIN_TREEIFY_CAPACITY <span>=</span> <span>64</span><span>;</span>\n    <span>//存储元素的数组，transient关键字表示该属性不能被序列化</span>\n    <span>transient</span> <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>[</span><span>]</span> table<span>;</span>\n    <span>//将数据转换成set的另一种存储形式，这个变量主要用于迭代功能。</span>\n    <span>transient</span> <span>Set</span><span><span>&lt;</span><span>Map<span>.</span>Entry</span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span><span>></span></span> entrySet<span>;</span>\n    <span>//元素数量</span>\n    <span>transient</span> <span>int</span> size<span>;</span>\n    <span>//统计该map修改的次数</span>\n    <span>transient</span> <span>int</span> modCount<span>;</span>\n    <span>//临界值，也就是元素数量达到临界值时，会进行扩容。</span>\n    <span>int</span> threshold<span>;</span>\n    <span>//也是加载因子，只不过这个是变量。</span>\n    <span>final</span> <span>float</span> loadFactor<span>;</span> \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><h3 id=\"hashmap常用内部类\"> HashMap常用内部类</h3>\n<p><strong>红黑树结构</strong></p>\n<div><pre><code><span>static</span> <span>final</span> <span>class</span> <span>TreeNode</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> <span>extends</span> <span>LinkedHashMap<span>.</span>Entry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> <span>{</span>\n        <span>TreeNode</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> parent<span>;</span>  \n        <span>TreeNode</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> left<span>;</span>\n        <span>TreeNode</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> right<span>;</span>\n        <span>TreeNode</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> prev<span>;</span>    \n        <span>boolean</span> red<span>;</span>\n        <span>TreeNode</span><span>(</span><span>int</span> hash<span>,</span> <span>K</span> key<span>,</span> <span>V</span> val<span>,</span> <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> next<span>)</span> <span>{</span>\n            <span>super</span><span>(</span>hash<span>,</span> key<span>,</span> val<span>,</span> next<span>)</span><span>;</span>\n        <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p><strong>结点类</strong></p>\n<div><pre><code><span>static</span> <span>class</span> <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> <span>implements</span> <span>Map<span>.</span>Entry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> <span>{</span>\n        <span>final</span> <span>int</span> hash<span>;</span>\n        <span>final</span> <span>K</span> key<span>;</span>\n        <span>V</span> value<span>;</span>\n        <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> next<span>;</span>\n \n        <span>Node</span><span>(</span><span>int</span> hash<span>,</span> <span>K</span> key<span>,</span> <span>V</span> value<span>,</span> <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> next<span>)</span> <span>{</span>\n            <span>this</span><span>.</span>hash <span>=</span> hash<span>;</span>\n            <span>this</span><span>.</span>key <span>=</span> key<span>;</span>\n            <span>this</span><span>.</span>value <span>=</span> value<span>;</span>\n            <span>this</span><span>.</span>next <span>=</span> next<span>;</span>\n        <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h3 id=\"构造方法-2\"> 构造方法</h3>\n<ul>\n<li>无参构造方法，默认容量<strong>16</strong>，默认的加载因子<strong>0.75</strong></li>\n<li>设置初始容量，并使用默认的加载因子<strong>0.75</strong>，调用的方法是第三个构造方法，将默认<strong>DEFAULT_LOAD_FACTOR</strong>作为形参传入第三个构造函数</li>\n<li>设置初始容量和加载因子</li>\n<li>传入一个Map，然后把该Map转为hashMap</li>\n</ul>\n<p><strong>无参构造方法</strong></p>\n<div><pre><code><span>public</span> <span>HashMap</span><span>(</span><span>)</span> <span>{</span>\n        <span>this</span><span>.</span>loadFactor <span>=</span> DEFAULT_LOAD_FACTOR<span>;</span> \n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>设置初始容量，并使用默认的加载因子0.75</strong></p>\n<div><pre><code><span>public</span> <span>HashMap</span><span>(</span><span>int</span> initialCapacity<span>)</span> <span>{</span>\n        <span>this</span><span>(</span>initialCapacity<span>,</span> DEFAULT_LOAD_FACTOR<span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>设置初始容量和加载因子</strong></p>\n<div><pre><code><span>public</span> <span>HashMap</span><span>(</span><span>int</span> initialCapacity<span>,</span> <span>float</span> loadFactor<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>initialCapacity <span>&lt;</span> <span>0</span><span>)</span>\n            <span>throw</span> <span>new</span> <span>IllegalArgumentException</span><span>(</span><span>\"Illegal initial capacity: \"</span> <span>+</span>\n                                               initialCapacity<span>)</span><span>;</span>\n        <span>if</span> <span>(</span>initialCapacity <span>></span> MAXIMUM_CAPACITY<span>)</span>\n            initialCapacity <span>=</span> MAXIMUM_CAPACITY<span>;</span>\n        <span>if</span> <span>(</span>loadFactor <span>&lt;=</span> <span>0</span> <span>||</span> <span>Float</span><span>.</span><span>isNaN</span><span>(</span>loadFactor<span>)</span><span>)</span>\n            <span>throw</span> <span>new</span> <span>IllegalArgumentException</span><span>(</span><span>\"Illegal load factor: \"</span> <span>+</span>\n                                               loadFactor<span>)</span><span>;</span>\n        <span>this</span><span>.</span>loadFactor <span>=</span> loadFactor<span>;</span>\n        <span>this</span><span>.</span>threshold <span>=</span> <span>tableSizeFor</span><span>(</span>initialCapacity<span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p><strong>传入一个Map，然后把该Map转为hashMap</strong></p>\n<div><pre><code><span>public</span> <span>HashMap</span><span>(</span><span>Map</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>K</span><span>,</span> <span>?</span> <span>extends</span> <span>V</span><span>></span></span> m<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>loadFactor <span>=</span> DEFAULT_LOAD_FACTOR<span>;</span>\n        <span>putMapEntries</span><span>(</span>m<span>,</span> <span>false</span><span>)</span><span>;</span>\n    <span>}</span>\n \n \n    <span>final</span> <span>void</span> <span>putMapEntries</span><span>(</span><span>Map</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>K</span><span>,</span> <span>?</span> <span>extends</span> <span>V</span><span>></span></span> m<span>,</span> <span>boolean</span> evict<span>)</span> <span>{</span>\n        <span>//获取该map的实际长度</span>\n        <span>int</span> s <span>=</span> m<span>.</span><span>size</span><span>(</span><span>)</span><span>;</span>\n        <span>if</span> <span>(</span>s <span>></span> <span>0</span><span>)</span> <span>{</span>\n            <span>//判断table是否初始化，如果没有初始化</span>\n            <span>if</span> <span>(</span>table <span>==</span> <span>null</span><span>)</span> <span>{</span> <span>// pre-size</span>\n                <span>/**求出需要的容量，因为实际使用的长度=容量*0.75得来的，+1是因为小数相除，基本都不会是整数，容量大小不能为小数的，后面转换为int，多余的小数就要被丢掉，所以+1，例如，map实际长度22，22/0.75=29.3,所需要的容量肯定为30，有人会问如果刚刚好除得整数呢，除得整数的话，容量大小多1也没什么影响**/</span>\n                <span>float</span> ft <span>=</span> <span>(</span><span>(</span><span>float</span><span>)</span>s <span>/</span> loadFactor<span>)</span> <span>+</span> <span>1.0F</span><span>;</span>\n                <span>//判断该容量大小是否超出上限。</span>\n                <span>int</span> t <span>=</span> <span>(</span><span>(</span>ft <span>&lt;</span> <span>(</span><span>float</span><span>)</span>MAXIMUM_CAPACITY<span>)</span> <span>?</span>\n                         <span>(</span><span>int</span><span>)</span>ft <span>:</span> MAXIMUM_CAPACITY<span>)</span><span>;</span>\n                <span>/**对临界值进行初始化，tableSizeFor(t)这个方法会返回大于t值的，且离其最近的2次幂，例如t为29，则返回的值是32**/</span>\n                <span>if</span> <span>(</span>t <span>></span> threshold<span>)</span>\n                    threshold <span>=</span> <span>tableSizeFor</span><span>(</span>t<span>)</span><span>;</span>\n            <span>}</span>\n            <span>//如果table已经初始化，则进行扩容操作，resize()就是扩容。</span>\n            <span>else</span> <span>if</span> <span>(</span>s <span>></span> threshold<span>)</span>\n                <span>resize</span><span>(</span><span>)</span><span>;</span>\n            <span>//遍历，把map中的数据转到hashMap中。</span>\n            <span>for</span> <span>(</span><span>Map<span>.</span>Entry</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>K</span><span>,</span> <span>?</span> <span>extends</span> <span>V</span><span>></span></span> e <span>:</span> m<span>.</span><span>entrySet</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n                <span>K</span> key <span>=</span> e<span>.</span><span>getKey</span><span>(</span><span>)</span><span>;</span>\n                <span>V</span> value <span>=</span> e<span>.</span><span>getValue</span><span>(</span><span>)</span><span>;</span>\n                <span>putVal</span><span>(</span><span>hash</span><span>(</span>key<span>)</span><span>,</span> key<span>,</span> value<span>,</span> <span>false</span><span>,</span> evict<span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br></div></div><h3 id=\"put-添加一个键值对-扩容机制\"> put()：添加一个键值对/扩容机制</h3>\n<p>向map中添加值(返回这个key以前的值,如果没有返回null)</p>\n<p><img src=\"./images/Java-Collections/principle_diagram_of_HashMap_put.png\" alt=\"HashMap的put原理图\" /></p>\n<p><strong>计算hash值</strong></p>\n<p>先获取到key的hashCode，然后进行移位再进行异或运算算出要插入的索引，为什么这么复杂，不用想肯定是为了减少hash冲突。如果key为空就返回索引0，也就是说插入到第一个结点。</p>\n<div><pre><code>    <span>static</span> <span>final</span> <span>int</span> <span>hash</span><span>(</span><span>Object</span> key<span>)</span> <span>{</span>\n        <span>int</span> h<span>;</span>\n        <span>return</span> <span>(</span>key <span>==</span> <span>null</span><span>)</span> <span>?</span> <span>0</span> <span>:</span> <span>(</span>h <span>=</span> key<span>.</span><span>hashCode</span><span>(</span><span>)</span><span>)</span> <span>^</span> <span>(</span>h <span>>>></span> <span>16</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><strong>方法源码</strong></p>\n<div><pre><code><span>public</span> <span>V</span> <span>put</span><span>(</span><span>K</span> key<span>,</span> <span>V</span> value<span>)</span> <span>{</span>\n        <span>/**四个参数，第一个hash值，第四个参数表示如果该key存在值，如果为null的话，则插入新的value，最后一个参数，在hashMap中没有用，可以不用管，使用默认的即可**/</span>\n        <span>return</span> <span>putVal</span><span>(</span><span>hash</span><span>(</span>key<span>)</span><span>,</span> key<span>,</span> value<span>,</span> <span>false</span><span>,</span> <span>true</span><span>)</span><span>;</span>\n    <span>}</span>\n \n    <span>final</span> <span>V</span> <span>putVal</span><span>(</span><span>int</span> hash<span>,</span> <span>K</span> key<span>,</span> <span>V</span> value<span>,</span> <span>boolean</span> onlyIfAbsent<span>,</span>\n                   <span>boolean</span> evict<span>)</span> <span>{</span>\n        <span>//tab 哈希数组，p 该哈希桶的首节点，n hashMap的长度，i 计算出的数组下标</span>\n        <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>[</span><span>]</span> tab<span>;</span> <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> p<span>;</span> <span>int</span> n<span>,</span> i<span>;</span>\n        <span>//获取长度并进行扩容，使用的是懒加载，table一开始是没有加载的，等put后才开始加载</span>\n        <span>if</span> <span>(</span><span>(</span>tab <span>=</span> table<span>)</span> <span>==</span> <span>null</span> <span>||</span> <span>(</span>n <span>=</span> tab<span>.</span>length<span>)</span> <span>==</span> <span>0</span><span>)</span>\n            n <span>=</span> <span>(</span>tab <span>=</span> <span>resize</span><span>(</span><span>)</span><span>)</span><span>.</span>length<span>;</span>\n        <span>/**如果计算出的该哈希桶的位置没有值，则把新插入的key-value放到此处，此处就算没有插入成功，也就是发生哈希冲突时也会把哈希桶的首节点赋予p**/</span>\n        <span>if</span> <span>(</span><span>(</span>p <span>=</span> tab<span>[</span>i <span>=</span> <span>(</span>n <span>-</span> <span>1</span><span>)</span> <span>&amp;</span> hash<span>]</span><span>)</span> <span>==</span> <span>null</span><span>)</span>\n            tab<span>[</span>i<span>]</span> <span>=</span> <span>newNode</span><span>(</span>hash<span>,</span> key<span>,</span> value<span>,</span> <span>null</span><span>)</span><span>;</span>\n        <span>//发生哈希冲突的几种情况</span>\n        <span>else</span> <span>{</span>\n            <span>// e 临时节点的作用， k 存放该当前节点的key </span>\n            <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> e<span>;</span> <span>K</span> k<span>;</span>\n            <span>//第一种，插入的key-value的hash值，key都与当前节点的相等，e = p，则表示为首节点</span>\n            <span>if</span> <span>(</span>p<span>.</span>hash <span>==</span> hash <span>&amp;&amp;</span>\n                <span>(</span><span>(</span>k <span>=</span> p<span>.</span>key<span>)</span> <span>==</span> key <span>||</span> <span>(</span>key <span>!=</span> <span>null</span> <span>&amp;&amp;</span> key<span>.</span><span>equals</span><span>(</span>k<span>)</span><span>)</span><span>)</span><span>)</span>\n                e <span>=</span> p<span>;</span>\n            <span>//第二种，hash值不等于首节点，判断该p是否属于红黑树的节点</span>\n            <span>else</span> <span>if</span> <span>(</span>p <span>instanceof</span> <span>TreeNode</span><span>)</span>\n                <span>/**为红黑树的节点，则在红黑树中进行添加，如果该节点已经存在，则返回该节点（不为null），该值很重要，用来判断put操作是否成功，如果添加成功返回null**/</span>\n                e <span>=</span> <span>(</span><span>(</span><span>TreeNode</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>)</span>p<span>)</span><span>.</span><span>putTreeVal</span><span>(</span><span>this</span><span>,</span> tab<span>,</span> hash<span>,</span> key<span>,</span> value<span>)</span><span>;</span>\n            <span>//第三种，hash值不等于首节点，不为红黑树的节点，则为链表的节点</span>\n            <span>else</span> <span>{</span>\n                <span>//遍历该链表</span>\n                <span>for</span> <span>(</span><span>int</span> binCount <span>=</span> <span>0</span><span>;</span> <span>;</span> <span>++</span>binCount<span>)</span> <span>{</span>\n                    <span>//如果找到尾部，则表明添加的key-value没有重复，在尾部进行添加</span>\n                    <span>if</span> <span>(</span><span>(</span>e <span>=</span> p<span>.</span>next<span>)</span> <span>==</span> <span>null</span><span>)</span> <span>{</span>\n                        p<span>.</span>next <span>=</span> <span>newNode</span><span>(</span>hash<span>,</span> key<span>,</span> value<span>,</span> <span>null</span><span>)</span><span>;</span>\n                        <span>//判断是否要转换为红黑树结构</span>\n                        <span>if</span> <span>(</span>binCount <span>>=</span> TREEIFY_THRESHOLD <span>-</span> <span>1</span><span>)</span> \n                            <span>treeifyBin</span><span>(</span>tab<span>,</span> hash<span>)</span><span>;</span>\n                        <span>break</span><span>;</span>\n                    <span>}</span>\n                    <span>//如果链表中有重复的key，e则为当前重复的节点，结束循环</span>\n                    <span>if</span> <span>(</span>e<span>.</span>hash <span>==</span> hash <span>&amp;&amp;</span>\n                        <span>(</span><span>(</span>k <span>=</span> e<span>.</span>key<span>)</span> <span>==</span> key <span>||</span> <span>(</span>key <span>!=</span> <span>null</span> <span>&amp;&amp;</span> key<span>.</span><span>equals</span><span>(</span>k<span>)</span><span>)</span><span>)</span><span>)</span>\n                        <span>break</span><span>;</span>\n                    p <span>=</span> e<span>;</span>\n                <span>}</span>\n            <span>}</span>\n            <span>//有重复的key，则用待插入值进行覆盖，返回旧值。</span>\n            <span>if</span> <span>(</span>e <span>!=</span> <span>null</span><span>)</span> <span>{</span> \n                <span>V</span> oldValue <span>=</span> e<span>.</span>value<span>;</span>\n                <span>if</span> <span>(</span><span>!</span>onlyIfAbsent <span>||</span> oldValue <span>==</span> <span>null</span><span>)</span>\n                    e<span>.</span>value <span>=</span> value<span>;</span>\n                <span>afterNodeAccess</span><span>(</span>e<span>)</span><span>;</span>\n                <span>return</span> oldValue<span>;</span>\n            <span>}</span>\n        <span>}</span>\n        <span>//到了此步骤，则表明待插入的key-value是没有key的重复，因为插入成功e节点的值为null</span>\n        <span>//修改次数+1</span>\n        <span>++</span>modCount<span>;</span>\n        <span>//实际长度+1，判断是否大于临界值，大于则扩容</span>\n        <span>if</span> <span>(</span><span>++</span>size <span>></span> threshold<span>)</span>\n            <span>resize</span><span>(</span><span>)</span><span>;</span>\n        <span>afterNodeInsertion</span><span>(</span>evict<span>)</span><span>;</span>\n        <span>//添加成功</span>\n        <span>return</span> <span>null</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br></div></div><h3 id=\"resize-扩容操作\"> resize()扩容操作</h3>\n<p>参考</p>\n<blockquote>\n<ul>\n<li><a href=\"https://blog.csdn.net/weixin_43689776/article/details/95335330?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522159897939119724836748682%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=159897939119724836748682&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_blog_default-1-95335330.pc_v2_rank_blog_default&amp;utm_term=%E6%89%A9%E5%AE%B9&amp;spm=1018.2118.3001.4187\" target=\"_blank\" rel=\"noopener noreferrer\">HashMap的底层实现原理和为何扩容为2的次数幂及与HashTable的区别。</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/114363420\" target=\"_blank\" rel=\"noopener noreferrer\">HashMap的扩容机制</a></li>\n</ul>\n</blockquote>\n<p>​\t当hashmap中的元素越来越多的时候，碰撞的几率也就越来越高（因为数组的长度是固定的），所以为了提高查询的效率，就要对hashmap的数组进行扩容，数组扩容这个操作也会出现在ArrayList中，所以这是一个通用的操作，很多人对它的性能表示过怀疑，不过想想我们的“均摊”原理，就释然了，而在hashmap数组扩容之后，最消耗性能的点就出现了：原数组中的数据必须重新计算其在新数组中的位置，并放进去，这就是resize。</p>\n<p>​    那么hashmap什么时候进行扩容呢？<strong>当hashmap中的元素个数超过阈值大小threshold</strong>时，就会进行数组扩容**，loadFactor的默认值为0.75，也就是说，默认情况下，数组大小为16，那么当hashmap中元素个数超过<strong>16 × 0.75 = 12</strong>的时候，就把数组的大小扩展为<strong>2 × 16=32</strong>，<strong>即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作</strong>，所以如果我们已经预知hashmap中元素的个数，那么预设元素的个数能够有效的提高hashmap的性能。比如说，我们有1000个元素new HashMap(1000), 但是理论上来讲new HashMap(1024)更合适，不过上面annegu已经说过，即使是1000，hashmap也自动会将其设置为1024。 但是new HashMap(1024)还不是更合适的，因为0**.75 × 1000 &lt; 1000**, 也就是说为了让<strong>0.75 × size &gt; 1000</strong>, 我们必须这样new HashMap(2048)才最合适，既考虑了&amp;的问题，也避免了resize的问题。</p>\n<div><pre><code>    <span>final</span> <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>[</span><span>]</span> <span>resize</span><span>(</span><span>)</span> <span>{</span>\n        <span>//把没插入之前的哈希数组做我诶oldTal</span>\n        <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>[</span><span>]</span> oldTab <span>=</span> table<span>;</span>\n        <span>//old的长度</span>\n        <span>int</span> oldCap <span>=</span> <span>(</span>oldTab <span>==</span> <span>null</span><span>)</span> <span>?</span> <span>0</span> <span>:</span> oldTab<span>.</span>length<span>;</span>\n        <span>//old的临界值</span>\n        <span>int</span> oldThr <span>=</span> threshold<span>;</span>\n        <span>//初始化new的长度和临界值</span>\n        <span>int</span> newCap<span>,</span> newThr <span>=</span> <span>0</span><span>;</span>\n        <span>//oldCap > 0也就是说不是首次初始化，因为hashMap用的是懒加载</span>\n        <span>if</span> <span>(</span>oldCap <span>></span> <span>0</span><span>)</span> <span>{</span>\n            <span>//大于最大值</span>\n            <span>if</span> <span>(</span>oldCap <span>>=</span> MAXIMUM_CAPACITY<span>)</span> <span>{</span>\n                <span>//临界值为整数的最大值</span>\n                threshold <span>=</span> <span>Integer</span><span>.</span>MAX_VALUE<span>;</span>\n                <span>return</span> oldTab<span>;</span>\n            <span>}</span>\n            <span>//标记##，其它情况，扩容两倍，并且扩容后的长度要小于最大值，old长度也要大于16</span>\n            <span>else</span> <span>if</span> <span>(</span><span>(</span>newCap <span>=</span> oldCap <span>&lt;&lt;</span> <span>1</span><span>)</span> <span>&lt;</span> MAXIMUM_CAPACITY <span>&amp;&amp;</span>\n                     oldCap <span>>=</span> DEFAULT_INITIAL_CAPACITY<span>)</span>\n                <span>//临界值也扩容为old的临界值2倍</span>\n                newThr <span>=</span> oldThr <span>&lt;&lt;</span> <span>1</span><span>;</span> \n        <span>}</span>\n        <span>/**如果oldCap&lt;0，但是已经初始化了，像把元素删除完之后的情况，那么它的临界值肯定还存在，        \n           如果是首次初始化，它的临界值则为0\n        **/</span>\n        <span>else</span> <span>if</span> <span>(</span>oldThr <span>></span> <span>0</span><span>)</span> \n            newCap <span>=</span> oldThr<span>;</span>\n        <span>//首次初始化，给与默认的值</span>\n        <span>else</span> <span>{</span>               \n            newCap <span>=</span> DEFAULT_INITIAL_CAPACITY<span>;</span>\n            <span>//临界值等于容量*加载因子</span>\n            newThr <span>=</span> <span>(</span><span>int</span><span>)</span><span>(</span>DEFAULT_LOAD_FACTOR <span>*</span> DEFAULT_INITIAL_CAPACITY<span>)</span><span>;</span>\n        <span>}</span>\n        <span>//此处的if为上面标记##的补充，也就是初始化时容量小于默认值16的，此时newThr没有赋值</span>\n        <span>if</span> <span>(</span>newThr <span>==</span> <span>0</span><span>)</span> <span>{</span>\n            <span>//new的临界值</span>\n            <span>float</span> ft <span>=</span> <span>(</span><span>float</span><span>)</span>newCap <span>*</span> loadFactor<span>;</span>\n            <span>//判断是否new容量是否大于最大值，临界值是否大于最大值</span>\n            newThr <span>=</span> <span>(</span>newCap <span>&lt;</span> MAXIMUM_CAPACITY <span>&amp;&amp;</span> ft <span>&lt;</span> <span>(</span><span>float</span><span>)</span>MAXIMUM_CAPACITY <span>?</span>\n                      <span>(</span><span>int</span><span>)</span>ft <span>:</span> <span>Integer</span><span>.</span>MAX_VALUE<span>)</span><span>;</span>\n        <span>}</span>\n        <span>//把上面各种情况分析出的临界值，在此处真正进行改变，也就是容量和临界值都改变了。</span>\n        threshold <span>=</span> newThr<span>;</span>\n        <span>//表示忽略该警告</span>\n        <span>@SuppressWarnings</span><span>(</span><span>{</span><span>\"rawtypes\"</span><span>,</span><span>\"unchecked\"</span><span>}</span><span>)</span>\n            <span>//初始化</span>\n            <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>[</span><span>]</span> newTab <span>=</span> <span>(</span><span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>[</span><span>]</span><span>)</span><span>new</span> <span>Node</span><span>[</span>newCap<span>]</span><span>;</span>\n        <span>//赋予当前的table</span>\n        table <span>=</span> newTab<span>;</span>\n        <span>//此处自然是把old中的元素，遍历到new中</span>\n        <span>if</span> <span>(</span>oldTab <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n            <span>for</span> <span>(</span><span>int</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> oldCap<span>;</span> <span>++</span>j<span>)</span> <span>{</span>\n                <span>//临时变量</span>\n                <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> e<span>;</span>\n                <span>//当前哈希桶的位置值不为null，也就是数组下标处有值，因为有值表示可能会发生冲突</span>\n                <span>if</span> <span>(</span><span>(</span>e <span>=</span> oldTab<span>[</span>j<span>]</span><span>)</span> <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n                    <span>//把已经赋值之后的变量置位null，当然是为了好回收，释放内存</span>\n                    oldTab<span>[</span>j<span>]</span> <span>=</span> <span>null</span><span>;</span>\n                    <span>//如果下标处的节点没有下一个元素</span>\n                    <span>if</span> <span>(</span>e<span>.</span>next <span>==</span> <span>null</span><span>)</span>\n                        <span>//把该变量的值存入newCap中，e.hash &amp; (newCap - 1)并不等于j</span>\n                        newTab<span>[</span>e<span>.</span>hash <span>&amp;</span> <span>(</span>newCap <span>-</span> <span>1</span><span>)</span><span>]</span> <span>=</span> e<span>;</span>\n                    <span>//该节点为红黑树结构，也就是存在哈希冲突，该哈希桶中有多个元素</span>\n                    <span>else</span> <span>if</span> <span>(</span>e <span>instanceof</span> <span>TreeNode</span><span>)</span>\n                        <span>//把此树进行转移到newCap中</span>\n                        <span>(</span><span>(</span><span>TreeNode</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>)</span>e<span>)</span><span>.</span><span>split</span><span>(</span><span>this</span><span>,</span> newTab<span>,</span> j<span>,</span> oldCap<span>)</span><span>;</span>\n                    <span>else</span> <span>{</span> <span>/**此处表示为链表结构，同样把链表转移到newCap中，就是把链表遍历后，把值转过去，在置位null**/</span>\n                        <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> loHead <span>=</span> <span>null</span><span>,</span> loTail <span>=</span> <span>null</span><span>;</span>\n                        <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> hiHead <span>=</span> <span>null</span><span>,</span> hiTail <span>=</span> <span>null</span><span>;</span>\n                        <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> next<span>;</span>\n                        <span>do</span> <span>{</span>\n                            next <span>=</span> e<span>.</span>next<span>;</span>\n                            <span>if</span> <span>(</span><span>(</span>e<span>.</span>hash <span>&amp;</span> oldCap<span>)</span> <span>==</span> <span>0</span><span>)</span> <span>{</span>\n                                <span>if</span> <span>(</span>loTail <span>==</span> <span>null</span><span>)</span>\n                                    loHead <span>=</span> e<span>;</span>\n                                <span>else</span>\n                                    loTail<span>.</span>next <span>=</span> e<span>;</span>\n                                loTail <span>=</span> e<span>;</span>\n                            <span>}</span>\n                            <span>else</span> <span>{</span>\n                                <span>if</span> <span>(</span>hiTail <span>==</span> <span>null</span><span>)</span>\n                                    hiHead <span>=</span> e<span>;</span>\n                                <span>else</span>\n                                    hiTail<span>.</span>next <span>=</span> e<span>;</span>\n                                hiTail <span>=</span> e<span>;</span>\n                            <span>}</span>\n                        <span>}</span> <span>while</span> <span>(</span><span>(</span>e <span>=</span> next<span>)</span> <span>!=</span> <span>null</span><span>)</span><span>;</span>\n                        <span>if</span> <span>(</span>loTail <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n                            loTail<span>.</span>next <span>=</span> <span>null</span><span>;</span>\n                            newTab<span>[</span>j<span>]</span> <span>=</span> loHead<span>;</span>\n                        <span>}</span>\n                        <span>if</span> <span>(</span>hiTail <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n                            hiTail<span>.</span>next <span>=</span> <span>null</span><span>;</span>\n                            newTab<span>[</span>j <span>+</span> oldCap<span>]</span> <span>=</span> hiHead<span>;</span>\n                        <span>}</span>\n                    <span>}</span>\n                <span>}</span>\n            <span>}</span>\n        <span>}</span>\n        <span>//返回扩容后的hashMap</span>\n        <span>return</span> newTab<span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br></div></div><h3 id=\"hashmap加载因子为啥是0-75\"> HashMap加载因子为啥是0.75</h3>\n<p>::: tips 参考</p>\n<ul>\n<li>https://www.cnblogs.com/aspirant/p/11470928.html</li>\n</ul>\n<p>:::</p>\n<h3 id=\"hashmap-的⻓度为什么是2的幂次方\"> HashMap 的⻓度为什么是2的幂次⽅</h3>\n<p>为了能让 HashMap 存取⾼效，尽量减少碰撞，也就是要尽量把数据分配均匀。我们上⾯也讲到了过 了，Hash 值的范围值-2147483648到2147483647，前后加起来⼤概40亿的映射空间，只要哈希函数映射 得⽐较均匀松散，⼀般应⽤是很难出现碰撞的。但问题是⼀个40亿⻓度的数组，内存是放不下的。所以 这个散列值是不能直接拿来⽤的。⽤之前还要先做对数组的⻓度取模运算，得到的余数才能⽤来要存放 的位置也就是对应的数组下标。这个数组下标的计算⽅法是“ <code>(n - 1) &amp; hash</code> ”。（n代表数组⻓ 度）。这也就解释了 HashMap 的⻓度为什么是2的幂次⽅。</p>\n<p>这个算法应该如何设计呢？</p>\n<p>我们⾸先可能会想到采⽤%取余的操作来实现。但是，重点来了：“取余(%)操作中如果除数是2的幂次则 等价于与其除数减⼀的与(&amp;)操作（也就是说 hash%lengthdehash&amp;(length-1)的前提是 length 是2的 n 次⽅；）。” 并且 采⽤⼆进制位操作 &amp;，相对于%能够提⾼运算效率，这就解释了 HashMap 的⻓度 为什么是2的幂次⽅。</p>\n<h3 id=\"jdk1-8中hashmap如何应对hash冲突\"> JDK1.8中HashMap如何应对hash冲突？</h3>\n<p>参考</p>\n<blockquote>\n<ul>\n<li><a href=\"https://blog.csdn.net/weixin_43689776/article/details/99999126?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param\" target=\"_blank\" rel=\"noopener noreferrer\">JDK1.8中HashMap如何应对hash冲突</a></li>\n</ul>\n</blockquote>\n<h3 id=\"如何降低hash冲突\"> 如何降低hash冲突</h3>\n<p>1、扰动函数算法，促使元素位置分布均匀，减少碰撞几率；</p>\n<p>2、使用final对象，并采用合适的equals方法和hashCode方法；</p>\n<h3 id=\"为什么hashmap线程不安全\"> 为什么HashMap线程不安全</h3>\n<p>参考</p>\n<blockquote>\n<ul>\n<li>https://blog.csdn.net/swpu_ocean/article/details/88917958</li>\n</ul>\n</blockquote>\n<p><strong>总结</strong></p>\n<blockquote>\n<ul>\n<li><strong>在JDK1.7中</strong>：当并发执行扩容操作时会造成环形链和数据丢失的情况。</li>\n<li><strong>在JDK1.8中</strong>：在并发执行put操作时会发生数据覆盖的情况。</li>\n</ul>\n</blockquote>\n<h3 id=\"为什么用红黑树不用avl树\"> 为什么用红黑树不用AVL树</h3>\n<p>参考</p>\n<blockquote>\n<ul>\n<li>https://blog.csdn.net/21aspnet/article/details/88939297</li>\n</ul>\n</blockquote>\n<p>AVL</p>\n<blockquote>\n<p>完全平衡二叉树</p>\n</blockquote>\n<p>最主要的一点是：</p>\n<p>在<code>CurrentHashMap</code>中是加锁了的，实际上是读写锁，如果写冲突就会等待，如果插入时间过长必然等待时间更长，而红黑树相对AVL树他的插入更快！</p>\n<p>红黑树和AVL树都是<strong>最常用的平衡二叉搜索树</strong>，它们的查找、删除、修改都是O(lgn) time</p>\n<p>AVL树和红黑树有几点比较和区别：</p>\n<blockquote>\n<ul>\n<li>AVL树是更加严格的平衡，因此可以提供更快的查找速度，一般读取查找密集型任务，适用AVL树。</li>\n<li>红黑树更适合于插入修改密集型任务。</li>\n<li>通常，AVL树的旋转比红黑树的旋转更加难以平衡和调试。</li>\n</ul>\n</blockquote>\n<p><strong>总结：</strong></p>\n<blockquote>\n<ul>\n<li>AVL以及红黑树是高度平衡的树数据结构。它们非常相似，真正的区别在于在任何添加/删除操作时完成的旋转操作次数。</li>\n<li>两种实现都缩放为a O(lg N)，其中N是叶子的数量，但实际上AVL树在查找密集型任务上更快：利用更好的平衡，树遍历平均更短。另一方面，插入和删除方面，AVL树速度较慢：需要更高的旋转次数才能在修改时正确地重新平衡数据结构。</li>\n<li>在AVL树中，从根到任何叶子的最短路径和最长路径之间的差异最多为1。在红黑树中，差异可以是2倍。</li>\n<li>两个都给O（log n）查找，但平衡AVL树可能需要O（log n）旋转，而红黑树将需要最多两次旋转使其达到平衡（尽管可能需要检查O（log n）节点以确定旋转的位置）。旋转本身是O（1）操作，因为你只是移动指针。</li>\n</ul>\n</blockquote>\n<h2 id=\"_6-map-linkedhashmap\"> 6. Map | LinkedHashMap</h2>\n<p>参考</p>\n<blockquote>\n<ul>\n<li>https://www.imooc.com/article/22931</li>\n</ul>\n</blockquote>\n<h2 id=\"_7-map-concurrenthashmap\"> 7. Map | ConcurrentHashMap</h2>\n<p>参考</p>\n<blockquote>\n<ul>\n<li>https://www.cnblogs.com/chengxiao/p/6842045.html</li>\n<li>https://www.jianshu.com/p/d0b37b927c48</li>\n</ul>\n</blockquote>\n<p>ConcurrentHashMap是Java并发包<code>java.util.concurrent</code>中提供的一个线程安全且高效的HashMap实现，ConcurrentHashMap在并发编程的场景中使用频率非常之高，本文就来分析下<code>ConcurrentHashMap</code>的实现原理，并对其实现原理进行分析（JDK1.7).</p>\n<p>众所周知，哈希表是中非常高效，复杂度为O(1)的数据结构，在Java开发中，我们最常见到最频繁使用的就是HashMap和HashTable，但是在线程竞争激烈的并发场景中使用都不够合理。</p>\n<blockquote>\n<ul>\n<li><strong>HashMap</strong> ：先说HashMap，HashMap是<strong>线程不安全</strong>的，在并发环境下，可能会形成<strong>环状链表</strong>（扩容时可能造成，具体原因自行百度google或查看源码分析），导致get操作时，cpu空转，所以，在并发环境中使用HashMap是非常危险的。</li>\n<li><strong>HashTable</strong> ： HashTable和HashMap的实现原理几乎一样，差别无非是<strong>1.HashTable不允许key和value为null；2.HashTable是线程安全的。<strong>但是HashTable线程安全的策略实现代价却太大了，简单粗暴，get/put所有相关操作都是synchronized的，这相当于给整个哈希表加了一把</strong>大锁</strong>，多线程访问时候，只要有一个线程访问或操作该对象，那其他线程只能阻塞，相当于将所有的操作<strong>串行化</strong>，在竞争激烈的并发场景中性能就会非常差。</li>\n</ul>\n</blockquote>\n<p>HashTable性能差主要是由于所有操作需要竞争同一把锁，而如果容器中有多把锁，每一把锁锁一段数据，这样在多线程访问时不同段的数据时，就不会存在锁竞争了，这样便可以有效地提高并发效率。这就是ConcurrentHashMap所采用的&quot;<strong>分段锁</strong>&quot;思想。</p>\n<p><img src=\"./images/Java-Collections/ConcurrentHashMap_segment_lock.png\" alt=\"ConcurrentHashMap分段锁\" /></p>\n<p>如何实现线程安全</p>\n<p><img src=\"./images/Java-Collections/The_principle_of_ConcurrentHashMap_thread_safety.png\" alt=\"ConcurrentHashMap线程安全的原理\" /></p>\n<h2 id=\"_8-map-区别\"> 8. Map | 区别</h2>\n<h3 id=\"hashmap与hashtable区别\"> HashMap与Hashtable区别</h3>\n<blockquote>\n<ol>\n<li><strong>线程是否安全</strong>： HashMap 是⾮线程安全的，HashTable 是线程安全的；HashTable 内部的⽅法 基本都经过 synchronized 修饰。（如果你要保证线程安全的话就使⽤ ConcurrentHashMap 吧！）；</li>\n<li><strong>效率</strong>： 因为线程安全的问题，HashMap 要⽐ HashTable 效率⾼⼀点。另外，HashTable 基本被 淘汰，不要在代码中使⽤它；</li>\n<li><strong>对Null key 和Null value的⽀持</strong>： HashMap 中，null 可以作为键，这样的键只有⼀个，可以 有⼀个或多个键所对应的值为 null。。但是在 HashTable 中 put 进的键值只要有⼀个 null， 直接抛出 NullPointerException。</li>\n<li><strong>初始容量⼤⼩和每次扩充容量⼤⼩的不同</strong> ： ①创建时如果不指定容量初始值，Hashtable 默认 的初始⼤⼩为11，之后每次扩充，容量变为原来的2n+1。HashMap 默认的初始化⼤⼩为16。之后 每次扩充，容量变为原来的2倍。②创建时如果给定了容量初始值，那么 Hashtable 会直接使⽤ 你给定的⼤⼩，⽽ HashMap 会将其扩充为2的幂次⽅⼤⼩（HashMap 中的 tableSizeFor() ⽅ 法保证，下⾯给出了源代码）。也就是说 HashMap 总是使⽤2的幂作为哈希表的⼤⼩,后⾯会介 绍到为什么是2的幂次⽅。</li>\n<li>底层数据结构： JDK1.8 以后的 HashMap 在解决哈希冲突时有了巨⼤的变化，当链表⻓度⼤于 阈值（默认为8）时，将链表转化为红⿊树，以减少搜索时间。Hashtable 没有这样的机制。</li>\n</ol>\n</blockquote>\n<h3 id=\"concurrenthashmap-和-hashtable-的区别\"> ConcurrentHashMap 和 Hashtable 的区别</h3>\n<p>ConcurrentHashMap 和 Hashtable 的区别主要体现在实现线程安全的⽅式上不同。</p>\n<blockquote>\n<ul>\n<li>底层数据结构： JDK1.7的 ConcurrentHashMap 底层采⽤ 分段的数组+链表 实现，JDK1.8 采⽤ 的数据结构跟HashMap1.8的结构⼀样，数组+链表/红⿊⼆叉树。Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采⽤ 数组+链表 的形式，数组是 HashMap 的主体，链表则是 主要为了解决哈希冲突⽽存在的；</li>\n<li>实现线程安全的⽅式（重要）： ① 在JDK1.7的时候，ConcurrentHashMap（分段锁） 对整个桶 数组进⾏了分割分段(Segment)，每⼀把锁只锁容器其中⼀部分数据，多线程访问容器⾥不同数 据段的数据，就不会存在锁竞争，提⾼并发访问率。 到了 JDK1.8 的时候已经摒弃了Segment的 概念，⽽是直接⽤ Node 数组+链表+红⿊树的数据结构来实现，并发控制使⽤ synchronized 和 CAS 来操作。（JDK1.6以后 对 synchronized锁做了很多优化） 整个看起来就像是优化过且线 程安全的 HashMap，虽然在JDK1.8中还能看到 Segment 的数据结构，但是已经简化了属性，只 是为了兼容旧版本；② Hashtable(同⼀把锁) :使⽤ synchronized 来保证线程安全，效率⾮常 低下。当⼀个线程访问同步⽅法时，其他线程也访问同步⽅法，可能会进⼊阻塞或轮询状态，如 使⽤ put 添加元素，另⼀个线程不能使⽤ put 添加元素，也不能使⽤ get，竞争会越来越激烈 效率越低。</li>\n</ul>\n</blockquote>\n",
      "date_published": "2020-08-23T20:37:41.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": []
    },
    {
      "title": "Java-IO",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/java/Java-IO/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/java/Java-IO/",
      "summary": "Java-IO",
      "content_html": "<h1 id=\"_10\"> 10</h1>\n<p>Java-你好</p>\n",
      "date_published": "2020-11-24T22:10:27.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": []
    },
    {
      "title": "Java-基础面试题",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/java/Java-Interview/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/java/Java-Interview/",
      "summary": "Java-基础面试题",
      "content_html": "<h2 id=\"学习路线\"> 学习路线</h2>\n<p><img src=\"./images/Java-Interview/Java_learning_roadmap.png\" alt=\"Java学习路线图\" /></p>\n<h2 id=\"jdk和jre区别\"> JDK和JRE区别</h2>\n<ul>\n<li>**<u>JDK（Java Development Kit）</u>**是针对Java开发员的产品，是整个Java的核心，包括了Java运行环境JRE、Java工具和Java基础类库。</li>\n<li>**<u>Java Runtime Environment（JRE）</u>**是运行JAVA程序所必须的环境的集合，包含JVM标准实现及Java核心类库。</li>\n<li>**<u>Java Virtual Machine（Java虚拟机JVM）</u>**的缩写，是整个java实现跨平台的最核心的部分，能够运行以Java语言写作的软件程序。</li>\n</ul>\n<p><img src=\"./images/Java-Interview/JDK&JRE&JVM.png\" alt=\"\" /></p>\n<h3 id=\"jdk-java-development-kit\"> JDK（Java Development Kit）</h3>\n<ul>\n<li>JDK中包含JRE，在JDK的安装目录下有一个名为jre的目录，里面有两个文件夹bin和lib，在这里可以认为bin里的就是jvm，lib中则是jvm工作所需要的类库，而jvm和 lib和起来就称为jre。</li>\n<li>JDK是整个JAVA的核心，包括了Java运行环境JRE（Java Runtime Envirnment）、一堆Java工具（javac/java/jdb等）和Java基础的类库（即Java API 包括rt.jar）。</li>\n</ul>\n<p><strong>类型</strong></p>\n<ul>\n<li>SE(J2SE)，standard edition，标准版，是我们通常用的一个版本，从JDK 5.0开始，改名为Java SE。</li>\n<li>EE(J2EE)，enterprise edition，企业版，使用这种JDK开发J2EE应用程序，从JDK 5.0开始，改名为Java EE。</li>\n<li>ME(J2ME)，micro edition，主要用于移动设备、嵌入式设备上的java应用程序，从JDK 5.0开始，改名为Java ME。</li>\n</ul>\n<h3 id=\"jre-java-runtime-environment\"> JRE（Java Runtime Environment）</h3>\n<p>​\t\t是运行基于Java语言编写的程序所不可缺少的运行环境。RE中包含了Java virtual machine（JVM），runtime class libraries和Java application launcher，这些是运行Java程序的必要组件。<strong>但是在运行编译好的程序中包含Servlet时，需要JDK</strong></p>\n<h3 id=\"jvm-java-virtual-machine\"> JVM（Java Virtual Machine）</h3>\n<p>​\t\t就是我们常说的java虚拟机，它是整个java实现跨平台的最核心的部分，所有的java程序会首先被编译为.class的类文件，这种类文件可以在虚拟机上执行。</p>\n<p>也就是说class并不直接与机器的操作系统相对应，而是经过虚拟机间接与操作系统交互，由虚拟机将程序解释给本地系统执行。</p>\n<p>只有JVM还不能成class的执行，因为在解释class的时候JVM需要调用解释所需要的类库lib，而jre包含lib类库。</p>\n<p>JVM屏蔽了与具体操作系统平台相关的信息，使Java程序只需生成在Java虚拟机上运行的目标代码（字节码）,就可以在多种平台上不加修改地运行。JVM在执行字节码时，实际上最终还是把字节码解释成具体平台上的机器指令执行。</p>\n<h2 id=\"重载和重写\"> 重载和重写</h2>\n<h3 id=\"重载-overload\"> 重载(Overload)</h3>\n<ol>\n<li>重载Overload是一个类中多态性的一种表现或者一个类中多个构造器的实现</li>\n<li>重载要求同名方法的参数列表不同(参数类型，参数个数甚至是参数顺序)</li>\n<li>重载的时候，返回值类型可以相同也可以不相同。无法以返回型别作为重载函数的区分标准</li>\n</ol>\n<div><pre><code><span>public</span> <span>class</span> <span>Father</span> <span>{</span>\n\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>// TODO Auto-generated method stub</span>\n        <span>Father</span> s <span>=</span> <span>new</span> <span>Father</span><span>(</span><span>)</span><span>;</span>\n        s<span>.</span><span>sayHello</span><span>(</span><span>)</span><span>;</span>\n        s<span>.</span><span>sayHello</span><span>(</span><span>\"wintershii\"</span><span>)</span><span>;</span>\n\n    <span>}</span>\n\n    <span>public</span> <span>void</span> <span>sayHello</span><span>(</span><span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"Hello\"</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>void</span> <span>sayHello</span><span>(</span><span>String</span> name<span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"Hello\"</span> <span>+</span> <span>\" \"</span> <span>+</span> name<span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h3 id=\"重写-override\"> 重写(Override)</h3>\n<ol>\n<li><strong>发生在父类与子类之间</strong></li>\n<li><strong>方法名，参数列表，返回类型（除过子类中方法的返回类型是父类中返回类型的子类）必须相同</strong></li>\n<li>访问修饰符的限制一定要<strong>大于</strong>被重写方法的访问修饰符（public&gt;protected&gt;default&gt;private)</li>\n<li>重写方法一定不能抛出新的检查异常或者比被重写方法申明更加宽泛的检查型异常</li>\n</ol>\n<div><pre><code><span>public</span> <span>class</span> <span>Father</span> <span>{</span>\n\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>// TODO Auto-generated method stub</span>\n        <span>Son</span> s <span>=</span> <span>new</span> <span>Son</span><span>(</span><span>)</span><span>;</span>\n        s<span>.</span><span>sayHello</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>void</span> <span>sayHello</span><span>(</span><span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"Hello\"</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n<span>class</span> <span>Son</span> <span>extends</span> <span>Father</span><span>{</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>sayHello</span><span>(</span><span>)</span> <span>{</span>\n        <span>// TODO Auto-generated method stub</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"hello by \"</span><span>)</span><span>;</span>\n    <span>}</span>\n\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><h3 id=\"重载-overload-和重写-override-的区别\"> 重载（Overload）和重写（Override）的区别</h3>\n<p>​\t\t方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的参数列表，有兼容的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。重载对返回类型没有特殊的要求，不能根据返回类型进行区分。</p>\n<h3 id=\"构造器constructor是否可被override-重写\"> 构造器Constructor是否可被Override(重写)</h3>\n<p>​\t\t构造器Constructor不能被继承，因此不能被<strong>重写(Override)</strong>，但是可以被<strong>重载（Overload）</strong>。如果父类自定义了有参构造函数，则子类无论定义构造函数与否，定义有参构造函数与否，都会报错，正确的做法是在子类的构造方法中添上super（参数），以表明子类构造之前先构造父类，而这句话必须放在第一句，否则报&quot;Constructor call must be the first statement in a constructor&quot;的错误。</p>\n<h2 id=\"类的加载顺序\"> 类的加载顺序</h2>\n<ol>\n<li>父类的静态代码块/初始化静态变量（两者优先级相同）</li>\n<li>执行子类的静态代码/初始化静态变量（两者优先级相同，谁写在前面谁先执行）</li>\n<li>初始化父类成员变量/执行代码块{}（两者优先级相同），父类的构造器</li>\n<li>子类的成员变量/代码块，最后子类的构造器。</li>\n</ol>\n<p>例如：</p>\n<div><pre><code><span>public</span> <span>class</span> <span>Test</span> <span>{</span>\n    <span>Person</span> person <span>=</span> <span>new</span> <span>Person</span><span>(</span><span>\"Test\"</span><span>)</span><span>;</span>\n    <span>static</span><span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"test static\"</span><span>)</span><span>;</span>\n    <span>}</span>\n     \n    <span>public</span> <span>Test</span><span>(</span><span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"test constructor\"</span><span>)</span><span>;</span>\n    <span>}</span>\n     \n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>new</span> <span>MyClass</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n \n<span>class</span> <span>Person</span><span>{</span>\n    <span>static</span><span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"person static\"</span><span>)</span><span>;</span>\n    <span>}</span>\n    <span>public</span> <span>Person</span><span>(</span><span>String</span> str<span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"person \"</span><span>+</span>str<span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n \n \n<span>class</span> <span>MyClass</span> <span>extends</span> <span>Test</span> <span>{</span>\n    <span>Person</span> person <span>=</span> <span>new</span> <span>Person</span><span>(</span><span>\"MyClass\"</span><span>)</span><span>;</span>\n    <span>static</span><span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"myclass static\"</span><span>)</span><span>;</span>\n    <span>}</span>\n     \n    <span>public</span> <span>MyClass</span><span>(</span><span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"myclass constructor\"</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br></div></div><p>结果：</p>\n<blockquote>\n<ul>\n<li>test static</li>\n<li>myclass static</li>\n<li>person static</li>\n<li>person Test</li>\n<li>test constructor</li>\n<li>person MyClass</li>\n<li>myclass constructor</li>\n</ul>\n</blockquote>\n<p>顺序解析：</p>\n<blockquote>\n<ul>\n<li>首先加载Test类，因此会执行Test类中的static块。</li>\n<li>接着执行new MyClass()，而MyClass类还没有被加载，因此需要加载MyClass类。在加载MyClass类的时候，发现MyClass类继承自Test类，但是由于Test类已经被加载了，所以只需要加载MyClass类，那么就会执行MyClass类的中的static块。</li>\n<li>在加载完之后，就通过构造器来生成对象。而在生成对象的时候，必须先初始化父类的成员变量，因此会执行Test中的Person person = new Person()，而Person类还没有被加载过，因此会先加载Person类并执行Person类中的static块，</li>\n<li>接着执行父类的构造器，完成了父类的初始化，然后就来初始化自身了，因此会接着执行MyClass中的Person person = new Person()，最后执行MyClass的构造器。</li>\n</ul>\n</blockquote>\n<h2 id=\"三大特性封装继承多态\"> 三大特性封装继承多态</h2>\n<p><img src=\"./images/Java-Interview/Encapsulation_inheritance_polymorphism.png\" alt=\"封装继承多态\" /></p>\n<h3 id=\"封装\"> 封装</h3>\n<p>​\t\t封装（Encapsulation）是面向对象方法的重要原则，就是把对象的属性和操作（或服务）结合为一个独立的整体，并尽可能隐藏对象的内部实现细节。实体类那些属性就是被封装</p>\n<ul>\n<li>将类的某些信息隐藏在类的内部，不允许外部程序进行直接的访问调用。</li>\n<li>通过该类提供的方法来实现对隐藏信息的操作和访问。</li>\n<li>隐藏对象的信息。</li>\n<li>留出访问的对外接口。</li>\n</ul>\n<h3 id=\"继承\"> 继承</h3>\n<p>​\t\t继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。当然，如果在父类中拥有私有属性(<code>private</code>修饰)，<strong>则子类是不能被继承的。</strong></p>\n<p>只支持单继承，即一个子类只允许有一个父类，但是可以实现多级继承，及子类拥有唯一的父类，而父类还可以再继承。</p>\n<ul>\n<li>子类可以拥有父类的属性和方法。</li>\n<li>子类可以拥有自己的属性和方法。</li>\n<li>子类可以重写覆盖父类的方法。</li>\n</ul>\n<h4 id=\"使用\"> 使用</h4>\n<p>在父子类关系继承中，<strong>如果成员变量重名</strong>，则创建子类对象时，访问有两种方式。</p>\n<ul>\n<li>\n<p>直接通过子类对象访问成员变量</p>\n<p>等号左边是谁，就优先使用谁，如果没有就向上找。</p>\n</li>\n<li>\n<p>间接通过成员方法访问成员变量</p>\n<p>该方法属于谁，谁就优先使用，如果没有就向上找。</p>\n</li>\n</ul>\n<div><pre><code><span>public</span> <span>class</span> FU <span>{</span>\n    <span>int</span> numFU <span>=</span> <span>10</span><span>;</span>\n    <span>int</span> num <span>=</span> <span>100</span><span>;</span>\n    <span>public</span> <span>void</span> <span>method</span><span>(</span><span>)</span><span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"父类成员变量：\"</span><span>+</span>numFU<span>)</span><span>;</span>\n    <span>}</span>\n    <span>public</span> <span>void</span> <span>methodFU</span><span>(</span><span>)</span><span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"父类成员方法!\"</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n<span>public</span> <span>class</span> <span>Zi</span> <span>extends</span> FU<span>{</span>\n    <span>int</span> numZi <span>=</span> <span>20</span><span>;</span>\n    <span>int</span> num <span>=</span> <span>200</span><span>;</span>\n    <span>public</span> <span>void</span> <span>method</span><span>(</span><span>)</span><span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"父类成员变量：\"</span><span>+</span>numFU<span>)</span><span>;</span>\n    <span>}</span>\n    <span>public</span> <span>void</span> <span>methodZi</span><span>(</span><span>)</span><span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"子类方法！\"</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n<span>public</span> <span>class</span> <span>ExtendDemo</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>FU</span> fu <span>=</span> <span>new</span> <span>FU</span><span>(</span><span>)</span><span>;</span>\n        <span>// 父类的实体对象只能调用父类的成员变量</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"父类：\"</span> <span>+</span> fu<span>.</span>numFU<span>)</span><span>;</span>   <span>// 结果：10</span>\n        \n        <span>Zi</span> zi <span>=</span> <span>new</span> <span>Zi</span><span>(</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"调用父类：\"</span> <span>+</span> zi<span>.</span>numFU<span>)</span><span>;</span> <span>// 结果：10</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"子类：\"</span> <span>+</span> zi<span>.</span>numZi<span>)</span><span>;</span>   <span>// 结果：20</span>\n\n        <span>/** 输出结果为200，证明在重名情况下，如果子类中存在则优先使用，\n         *  如果不存在则去父类查找，但如果父类也没有那么编译期就会报错。\n         */</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>zi<span>.</span>num<span>)</span><span>;</span> <span>// 结果：200</span>\n        <span>/**\n         * 通过成员方法调用成员变量\n         */</span>\n        zi<span>.</span><span>method</span><span>(</span><span>)</span><span>;</span>    <span>// 结果：10</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br></div></div><h3 id=\"多态\"> 多态</h3>\n<p>参考</p>\n<blockquote>\n<ul>\n<li>https://blog.csdn.net/qq_31655965/article/details/54746235</li>\n</ul>\n</blockquote>\n<p>指允许不同类的对象对同一消息做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式。动态绑定（dynamic binding），是指在执行期间判断所引用对象的实际类型，根据其实际的类型调用其相应的方法。</p>\n<p><strong>实现方式</strong></p>\n<ul>\n<li>接口多态性。</li>\n<li>继承多态性。</li>\n<li>通过抽象类实现的多态性。</li>\n</ul>\n<h4 id=\"举例\"> 举例</h4>\n<p>多态，简而言之就是同一个行为具有多个不同表现形式或形态的能力。比如说，有一杯水，我不知道它是温的、冰的还是烫的，但是我一摸我就知道了。我摸水杯这个动作，对于不同温度的水，就会得到不同的结果。这就是多态。</p>\n<div><pre><code><span>public</span> <span>class</span> <span>Water</span> <span>{</span>\n    <span>public</span> <span>void</span> <span>showTem</span><span>(</span><span>)</span><span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"我的温度是: 0度\"</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n<span>public</span> <span>class</span> <span>IceWater</span> <span>extends</span> <span>Water</span> <span>{</span>\n    <span>public</span> <span>void</span> <span>showTem</span><span>(</span><span>)</span><span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"我的温度是: 0度\"</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n<span>public</span> <span>class</span> <span>WarmWater</span> <span>extends</span> <span>Water</span> <span>{</span>\n    <span>public</span> <span>void</span> <span>showTem</span><span>(</span><span>)</span><span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"我的温度是: 40度\"</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n<span>public</span> <span>class</span> <span>HotWater</span> <span>extends</span> <span>Water</span> <span>{</span>\n    <span>public</span> <span>void</span> <span>showTem</span><span>(</span><span>)</span><span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"我的温度是: 100度\"</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n<span>public</span> <span>class</span> <span>TestWater</span><span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>Water</span> w <span>=</span> <span>new</span> <span>WarmWater</span><span>(</span><span>)</span><span>;</span>\n        w<span>.</span><span>showTem</span><span>(</span><span>)</span><span>;</span>\n\n        w <span>=</span> <span>new</span> <span>IceWater</span><span>(</span><span>)</span><span>;</span>\n        w<span>.</span><span>showTem</span><span>(</span><span>)</span><span>;</span>\n\n        w <span>=</span> <span>new</span> <span>HotWater</span><span>(</span><span>)</span><span>;</span>\n        w<span>.</span><span>showTem</span><span>(</span><span>)</span><span>;</span>\n\n    <span>}</span>\n<span>}</span>\n\n<span>//结果:</span>\n<span>//我的温度是: 40度</span>\n<span>//我的温度是: 0度</span>\n<span>//我的温度是: 100度</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br></div></div><p>这里的方法<code>showTem()</code>就相当于你去摸水杯。我们定义的water类型的引用变量w就相当于水杯，你在水杯里放了什么温度的水，那么我摸出来的感觉就是什么。就像代码中的那样，放置不同温度的水，得到的温度也就不同，但水杯是同一个。</p>\n<h4 id=\"分类\"> 分类</h4>\n<ul>\n<li>\n<p><strong>重写式多态</strong>：也叫编译时多态。也就是说这种多态再编译时已经确定好了。重载大家都知道，方法名相同而参数列表不同的一组方法就是重载。在调用这种重载的方法时，通过传入不同的参数最后得到不同的结果。</p>\n</li>\n<li>\n<p><strong>重载式多态</strong>：也叫运行时多态。这种多态通过动态绑定（dynamic binding）技术来实现，是指在执行期间判断所引用对象的实际类型，根据其实际的类型调用其相应的方法。也就是说，只有程序运行起来，你才知道调用的是哪个子类的方法。\n这种多态通过<code>函数的重写</code>以及<code>向上转型</code>来实现，我们上面代码中的例子就是一个完整的重写式多态。我们接下来讲的所有多态都是重写式多态，因为它才是面向对象编程中真正的多态。</p>\n</li>\n</ul>\n<h4 id=\"条件\"> 条件</h4>\n<ul>\n<li><strong>继承</strong>：在多态中必须存在有继承关系的子类和父类。</li>\n<li><strong>重写</strong>：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。</li>\n<li><strong>向上转型</strong>：在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法。</li>\n</ul>\n<h3 id=\"向上转型\"> 向上转型</h3>\n<p>参考</p>\n<blockquote>\n<ul>\n<li>https://blog.csdn.net/qq_31655965/article/details/54746235</li>\n</ul>\n</blockquote>\n<p><img src=\"./images/Java-Interview/Upward_transition.png\" alt=\"向上转型\" /></p>\n<div><pre><code><span>public</span> <span>class</span> <span>Animal</span> <span>{</span>\n    <span>public</span> <span>void</span> <span>eat</span><span>(</span><span>)</span><span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"animal eatting...\"</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n<span>public</span> <span>class</span> <span>Cat</span> <span>extends</span> <span>Animal</span><span>{</span>\n\n    <span>public</span> <span>void</span> <span>eat</span><span>(</span><span>)</span><span>{</span>\n\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"我吃鱼\"</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n<span>public</span> <span>class</span> <span>Dog</span> <span>extends</span> <span>Animal</span><span>{</span>\n\n    <span>public</span> <span>void</span> <span>eat</span><span>(</span><span>)</span><span>{</span>\n\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"我吃骨头\"</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span><span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"我会跑\"</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n<span>public</span> <span>class</span> <span>Main</span> <span>{</span>\n\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n\n        <span>Animal</span> animal <span>=</span> <span>new</span> <span>Cat</span><span>(</span><span>)</span><span>;</span> <span>//向上转型</span>\n        animal<span>.</span><span>eat</span><span>(</span><span>)</span><span>;</span>\n\n        animal <span>=</span> <span>new</span> <span>Dog</span><span>(</span><span>)</span><span>;</span>\n        animal<span>.</span><span>eat</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n\n<span>}</span>\n\n<span>//结果:</span>\n<span>//我吃鱼</span>\n<span>//我吃骨头</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br></div></div><p><strong>注意事项</strong></p>\n<ul>\n<li>向上转型时，子类单独定义的方法会丢失。比如上面<code>Dog</code>类中定义的<code>run</code>方法，当<code>animal</code>引用指向<code>Dog</code>类实例时是访问不到<code>run</code>方法的，<code>animal.run()</code>会报错。</li>\n<li>子类引用不能指向父类对象。<code>Cat c = (Cat)new Animal()</code>这样是不行的。</li>\n</ul>\n<p><strong>好处</strong></p>\n<ul>\n<li>减少重复代码，使代码变得简洁。</li>\n<li>提高系统扩展性。</li>\n</ul>\n<p>坏处</p>\n<ul>\n<li>无法使用子类特定的方法</li>\n</ul>\n<p>使用场景</p>\n<ul>\n<li>不需要面对子类型，通过提高扩展性，或者使用父类的功能即可完成操作，就是使用向上转型。</li>\n</ul>\n<p>比如我现在有很多种类的动物，要喂它们吃东西。如果不用向上转型，那我需要像下面这样写</p>\n<div><pre><code><span>public</span> <span>void</span> <span>eat</span><span>(</span><span>Cat</span> c<span>)</span><span>{</span>\n    c<span>.</span><span>eat</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n\n<span>public</span> <span>void</span> <span>eat</span><span>(</span><span>Dog</span> d<span>)</span><span>{</span>\n    d<span>.</span><span>eat</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n<span>//......</span>\n\n<span>eat</span><span>(</span><span>new</span> <span>Cat</span><span>(</span><span>)</span><span>)</span><span>;</span>\n<span>eat</span><span>(</span><span>new</span> <span>Cat</span><span>(</span><span>)</span><span>)</span><span>;</span>\n<span>eat</span><span>(</span><span>new</span> <span>Dog</span><span>(</span><span>)</span><span>)</span><span>;</span>\n<span>//......</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><blockquote>\n<p>此时每增加一种动物就要多写一个方法来接收不同的参数</p>\n</blockquote>\n<p>如果使用向上转型</p>\n<div><pre><code><span>public</span> <span>void</span> <span>eat</span><span>(</span><span>Animal</span> a<span>)</span><span>{</span>\n    a<span>.</span><span>eat</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n\n<span>eat</span><span>(</span><span>new</span> <span>Cat</span><span>(</span><span>)</span><span>)</span><span>;</span>\n<span>eat</span><span>(</span><span>new</span> <span>Cat</span><span>(</span><span>)</span><span>)</span><span>;</span>\n<span>eat</span><span>(</span><span>new</span> <span>Dog</span><span>(</span><span>)</span><span>)</span><span>;</span>\n<span>//.....</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><blockquote>\n<p>因为其他动物类是Animal的子类，可以接收，就像<code>double</code>类型可以接收<code>int</code>，但<code>int</code>类型接收<code>double</code>就会精度缺失。而且这个时候，如果我又有一种新的动物加进来，我只需要实现它自己的类，让他继承Animal就可以了，而不需要为它单独写一个eat方法</p>\n</blockquote>\n<p><strong>经典案例</strong></p>\n<div><pre><code><span>class</span> <span>A</span> <span>{</span>\n    <span>public</span> <span>String</span> <span>show</span><span>(</span><span>D</span> obj<span>)</span> <span>{</span>\n        <span>return</span> <span>(</span><span>\"A and D\"</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>String</span> <span>show</span><span>(</span><span>A</span> obj<span>)</span> <span>{</span>\n        <span>return</span> <span>(</span><span>\"A and A\"</span><span>)</span><span>;</span>\n    <span>}</span>\n\n<span>}</span>\n\n<span>class</span> <span>B</span> <span>extends</span> <span>A</span><span>{</span>\n  <span>//父类没有此方法，虽然方法名字一样，但是由于参数不同不是重写</span>\n    <span>public</span> <span>String</span> <span>show</span><span>(</span><span>B</span> obj<span>)</span><span>{</span>\n        <span>return</span> <span>(</span><span>\"B and B\"</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>String</span> <span>show</span><span>(</span><span>A</span> obj<span>)</span><span>{</span>\n        <span>return</span> <span>(</span><span>\"B and A\"</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n<span>class</span> <span>C</span> <span>extends</span> <span>B</span><span>{</span>\n\n<span>}</span>\n\n<span>class</span> <span>D</span> <span>extends</span> <span>B</span><span>{</span>\n\n<span>}</span>\n\n<span>public</span> <span>class</span> <span>Demo</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>A</span> a1 <span>=</span> <span>new</span> <span>A</span><span>(</span><span>)</span><span>;</span>\n        <span>A</span> a2 <span>=</span> <span>new</span> <span>B</span><span>(</span><span>)</span><span>;</span>\n        <span>B</span> b <span>=</span> <span>new</span> <span>B</span><span>(</span><span>)</span><span>;</span>\n        <span>C</span> c <span>=</span> <span>new</span> <span>C</span><span>(</span><span>)</span><span>;</span>\n        <span>D</span> d <span>=</span> <span>new</span> <span>D</span><span>(</span><span>)</span><span>;</span>\n\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"1--\"</span> <span>+</span> a1<span>.</span><span>show</span><span>(</span>b<span>)</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"2--\"</span> <span>+</span> a1<span>.</span><span>show</span><span>(</span>c<span>)</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"3--\"</span> <span>+</span> a1<span>.</span><span>show</span><span>(</span>d<span>)</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"4--\"</span> <span>+</span> a2<span>.</span><span>show</span><span>(</span>b<span>)</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"5--\"</span> <span>+</span> a2<span>.</span><span>show</span><span>(</span>c<span>)</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"6--\"</span> <span>+</span> a2<span>.</span><span>show</span><span>(</span>d<span>)</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"7--\"</span> <span>+</span> b<span>.</span><span>show</span><span>(</span>b<span>)</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"8--\"</span> <span>+</span> b<span>.</span><span>show</span><span>(</span>c<span>)</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"9--\"</span> <span>+</span> b<span>.</span><span>show</span><span>(</span>d<span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n<span>//结果：</span>\n<span>//1--A and A</span>\n<span>//2--A and A</span>\n<span>//3--A and D</span>\n<span>//4--B and A</span>\n<span>//5--B and A</span>\n<span>//6--A and D</span>\n<span>//7--B and B</span>\n<span>//8--B and B</span>\n<span>//9--A and D</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br></div></div><p>当父类对象引用变量引用子类对象时，被引用对象的类型决定了调用谁的成员方法，引用变量类型决定可调用的方法。<strong>如果子类中没有覆盖该方法，那么会去父类中寻找</strong>。</p>\n<blockquote>\n<p>继承链中对象方法的调用的优先级：this.show(O)、super.show(O)、this.show((super)O)、super.show((super)O)。</p>\n<p>事实上，子类继承了父类的方法，所以所谓super.show(O)时调用的是在子类中继承下来的方法</p>\n</blockquote>\n<p>解析第四个</p>\n<blockquote>\n<p>a2为指向B对象的A类的引用类型，当调用<code>show(B obj)</code>时，会首先去父类找是否有此方法，如果没有那么即使子类有此方法但不会去调用(超出范围)，因为引用类型决定了能调用的方法(即使不是调用自己类的方法)，所以B类中的<code>show(B obj)</code>没有被调用(如果有就会调用子类的<code>show(B obj)</code>)。这时候按照顺序会调用<code>this.show((super)O)</code>,参数为能向上转型的类型，可以发现A类中有<code>show(A obj)</code>，那么就去子类中看是否有此方法，发现有那么调用子类的<code>show(A obj)</code>（如果没有就直接调用父类A类的此方法）。所以最后<code>a2.show(b)</code>调用的是子类B类方法<code>show(A obj)</code>，结果返回<code>&quot;B and A&quot;</code></p>\n</blockquote>\n<p>解析第九个</p>\n<blockquote>\n<p>虽然b的引用类型和指向对象都是B，但是在调用<code>b.show(d)</code>是我们以为会调用B类中的<code>show(B obj)</code>方法，但由于B继承下来A类中<code>show(D obj)</code>方法，相当于B类中有此方法，所以会调用B类中<code>show(D obj)</code>。所以结果为<code>&quot;A and D&quot;</code></p>\n</blockquote>\n<h3 id=\"向下转型\"> 向下转型</h3>\n<p><img src=\"./images/Java-Interview/Upward_transition.png\" alt=\"\" /></p>\n<p>好处</p>\n<ul>\n<li>不仅能继承父类的方法，还可以使用子类型的特有功能</li>\n</ul>\n<p>坏处</p>\n<ul>\n<li>面对具体的子类型，向下转型具有风险。即容易发生<code>ClassCastException</code>，只要转换类型和对象不匹配就会发生。解决方法：使用关键字<code>instanceof</code>。</li>\n</ul>\n<div><pre><code><span>//还是上面的animal和cat dog</span>\n<span>Animal</span> a <span>=</span> <span>new</span> <span>Cat</span><span>(</span><span>)</span><span>;</span>\n<span>Cat</span> c <span>=</span> <span>(</span><span>(</span><span>Cat</span><span>)</span> a<span>)</span><span>;</span>\nc<span>.</span><span>eat</span><span>(</span><span>)</span><span>;</span>\n<span>//输出  我吃鱼</span>\n<span>Dog</span> d <span>=</span> <span>(</span><span>(</span><span>Dog</span><span>)</span> a<span>)</span><span>;</span>\nd<span>.</span><span>eat</span><span>(</span><span>)</span><span>;</span>\n<span>// 报错 ： java.lang.ClassCastException：com.chengfan.animal.Cat cannot be cast to com.chengfan.animal.Dog</span>\n<span>Animal</span> a1 <span>=</span> <span>new</span> <span>Animal</span><span>(</span><span>)</span><span>;</span>\n<span>Cat</span> c1 <span>=</span> <span>(</span><span>(</span><span>Cat</span><span>)</span> a1<span>)</span><span>;</span>\nc1<span>.</span><span>eat</span><span>(</span><span>)</span><span>;</span>\n<span>// 报错 ： java.lang.ClassCastException：com.chengfan.animal.Animal cannot be cast to com.chengfan.animal.Cat</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><blockquote>\n<ul>\n<li>向下转型的前提是父类对象指向的是子类对象（也就是说，在向下转型之前，它得先向上转型）</li>\n<li>向下转型只能转型为本类对象（猫是不能变成狗的）。</li>\n</ul>\n</blockquote>\n<p>为什么要向下转型</p>\n<div><pre><code><span>public</span> <span>void</span> <span>eat</span><span>(</span><span>Animal</span> a<span>)</span><span>{</span>\n    <span>if</span><span>(</span>a <span>instanceof</span> <span>Dog</span><span>)</span><span>{</span>  \n        <span>Dog</span> d <span>=</span> <span>(</span><span>Dog</span><span>)</span>a<span>;</span>\n        d<span>.</span><span>eat</span><span>(</span><span>)</span><span>;</span>\n        d<span>.</span><span>run</span><span>(</span><span>)</span><span>;</span><span>//狗有一个跑的方法      </span>\n    <span>}</span> \n    <span>if</span><span>(</span>a <span>instanceof</span> <span>Cat</span><span>)</span><span>{</span>  \n        <span>Cat</span> c <span>=</span> <span>(</span><span>Cat</span><span>)</span>a<span>;</span>\n        c<span>.</span><span>eat</span><span>(</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"我也想跑，但是不会\"</span><span>)</span><span>;</span> <span>//猫会抱怨    </span>\n    <span>}</span> \n    a<span>.</span><span>eat</span><span>(</span><span>)</span><span>;</span><span>//其他动物只会吃</span>\n<span>}</span>\n\n<span>eat</span><span>(</span><span>new</span> <span>Cat</span><span>(</span><span>)</span><span>)</span><span>;</span>\n<span>eat</span><span>(</span><span>new</span> <span>Cat</span><span>(</span><span>)</span><span>)</span><span>;</span>\n<span>eat</span><span>(</span><span>new</span> <span>Dog</span><span>(</span><span>)</span><span>)</span><span>;</span>\n<span>//.....</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h3 id=\"里氏替换原则\"> 里氏替换原则</h3>\n<div><p>参考</p>\n<ul>\n<li>https://blog.csdn.net/sunpeiv/article/details/107424253</li>\n<li>https://www.douban.com/note/363404356/</li>\n</ul>\n</div>\n<h4 id=\"里氏替换原则的定义\"> 里氏替换原则的定义</h4>\n<div><p>里氏替换原则的定义</p>\n<ul>\n<li>里氏替换原则通俗的来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。</li>\n<li>里氏代换原则告诉我们，在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常（<code>向下转型</code>），反过来则不成立（<code>向上转型</code>），如果一个软件实体使用的是一个子类对象的话，那么它不一定能够使用基类对象。</li>\n<li>里氏代换原则是实现<code>开闭原则</code>的重要方式之一，由于使用基类对象的地方都可以使用子类对象，因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。</li>\n</ul>\n</div>\n<h4 id=\"里氏替换原则包含的含义\"> 里氏替换原则包含的含义</h4>\n<p><strong>1、子类可以实现父类的抽象方法，但是不能覆盖父类的非抽象方法</strong></p>\n<div><p>Info</p>\n<p>在我们做系统设计时，经常会设计接口或抽象类，然后由子类来实现抽象方法，这里使用的其实就是里氏替换原则。子类可以实现父类的抽象方法很好理解，事实上，子类也必须完全实现父类的抽象方法，哪怕写一个空方法，否则会编译报错。</p>\n<p>里氏替换原则的关键点在于不能覆盖父类的非抽象方法。父类中凡是已经实现好的方法，实际上是在设定一系列的规范和契约，虽然它不强制要求所有的子类必须遵从这些规范，但是如果子类对这些非抽象方法任意修改，就会对整个继承体系造成破坏。而里氏替换原则就是表达了这一层含义。</p>\n</div>\n<p><strong>2、子类中可以增加自己特有的方法</strong></p>\n<div><p>Info</p>\n<p>在继承父类属性和方法的同时，每个子类也都可以有自己的个性，在父类的基础上扩展自己的功能。前面其实已经提到，当功能扩展时，子类尽量不要重写父类的方法，而是另写一个方法</p>\n</div>\n<p><strong>3、当子类覆盖或实现父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松</strong></p>\n<h2 id=\"this-super-final-static关键字\"> this | super | final | static关键字</h2>\n<h3 id=\"this\"> this</h3>\n<ul>\n<li>本类成员方法中，访问<strong>本类</strong>的成员变量。</li>\n<li>本类成员方法中，访问<strong>本类</strong>的另一个成员方法。</li>\n<li>本类的构造方法中，访问<strong>本类</strong>的另一个构造方法。</li>\n</ul>\n<p><img src=\"./images/Java-Interview/this_keyword.png\" alt=\"this关键字\" /></p>\n<h3 id=\"super\"> super</h3>\n<ul>\n<li>子类的成员方法中，访问<strong>父类</strong>的成员变量。</li>\n<li>子类的成员方法中，访问<strong>父类</strong>的成员方法。</li>\n<li>子类的构造方法中，访问<strong>父类</strong>的构造方法。</li>\n</ul>\n<p><img src=\"./images/Java-Interview/super_keyword.png\" alt=\"super关键字\" /></p>\n<p><strong>注意</strong></p>\n<ul>\n<li>this关键字同super一样，必须在构造方法的第一个语句，且是唯一的。</li>\n<li>this与super不能同时存在。</li>\n</ul>\n<h3 id=\"final\"> final</h3>\n<p><img src=\"./images/Java-Interview/final_keyword.png\" alt=\"final关键字\" /></p>\n<p><img src=\"./images/Java-Interview/final_keyword_2.png\" alt=\"final关键字2\" /></p>\n<h3 id=\"static\"> static</h3>\n<p><img src=\"./images/Java-Interview/static_keyword.png\" alt=\"static关键字\" /></p>\n<h3 id=\"java中是否可以覆盖-override-一个private或者是static的方法\"> Java中是否可以覆盖(override)一个<code>private</code>或者是<code>static</code>的方法？</h3>\n<p>java中也不可以覆盖private的方法，因为private修饰的变量和方法只能在当前类中使用，如果是其他的类继承当前类是不能访问到private变量或方法的，当然也不能覆盖。</p>\n<h3 id=\"是否可以在static环境中访问非static变量\"> 是否可以在<code>static</code>环境中访问<code>非static</code>变量？</h3>\n<p>static变量在Java中是属于类的，它在所有的实例中的值是一样的。当类被Java虚拟机载入的时候，会对static变量进行初始化。如果你的代码尝试不用实例来访问非static的变量，编译器会报错，因为这些变量还没有被创建出来，还没有跟任何实例关联上。</p>\n<h2 id=\"string-stringbuffer-和-stringbuilder-的区别是什么-string-为什么是不可变的\"> String StringBuffer 和 StringBuilder 的区别是什么? String 为什么是不可变的?</h2>\n<h3 id=\"java-string-类-string字符串常量\"> Java String 类：String字符串常量</h3>\n<p>需要注意的是，String的值是不可变的，这就导致每次对String的操作都会生成<strong>新的String对象</strong>，这样不仅效率低下，而且大量浪费有限的内存空间。我们来看一下这张对String操作时内存变化的图：</p>\n<p><img src=\"./images/Java-Interview/String_immutable.png\" alt=\"String不可变\" /></p>\n<p>我们可以看到，初始String值为“hello”，然后在这个字符串后面加上新的字符串“world”，这个过程是需要重新在栈堆内存中开辟内存空间的，最终得到了“hello world”字符串也相应的需要开辟内存空间，<strong>这样短短的两个字符串，却需要开辟三次内存空间</strong>，不得不说这是对内存空间的<strong>极大浪费</strong>。为了应对经常性的字符串相关的操作，就需要使用Java提供的其他两个操作字符串的类——StringBuffer类和StringBuild类来对此种变化字符串进行处理。</p>\n<h3 id=\"stringbuffer-和-stringbuilder-类-stringbuffer、stringbuilder字符串变量\"> StringBuffer 和 StringBuilder 类——StringBuffer、StringBuilder字符串变量</h3>\n<p><img src=\"./images/Java-Interview/StringBuffer&StringBuilder_3.png\" alt=\"\" /></p>\n<p>当对字符串进行修改的时候，需要使用 <strong>StringBuffer(线程安全)</strong> 和 <strong>StringBuilder(线程不安全)</strong> 类。</p>\n<p>和 String 类不同的是，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象。</p>\n<p>StringBuilder 类在 Java 5 中被提出，它和 StringBuffer 之间的最大不同在于 <strong>StringBuilder 的方法不是线程安全的（不能同步访问）</strong>。</p>\n<p>由于 StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类。然而在应用程序要求线程安全的情况下，则必须使用 StringBuffer 类。</p>\n<p><img src=\"./images/Java-Interview/String_inheritance_structure.png\" alt=\"String继承结构\" /></p>\n<h3 id=\"区别\"> 区别</h3>\n<ul>\n<li>**String：**不可变字符串；</li>\n<li>**StringBuffer：**可变字符串、效率低、线程安全；</li>\n<li>**StringBuilder：**可变字符序列、效率高、线程不安全；</li>\n</ul>\n<p>初始化上的区别，String可以空赋值，后者不行，报错</p>\n<p><img src=\"./images/Java-Interview/StringBuffer&StringBuilder.png\" alt=\"\" /></p>\n<p><img src=\"./images/Java-Interview/StringBuffer&StringBuilder_2.png\" alt=\"\" /></p>\n<h2 id=\"装箱与拆箱\"> 装箱与拆箱</h2>\n<p>https://www.cnblogs.com/dolphin0520/p/3780005.html</p>\n<p><img src=\"./images/Java-Interview/box_unbox_1.png\" alt=\"装箱与拆箱1\" /></p>\n<p><img src=\"./images/Java-Interview/box_unbox_2.png\" alt=\"装箱与拆箱2\" /></p>\n<h3 id=\"面试题\"> 面试题</h3>\n<p><img src=\"./images/Java-Interview/box_unbox_interview_1.png\" alt=\"装箱与拆箱面试题1\" /></p>\n<p>​\t\t从这2段代码可以看出，在通过valueOf方法创建Integer对象的时候，如果数值在**[-128,127]**之间，便返回指向IntegerCache.cache中已经存在的对象的引用；否则创建一个新的Integer对象。</p>\n<p>​\t\t上面的代码中i1和i2的数值为100，因此会直接从cache中取已经存在的对象，所以i1和i2指向的是同一个对象，而i3和i4则是分别指向不同的对象。</p>\n<p><img src=\"./images/Java-Interview/box_unbox_interview_2.png\" alt=\"装箱与拆箱面试题2\" /></p>\n<p><img src=\"./images/Java-Interview/box_unbox_interview_3.png\" alt=\"装箱与拆箱面试题3\" /></p>\n<h2 id=\"在-java-中定义一个不做事且没有参数的构造方法的作用\"> 在 Java 中定义⼀个不做事且没有参数的构造⽅法的作⽤</h2>\n<p>​\t\tJava 程序在执⾏⼦类的构造⽅法之前，如果没有⽤ <strong>super()</strong> 来调⽤⽗类特定的构造⽅法，则会调⽤ <strong>⽗类中“没有参数的构造⽅法”</strong>。因此，如果⽗类中只定义了有参数的构造⽅法，⽽在⼦类的构造⽅法中 ⼜没有⽤ super() 来调⽤⽗类中特定的构造⽅法，则编译时将发⽣错误，因为 Java 程序在⽗类中找 不到没有参数的构造⽅法可供执⾏。解决办法是在⽗类⾥加上⼀个不做事且没有参数的构造⽅法。</p>\n<h2 id=\"接口和抽象类\"> 接⼝和抽象类</h2>\n<p><img src=\"./images/Java-Interview/Comparison_of_abstract_classes_and_interfaces_1.png\" alt=\"抽象类和接口的对比\" /></p>\n<p><img src=\"./images/Java-Interview/Comparison_of_abstract_classes_and_interfaces_2.png\" alt=\"抽象类和接口的对比2\" /></p>\n<p><img src=\"./images/Java-Interview/Comparison_of_abstract_classes_and_interfaces_3.png\" alt=\"抽象类和接口的对比3\" /></p>\n<h2 id=\"成员变量与局部变量的区别有哪些\"> 成员变量与局部变量的区别有哪些？</h2>\n<p><img src=\"./images/Java-Interview/difference_between_memberVariables_and_localVariables.png\" alt=\"成员变量和局部变量的区别\" /></p>\n<h2 id=\"静态方法和实例方法有何不同\"> 静态⽅法和实例⽅法有何不同</h2>\n<ul>\n<li>在外部调用静态方法时，可以使用**&quot;类名.方法名&quot;<strong>的方式，也可以使用</strong>&quot;对象名.方法名&quot;**的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。</li>\n<li>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制。</li>\n</ul>\n<h2 id=\"与equals\"> ==与equals()</h2>\n<p><img src=\"./images/Java-Interview/==&equals.png\" alt=\"==与equals\" /></p>\n<h2 id=\"hashcode-与equals\"> hashcode()与equals()</h2>\n<p>参考</p>\n<blockquote>\n<ul>\n<li>https://blog.csdn.net/zj15527620802/article/details/88547914</li>\n<li><a href=\"https://www.cnblogs.com/chenpi/p/5489494.html\" target=\"_blank\" rel=\"noopener noreferrer\">equals()和hashCode()之间的关系</a></li>\n<li>https://www.cnblogs.com/skywang12345/p/3324958.html</li>\n</ul>\n</blockquote>\n<h3 id=\"第一种-不会创建-类对应的散列表\"> 第一种 不会创建“类对应的散列表”</h3>\n<h2 id=\"为什么-java-中只有值传递\"> 为什么 Java 中只有值传递？</h2>\n<p>参考</p>\n<blockquote>\n<p>https://blog.csdn.net/bjweimengshu/article/details/79799485</p>\n</blockquote>\n<h2 id=\"java中异常处理\"> Java中异常处理</h2>\n<p>参考</p>\n<blockquote>\n<p>https://blog.csdn.net/sugar_no1/article/details/88593255</p>\n</blockquote>\n<p><img src=\"./images/Java-Interview/Java_Exception_handling_1.png\" alt=\"Java中的异常处理1\" /></p>\n<p><img src=\"./images/Java-Interview/Java_Exception_handling_2.png\" alt=\"Java中的异常处理2\" /></p>\n<p><img src=\"./images/Java-Interview/Java_Exception_handling_3.png\" alt=\"Java中的异常处理3\" /></p>\n<p><img src=\"./images/Java-Interview/Java_Exception_handling_4.png\" alt=\"Java中的异常处理4\" /></p>\n<h3 id=\"stackoverflow的几种-todo\"> StackOverFlow的几种(TODO)</h3>\n<h3 id=\"异常处理的三种方式\"> 异常处理的三种方式</h3>\n<p>参考</p>\n<blockquote>\n<ul>\n<li>https://blog.csdn.net/qq_22067469/article/details/82930798</li>\n</ul>\n</blockquote>\n<h4 id=\"_1-系统自动抛出异常\"> 1. 系统自动抛出异常</h4>\n<p>当程序语句出现一些逻辑错误、主义错误或者类型转换错误时，系统会自动抛出异常</p>\n<div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n\t<span>int</span> a <span>=</span> <span>5</span><span>;</span>\n\t<span>int</span> b <span>=</span> <span>0</span><span>;</span>\n\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span> a <span>/</span> b<span>)</span><span>;</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>运行结果</p>\n<div><pre><code><span>Exception</span> in thread <span>\"main\"</span> <span><span>java<span>.</span>lang<span>.</span></span>ArithmeticException</span><span>:</span> <span>/</span> by zero\n\tat <span><span>io<span>.</span>renren<span>.</span>modules<span>.</span>sys<span>.</span>controller<span>.</span></span>SysUserController</span><span>.</span><span>main</span><span>(</span><span>SysUserController</span><span>.</span>java<span>:</span><span>154</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h4 id=\"_3-try-catch-抛出异常\"> 3. try{ } catch{}抛出异常</h4>\n<p>在try中放入待执行代码，如果程序正常运行就会执行try中的代码，如果出现异常，就会执行catch中的代码，当然，try后面可以跟多个catch，当通过try catch这种方法抛出异常的时候要注意抛出异常的顺序，异常范围小的放在前面，异常范围大的放在后面，在这里举个例子：</p>\n<div><pre><code><span>try</span><span>{</span>\n                  <span>//待执行的代码</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>FileNotFoundException</span> e<span>)</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"找不到文件\"</span><span>)</span><span>;</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>IOException</span> e<span>)</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"IO操作失败\"</span><span>)</span><span>;</span>\n        <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h4 id=\"_4-throw\"> 4. throw</h4>\n<p>throw是语句抛出一个异常，一般是在代码的内部，当程序出现某种逻辑错误时同程序主动抛出某种特定类型的异常</p>\n<div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n\t<span>String</span> str <span>=</span> <span>\"NBA\"</span><span>;</span>\n\t<span>if</span> <span>(</span>str<span>.</span><span>equals</span><span>(</span><span>\"NBA\"</span><span>)</span><span>)</span> <span>{</span>\n\t\t<span>throw</span> <span>new</span> <span>NumberFormatException</span><span>(</span><span>)</span><span>;</span>\n\t<span>}</span> <span>else</span> <span>{</span>\n\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>str<span>)</span><span>;</span>\n\t<span>}</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h4 id=\"_5-throws\"> 5. throws</h4>\n<p>throws是方法可能会抛出一个异常(用在<code>声明方法</code>时，表示该方法可能要抛出异常),当某个方法可能会抛出某种异常时用于throws 声明可能抛出的异常，然后交给上层调用它的方法程序处理</p>\n<div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>testThrows</span><span>(</span><span>)</span> <span>throws</span> <span>NumberFormatException</span> <span>{</span>\n\t<span>String</span> str <span>=</span> <span>\"NBA\"</span><span>;</span>\n\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Integer</span><span>.</span><span>parseInt</span><span>(</span>str<span>)</span><span>)</span><span>;</span>\n<span>}</span>\n\n<span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n\t<span>try</span> <span>{</span>\n\t\t<span>testThrows</span><span>(</span><span>)</span><span>;</span>\n\t<span>}</span> <span>catch</span> <span>(</span><span>NumberFormatException</span> e<span>)</span> <span>{</span>\n\t\te<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"非数直类型不能强制类型转换\"</span><span>)</span><span>;</span>\n\t<span>}</span>\n<span>}</span>\n\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h3 id=\"throw与throws的比较\"> throw与throws的比较</h3>\n<ul>\n<li>throws出现在方法函数头，而throw出现在函数体。</li>\n<li>throws表示出现异常的一种可能性，并不一定会发生这些异常，throw则是抛出了异常，执行throw则一定抛出了某种异常对象。</li>\n<li>两者都是消极处理异常的方式（这里的消极并不是说这种方式不好），只是抛出或者可能抛出异常，但不会由函数去处理异常，真正的处理异常由函数的上层调用处理。</li>\n</ul>\n<h3 id=\"编程习惯\"> 编程习惯</h3>\n<ul>\n<li>在写程序时，对可能会出现异常的部分通常要用try{…}catch{…}去捕捉它并对它进行处理；</li>\n<li>用try{…}catch{…}捕捉了异常之后一定要对在catch{…}中对其进行处理，那怕是最简单的一句输出语句，或栈输入e.printStackTrace();</li>\n<li>如果是捕捉IO输入输出流中的异常，一定要在try{…}catch{…}后加finally{…}把输入输出流关闭；</li>\n<li>如果在函数体内用throw抛出了某种异常，最好要在函数名中加throws抛异常声明，然后交给调用它的上层函数进行处理。</li>\n</ul>\n<h2 id=\"获取用键盘输入常用的两种方法\"> 获取⽤键盘输⼊常⽤的两种⽅法</h2>\n<p><img src=\"./images/Java-Interview/keyboard_input.png\" alt=\"键盘输入\" /></p>\n<h3 id=\"输入一个字符\"> 输入一个字符</h3>\n<div><pre><code><span>Scanner</span> input <span>=</span> <span>new</span> <span>Scanner</span><span>(</span><span>System</span><span>.</span>in<span>)</span><span>;</span>\n<span>char</span> c <span>=</span> input<span>.</span><span>next</span><span>(</span><span>)</span><span>.</span><span>charAt</span><span>(</span><span>0</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h3 id=\"next-和nextline\"> next()和nextLine()</h3>\n<ul>\n<li>**next()：**不可以读取空格。它不能读两个由空格或符号隔开的单词。此外，next()在读取输入后将光标放在同一行中。(next()只读空格之前的数据,并且光标指向本行)</li>\n<li>**nextLine()：**可以读取空格，包括单词之间的空格和除回车以外的所有符号(即。它读到行尾)。读取输入后，nextLine()将光标定位在下一行。</li>\n</ul>\n<h2 id=\"泛型使用\"> 泛型使用</h2>\n<p>参考</p>\n<blockquote>\n<p>https://www.cnblogs.com/jpfss/p/9928747.html</p>\n</blockquote>\n<h2 id=\"浅拷贝-深拷贝\"> 浅拷贝 | 深拷贝</h2>\n<ul>\n<li>浅拷贝（shallowCopy）只是增加了一个指针指向已存在的内存地址</li>\n<li>深拷贝（deepCopy）是增加了一个指针并且申请了一个新的内存，使这个增加的指针指向这个新的内存</li>\n</ul>\n<h2 id=\"串行化-并行化\"> 串行化 | 并行化</h2>\n<div><p>参考</p>\n<ul>\n<li>https://www.cnblogs.com/xh0102/p/5759803.html</li>\n<li>https://blog.csdn.net/kuangpeng1956/article/details/83817369</li>\n</ul>\n</div>\n<h2 id=\"内部类\"> 内部类</h2>\n<p>::: tips 参考</p>\n<ul>\n<li>https://www.cnblogs.com/dolphin0520/p/3811445.html</li>\n<li>https://blog.csdn.net/weixin_42762133/article/details/82890555</li>\n</ul>\n<p>:::</p>\n<h2 id=\"bio-nio-aio\"> BIO | NIO | AIO</h2>\n",
      "date_published": "2020-08-08T23:24:32.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": []
    },
    {
      "title": "Java-常用方法汇总",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/java/Java-Methods/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/java/Java-Methods/",
      "content_html": "<h1 id=\"_1-java集合\"> 1. Java集合</h1>\n<h2 id=\"_1-1-collection\"> 1.1 Collection</h2>\n<h3 id=\"_1-1-1-排序操作\"> 1.1.1 排序操作</h3>\n<div><pre><code><span>void</span> <span>reverse</span><span>(</span><span>List</span> list<span>)</span><span>//反转</span>\n<span>void</span> <span>shuffle</span><span>(</span><span>List</span> list<span>)</span><span>//随机排序</span>\n<span>void</span> <span>sort</span><span>(</span><span>List</span> list<span>)</span><span>//按自然排序的升序排序</span>\n<span>void</span> <span>sort</span><span>(</span><span>List</span> list<span>,</span> <span>Comparator</span> c<span>)</span><span>//定制排序，由Comparator控制排序逻辑</span>\n<span>void</span> <span>swap</span><span>(</span><span>List</span> list<span>,</span> <span>int</span> i <span>,</span> <span>int</span> j<span>)</span><span>//交换两个索引位置的元素</span>\n<span>void</span> <span>rotate</span><span>(</span><span>List</span> list<span>,</span> <span>int</span> distance<span>)</span><span>//旋转。当distance为正数时，将list后distance个元素整体移到前面。当distance为负数时，将 list的前distance个元素整体移到后面。</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>示例代码</p>\n<div><pre><code><span>ArrayList</span><span><span>&lt;</span><span>Integer</span><span>></span></span> arrayList <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>Integer</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n\t\tarrayList<span>.</span><span>add</span><span>(</span><span>-</span><span>1</span><span>)</span><span>;</span>\n\t\tarrayList<span>.</span><span>add</span><span>(</span><span>3</span><span>)</span><span>;</span>\n\t\tarrayList<span>.</span><span>add</span><span>(</span><span>3</span><span>)</span><span>;</span>\n\t\tarrayList<span>.</span><span>add</span><span>(</span><span>-</span><span>5</span><span>)</span><span>;</span>\n\t\tarrayList<span>.</span><span>add</span><span>(</span><span>7</span><span>)</span><span>;</span>\n\t\tarrayList<span>.</span><span>add</span><span>(</span><span>4</span><span>)</span><span>;</span>\n\t\tarrayList<span>.</span><span>add</span><span>(</span><span>-</span><span>9</span><span>)</span><span>;</span>\n\t\tarrayList<span>.</span><span>add</span><span>(</span><span>-</span><span>7</span><span>)</span><span>;</span>\n\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"原始数组:\"</span><span>)</span><span>;</span>\n\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>arrayList<span>)</span><span>;</span>\n\t<span>// void reverse(List list)：反转</span>\n\t\t<span>Collections</span><span>.</span><span>reverse</span><span>(</span>arrayList<span>)</span><span>;</span>\n\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"Collections.reverse(arrayList):\"</span><span>)</span><span>;</span>\n\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>arrayList<span>)</span><span>;</span>\n\n\n\t\t<span>Collections</span><span>.</span><span>rotate</span><span>(</span>arrayList<span>,</span> <span>4</span><span>)</span><span>;</span>\n\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"Collections.rotate(arrayList, 4):\"</span><span>)</span><span>;</span>\n\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>arrayList<span>)</span><span>;</span>\n\n\t\t<span>// void sort(List list),按自然排序的升序排序</span>\n\t\t<span>Collections</span><span>.</span><span>sort</span><span>(</span>arrayList<span>)</span><span>;</span>\n\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"Collections.sort(arrayList):\"</span><span>)</span><span>;</span>\n\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>arrayList<span>)</span><span>;</span>\n\n\t\t<span>// void shuffle(List list),随机排序</span>\n\t\t<span>Collections</span><span>.</span><span>shuffle</span><span>(</span>arrayList<span>)</span><span>;</span>\n\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"Collections.shuffle(arrayList):\"</span><span>)</span><span>;</span>\n\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>arrayList<span>)</span><span>;</span>\n\n\t\t<span>// void swap(List list, int i , int j),交换两个索引位置的元素</span>\n\t\t<span>Collections</span><span>.</span><span>swap</span><span>(</span>arrayList<span>,</span> <span>2</span><span>,</span> <span>5</span><span>)</span><span>;</span>\n\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"Collections.swap(arrayList, 2, 5):\"</span><span>)</span><span>;</span>\n\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>arrayList<span>)</span><span>;</span>\n\n\t\t<span>// 定制排序的用法</span>\n\t\t<span>Collections</span><span>.</span><span>sort</span><span>(</span>arrayList<span>,</span> <span>new</span> <span>Comparator</span><span><span>&lt;</span><span>Integer</span><span>></span></span><span>(</span><span>)</span> <span>{</span>\n\n\t\t\t<span>@Override</span>\n\t\t\t<span>public</span> <span>int</span> <span>compare</span><span>(</span><span>Integer</span> o1<span>,</span> <span>Integer</span> o2<span>)</span> <span>{</span>\n\t\t\t\t<span>return</span> o2<span>.</span><span>compareTo</span><span>(</span>o1<span>)</span><span>;</span>\n\t\t\t<span>}</span>\n\t\t<span>}</span><span>)</span><span>;</span>\n\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"定制排序后：\"</span><span>)</span><span>;</span>\n\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>arrayList<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br></div></div><h3 id=\"_1-1-2-查找-替换操作\"> 1.1.2 查找,替换操作</h3>\n<div><pre><code><span>int</span> <span>binarySearch</span><span>(</span><span>List</span> list<span>,</span> <span>Object</span> key<span>)</span><span>//对List进行二分查找，返回索引，注意List必须是有序的</span>\n<span>int</span> <span>max</span><span>(</span><span>Collection</span> coll<span>)</span><span>//根据元素的自然顺序，返回最大的元素。 类比int min(Collection coll)</span>\n<span>int</span> <span>min</span><span>(</span><span>Collection</span> coll<span>)</span><span>//最小值</span>\n<span>int</span> <span>max</span><span>(</span><span>Collection</span> coll<span>,</span> <span>Comparator</span> c<span>)</span><span>//根据定制排序，返回最大元素，排序规则由Comparatator类控制。类比int min(Collection coll, Comparator c)</span>\n<span>void</span> <span>fill</span><span>(</span><span>List</span> list<span>,</span> <span>Object</span> obj<span>)</span><span>//用指定的元素代替指定list中的所有元素。</span>\n<span>int</span> <span>frequency</span><span>(</span><span>Collection</span> c<span>,</span> <span>Object</span> o<span>)</span><span>//统计元素出现次数</span>\n<span>int</span> <span>indexOfSubList</span><span>(</span><span>List</span> list<span>,</span> <span>List</span> target<span>)</span><span>//统计target在list中第一次出现的索引，找不到则返回-1，类比int lastIndexOfSubList(List source, list target).</span>\n<span>boolean</span> <span>replaceAll</span><span>(</span><span>List</span> list<span>,</span> <span>Object</span> oldVal<span>,</span> <span>Object</span> newVal<span>)</span><span>//用新元素替换旧元素</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p><strong>示例代码</strong></p>\n<div><pre><code><span>ArrayList</span><span><span>&lt;</span><span>Integer</span><span>></span></span> arrayList <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>Integer</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n\t\tarrayList<span>.</span><span>add</span><span>(</span><span>-</span><span>1</span><span>)</span><span>;</span>\n\t\tarrayList<span>.</span><span>add</span><span>(</span><span>3</span><span>)</span><span>;</span>\n\t\tarrayList<span>.</span><span>add</span><span>(</span><span>3</span><span>)</span><span>;</span>\n\t\tarrayList<span>.</span><span>add</span><span>(</span><span>-</span><span>5</span><span>)</span><span>;</span>\n\t\tarrayList<span>.</span><span>add</span><span>(</span><span>7</span><span>)</span><span>;</span>\n\t\tarrayList<span>.</span><span>add</span><span>(</span><span>4</span><span>)</span><span>;</span>\n\t\tarrayList<span>.</span><span>add</span><span>(</span><span>-</span><span>9</span><span>)</span><span>;</span>\n\t\tarrayList<span>.</span><span>add</span><span>(</span><span>-</span><span>7</span><span>)</span><span>;</span>\n\t\t<span>ArrayList</span><span><span>&lt;</span><span>Integer</span><span>></span></span> arrayList2 <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>Integer</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n\t\tarrayList2<span>.</span><span>add</span><span>(</span><span>-</span><span>3</span><span>)</span><span>;</span>\n\t\tarrayList2<span>.</span><span>add</span><span>(</span><span>-</span><span>5</span><span>)</span><span>;</span>\n\t\tarrayList2<span>.</span><span>add</span><span>(</span><span>7</span><span>)</span><span>;</span>\n\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"原始数组:\"</span><span>)</span><span>;</span>\n\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>arrayList<span>)</span><span>;</span>\n\n\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"Collections.max(arrayList):\"</span><span>)</span><span>;</span>\n\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Collections</span><span>.</span><span>max</span><span>(</span>arrayList<span>)</span><span>)</span><span>;</span>\n\n\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"Collections.min(arrayList):\"</span><span>)</span><span>;</span>\n\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Collections</span><span>.</span><span>min</span><span>(</span>arrayList<span>)</span><span>)</span><span>;</span>\n\n\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"Collections.replaceAll(arrayList, 3, -3):\"</span><span>)</span><span>;</span>\n\t\t<span>Collections</span><span>.</span><span>replaceAll</span><span>(</span>arrayList<span>,</span> <span>3</span><span>,</span> <span>-</span><span>3</span><span>)</span><span>;</span>\n\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>arrayList<span>)</span><span>;</span>\n\n\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"Collections.frequency(arrayList, -3):\"</span><span>)</span><span>;</span>\n\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Collections</span><span>.</span><span>frequency</span><span>(</span>arrayList<span>,</span> <span>-</span><span>3</span><span>)</span><span>)</span><span>;</span>\n\n\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"Collections.indexOfSubList(arrayList, arrayList2):\"</span><span>)</span><span>;</span>\n\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Collections</span><span>.</span><span>indexOfSubList</span><span>(</span>arrayList<span>,</span> arrayList2<span>)</span><span>)</span><span>;</span>\n\n\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"Collections.binarySearch(arrayList, 7):\"</span><span>)</span><span>;</span>\n\t\t<span>// 对List进行二分查找，返回索引，List必须是有序的</span>\n\t\t<span>Collections</span><span>.</span><span>sort</span><span>(</span>arrayList<span>)</span><span>;</span>\n\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Collections</span><span>.</span><span>binarySearch</span><span>(</span>arrayList<span>,</span> <span>7</span><span>)</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br></div></div><h3 id=\"_1-1-3-其它操作\"> 1.1.3 其它操作</h3>\n<div><pre><code><span>List</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>nCopies</span><span>(</span><span>int</span> i <span>,</span> <span>T</span> t<span>)</span><span>//根据泛型t复制i次，最后组成一个List&lt;T>并返回</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>ArrayList</p>\n<h3 id=\"共有方法\"> 共有方法</h3>\n<ol>\n<li>\n<p><strong>boolean add(E e)</strong></p>\n<blockquote>\n<p>添加一个元素</p>\n</blockquote>\n</li>\n<li>\n<p><strong>boolean addAll(Collection&lt;? extends E&gt; c)</strong></p>\n<blockquote>\n<p>将集合中的所有元素添加到其他集合中</p>\n</blockquote>\n</li>\n<li>\n<p><strong>clear()</strong></p>\n<blockquote>\n<p>暴力清除集合中所有元素</p>\n</blockquote>\n</li>\n<li>\n<p><strong>boolean contains(Object o)</strong></p>\n<blockquote>\n<p>判断集合是否包含某个元素，包含返回true</p>\n</blockquote>\n</li>\n<li>\n<p><strong>boolean isEmpty()</strong></p>\n<blockquote>\n<p>如果此集合不包含元素，则返回true</p>\n</blockquote>\n</li>\n<li>\n<p><strong>int size()</strong></p>\n<blockquote>\n<p>返回集合个数</p>\n</blockquote>\n</li>\n<li>\n<p><strong>Iterator iterator()</strong></p>\n<blockquote>\n<p>迭代器，返回Iterator类型</p>\n</blockquote>\n</li>\n</ol>\n<h2 id=\"_1-2-list特有\"> 1.2 List特有</h2>\n<h2 id=\"_1-2-map\"> 1.2 Map</h2>\n<h3 id=\"_1-2-1-增删查改类\"> 1.2.1 增删查改类</h3>\n<h3 id=\"v-put-k-key-v-value\"> V put(K key , V value)</h3>\n<p>向map中添加键值对，并返回<code>value</code>值，如果<code>key</code>重复，则返回之前的<code>oldValue</code>值</p>\n<div><pre><code><span>///*Integer*/map.put(\"1\", 1);//向map中添加值(返回这个key以前的值,如果没有返回null)</span>\n         <span>HashMap</span><span><span>&lt;</span><span>String</span><span>,</span> <span>Integer</span><span>></span></span> map<span>=</span><span>new</span> <span>HashMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n         <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>map<span>.</span><span>put</span><span>(</span><span>\"1\"</span><span>,</span> <span>1</span><span>)</span><span>)</span><span>;</span><span>//null</span>\n         <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>map<span>.</span><span>put</span><span>(</span><span>\"1\"</span><span>,</span> <span>2</span><span>)</span><span>)</span><span>;</span><span>//1</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id=\"v-putifabsent-k-key-v-value\"> V putIfAbsent(K key , V Value)</h3>\n<p><code>JDK1.8</code></p>\n<p>如果当前 <code>Map</code> 不存在键 <em>key</em> 或者该 <em>key</em> 关联的值为 <code>null</code>，那么就执行 <code>put(key, value)</code>；否则，便不执行 <code>put</code> 操作并返回null</p>\n<div><pre><code><span>HashMap</span><span><span>&lt;</span><span>String</span><span>,</span> <span>Integer</span><span>></span></span> map<span>=</span><span>new</span> <span>HashMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n<span>/*boolean*/</span><span>/</span><span>/</span>判断map中是否存在这个key\nmap<span>.</span><span>put</span><span>(</span><span>\"DEMO1\"</span><span>,</span> <span>1</span><span>)</span><span>;</span>\nmap<span>.</span><span>put</span><span>(</span><span>\"DEMO2\"</span><span>,</span> <span>2</span><span>)</span><span>;</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>map<span>)</span><span>;</span><span>//{DEMO1=1, DEMO2=2}</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>map<span>.</span><span>putIfAbsent</span><span>(</span><span>\"DEMO1\"</span><span>,</span> <span>12222</span><span>)</span><span>)</span><span>;</span><span>//1</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>map<span>.</span><span>putIfAbsent</span><span>(</span><span>\"DEMO3\"</span><span>,</span> <span>12222</span><span>)</span><span>)</span><span>;</span><span>//null</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>map<span>)</span><span>;</span><span>//{DEMO1=1, DEMO2=2,DEMO3=12222}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id=\"map-k-v-putall-map-extends-k-extends-v-m\"> Map&lt;K , V&gt; putAll(Map&lt;? extends K, ? extends V&gt; m)</h3>\n<p>putAll可以合并两个相同类型的Map，被合并的类型必须是相等或继承的类型，只不过如果有相同的key那么用被合并的覆盖前面的</p>\n<div><pre><code><span>HashMap</span> map3<span>=</span><span>new</span> <span>HashMap</span><span>(</span><span>)</span><span>;</span>\nmap3<span>.</span><span>put</span><span>(</span><span>\"1\"</span><span>,</span> <span>\"A\"</span><span>)</span><span>;</span>\n\n<span>HashMap</span> map4 <span>=</span> <span>new</span> <span>HashMap</span><span>(</span><span>)</span><span>;</span>\nmap4<span>.</span><span>put</span><span>(</span><span>\"1\"</span><span>,</span> <span>\"B\"</span><span>)</span><span>;</span>\nmap4<span>.</span><span>put</span><span>(</span><span>\"3\"</span><span>,</span> <span>\"C\"</span><span>)</span><span>;</span>\n\nmap3<span>.</span><span>putAll</span><span>(</span>map4<span>)</span><span>;</span>\n\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>map3<span>)</span><span>;</span>\n<span>//{3=C, 1=B},key为1value为“A“被覆盖</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h3 id=\"v-get-k-key\"> V get(K key)</h3>\n<p>得到map中key相对应的value的值,为空返回null</p>\n<h3 id=\"map-k-v-clone\"> Map&lt;K , V&gt; clone()</h3>\n<p>克隆map</p>\n<h3 id=\"void-clear\"> void clear()</h3>\n<p>清空map</p>\n<h3 id=\"int-size\"> int Size()</h3>\n<p>返回大小</p>\n<h3 id=\"v-replace-k-key-v-newvalue\"> V replace(K key , V newValue)</h3>\n<p><code>JDK1.8新方法</code></p>\n<p>在指定的键已经存在并且有与之相关的映射值时才会将指定的键映射到指定的值（新值）, 并返回<code>旧的oldValue值</code></p>\n<p>在指定的键不存在时，方法会return回来一个<code>null</code></p>\n<h3 id=\"boolean-replace-k-key-v-oldvalue-v-newvalue\"> boolean replace(K key , V oldValue , V newValue)</h3>\n<p><code>JDK1.8新方法</code></p>\n<p>当<code>Map.Entry&lt;key , oldValue&gt;</code>存在时，也就是说存在<code>key-oldValue</code>这个键值对时才进行替换操作</p>\n<p>成功返回<code>true</code>，否则<code>false</code></p>\n<div><pre><code><span>HashMap</span><span><span>&lt;</span><span>String</span><span>,</span> <span>String</span><span>></span></span> map3<span>=</span><span>new</span> <span>HashMap</span><span>(</span><span>)</span><span>;</span>\nmap3<span>.</span><span>put</span><span>(</span><span>\"1\"</span><span>,</span> <span>\"a\"</span><span>)</span><span>;</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>map3<span>.</span><span>replace</span><span>(</span><span>\"1\"</span> <span>,</span> <span>\"a\"</span> <span>,</span> <span>\"b\"</span><span>)</span><span>)</span><span>;</span><span>//true</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>map3<span>.</span><span>replace</span><span>(</span><span>\"2\"</span> <span>,</span> <span>\"a\"</span> <span>,</span> <span>\"b\"</span><span>)</span><span>)</span><span>;</span><span>//false,key不同，value相同</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>map3<span>.</span><span>replace</span><span>(</span><span>\"1\"</span> <span>,</span> <span>\"s\"</span> <span>,</span> <span>\"b\"</span><span>)</span><span>)</span><span>;</span><span>//false,key相同，value不同</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id=\"boolean-remove-k-key\"> boolean remove(K key)</h3>\n<p>根据key删除此键值对下的键值对</p>\n<h3 id=\"boolean-remove-k-key-v-value\"> boolean remove(K key , V value)</h3>\n<p>删除key和value都符合的键值对</p>\n<h3 id=\"boolean-isempty\"> boolean isEmpty()</h3>\n<p>判断是否为空</p>\n<h3 id=\"boolean-containskey-k-key\"> boolean containsKey(K key)</h3>\n<p>查看是否包含此key</p>\n<h3 id=\"boolean-containsvalue-v-value\"> boolean containsValue(V value)</h3>\n<p>查看是否包含此value</p>\n<h3 id=\"_1-2-2-遍历类\"> 1.2.2 遍历类</h3>\n<h3 id=\"collection-v-values\"> Collection&lt;V&gt; values()</h3>\n<p>获取map中所有的key并返回为<code>Collection&lt;V&gt;</code>类型</p>\n<h3 id=\"set-v-keyset\"> Set&lt;V&gt; keySet()</h3>\n<p>获取map中所有的key并返回<code>Set&lt;V&gt;</code>类型，因为Set的元素是独一无二之的，之后可以用迭代器<code>iterator()</code>遍历</p>\n<div><pre><code><span>Iterator</span> ot <span>=</span> map<span>.</span><span>keySet</span><span>(</span><span>)</span><span>.</span><span>iterator</span><span>(</span><span>)</span><span>;</span>\n<span>while</span> <span>(</span>ot<span>.</span><span>hasNext</span><span>(</span><span>)</span><span>)</span><span>{</span>\n  <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>ot<span>.</span><span>next</span><span>(</span><span>)</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id=\"set-map-entry-k-v-entryset\"> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</h3>\n<p>返回所有结点，类型为<code>Set&lt;Map.Entry&lt;K,V&gt;&gt;</code>。也可以转换为迭代器<code>iterator()</code>遍历</p>\n<div><pre><code><span>Set</span><span><span>&lt;</span><span>Map<span>.</span>Entry</span><span>&lt;</span><span>String</span><span>,</span><span>String</span><span>></span><span>></span></span> es <span>=</span> map<span>.</span><span>entrySet</span><span>(</span><span>)</span><span>;</span>\n<span>Iterator</span><span><span>&lt;</span><span>Map<span>.</span>Entry</span><span>&lt;</span><span>String</span><span>,</span><span>String</span><span>></span><span>></span></span> it <span>=</span> es<span>.</span><span>iterator</span><span>(</span><span>)</span><span>;</span>\n <span>while</span><span>(</span>it<span>.</span><span>hasNext</span><span>(</span><span>)</span><span>)</span><span>{</span>\n\t<span>Map<span>.</span>Entry</span><span><span>&lt;</span><span>String</span><span>,</span> <span>String</span><span>></span></span> mey <span>=</span> it<span>.</span><span>next</span><span>(</span><span>)</span><span>;</span>\n               \n\t<span>//getKey()和getValue是接口Map.Entry&lt;K,V>中的方法，返回对应的键和对应的值</span>\n\t<span>String</span> key <span>=</span> mey<span>.</span><span>getKey</span><span>(</span><span>)</span><span>;</span>\n\t<span>String</span> value <span>=</span> mey<span>.</span><span>getValue</span><span>(</span><span>)</span><span>;</span>\n\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>key<span>+</span><span>\":\"</span><span>+</span>value<span>)</span><span>;</span>\n   \n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h1 id=\"_2-数组arrays\"> 2. 数组Arrays</h1>\n<p>Arrays类位于java.util 包中，主要包含了操纵数组的各种方法</p>\n<p>参考</p>\n<blockquote>\n<ul>\n<li>https://blog.csdn.net/u013256816/article/details/50924762</li>\n</ul>\n</blockquote>\n<h1 id=\"_3-string字符串\"> 3. String字符串</h1>\n<p>参考</p>\n<blockquote>\n<ul>\n<li>https://www.cnblogs.com/windbyside/p/9393716.html</li>\n</ul>\n</blockquote>\n<h2 id=\"char-charat-int-index\"> char charAt(int index)</h2>\n<p>返回指定索引位置的字符</p>\n<div><pre><code><span>String</span> str <span>=</span> <span>new</span> <span>String</span><span>(</span><span>\"String\"</span><span>)</span><span>;</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>str<span>.</span><span>charAt</span><span>(</span><span>0</span><span>)</span><span>)</span><span>;</span>\n<span>//return \"S\";</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id=\"string-substring-int-beginindex\"> String substring(int beginIndex)</h2>\n<p>返回指定起始位置至字符串末尾的字符串</p>\n<div><pre><code><span>String</span> str <span>=</span> <span>new</span> <span>String</span><span>(</span><span>\"String\"</span><span>)</span><span>;</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>str<span>.</span><span>substring</span><span>(</span><span>1</span><span>)</span><span>)</span><span>;</span>\n<span>//return \"tring\";</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id=\"string-substring-int-beginindex-int-endindex\"> <strong>String</strong> substring(int beginIndex, int endIndex)</h2>\n<p>返回指定起始位置（含）到结束位置（不含）之间的字符串</p>\n<div><pre><code><span>String</span> str <span>=</span> <span>new</span> <span>String</span><span>(</span><span>\"String\"</span><span>)</span><span>;</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>str<span>.</span><span>substring</span><span>(</span><span>1</span><span>,</span> <span>3</span><span>)</span><span>)</span><span>;</span>\n<span>//return \"tr\";</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id=\"int-indexof-string-str\"> int indexOf(String str)</h2>\n<p>返回指定字符串的索引位置， 没有则返回-1</p>\n<div><pre><code><span>String</span> str <span>=</span> <span>new</span> <span>String</span><span>(</span><span>\"String\"</span><span>)</span><span>;</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>str<span>.</span><span>indexOf</span><span>(</span><span>\"i\"</span><span>)</span><span>)</span><span>;</span>\n<span>//return \"3\";</span>\n\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>str<span>.</span><span>indexOf</span><span>(</span><span>\"ing\"</span><span>)</span><span>)</span><span>;</span>\n<span>//return \"3\";</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id=\"int-indexof-string-str-int-fromindex\"> int indexOf(String str, int fromIndex)</h2>\n<p>返回从指定索引位置fromIndex开始的str的索引位置,如果没有返回-1</p>\n<div><pre><code><span>String</span> str <span>=</span> <span>new</span> <span>String</span><span>(</span><span>\"String\"</span><span>)</span><span>;</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>str<span>.</span><span>indexOf</span><span>(</span><span>\"ing\"</span><span>,</span> <span>2</span><span>)</span><span>)</span><span>;</span>\n<span>//return \"3\";</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id=\"int-lastindexof-string-str\"> int lastIndexOf(String str)</h2>\n<p>返回子字符串最后出现的位置。没有找到，则返回 -1。</p>\n<div><pre><code><span>String</span> str <span>=</span> <span>new</span> <span>String</span><span>(</span><span>\"StringString\"</span><span>)</span><span>;</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>str<span>.</span><span>indexOf</span><span>(</span><span>\"String\"</span><span>)</span><span>)</span><span>;</span>\n<span>//return \"6\";</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id=\"string-replace-charsequence-oldstring-charsequence-newstring\"> String replace(CharSequence oldString, CharSequence newString):</h2>\n<p>用newString替换字符串中的oldString，注意相当于new了个新的String，原String不变</p>\n<div><pre><code><span>String</span> str <span>=</span> <span>new</span> <span>String</span><span>(</span><span>\"String\"</span><span>)</span><span>;</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>str<span>.</span><span>replace</span><span>(</span><span>\"g\"</span><span>,</span> <span>\"gs\"</span><span>)</span><span>)</span><span>;</span>\n<span>//return \"Strings\";</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id=\"string-trim\"> String trim()</h2>\n<p>返回一个去除两头空格的新字符串</p>\n<div><pre><code><span>String</span> str1 <span>=</span> <span>new</span> <span>String</span><span>(</span><span>)</span><span>;</span>\n　　str1 <span>=</span>  <span>\" \"</span><span>+</span><span>\"string\"</span><span>+</span><span>\" \"</span><span>;</span>\n　　<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>str1<span>.</span><span>length</span><span>(</span><span>)</span><span>)</span><span>;</span>\n　　<span>//return \"8\"</span>\n　　str1 <span>=</span> str1<span>.</span><span>trim</span><span>(</span><span>)</span><span>;</span>\n　　<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>str<span>.</span><span>length</span><span>(</span><span>)</span><span>)</span><span>;</span>\n　　<span>//return \"6\"</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id=\"string-split-string-regex\"> String[ ] split(String regex)</h2>\n<p>指定正则表达式分隔符，返回一个字符串数组</p>\n<div><pre><code><span>String</span> str2 <span>=</span> <span>new</span> <span>String</span><span>(</span><span>)</span><span>;</span>\n　　str2 <span>=</span> <span>\"A/B/C\"</span><span>;</span>\n　　<span>String</span> s<span>[</span><span>]</span> <span>=</span> str2<span>.</span><span>split</span><span>(</span><span>\"/\"</span><span>)</span><span>;</span>\n　　<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"s[0] = \"</span><span>+</span>s<span>[</span><span>0</span><span>]</span><span>)</span><span>;</span>\n　　<span>//return\"A\"</span>\n　　<span>for</span><span>(</span><span>String</span> ss<span>:</span> s<span>)</span> <span>{</span>\n　　<span>System</span><span>.</span>out<span>.</span><span>print</span><span>(</span>ss<span>+</span><span>\" \"</span><span>)</span><span>;</span>\n　　<span>}</span>\n　　<span>//return\"A B C\"</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h2 id=\"string-split-string-regex-int-limit\"> String[ ] split(String regex, int limit)</h2>\n<p>指定正则表达式分隔符regex和分隔份数limit，返回一个字符串数组</p>\n<div><pre><code><span>String</span> str2 <span>=</span> <span>new</span> <span>String</span><span>(</span><span>)</span><span>;</span>\n　　str2 <span>=</span> <span>\"A/B/C\"</span><span>;</span>\n　　<span>String</span> s<span>[</span><span>]</span> <span>=</span> str2<span>.</span><span>split</span><span>(</span><span>\"/\"</span><span>,</span> <span>2</span><span>)</span><span>;</span>\n　　<span>for</span><span>(</span><span>String</span> ss<span>:</span> s<span>)</span> <span>{</span>\n　　<span>System</span><span>.</span>out<span>.</span><span>print</span><span>(</span>ss<span>+</span><span>\" \"</span><span>)</span><span>;</span>\n　　<span>}</span>\n　　<span>//return\"A B/C\"</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id=\"string-copyvalueof-char-chararray\"> String.copyValueOf(char[] charArray)</h2>\n<p>将字符数组转换为字符串</p>\n<div><pre><code><span>char</span><span>[</span><span>]</span> arr<span>=</span><span>[</span><span>'a'</span><span>,</span><span>'b'</span><span>,</span><span>'c'</span><span>]</span><span>;</span>\n<span>String</span> string <span>=</span><span>String</span><span>.</span><span>copyValueOf</span><span>(</span>arr<span>)</span><span>;</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>string<span>)</span><span>;</span>          <span>//abc</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id=\"string-tolowercase\"> String toLowerCase()</h2>\n<p>转换为小写字母</p>\n<h2 id=\"string-touppercase\"> String toUpperCase()</h2>\n<p>转换为大写字母</p>\n<h2 id=\"string-intern\"> String intern()</h2>\n<ul>\n<li>如果字符串常量池已经包含一个等于此String对象的字符串（用equals(oject)方法确定），则返回池中的字符串的引用值。</li>\n<li>如果不包含，将此String对象添加到池中，并返回字符串常量池此String对象的引用</li>\n</ul>\n<p>JDK 1.7后，intern方法还是会先去查询常量池中是否有已经存在，如果存在，则返回常量池中的引用，这一点与之前没有区别，区别在于，<strong>如果在常量池找不到对应的字符串，则不会再将字符串拷贝到常量池，而只是在常量池中生成一个对原字符串的引用简单的说，就是往常量池放的东西变了：原来在常量池中找不到时，复制一个副本放到常量池，1.7后则是将在堆上的地址引用复制到常量池。</strong></p>\n<h2 id=\"string-string-join-string-str-string-strarr\"> String String.join(String str, String[] strArr)</h2>\n<p>在指定 String 数组B的每个元素之间串联指定的分隔符 A，从而产生单个串联的字符串</p>\n<div><pre><code><span>String</span><span>[</span><span>]</span> tmpStr<span>=</span><span>{</span>abc<span>,</span>def<span>,</span>ghi<span>}</span><span>;</span>\n<span>String</span> jn <span>=</span> <span>String<span>.</span>Join</span><span>(</span><span>\"-\"</span><span>,</span> tmpStr<span>)</span><span>;</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"jn ：\"</span>jn<span>)</span><span>;</span>\n<span>//jn：\"abc-def-ghi\"</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id=\"boolean-contains-string-s\"> boolean contains(String s)</h2>\n<p>该方法是判断字符串中是否有子字符串。如果有则返回true，如果没有则返回false。</p>\n<h2 id=\"boolean-startswith-string-prefix\"> boolean startsWith(String prefix)</h2>\n<p>如果字符串以prefix开头返回true，否则返回false</p>\n<h2 id=\"boolean-endswith-string-suffix\"> boolean endsWith(String suffix)</h2>\n<p>如果字符串以suffix结尾返回true，否则返回false</p>\n<h2 id=\"boolean-equals-object-other\"> boolean equals(Object other)</h2>\n<p>如果字符串与other相等返回true，否则返回false</p>\n<h2 id=\"boolean-equalsignorecase-string-other\"> boolean equalsIgnoreCase(String other)</h2>\n<p>如果字符串与other相等（忽略大小写）返回true，否则返回false</p>\n<h2 id=\"stringbuffer-stringbuilder\"> StringBuffer | StringBuilder</h2>\n<p>通用于<strong>StringBuilder</strong>,普通模式下建议用<strong>StringBuilder非线程安全</strong>。</p>\n<h3 id=\"stringbuilder-append-string-s\"> StringBuilder append(String s)</h3>\n<p>将其他类型拼接操作。可用于字符串数组转</p>\n<p><img src=\"./images/Java-Methods/StringBuffer_append().jpg\" alt=\"\" /></p>\n<h3 id=\"string-tostring\"> String toString()</h3>\n<p>转换为String。也可以通过构造方法进行转换</p>\n<div><pre><code><span>StringBuilder</span> stringBuilder <span>=</span> <span>new</span> <span>StringBuilder</span><span>(</span><span>\"String\"</span><span>)</span><span>;</span>\nstringBuilder<span>.</span><span>toString</span><span>(</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h3 id=\"stringbuilder-reverse\"> StringBuilder reverse()</h3>\n<p>反转字符串</p>\n<div><pre><code><span>StringBuilder</span> stringBuilder <span>=</span> <span>new</span> <span>StringBuilder</span><span>(</span><span>\"String\"</span><span>)</span><span>;</span>\nstringBuilder<span>.</span><span>reverse</span><span>(</span><span>)</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>stringBuilder<span>)</span><span>;</span><span>//\"gnirtS\"</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id=\"字符串-数组-其它类型-互转\"> 字符串 | 数组 | 其它类型 互转</h2>\n<h3 id=\"char-tochararray\"> char[] toCharArray()</h3>\n<p>字符串 -&gt; 字符数组</p>\n<div><pre><code><span>String</span> str <span>=</span> <span>new</span> <span>String</span><span>(</span><span>\"String\"</span><span>)</span><span>;</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>str<span>.</span><span>toCharArray</span><span>(</span><span>)</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h3 id=\"string-string-copyvalueof-char-chararray\"> String String.copyValueOf(char[] charArray)</h3>\n<p>字符数组 -&gt; 字符串</p>\n<div><pre><code><span>char</span><span>[</span><span>]</span> arr<span>=</span><span>[</span><span>'a'</span><span>,</span><span>'b'</span><span>,</span><span>'c'</span><span>]</span><span>;</span>\n<span>String</span> string <span>=</span><span>String</span><span>.</span><span>copyValueOf</span><span>(</span>arr<span>)</span><span>;</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>string<span>)</span><span>;</span>          <span>//abc</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id=\"string-string-valueof-object-obj\"> String String.valueOf(Object obj)</h3>\n<p>将其它类型转换为字符串</p>\n<p><img src=\"./images/Java-Methods/valueOf.jpg\" alt=\"\" /></p>\n<h3 id=\"string-split-string-s\"> String[] split(String s)</h3>\n<p>字符串转字符串数组。split() 方法根据匹配给定的正则表达式来拆分字符串。 **. 、 | 和 *** 等转义字符，必须得加 \\ \\。多个分隔符，可以用 | 作为连字符。</p>\n<div><pre><code><span>// 字符串转数组  java.lang.String</span>\n<span>String</span> str <span>=</span> <span>\"0,1,2,3,4,5\"</span><span>;</span>\n<span>String</span><span>[</span><span>]</span> arr <span>=</span> str<span>.</span><span>split</span><span>(</span><span>\",\"</span><span>)</span><span>;</span> <span>// 用,分割</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Arrays</span><span>.</span><span>toString</span><span>(</span>arr<span>)</span><span>)</span><span>;</span> <span>// [0, 1, 2, 3, 4, 5]</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><blockquote>\n<p>字符串数组转字符串可以使用<strong>StringBuffer</strong>的拼接操作**append(String s)**进行遍历拼接</p>\n</blockquote>\n<h3 id=\"string-stringbuffer-stringbuilder-互转\"> String | StringBuffer/StringBuilder 互转</h3>\n<h4 id=\"string-转-stringbuffer-stringbuilder\"> String 转 StringBuffer/StringBuilder</h4>\n<div><pre><code><span>String</span> s <span>=</span> <span>\"abc\"</span><span>;</span>\n\n<span>//通过构造方法</span>\n<span>StringBuffer</span> sb <span>=</span> <span>new</span> <span>StringBuffer</span><span>(</span>s<span>)</span><span>;</span>\n\n<span>//通过append()方法</span>\n<span>StringBuffer</span> sb <span>=</span> <span>new</span> <span>StringBuffer</span><span>(</span><span>)</span><span>;</span>\nsb<span>.</span><span>append</span><span>(</span>s<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h4 id=\"stringbuffer-stringbuilder-转-string\"> StringBuffer/StringBuilder 转 String</h4>\n<div><pre><code><span>StringBuffer</span> sb <span>=</span> <span>new</span> <span>StringBuffer</span><span>(</span><span>\"abc\"</span><span>)</span><span>;</span>\n\n<span>//通过构造方法</span>\n<span>String</span> s <span>=</span> <span>new</span> <span>String</span><span>(</span>sb<span>)</span><span>;</span>\n\n<span>//通过toString()方法</span>\n<span>String</span> s <span>=</span> sb<span>.</span><span>toString</span><span>(</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h1 id=\"_4-封装类型\"> 4. 封装类型</h1>\n<h2 id=\"静态成员变量\"> 静态成员变量</h2>\n<div><pre><code><span>public</span> <span>class</span> <span>Demo1</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>int</span> max <span>=</span> <span>Integer</span><span>.</span>MAX_VALUE<span>;</span>\n        <span>int</span> min <span>=</span> <span>Integer</span><span>.</span>MIN_VALUE<span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"int最大值是：\"</span><span>+</span>max<span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"int最小值是：\"</span><span>+</span>min<span>)</span><span>;</span>\n\n        <span>//根据上面的估计你就会做出举一反三的动作，如下：</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"Long最大值是：\"</span><span>+</span><span>Long</span><span>.</span>MAX_VALUE<span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"Long最小值是：\"</span><span>+</span><span>Long</span><span>.</span>MIN_VALUE<span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"Double最大值是：\"</span><span>+</span><span>Double</span><span>.</span>MAX_VALUE<span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"Double最小值是：\"</span><span>+</span><span>Double</span><span>.</span>MIN_VALUE<span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n\n\n<span>/*\n以上代码执行结果如下：\nint最大值是：2147483647\nint最小值是：-2147483648\nLong最大值是：9223372036854775807\nLong最小值是：-9223372036854775808\nDouble最大值是：1.7976931348623157E308\nDouble最小值是：4.9E-324\n*/</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><h2 id=\"_4-1-integer\"> 4.1 Integer</h2>\n<h3 id=\"静态成员变量-2\"> 静态成员变量</h3>\n<div><pre><code><span>int</span> max <span>=</span> <span>Integer</span><span>.</span>MAX_VALUE<span>;</span>\n<span>int</span> min <span>=</span> <span>Integer</span><span>.</span>MIN_VALUE<span>;</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"int最大值是：\"</span><span>+</span>max<span>)</span><span>;</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"int最小值是：\"</span><span>+</span>min<span>)</span><span>;</span>\n<span>/*\n以上代码执行结果如下：\nint最大值是：2147483647\nint最小值是：-2147483648\n*/</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id=\"构造方法\"> 构造方法</h3>\n<ul>\n<li>Integer(int i)</li>\n<li>Integer(String str)：常用的构造方法Integer(String s)是将数字格式的字符串，传递到Integer类的构造方法中，创建Integer对象，包装的是一个字符串。将构造方法中的字符串转成基本数据类型，调用非静态方法。</li>\n</ul>\n<h3 id=\"int-intvalue\"> int intValue()</h3>\n<p>将Integer转换为int类型</p>\n<h3 id=\"string-integer-tostring-int-int-radix\"> String Integer.toString(int , int radix)</h3>\n<p>Integer类中的静态方法toString()转换成字符串,将int整数转成指定的进制数radix</p>\n<div><pre><code><span>int</span> src <span>=</span> <span>32</span><span>;</span>\n<span>//将int整数转换成指定的进制数</span>\n<span>String</span> dest <span>=</span> <span>Integer</span><span>.</span><span>toString</span><span>(</span>src<span>,</span><span>2</span><span>)</span><span>;</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>dest<span>)</span><span>;</span><span>//100000</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id=\"int-integer-parseint-string-s\"> int Integer.parseInt(String s)</h3>\n<p>用于将字符串转换成基本数据类型(int)，要求字符串必须是数字格式.</p>\n<div><pre><code><span>String</span> year <span>=</span> <span>\"2018\"</span><span>;</span>\n<span>int</span> i <span>=</span> <span>Integer</span><span>.</span><span>parseInt</span><span>(</span>year<span>)</span><span>;</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>i<span>/</span><span>2</span><span>)</span><span>;</span><span>//1009</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id=\"int-integer-parseint-string-s-int-radix\"> int Integer.parseInt(String s,int radix)</h3>\n<p>将字符串s按照radix进行转换相应的进制数，然后运行的结果都是以十进制的形式打印。</p>\n<div><pre><code><span>String</span> year <span>=</span> <span>\"1110\"</span><span>;</span>\n<span>String</span> age <span>=</span> <span>\"A\"</span><span>;</span>\n<span>//指定year的进制为2进制</span>\n<span>int</span> i <span>=</span> <span>Integer</span><span>.</span><span>parseInt</span><span>(</span>year<span>,</span><span>2</span><span>)</span><span>;</span>\n<span>//指定age的进制为16进制</span>\n<span>int</span> i2 <span>=</span> <span>Integer</span><span>.</span><span>parseInt</span><span>(</span>age<span>,</span><span>16</span><span>)</span><span>;</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>i<span>)</span><span>;</span><span>//14</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>i2<span>)</span><span>;</span><span>//10</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h1 id=\"_5-随机数random\"> 5. 随机数Random()</h1>\n<p>参考</p>\n<blockquote>\n<ul>\n<li>https://blog.csdn.net/qq_36850813/article/details/90900744</li>\n</ul>\n</blockquote>\n",
      "date_published": "2020-08-09T23:56:52.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": []
    },
    {
      "title": "Java-新特性",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/java/Java-NewFeature/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/java/Java-NewFeature/",
      "content_html": "<h2 id=\"参考\"> 参考</h2>\n<ul>\n<li><a href=\"https://blog.csdn.net/PorkBird/article/details/113727704\" target=\"_blank\" rel=\"noopener noreferrer\">Java8新特性</a></li>\n</ul>\n<h2 id=\"jdk8\"> jdk8</h2>\n<ul>\n<li>Lambda表达式</li>\n<li>函数式接口</li>\n<li>方法引用/构造器</li>\n<li>Stream流 API</li>\n<li>接口的增强</li>\n<li>Optiona类</li>\n<li>新的时间和日期API</li>\n</ul>\n<p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/Java-NewFeature/jdk8新特性.png\" alt=\"image-20211017210905258\" /></p>\n<h3 id=\"lambda表达式\"> Lambda表达式</h3>\n<p>总结六种情况</p>\n<ul>\n<li>-&gt; 左边：Lambda形参列表的参数类型可以沈省略(类型推断)；如果Lambda形参别表至少是一个参数，括号也可以省略</li>\n<li>-&gt; 右边：Lambda应该用<code>{}</code>包裹，如果Lambda只有一条执行语句，可以省略return和括号</li>\n</ul>\n<h3 id=\"函数式接口\"> 函数式接口</h3>\n<p>如果一个接口中，只声明了一个抽象方法，则此接口就称为函数式接口。我们可以在一个接口使用<code>@FunctionalInterface</code> 注解， 这样做可以检查它是否是一个函数式接口。</p>\n<blockquote>\n<p>Lambda表达式的本质：作为函数式接口的实例化</p>\n</blockquote>\n<ul>\n<li>简单的说，在Java8中，Lambda表达式就是一个函数式接口的实例。这就是Lambda表达式和函数式接口的关系。也就是说，<strong>只要一个对象是函数式接口的实例，那么该对象就可以用Lambda表达式来表示</strong>。</li>\n<li><strong>所以以前用匿名实现类表示的现在都可以用Lambda表达式来写。</strong></li>\n</ul>\n<p>Java内置核心函数接口</p>\n<ul>\n<li>消费型接口 Consumer<T>     void accept(T t)</li>\n<li>供给型接口 Supplier<T>     T get()</li>\n<li>函数型接口 Function&lt;T,R&gt;   R apply(T t)</li>\n<li>断定型接口 Predicate<T>    boolean test(T t)</li>\n</ul>\n<p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/Java-NewFeature/函数式接口.png\" alt=\"image-20211023141750400\" /></p>\n<h3 id=\"方法引用\"> 方法引用</h3>\n<p>当要传递给Lambda体的操作，已经有实现的方法了，可以使用方法引用！\n方法引用可以看做是Lambda表达式深层次的表达。换句话说，方法引用就是Lambda表达式，也就是函数式接口的一个实例，通过方法的名字来指向一个方法，可以认为是Lambda表达式的一个语法糖。\n要求：实现接口的抽象方法的参数列表和返回值类型，必须与方法引用的方法的参数列表和返回值类型保持一致！\n格式：使用操作符“::” 将类(或对象) 与方法名分隔开来。</p>\n<p>如下三种主要使用情况：</p>\n<ul>\n<li>对象::实例方法名</li>\n<li>类::静态方法名</li>\n<li>类::实例方法名</li>\n</ul>\n<h3 id=\"stream流api\"> Stream流API</h3>\n<p>1.Stream关注的是对数据的运算，与CPU打交道</p>\n<p>集合关注的是数据的存储，与内存打交道</p>\n<ol start=\"2\">\n<li></li>\n</ol>\n<p>①Stream 自己不会存储元素。</p>\n<p>②Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。</p>\n<p>③Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行</p>\n<p>3.Stream 执行流程</p>\n<p>① Stream的实例化</p>\n<p>② 一系列的中间操作（过滤、映射、...)</p>\n<p>③ 终止操作</p>\n<p>4.说明：</p>\n<p>4.1 一个中间操作链，对数据源的数据进行处理</p>\n<p>4.2 一旦执行终止操作，就执行中间操作链，并产生结果。之后，不会再被使用</p>\n<p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/Java-NewFeature/stream处理流程.png\" alt=\"image-20211017210932065\" /></p>\n<p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/Java-NewFeature/20181223012834784.png\" alt=\"操作总览\" /></p>\n<p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/Java-NewFeature/stream图.png\" alt=\"img\" /></p>\n<h4 id=\"中间操作-筛选与切片\"> 中间操作：筛选与切片</h4>\n<p>多个中间操作可以连接起来形成一个流水线，除非流水线上触发终止操作，否则中间操作不会执行任何的处理！而在终止操作时一次性全部处理，称为“惰性求值”。</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>filter(Predicate p)</td>\n<td>接收Lambda ，从流中排除某些元素</td>\n</tr>\n<tr>\n<td>distinct()</td>\n<td>筛选，通过流所生成元素的hashCode() 和equals() 去除重复元素</td>\n</tr>\n<tr>\n<td>limit(long maxSize)</td>\n<td>截断流，使其元素不超过给定数量</td>\n</tr>\n<tr>\n<td>skip(long n)</td>\n<td>跳过元素，返回一个扔掉了前n 个元素的流。若流中元素不足n 个，则返回一个空流。与limit(n)互补</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"中间操作-映射\"> 中间操作：映射</h4>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>map(Function f)</td>\n<td>接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。</td>\n</tr>\n<tr>\n<td>mapToDouble(ToDoubleFunction f)</td>\n<td>接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的DoubleStream。</td>\n</tr>\n<tr>\n<td>mapToInt(ToIntFunction f)</td>\n<td>接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的IntStream。</td>\n</tr>\n<tr>\n<td>mapToLong(ToLongFunction f)</td>\n<td>接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的LongStream。</td>\n</tr>\n<tr>\n<td>flatMap(Function f)</td>\n<td>接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流</td>\n</tr>\n<tr>\n<td>peek(Consumer c)</td>\n<td>接收一个函数作为参数，不同于map有返回值，peek无返回值</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"中间操作-排序\"> 中间操作：排序</h4>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>sorted()</td>\n<td>产生一个新流，其中按自然顺序排序</td>\n</tr>\n<tr>\n<td>sorted(Comparator com)</td>\n<td>产生一个新流，其中按比较器顺序排序</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"终止操作-匹配与查找\"> 终止操作：匹配与查找</h4>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>allMatch(Predicate p)</td>\n<td>检查是否匹配所有元素</td>\n</tr>\n<tr>\n<td>anyMatch(Predicate p)</td>\n<td>检查是否至少匹配一个元素</td>\n</tr>\n<tr>\n<td>noneMatch(Predicate p)</td>\n<td>检查是否没有匹配所有元素</td>\n</tr>\n<tr>\n<td>findFirst()</td>\n<td>返回第一个元素</td>\n</tr>\n<tr>\n<td>findAny()</td>\n<td>返回当前流中的任意元素</td>\n</tr>\n<tr>\n<td>count()</td>\n<td>返回流中元素总数</td>\n</tr>\n<tr>\n<td>max(Comparator c)</td>\n<td>返回流中最大值</td>\n</tr>\n<tr>\n<td>min(Comparator c)</td>\n<td>返回流中最小值</td>\n</tr>\n<tr>\n<td>forEach(Consumer c)</td>\n<td>内部迭代(使用Collection 接口需要用户去做迭代，称为外部迭代。相反，Stream API 使用内部迭代——它帮你把迭代做了)</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"终止操作-归约\"> 终止操作：归约</h4>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>reduce(T iden, BinaryOperator b)</td>\n<td>可以将流中元素反复结合起来，得到一个值。返回T</td>\n</tr>\n<tr>\n<td>reduce(BinaryOperator b)</td>\n<td>可以将流中元素反复结合起来，得到一个值。返回Optional</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>map 和reduce 的连接通常称为map-reduce 模式，因Google 用它来进行网络搜索而出名。</p>\n</blockquote>\n<ul>\n<li>Optional reduce(BinaryOperator accumulator)：第一次执行时，accumulator函数的第一个参数为流中的第一个元素，第二个参数为流中元素的第二个元素；第二次执行时，第一个参数为第一次函数执行的结果，第二个参数为流中的第三个元素；依次类推。</li>\n<li>T reduce(T identity, BinaryOperator accumulator)：流程跟上面一样，只是第一次执行时，accumulator函数的第一个参数为identity，而第二个参数为流中的第一个元素。</li>\n</ul>\n<h4 id=\"终止操作-收集\"> 终止操作：收集</h4>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>collect(Collector c)</td>\n<td>将流转换为其他形式。接收一个Collector接口的实现，用于给Stream中元素做汇总的方法</td>\n</tr>\n</tbody>\n</table>\n<p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/Java-NewFeature/Collectors1.png\" alt=\"img\" /></p>\n<p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/Java-NewFeature/Collectors2.png\" alt=\"img\" /></p>\n<h4 id=\"并行流\"> 并行流</h4>\n<p>参考</p>\n<ul>\n<li><a href=\"https://www.cnblogs.com/baidawei/p/9370048.html\" target=\"_blank\" rel=\"noopener noreferrer\">并行流</a></li>\n</ul>\n<p>注意</p>\n<ul>\n<li>在现实中，对顺序流调用 parallel 方法并不意味着流本身有任何实际的变化。它在内部实际上就是设了一个 boolean 标志，表示你想让调用 parallel 之后进行的所有操作都并行执行。</li>\n<li>类似地，你只需要对并行流调用 sequential 方法就可以把它变成顺序流。</li>\n<li>如果有多个，调用的方式是看最后一次 parallel 或 sequential从而决定整体流水线调用方式</li>\n</ul>\n<p>关于效率问题</p>\n<p>参考：<a href=\"https://blog.csdn.net/ryo1060732496/article/details/88831864\" target=\"_blank\" rel=\"noopener noreferrer\">https://blog.csdn.net/ryo1060732496/article/details/88831864</a></p>\n<h3 id=\"optional\"> Optional</h3>\n<ul>\n<li>Optional 类(java.util.Optional) 是一个容器类，它可以保存类型T的值，代表这个值存在。或者仅仅保存null，表示这个值不存在。原来用null 表示一个值不存在，现在Optional 可以更好的表达这个概念。并且可以避免空指针异常。Optional类的Javadoc描述如下：这是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。</li>\n<li>Optional提供很多有用的方法，这样我们就不用显式进行空值检测。</li>\n<li>创建Optional类对象的方法：\n<ul>\n<li><code>Optional.of(T t)</code>: 创建一个Optional 实例，t必须非空，否则抛NP异常</li>\n<li><code>Optional.empty()</code> : 创建一个空的Optional 实例</li>\n<li><code>Optional.ofNullable(T t)</code>：t可以为null</li>\n</ul>\n</li>\n<li>判断Optional容器中是否包含对象\n<ul>\n<li><code>boolean isPresent()</code> : 判断是否包含对象</li>\n<li><code>void ifPresent(Consumer&lt;? super T&gt; consumer)</code> ：如果有值，就执行Consumer接口的实现代码，并且该值会作为参数传给它。</li>\n</ul>\n</li>\n<li>获取Optional容器的对象：\n<ul>\n<li><code>T get()</code>: 如果调用对象包含值，返回该值，否则抛异常</li>\n<li><code>T orElse(T other)</code> ：如果有值则将其返回，否则返回指定的other对象。</li>\n<li><code>T orElseGet(Supplier&lt;? extends T&gt; other)</code> ：如果有值则将其返回，否则返回由Supplier接口实现提供的对象。</li>\n<li><code>T orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier)</code> ：如果有值则将其返回，否则抛出由Supplier接口实现提供的异常。</li>\n</ul>\n</li>\n</ul>\n<p>of()和get()搭配使用，ofNullable()和orElse()搭配使用</p>\n",
      "image": "https://blog-1300186248.cos.ap-shanghai.myqcloud.com/Java-NewFeature/jdk8%E6%96%B0%E7%89%B9%E6%80%A7.png",
      "date_published": "2020-11-04T17:31:40.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": []
    },
    {
      "title": "Java-String",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/java/Java-String/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/java/Java-String/",
      "summary": "Java-IO",
      "content_html": "<h2 id=\"_1-string常用方法\"> 1. String常用方法</h2>\n<blockquote>\n<ul>\n<li><a href=\"https://wiki.lifeisgg.online/archives/Java-%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB/#toc_28\" target=\"_blank\" rel=\"noopener noreferrer\">String常用方法</a></li>\n</ul>\n</blockquote>\n<h2 id=\"_2-两种方式创建的底层原理和字符串常量\"> 2. 两种方式创建的底层原理和字符串常量</h2>\n<ul>\n<li>\n<p>第一种是通过**“字面量”**赋值</p>\n<div><pre><code><span>String</span> str<span>=</span><span>\"hello\"</span>\n</code></pre>\n<div><span>1</span><br></div></div></li>\n<li>\n<p>第二种是通过<strong>new关键字创建新对象</strong>，在内存中用构造器创建新对象形式</p>\n<div><pre><code><span>String</span> str<span>=</span><span>new</span> <span>String</span><span>(</span><span>\"hello\"</span><span>)</span>\n</code></pre>\n<div><span>1</span><br></div></div></li>\n</ul>\n<h3 id=\"_2-1-案例一-通过字面量来创建string\"> 2.1 案例一：通过字面量来创建String</h3>\n<div><pre><code><span>String</span> s1 <span>=</span> <span>\"abc\"</span><span>;</span>\n<span>String</span> s2 <span>=</span> <span>\"abc\"</span><span>;</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>s1 <span>==</span> s2<span>)</span><span>;</span> <span>// True</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>s1<span>.</span><span>equals</span><span>(</span>s2<span>)</span><span>)</span><span>;</span> <span>// True</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>采用字面值的方式创建一个字符串时，JVM首先会去字符串池中查找是否存在&quot;abc&quot;这个对象，此时有两种情况</p>\n<ul>\n<li>如果不存在，则在字符串常量池中创建&quot;abc&quot;这个对象，然后将池中&quot;abc&quot;这个对象的引用地址返回给&quot;abc&quot;对象的引用s1，这样s1会指向字符串常量池中&quot;abc&quot;这个字符串对象；</li>\n<li>如果存在，则不创建任何对象，直接将池中&quot;abc&quot;这个对象的地址返回，赋给引用s2。因为s1、s2都是指向同一个字符串池中的&quot;abc&quot;对象，所以结果为true。</li>\n</ul>\n<p>当相同的字符串被创建多次，内存中只保存一份字符串常量值，这就是字符串的&quot;驻留&quot;</p>\n<h3 id=\"_2-2-案例二-通过new对象形式\"> 2.2 案例二：通过new对象形式</h3>\n<div><pre><code><span>String</span> s3 <span>=</span> <span>new</span> <span>String</span><span>(</span><span>\"xyz\"</span><span>)</span><span>;</span>\n<span>String</span> s4 <span>=</span> <span>new</span> <span>String</span><span>(</span><span>\"xyz\"</span><span>)</span><span>;</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>s3 <span>==</span> s4<span>)</span><span>;</span> <span>// False</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>s3<span>.</span><span>equals</span><span>(</span>s4<span>)</span><span>)</span><span>;</span> <span>// True</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>采用new关键字新建一个字符串对象时，JVM首先在字符串池中查找有没有&quot;xyz&quot;这个字符串对象，</p>\n<ul>\n<li>如果有：则不在池中再去创建&quot;xyz&quot;这个对象了，直接在堆中创建一个&quot;xyz&quot;字符串对象，然后将堆中的这个&quot;xyz&quot;对象的地址返回赋给引用s3，这样，s3就指向了堆中创建的这个&quot;xyz&quot;字符串对象；</li>\n<li>如果没有：则首先在字符串池中创建一个&quot;xyz&quot;字符串对象，然后再在堆中创建一个&quot;xyz&quot;字符串对象，然后将堆中这个&quot;xyz&quot;字符串对象的地址返回赋给s3引用，这样，s3指向了堆中创建的这个&quot;xyz&quot;字符串对象。s4则指向了堆中创建的另一个&quot;xyz&quot;字符串对象。s3 、s4是两个指向不同对象的引用，结果当然是false。</li>\n</ul>\n<h3 id=\"_2-3-案例三-创建了多少对象\"> 2.3 案例三：创建了多少对象</h3>\n<div><pre><code> <span>String</span> s <span>=</span> <span>new</span> <span>String</span><span>(</span>“xyz”<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>产生几个对象？一个或两个，如果常量池中原来没有 ”xyz”, 就是两个。</p>\n<ul>\n<li>常量池中没有 <code>”xyz”</code>：就先去字符串常量池创建，然后再去堆中创建实例，所以会创建两个对象</li>\n<li>常量池中有 <code>”xyz”</code>：就直接去堆中创建实例，所以会创建一个对象</li>\n</ul>\n<h2 id=\"_3-intern的实现原理-jdk1-8\"> 3. intern的实现原理（JDK1.8）</h2>\n<p>参考</p>\n<blockquote>\n<ul>\n<li>https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html</li>\n</ul>\n</blockquote>\n<div><pre><code><span>public</span> <span>native</span> <span>String</span> <span>intern</span><span>(</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"_3-1-jdk6的intern\"> 3.1 JDK6的intern()</h3>\n<p><img src=\"./images/Java-String/jdk6_intern.png\" alt=\"\" /></p>\n<h3 id=\"_3-2-jdk7的intern\"> 3.2 JDK7的intern()</h3>\n<p><img src=\"./images/Java-String/jdk7_intern.png\" alt=\"\" /></p>\n<p>这个方法是一个 <code>native</code> 的方法，但注释写的非常明了。当调用 intern方法时：</p>\n<ul>\n<li>如果字符串常量池已经包含一个等于此String对象的字符串（值比较用equals(oject)方法确定），则返回池中的字符串对象的地址。</li>\n<li>如果不包含，将此String对象添加到字符串常量池中为新的String对象，并返回字符串常量池中此新的String对象的引用</li>\n</ul>\n<p>JDK 1.7后，intern方法还是会先去查询常量池中是否有已经存在，如果存在，则返回常量池中的引用，这一点与之前没有区别，区别在于，<strong>如果在常量池找不到对应的字符串，则不会再将字符串拷贝到常量池，而只是在常量池中生成一个对原字符串的引用简单的说，就是往常量池放的东西变了：原来在常量池中找不到时，复制一个副本放到常量池，1.7后则是将在堆上的地址引用复制到常量池。</strong></p>\n<h3 id=\"_3-3-举例\"> 3.3 举例</h3>\n<div><pre><code><span>String</span> str2 <span>=</span> <span>new</span> <span>String</span><span>(</span><span>\"str\"</span><span>)</span> <span>+</span> <span>new</span> <span>String</span><span>(</span><span>\"01\"</span><span>)</span><span>;</span><span>//创建了\"str\"和\"01\"常量，但是没有创建\"str01\"常量</span>\nstr2<span>.</span><span>intern</span><span>(</span><span>)</span><span>;</span>\n<span>String</span> str1 <span>=</span> <span>\"str01\"</span><span>;</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>str2<span>==</span>str1<span>)</span><span>;</span><span>//true</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><blockquote>\n<ol>\n<li>第一行：字符串常量池中生成&quot;str&quot;和&quot;01&quot;，在堆中创建两个String对象，相加后返回在堆为&quot;str01&quot;的新的String对象的引用，<strong>此时常量池没有&quot;str01&quot;对象，只有&quot;str&quot;和&quot;01&quot;</strong></li>\n<li>第二行：调用intern()后，由于字符串常量池中不存在&quot;str01&quot;，所以复制str2地址引用到字符串常量池(1.7后的改动)</li>\n<li>第三行：由于字符串常量池中已存在&quot;str01&quot;，所以str1指向已存在的，即st2所指向的对象</li>\n<li>第四行：两个指向同一个对象所以结果为true</li>\n</ol>\n</blockquote>\n<div><pre><code><span>String</span> str2 <span>=</span> <span>new</span> <span>String</span><span>(</span><span>\"str\"</span><span>)</span><span>+</span><span>new</span> <span>String</span><span>(</span><span>\"01\"</span><span>)</span><span>;</span>\n<span>String</span> str1 <span>=</span> <span>\"str01\"</span><span>;</span>\nstr2<span>.</span><span>intern</span><span>(</span><span>)</span><span>;</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>str2<span>==</span>str1<span>)</span><span>;</span><span>//false</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><blockquote>\n<ol>\n<li>第一行：字符串常量池中生成&quot;str&quot;和&quot;01&quot;，在堆中创建两个String对象，相加后返回值为&quot;str01&quot;的新的String对象</li>\n<li>第二行：由于字符串常量池不存在&quot;str01&quot;，所以此时在字符串常量池中创建新的对象</li>\n<li>第三行：由于已经存在&quot;str01&quot;，所以不会把str2地址引用到字符串常量池，而是返回已经存在的&quot;str01&quot;对象的地址</li>\n<li>第四行：由于str1指向字符串常量池对象，str2指向堆中的对象，所以返回false</li>\n</ol>\n</blockquote>\n<h2 id=\"_4-字符串相加原理\"> 4. 字符串相加原理</h2>\n<p>参考</p>\n<blockquote>\n<ul>\n<li>https://blog.csdn.net/u010775025/article/details/86507090</li>\n</ul>\n</blockquote>\n<h3 id=\"_4-1-三种情况\"> 4.1 三种情况</h3>\n<ul>\n<li>两个或者两个以上的字符串常量相加，在预编译的时候“+”会被优化，相当于把字符串常量自动合成一个字符串常量</li>\n<li>字符串对象的+操作其本质是new了StringBuilder对象进行append操作，拼接后调用toString()返回String对象</li>\n<li><code>final</code>修饰的String在相加的时候等同于<code>字符串常量</code>直接相加，在编译后会直接替换成对应的值</li>\n</ul>\n<div><pre><code><span>String</span> s1 <span>=</span> <span>\"Programming\"</span><span>;</span>\n<span>String</span> s2 <span>=</span> <span>new</span> <span>String</span><span>(</span><span>\"Programming\"</span><span>)</span><span>;</span>\n<span>String</span> s3 <span>=</span> <span>\"Program\"</span><span>;</span>\n<span>String</span> s4 <span>=</span> <span>\"ming\"</span><span>;</span>\n<span>String</span> s5 <span>=</span> <span>\"Program\"</span> <span>+</span> <span>\"ming\"</span><span>;</span>\n<span>String</span> s6 <span>=</span> s3 <span>+</span> s4<span>;</span>\n<span>String</span> s7 <span>=</span> s3 <span>+</span> <span>\"ming\"</span><span>;</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>s1 <span>==</span> s2<span>)</span><span>;</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>s1 <span>==</span> s5<span>)</span><span>;</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>s1 <span>==</span> s6<span>)</span><span>;</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>s1 <span>==</span> s7<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><ul>\n<li>\n<p>**常量相加：**全都是常量相加时，会在字符串常量池创建新对象，不会在堆中创建新的对象</p>\n<p><img src=\"./images/Java-String/String_addition_bytecode.png\" alt=\"String相加字节码\" /></p>\n<p>第20~22行，我们通过对比知道，String s5 = &quot;Program&quot; + &quot;ming&quot;;在被编译器优化成了String s5 = &quot;Programming&quot;;</p>\n<p>也可以得出字符串常量相加，不会用到<code>StringBuilder</code>对象，有一点要注意的是：字符串常量和字符串是不同的概念，字符串常量储存于方法区，而字符串储存于堆(heap)。</p>\n</li>\n<li>\n<p>包含String对象的相加：操作其本质是new了StringBuilder对象进行append操作，拼接后调用toString()返回新的String对象</p>\n<p><img src=\"./images/Java-String/String_addition_bytecode_2.png\" alt=\"String相加字节码\" /></p>\n<blockquote>\n<ol>\n<li>第24行：使用new 了 StringBuider对象</li>\n<li>第25行：进行StringBuider对象初始化</li>\n<li>第26行：使用append() 方法拼接s3的内容</li>\n<li>第27行：再使用append() 方法拼接s4的内容</li>\n<li>第28行：最后调用toString() 返回String对象</li>\n</ol>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"_4-2-特殊情况\"> 4.2 特殊情况</h3>\n<div><pre><code><span>String</span> s2 <span>=</span> <span>new</span> <span>StringBuilder</span><span>(</span><span>\"ja\"</span><span>)</span><span>.</span><span>append</span><span>(</span><span>\"va\"</span><span>)</span><span>.</span><span>toString</span><span>(</span><span>)</span><span>;</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>s2<span>.</span><span>intern</span><span>(</span><span>)</span> <span>==</span> s2<span>)</span><span>;</span><span>//false</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>常理认为，在执行<code>s2.intern()</code>时，由于字符串常量池中不存在，所以会复制引用s2到字符串常量池中去，最后对比指向同一个对象地址为<code>true</code>，但事实上<code>&quot;java&quot;</code>这个字符串在执行此语句之前，字符串常量池中已经存在此字符串</p>\n<h2 id=\"_5-stringbuffer-和-stringbuilder\"> 5. StringBuffer 和 StringBuilder</h2>\n<blockquote>\n<p>String StringBuffer 和 StringBuilder 的区别是什么? String 为什么是不可变的?</p>\n</blockquote>\n<h3 id=\"_5-1-java-string-类-string字符串常量\"> 5.1 Java String 类：String字符串常量</h3>\n<p>需要注意的是，String的值是不可变的，这就导致每次对String的操作都会生成<strong>新的String对象</strong>，这样不仅效率低下，而且大量浪费有限的内存空间。我们来看一下这张对String操作时内存变化的图：</p>\n<p><img src=\"./images/Java-String/String_immutable.png\" alt=\"String不可变\" /></p>\n<p>我们可以看到，初始String值为“hello”，然后在这个字符串后面加上新的字符串“world”，这个过程是需要重新在栈堆内存中开辟内存空间的，最终得到了“hello world”字符串也相应的需要开辟内存空间，<strong>这样短短的两个字符串，却需要开辟三次内存空间</strong>，不得不说这是对内存空间的<strong>极大浪费</strong>。为了应对经常性的字符串相关的操作，就需要使用Java提供的其他两个操作字符串的类——StringBuffer类和StringBuild类来对此种变化字符串进行处理。</p>\n<h3 id=\"_5-2-stringbuffer-和-stringbuilder-类-stringbuffer、stringbuilder字符串变量\"> 5.2 StringBuffer 和 StringBuilder 类——StringBuffer、StringBuilder字符串变量</h3>\n<p><img src=\"./images/Java-String/StringBuffer&StringBuilder_3.png\" alt=\"\" /></p>\n<p>当对字符串进行修改的时候，需要使用 <strong>StringBuffer(线程安全)</strong> 和 <strong>StringBuilder(线程不安全)</strong> 类。</p>\n<p>和 String 类不同的是，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象。</p>\n<p>StringBuilder 类在 Java 5 中被提出，它和 StringBuffer 之间的最大不同在于 <strong>StringBuilder 的方法不是线程安全的（不能同步访问）</strong>。</p>\n<p>由于 StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类。然而在应用程序要求线程安全的情况下，则必须使用 StringBuffer 类。</p>\n<p><img src=\"./images/Java-String/String_inheritance_structure.png\" alt=\"String继承结构\" /></p>\n<h3 id=\"_5-3-区别\"> 5.3 区别</h3>\n<ul>\n<li>**String：**不可变字符串；</li>\n<li>**StringBuffer：**可变字符串、效率低、线程安全；</li>\n<li>**StringBuilder：**可变字符序列、效率高、线程不安全；</li>\n</ul>\n<p>初始化上的区别，String可以空赋值，后者不行，报错</p>\n<p><img src=\"./images/Java-String/StringBuffer&StringBuilder.png\" alt=\"\" /></p>\n<p><img src=\"./images/Java-String/StringBuffer&StringBuilder_2.png\" alt=\"\" /></p>\n",
      "date_published": "2020-11-25T23:10:27.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": []
    },
    {
      "title": "Java-UML类图",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/java/Java-UML-ClassDiagram/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/java/Java-UML-ClassDiagram/",
      "content_html": "<h2 id=\"参考\"> 参考</h2>\n<div><p>参考</p>\n<ul>\n<li>http://c.biancheng.net/view/1319.html</li>\n<li>https://www.jianshu.com/p/57620b762160</li>\n</ul>\n</div>\n<h2 id=\"_1-类、接口和类图\"> 1. 类、接口和类图</h2>\n<h3 id=\"_1-1-类\"> 1.1 类</h3>\n<p>类（Class）是指具有相同属性、方法和关系的对象的抽象，它封装了数据和行为，是面向对象程序设计（OOP）的基础，具有封装性、继承性和多态性等三大特性。在 UML 中，类使用包含类名、属性和操作且带有分隔线的矩形来表示。</p>\n<div><p>注意</p>\n<p>_下划线表示static\n斜体表示抽象</p>\n</div>\n<p>(1) 类名（Name）是一个字符串，例如，Student。</p>\n<p>(2) 属性（Attribute）是指类的特性，即类的成员变量。UML 按以下格式表示：</p>\n<div><pre><code>[可见性]属性名:类型[=默认值]\n-name:String\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>可见性</p>\n<div><p>可见性</p>\n<ul>\n<li>+：公有（Public）</li>\n<li>-：私有（Private）</li>\n<li>#：受保护（Protected）</li>\n<li>~：包权限（Default）</li>\n</ul>\n</div>\n<p>(3) 操作（Operations）是类的任意一个实例对象都可以使用的行为，是类的成员方法。UML 按以下格式表示：</p>\n<div><pre><code>[可见性]名称(参数列表)[:返回类型]\n+display():void\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>图 1 所示是学生类的 UML 表示。</p>\n<p><img src=\"./images/Java-UML-ClassDiagram/Student_class.gif\" alt=\"学生类的 UML 表示\" /></p>\n<h3 id=\"_1-2-接口\"> 1.2 接口</h3>\n<p>接口（Interface）是一种特殊的类，它具有类的结构但不可被实例化，只可以被子类实现。它包含抽象操作，但不包含属性。它描述了类或组件对外可见的动作。在 UML 中，接口使用一个带有名称的小圆圈来进行表示。</p>\n<p>图 2 所示是图形类接口的 UMDL 表示。</p>\n<p><img src=\"./images/Java-UML-ClassDiagram/Graph_interface.gif\" alt=\"Graph接口\" /></p>\n<h3 id=\"_1-3-类图\"> 1.3 类图</h3>\n<p>类图（ClassDiagram）是用来显示系统中的类、接口、协作以及它们之间的静态结构和关系的一种静态模型。它主要用于描述软件系统的结构化设计，帮助人们简化对软件系统的理解，它是系统分析与设计阶段的重要产物，也是系统编码与测试的重要模型依据。</p>\n<p>类图中的类可以通过某种编程 语言直接实现。类图在软件系统开发的整个生命周期都是有效的，它是面向对象系统的建模中最常见的图。图 3 所示是“计算长方形和圆形的周长与面积”的类图，图形接口有计算面积和周长的抽象方法，长方形和圆形实现这两个方法供访问类调用。</p>\n<p><img src=\"./images/Java-UML-ClassDiagram/ClassDiagram.gif\" alt=\"计算长方形和圆形的周长与面积的类图\" /></p>\n<h2 id=\"_2-类之间的关系\"> 2. 类之间的关系</h2>\n<p>在软件系统中，类不是孤立存在的，类与类之间存在各种关系。根据类与类之间的耦合度从弱到强排列，UML 中的类图有以下几种关系：依赖关系、关联关系、聚合关系、组合关系、泛化关系和实现关系。其中泛化和实现的耦合度相等，它们是最强的。</p>\n<div><p>关系</p>\n<ul>\n<li>依赖关系</li>\n<li>泛化关系</li>\n<li>实现关系</li>\n<li>关联关系</li>\n<li>聚合关系</li>\n<li>组合关系</li>\n</ul>\n</div>\n<p><img src=\"./images/Java-UML-ClassDiagram/The_relationship_between_class_and_class.jpg\" alt=\"类之间的关系\" /></p>\n<h3 id=\"_2-1-依赖关系\"> 2.1 依赖关系</h3>\n<p><code>依赖（Dependency）</code>关系是一种使用关系，它是对象之间耦合度最弱的一种关联方式，是临时性的关联。在代码中，某个类的方法通过局部变量、方法的参数或者对静态方法的调用来访问另一个类（被依赖类）中的某些方法来完成一些职责。</p>\n<p>对于两个相对独立的对象，当一个对象负责构造另一个对象的实例，或者依赖另一个对象的服务时，这两个对象之间主要体现为依赖关系。</p>\n<p>在 UML 类图中，依赖关系使用<code>带箭头的虚线</code>来表示，箭头从使用类指向被依赖的类。图 4 所示是人与手机的关系图，人通过手机的语音传送方法打电话。</p>\n<p>表示方式</p>\n<div><p>表示方式</p>\n<p><strong>带箭头的虚线</strong></p>\n</div>\n<p><img src=\"./images/Java-UML-ClassDiagram/Dependency.gif\" alt=\"计算长方形和圆形的周长与面积的类图\" /></p>\n<p>动物依赖氧气和水。调用新陈代谢方法需要氧气类与水类的实例作为参数</p>\n<p><img src=\"./images/Java-UML-ClassDiagram/Dependency_2.jpg\" alt=\"计算长方形和圆形的周长与面积的类图2\" /></p>\n<h3 id=\"_2-2-泛化关系\"> 2.2 泛化关系</h3>\n<p><code>泛化（Generalization）</code>关系是对象之间耦合度最大的一种关系，表示一般与特殊的关系，是父类与子类之间的关系，是一种继承关系，是 is-a 的关系。</p>\n<p>在 UML 类图中，泛化关系用带空心三角箭头的实线来表示，箭头从子类指向父类。在代码实现时，使用面向对象的继承机制来实现泛化关系。例如，Student 类和 Teacher 类都是 Person 类的子类，其类图如图 8 所示。</p>\n<p>表示方式</p>\n<div><p>表示方式</p>\n<p><strong>空心三角形+实线</strong></p>\n</div>\n<p><img src=\"./images/Java-UML-ClassDiagram/Generalization.gif\" alt=\"泛化关系\" /></p>\n<p>鸟类继承抽象类动物</p>\n<p><img src=\"./images/Java-UML-ClassDiagram/Generalization_2.jpg\" alt=\"泛化关系\" /></p>\n<h3 id=\"_2-3-实现关系\"> 2.3 实现关系</h3>\n<p><code>实现（Realization）</code>关系是接口与实现类之间的关系。在这种关系中，类实现了接口，类中的操作实现了接口中所声明的所有的抽象操作。</p>\n<p>在 UML 类图中，实现关系使用带空心三角箭头的虚线来表示，箭头从实现类指向接口。例如，汽车和船实现了交通工具，其类图如图 9 所示。</p>\n<p>表示方式</p>\n<div><p>表示方式</p>\n<p><strong>空心三角箭头+虚线</strong></p>\n</div>\n<p><img src=\"./images/Java-UML-ClassDiagram/Realization.gif\" alt=\"实现关系\" /></p>\n<h3 id=\"_2-4-关联关系\"> 2.4 关联关系</h3>\n<p><code>关联（Association）</code>关系是对象之间的一种引用关系，用于表示一类对象与另一类对象之间的联系，如老师和学生、师傅和徒弟、丈夫和妻子等。关联关系是类与类之间最常用的一种关系，分为:</p>\n<blockquote>\n<ul>\n<li>一般关联关系</li>\n<li>聚合关系</li>\n<li>组合关系。</li>\n</ul>\n</blockquote>\n<p>我们先介绍<code>一般关联</code>。</p>\n<p>关联可以是双向的，也可以是单向的。在 UML 类图中，双向的关联可以用带两个箭头或者没有箭头的实线来表示，单向的关联用带一个箭头的实线来表示，箭头从使用类指向被关联的类。也可以在关联线的两端标注角色名，代表两种不同的角色。</p>\n<p>对于两个相对独立的对象，当一个对象的实例与另一个对象的一些特定实例<code>存在固定的对应关系</code>时，这两个对象之间为关联关系。</p>\n<p>在代码中通常将一个类的对象作为另一个类的成员变量来实现关联关系。图 5 所示是老师和学生的关系图，<code>每个老师可以教多个学生，每个学生也可向多个老师学</code>，他们是双向关联。</p>\n<p>表示方式</p>\n<div><p>表示方式</p>\n<p><strong>带箭头的实线</strong></p>\n</div>\n<p><img src=\"./images/Java-UML-ClassDiagram/Association.gif\" alt=\"一般关联\" /></p>\n<p>企鹅需要‘知道’气候的变化，需要‘了解’气候规律。当一个类‘知道’另一个类时，可以用关联。</p>\n<p><img src=\"./images/Java-UML-ClassDiagram/Association_2.jpg\" alt=\"一般关联\" /></p>\n<h3 id=\"_2-5-聚合关系\"> 2.5 聚合关系</h3>\n<p><code>聚合（Aggregation）</code>关系是关联关系的一种，是强关联关系，是整体和部分之间的关系，是 has-a 的关系。</p>\n<p>聚合关系也是通过成员对象来实现的，其中成员对象是整体对象的一部分，但是成员对象可以脱离整体对象而独立存在。例如，学校与老师的关系，学校包含老师，但如果学校停办了，老师依然存在。</p>\n<p>在 UML 类图中，聚合关系可以用带<code>空心菱形的实线</code>来表示，<code>空心菱形</code>指向<code>整体</code>。图 6 所示是大学和教师的关系图。</p>\n<p>表示方式</p>\n<div><p>表示方式</p>\n<p><strong>空心菱形的实线</strong></p>\n</div>\n<p><img src=\"./images/Java-UML-ClassDiagram/Aggregation.gif\" alt=\"聚合关系\" /></p>\n<p>每一只大雁都属于一个大雁群，一个大雁群可以有多只大雁。当大雁死去后大雁群并不会消失，两个对象生命周期不同。</p>\n<p><img src=\"./images/Java-UML-ClassDiagram/Aggregation_2.jpg\" alt=\"聚合关系\" /></p>\n<h3 id=\"_2-6-组合关系\"> 2.6 组合关系</h3>\n<p><code>组合（Composition）</code>关系也是关联关系的一种，也表示类之间的整体与部分的关系，但它是一种更强烈的聚合关系，是 cxmtains-a 关系。</p>\n<p>在组合关系中，整体对象可以控制部分对象的生命周期，一旦整体对象不存在，部分对象也将不存在，部分对象不能脱离整体对象而存在。例如，头和嘴的关系，没有了头，嘴也就不存在了。</p>\n<p>在 UML 类图中，组合关系用带<code>实心菱形的实线</code>来表示，<code>实心菱形</code>指向<code>整体</code>。图 7 所示是头和嘴的关系图。</p>\n<p>表示方式</p>\n<div><p>表示方式</p>\n<p><strong>实心菱形+实线</strong></p>\n</div>\n<p><img src=\"./images/Java-UML-ClassDiagram/Composition.gif\" alt=\"组合关系\" /></p>\n<p>鸟和翅膀就是组合关系，因为它们是部分和整体的关系，并且翅膀和鸟的生命周期是相同的。</p>\n<p><img src=\"./images/Java-UML-ClassDiagram/Composition_2.jpg\" alt=\"组合关系\" /></p>\n",
      "date_published": "2020-12-20T16:24:28.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": []
    },
    {
      "title": "Java-注解和反射",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/java/Java-annotation&reflection/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/java/Java-annotation&reflection/",
      "content_html": "<h2 id=\"参考\"> 参考</h2>\n<blockquote>\n<ul>\n<li>https://blog.csdn.net/huangliniqng/article/details/88554510</li>\n<li>https://www.jianshu.com/p/9be58ee20dee</li>\n</ul>\n</blockquote>\n<h2 id=\"注解\"> 注解</h2>\n<p>所有的注解类型都继承自这个普通的接口（Annotation）</p>\n<p>这句话有点抽象，但却说出了注解的本质。我们看一个 JDK 内置注解的定义：</p>\n<div><pre><code><span>@Target</span><span>(</span><span>ElementType</span><span>.</span>METHOD<span>)</span>\n<span>@Retention</span><span>(</span><span>RetentionPolicy</span><span>.</span>SOURCE<span>)</span>\n<span>public</span> <span>@interface</span> <span>Override</span> <span>{</span>\n\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>这是注解 @Override 的定义，其实它本质上就是：</p>\n<div><pre><code><span>public</span> <span>interface</span> <span>Override</span> <span>extends</span> <span>Annotation</span><span>{</span>\n    \n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id=\"内置注解\"> 内置注解</h3>\n<ul>\n<li>@Override - 检查该方法是否是重写方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。</li>\n<li>@Deprecated - 标记过时方法。如果使用该方法，会报编译警告。</li>\n<li>@SuppressWarnings - 指示编译器去忽略注解中声明的警告。</li>\n</ul>\n<h3 id=\"元注解\"> 元注解</h3>\n<p>定义在注解上的注解</p>\n<ul>\n<li>@Retention：注解的生命周期</li>\n<li>@Documented：注解是否应当被包含在 JavaDoc 文档中</li>\n<li>@Target：注解的作用目标范围，例如方法，类</li>\n<li>@Inherited：是否允许子类继承该注解</li>\n</ul>\n<p>@Target</p>\n<ul>\n<li>ElementType.TYPE：允许被修饰的注解作用在类、接口和枚举上</li>\n<li>ElementType.FIELD：允许作用在属性字段上</li>\n<li>ElementType.METHOD：允许作用在方法上</li>\n<li>ElementType.PARAMETER：允许作用在方法参数上</li>\n<li>ElementType.CONSTRUCTOR：允许作用在构造器上</li>\n<li>ElementType.LOCAL_VARIABLE：允许作用在本地局部变量上</li>\n<li>ElementType.ANNOTATION_TYPE：允许作用在注解上</li>\n<li>ElementType.PACKAGE：允许作用在包上</li>\n</ul>\n<div><pre><code><span>public</span> <span>enum</span> <span>ElementType</span> <span>{</span>\n    <span>/** Class, interface (including annotation type), or enum declaration */</span>\n    TYPE<span>,</span>\n\n    <span>/** Field declaration (includes enum constants) */</span>\n    FIELD<span>,</span>\n\n    <span>/** Method declaration */</span>\n    METHOD<span>,</span>\n\n    <span>/** Formal parameter declaration */</span>\n    PARAMETER<span>,</span>\n\n    <span>/** Constructor declaration */</span>\n    CONSTRUCTOR<span>,</span>\n\n    <span>/** Local variable declaration */</span>\n    LOCAL_VARIABLE<span>,</span>\n\n    <span>/** Annotation type declaration */</span>\n    ANNOTATION_TYPE<span>,</span>\n\n    <span>/** Package declaration */</span>\n    PACKAGE<span>,</span>\n\n    <span>/**\n     * Type parameter declaration\n     *\n     * @since 1.8\n     */</span>\n    TYPE_PARAMETER<span>,</span>\n\n    <span>/**\n     * Use of a type\n     *\n     * @since 1.8\n     */</span>\n    TYPE_USE\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br></div></div><p>@Retention</p>\n<p>RUNTIME&gt;CLASS&gt;SOURCE</p>\n<ul>\n<li>SOURCE：注解将被编译器丢弃（该类型的注解信息只会保留在源码里，源码经过编译后，注解信息会被丢弃，不会保留在编译好的class文件里）</li>\n<li>CLASS：注解在class文件中可用，但会被VM丢弃（该类型的注解信息会保留在源码里和class文件里，在执行的时候，不会加载到虚拟机中），请注意，当注解未定义Retention值时，默认值是CLASS，如Java内置注解，@Override、@Deprecated、@SuppressWarnning等</li>\n<li>RUNTIME：注解信息将在运行期(JVM)也保留，因此可以通过反射机制读取注解的信息（源码、class文件和执行的时候都有注解的信息），如SpringMvc中的@Controller、@Autowired、@RequestMapping等。</li>\n</ul>\n<h3 id=\"自定义注解\"> 自定义注解</h3>\n<p>使用@interface，在定义注解时，不能继承其他的注解或接口。</p>\n<div><pre><code><span>@Retention</span><span>(</span><span>RetentionPolicy</span><span>.</span>RUNTIME<span>)</span>\n<span>@Target</span><span>(</span><span>{</span><span>ElementType</span><span>.</span>METHOD<span>,</span> <span>ElementType</span><span>.</span>TYPE<span>}</span><span>)</span>\n<span>@Documented</span>\n<span>@Inherited</span>\n<span>public</span> <span>@interface</span> <span>MyAnnotation</span> <span>{</span>\n\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><ul>\n<li>方法就是声明配置参数，方法名就是参数名称</li>\n<li>方法返回值为参数类型，只能是基本类型以及String，enum，Class，数组</li>\n<li>只有一个方法时指定为value在使用注解时可以省略名称</li>\n</ul>\n<h2 id=\"反射\"> 反射</h2>\n<p>JAVA反射机制是在运行状态中</p>\n<blockquote>\n<ul>\n<li>对于任意一个类，都能够知道这个类的所有属性和方法；</li>\n<li>对于任意一个对象，都能够调用它的任意方法和属性；</li>\n</ul>\n</blockquote>\n<p>这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。</p>\n<h3 id=\"优缺点\"> 优缺点</h3>\n<ul>\n<li>优点：实现动态创建对象和编译</li>\n<li>缺点：对性能有影响。使用反射基本上是一种解释操作,我们可以告诉JM,我们希望做什么并且它满足我们的要求。这类操作总是慢于直接执行相同的操作</li>\n</ul>\n<h3 id=\"用途\"> 用途</h3>\n<p>参考</p>\n<blockquote>\n<ul>\n<li><a href=\"https://www.jianshu.com/p/3fd80b251399\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.jianshu.com/p/3fd80b251399</a></li>\n</ul>\n</blockquote>\n<p>在日常的第三方应用开发过程中，经常会遇到某个类的某个成员变量、方法或是属性是私有的或是只对系统应用开放，这时候就可以利用Java的反射机制通过反射来获取所需的私有成员或是方法。当然，也不是所有的都适合反射，之前就遇到一个案例，通过反射得到的结果与预期不符。阅读源码发现，经过层层调用后在最终返回结果的地方对应用的权限进行了校验，对于没有权限的应用返回值是没有意义的缺省值，否则返回实际值起到保护用户的隐私目的。</p>\n<h3 id=\"常用方法\"> 常用方法</h3>\n<p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/Java-annotation&reflection/反射常用方法.png\" alt=\"image-20211123185734399\" /></p>\n<p>通过setAccessible方法解除限制为public</p>\n<h3 id=\"反射机制的相关类\"> 反射机制的相关类</h3>\n<p>类名 用途   Class类 代表类的实体，在运行的Java应用程序中表示类和接口  Field类 代表类的成员变量（成员变量也称为类的属性）  Method类 代表类的方法  Constructor类 代表类的构造方法</p>\n<table>\n<thead>\n<tr>\n<th><strong>类名</strong></th>\n<th><strong>用途</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Class类</td>\n<td>代表类的实体，在运行的Java应用程序中表示类和接口</td>\n</tr>\n<tr>\n<td>Field类</td>\n<td>代表类的成员变量（成员变量也称为类的属性）</td>\n</tr>\n<tr>\n<td>Method类</td>\n<td>代表类的方法</td>\n</tr>\n<tr>\n<td>Constructor类</td>\n<td>代表类的构造方法</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"常见类型的类举例\"> 常见类型的类举例</h3>\n<div><pre><code><span>@Test</span>\n<span>public</span> <span>void</span> <span>allClassTest</span><span>(</span><span>)</span><span>{</span>\n\n    <span>List</span><span><span>&lt;</span><span>Class</span><span>></span></span> classList <span>=</span> <span>Lists</span><span>.</span><span>newArrayList</span><span>(</span><span>)</span><span>;</span>\n    classList<span>.</span><span>add</span><span>(</span><span>Object</span><span>.</span><span>class</span><span>)</span><span>;</span><span>//类</span>\n    classList<span>.</span><span>add</span><span>(</span><span>Comparable</span><span>.</span><span>class</span><span>)</span><span>;</span><span>//接口</span>\n    classList<span>.</span><span>add</span><span>(</span><span>String</span><span>[</span><span>]</span><span>.</span><span>class</span><span>)</span><span>;</span><span>//数组</span>\n    classList<span>.</span><span>add</span><span>(</span><span>int</span><span>[</span><span>]</span><span>.</span><span>class</span><span>)</span><span>;</span><span>//不同类型数组</span>\n    classList<span>.</span><span>add</span><span>(</span><span>int</span><span>[</span><span>]</span><span>[</span><span>]</span><span>.</span><span>class</span><span>)</span><span>;</span><span>//不同维度数组</span>\n    classList<span>.</span><span>add</span><span>(</span><span>Override</span><span>.</span><span>class</span><span>)</span><span>;</span><span>//注解</span>\n    classList<span>.</span><span>add</span><span>(</span><span>ElementType</span><span>.</span><span>class</span><span>)</span><span>;</span><span>//枚举</span>\n    classList<span>.</span><span>add</span><span>(</span><span>Integer</span><span>.</span><span>class</span><span>)</span><span>;</span><span>//包装类型</span>\n    classList<span>.</span><span>add</span><span>(</span><span>void</span><span>.</span><span>class</span><span>)</span><span>;</span><span>//void</span>\n    classList<span>.</span><span>add</span><span>(</span> <span>Class</span><span>.</span><span>class</span><span>)</span><span>;</span><span>//Class</span>\n    classList<span>.</span><span>forEach</span><span>(</span><span>System</span><span>.</span>out<span>::</span><span>println</span><span>)</span><span>;</span>\n    <span>//class java.lang.Object</span>\n    <span>//interface java.lang.Comparable</span>\n    <span>//class [Ljava.lang.String;</span>\n    <span>//class [I</span>\n    <span>//class [[I</span>\n    <span>//interface java.lang.Override</span>\n    <span>//class java.lang.annotation.ElementType</span>\n    <span>//class java.lang.Integer</span>\n    <span>//void</span>\n    <span>//class java.lang.Class</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><h3 id=\"class类\"> Class类</h3>\n<p>Class代表类的实体，在运行的Java应用程序中表示类和接口。在这个类中提供了很多有用的方法，这里对他们简单的分类介绍。</p>\n<h4 id=\"获取方式\"> 获取方式</h4>\n<div><pre><code><span>@Test</span>\n<span>public</span> <span>void</span> <span>reflectTest</span><span>(</span><span>)</span> <span>throws</span> <span>ClassNotFoundException</span> <span>{</span>\n    <span>ReflectTest</span> reflectTest <span>=</span> <span>new</span> <span>ReflectTest</span><span>(</span><span>)</span><span>;</span>\n    <span>//三种获取Class,获取的都是单例的class对象</span>\n    <span>Class</span> clz_1 <span>=</span> <span>ReflectTest</span><span>.</span><span>class</span><span>;</span>\n    <span>Class</span> clz_2 <span>=</span> reflectTest<span>.</span><span>getClass</span><span>(</span><span>)</span><span>;</span>\n    <span>Class</span> clz_3 <span>=</span> <span>Class</span><span>.</span><span>forName</span><span>(</span><span>\"annotationAndReflect.ReflectTest\"</span><span>)</span><span>;</span>\n\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h4 id=\"类相关的方法\"> 类相关的方法</h4>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>用途</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>asSubclass(Class&lt;U&gt; clazz)</td>\n<td>把传递的类的对象转换成代表其子类的对象</td>\n</tr>\n<tr>\n<td>Cast</td>\n<td>把对象转换成代表类或是接口的对象</td>\n</tr>\n<tr>\n<td>getClassLoader()</td>\n<td>获得类的加载器</td>\n</tr>\n<tr>\n<td>getClasses()</td>\n<td>返回一个数组，数组中包含该类中所有公共类和接口类的对象</td>\n</tr>\n<tr>\n<td>getDeclaredClasses()</td>\n<td>返回一个数组，数组中包含该类中所有类和接口类的对象</td>\n</tr>\n<tr>\n<td>forName(String className)</td>\n<td>根据类名返回类的对象</td>\n</tr>\n<tr>\n<td>getName()</td>\n<td>获得类的完整路径名字</td>\n</tr>\n<tr>\n<td>newInstance()</td>\n<td>创建类的实例</td>\n</tr>\n<tr>\n<td>getPackage()</td>\n<td>获得类的包</td>\n</tr>\n<tr>\n<td>getSimpleName()</td>\n<td>获得类的名字</td>\n</tr>\n<tr>\n<td>getSuperclass()</td>\n<td>获得当前类继承的父类的名字</td>\n</tr>\n<tr>\n<td>getInterfaces()</td>\n<td>获得当前类实现的类或是接口</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"类中构造器相关的方法\"> 类中构造器相关的方法</h4>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>用途</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>getConstructor(Class...&lt;?&gt; parameterTypes)</td>\n<td>获得该类中与参数类型匹配的公有构造方法</td>\n</tr>\n<tr>\n<td>getConstructors()</td>\n<td>获得该类的所有公有构造方法</td>\n</tr>\n<tr>\n<td>getDeclaredConstructor(Class...&lt;?&gt; parameterTypes)</td>\n<td>获得该类中与参数类型匹配的构造方法</td>\n</tr>\n<tr>\n<td>getDeclaredConstructors()</td>\n<td>获得该类所有构造方法</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"类中方法相关的方法\"> 类中方法相关的方法</h4>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>用途</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>getMethod(String name, Class...&lt;?&gt; parameterTypes)</td>\n<td>获得该类某个公有的方法</td>\n</tr>\n<tr>\n<td>getMethods()</td>\n<td>获得该类所有公有的方法</td>\n</tr>\n<tr>\n<td>getDeclaredMethod(String name, Class...&lt;?&gt; parameterTypes)</td>\n<td>获得该类某个方法</td>\n</tr>\n<tr>\n<td>getDeclaredMethods()</td>\n<td>获得该类所有方法</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"类中判断类型\"> 类中判断类型</h4>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>用途</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>isAnnotation()</td>\n<td>如果是注解类型则返回true</td>\n</tr>\n<tr>\n<td>isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass)</td>\n<td>如果是指定类型注解类型则返回true</td>\n</tr>\n<tr>\n<td>isAnonymousClass()</td>\n<td>如果是匿名类则返回true</td>\n</tr>\n<tr>\n<td>isArray()</td>\n<td>如果是一个数组类则返回true</td>\n</tr>\n<tr>\n<td>isEnum()</td>\n<td>如果是枚举类则返回true</td>\n</tr>\n<tr>\n<td>isInstance(Object obj)</td>\n<td>如果obj是该类的实例则返回true</td>\n</tr>\n<tr>\n<td>isInterface()</td>\n<td>如果是接口类则返回true</td>\n</tr>\n<tr>\n<td>isLocalClass()</td>\n<td>如果是局部类则返回true</td>\n</tr>\n<tr>\n<td>isMemberClass()</td>\n<td>如果是内部类则返回true</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"field类\"> Field类</h3>\n<p><a href=\"https://developer.android.google.cn/reference/java/lang/reflect/Field\" target=\"_blank\" rel=\"noopener noreferrer\">Field</a>代表类的成员变量（成员变量也称为类的属性）。</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>用途</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>equals(Object obj)</td>\n<td>属性与obj相等则返回true</td>\n</tr>\n<tr>\n<td>get(Object obj)</td>\n<td>获得obj中对应的属性值</td>\n</tr>\n<tr>\n<td>set(Object obj, Object value)</td>\n<td>设置obj中对应属性值</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"method类\"> Method类</h3>\n<p><a href=\"https://developer.android.google.cn/reference/java/lang/reflect/Method\" target=\"_blank\" rel=\"noopener noreferrer\">Method</a>代表类的方法。</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>用途</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>invoke(Object obj, Object... args)</td>\n<td>传递object对象及参数调用该对象对应的方法</td>\n</tr>\n</tbody>\n</table>\n<p><img src=\"./images/Java-reflection/get_methods_1.png\" alt=\"\" /></p>\n<p><img src=\"./images/Java-reflection/get_methods_2.png\" alt=\"\" /></p>\n<h3 id=\"constructor类\"> Constructor类</h3>\n<p><a href=\"https://developer.android.google.cn/reference/java/lang/reflect/Constructor\" target=\"_blank\" rel=\"noopener noreferrer\">Constructor</a>代表类的构造方法。</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>用途</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>newInstance(Object... initargs)</td>\n<td>根据传递的参数创建类的对象</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"反射操作泛型\"> 反射操作泛型</h2>\n<p>参数或返回类型包含泛型</p>\n<div><pre><code><span>public</span> <span>class</span> <span>ReflectEntity</span> <span>{</span>\n    <span>public</span> <span>void</span> <span>generics</span><span>(</span><span>Map</span><span><span>&lt;</span><span>String</span><span>,</span> <span>String</span><span>></span></span> map<span>,</span> <span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> list<span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"泛型方法\"</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>Map</span><span><span>&lt;</span><span>String</span><span>,</span> <span>String</span><span>></span></span> <span>generics</span><span>(</span><span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"泛型方法2\"</span><span>)</span><span>;</span>\n        <span>return</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>操作泛型</p>\n<div><pre><code><span>//泛型方法获取</span>\n<span>@Test</span>\n<span>public</span> <span>void</span> <span>genericsTest</span><span>(</span><span>)</span> <span>throws</span> <span>NoSuchMethodException</span> <span>{</span>\n    <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> clz <span>=</span> <span>ReflectEntity</span><span>.</span><span>class</span><span>;</span>\n    <span>Method</span> method <span>=</span> clz<span>.</span><span>getDeclaredMethod</span><span>(</span><span>\"generics\"</span><span>,</span> <span>Map</span><span>.</span><span>class</span><span>,</span> <span>List</span><span>.</span><span>class</span><span>)</span><span>;</span>\n    <span>Type</span><span>[</span><span>]</span> genericParameterTypes <span>=</span> method<span>.</span><span>getGenericParameterTypes</span><span>(</span><span>)</span><span>;</span>\n    <span>Arrays</span><span>.</span><span>stream</span><span>(</span>genericParameterTypes<span>)</span><span>.</span><span>forEach</span><span>(</span>item <span>-></span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>item<span>)</span><span>;</span>\n        <span>//如果是一个参数化类型</span>\n        <span>if</span> <span>(</span>item <span>instanceof</span> <span>ParameterizedType</span><span>)</span> <span>{</span>\n            <span>//获得真实类型</span>\n            <span>Type</span><span>[</span><span>]</span> actualTypeArguments <span>=</span> <span>(</span><span>(</span><span>ParameterizedType</span><span>)</span> item<span>)</span><span>.</span><span>getActualTypeArguments</span><span>(</span><span>)</span><span>;</span>\n            <span>Arrays</span><span>.</span><span>stream</span><span>(</span>actualTypeArguments<span>)</span><span>.</span><span>forEach</span><span>(</span><span>System</span><span>.</span>out<span>::</span><span>println</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span><span>)</span><span>;</span>\n\n    method <span>=</span> clz<span>.</span><span>getDeclaredMethod</span><span>(</span><span>\"generics\"</span><span>)</span><span>;</span>\n    <span>Type</span> genericReturnType <span>=</span> method<span>.</span><span>getGenericReturnType</span><span>(</span><span>)</span><span>;</span>\n    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>genericReturnType<span>)</span><span>;</span>\n    <span>if</span> <span>(</span>genericReturnType <span>instanceof</span> <span>ParameterizedType</span><span>)</span> <span>{</span>\n        <span>//获得真实类型</span>\n        <span>Type</span><span>[</span><span>]</span> actualTypeArguments <span>=</span> <span>(</span><span>(</span><span>ParameterizedType</span><span>)</span> genericReturnType<span>)</span><span>.</span><span>getActualTypeArguments</span><span>(</span><span>)</span><span>;</span>\n        <span>Arrays</span><span>.</span><span>stream</span><span>(</span>actualTypeArguments<span>)</span><span>.</span><span>forEach</span><span>(</span><span>System</span><span>.</span>out<span>::</span><span>println</span><span>)</span><span>;</span>\n    <span>}</span>\n\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><h2 id=\"反射获取注解类型\"> 反射获取注解类型</h2>\n<div><pre><code><span>//反射操作注解</span>\n<span>@Test</span>\n<span>public</span> <span>void</span> <span>annotationTest</span><span>(</span><span>)</span> <span>throws</span> <span>NoSuchFieldException</span> <span>{</span>\n    <span>Class</span> clz <span>=</span> <span>Student</span><span>.</span><span>class</span><span>;</span>\n    <span>//获取类上注解的标记的value值</span>\n    <span>Annotation</span><span>[</span><span>]</span> declaredAnnotations <span>=</span> clz<span>.</span><span>getDeclaredAnnotations</span><span>(</span><span>)</span><span>;</span>\n    <span>Table</span> table <span>=</span> <span>(</span><span>Table</span><span>)</span> clz<span>.</span><span>getAnnotation</span><span>(</span><span>Table</span><span>.</span><span>class</span><span>)</span><span>;</span>\n    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>table<span>.</span><span>value</span><span>(</span><span>)</span><span>)</span><span>;</span>\n\n    <span>//获取字段上的</span>\n    <span>Field</span> id <span>=</span> clz<span>.</span><span>getDeclaredField</span><span>(</span><span>\"id\"</span><span>)</span><span>;</span>\n    <span>TableField</span> annotation <span>=</span> <span>(</span><span>TableField</span><span>)</span> id<span>.</span><span>getAnnotation</span><span>(</span><span>TableField</span><span>.</span><span>class</span><span>)</span><span>;</span>\n    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>annotation<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div>",
      "image": "https://blog-1300186248.cos.ap-shanghai.myqcloud.com/Java-annotation&reflection/%E5%8F%8D%E5%B0%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95.png",
      "date_published": "2021-11-22T23:08:41.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": []
    },
    {
      "title": "设计模式之行为型设计模式",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/java/java-DesignPatterns/Java-DesignPatterns-BehavioralPatterns/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/java/java-DesignPatterns/Java-DesignPatterns-BehavioralPatterns/",
      "content_html": "<h2 id=\"参考\"> 参考</h2>\n<div><p>参考</p>\n<ul>\n<li>https://www.runoob.com/design-pattern/design-pattern-intro.html</li>\n<li>http://c.biancheng.net/view/1317.html</li>\n<li><a href=\"TheZen0fDesignPattern_2.pdf\">设计模式之禅</a></li>\n</ul>\n</div>\n<h2 id=\"模板方法模式\"> 模板方法模式</h2>\n<h3 id=\"定义\"> 定义</h3>\n<p>其定义如下： Define the skeleton of an algorithm in an operation,deferring some steps to subclasses.Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithm's structure.（定义一个操作中的算法的框架，而将一些步骤延迟到子类中。使得子类可以不改 变一个算法的结构即可重定义该算法的某些特定步骤。）</p>\n<p>类图</p>\n<p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/Java-DesignPatterns-BehavioralPatterns/模板方法类图.png\" alt=\"image-20211112221050944\" /></p>\n<p>模板方法模式确实非常简单，仅仅使用了Java的继承机制，但它是一个应用非常广泛的 模式。其中，AbstractClass叫做抽象模板，它的方法分为两类：</p>\n<ul>\n<li>基本方法：基本方法也叫做基本操作，是由子类实现的方法，并且在模板方法被调用。</li>\n<li>模板方法：可以有一个或几个，一般是一个具体方法，也就是一个框架，实现对基本方法的调度， 完成固定的逻辑。</li>\n</ul>\n<h3 id=\"优点\"> 优点</h3>\n<ul>\n<li>封装不变部分，扩展可变部分：把认为是不变部分的算法封装到父类实现，而可变部分的则可以通过继承来继续扩展。 在悍马模型例子中，是不是就非常容易扩展？例如增加一个H3型号的悍马模型，很容易 呀，增加一个子类，实现父类的基本方法就可以了。</li>\n<li>提取公共部分代码，便于维护：我们例子中刚刚走过的弯路就是最好的证明，如果我们不抽取到父类中，任由这种散乱 的代码发生，想想后果是什么样子？维护人员为了修正一个缺陷，需要到处查找类似的代 码！</li>\n<li>行为由父类控制，子类实现：基本方法是由子类实现的，因此子类可以通过扩展的方式增加相应的功能，符合开闭原则。</li>\n</ul>\n<h3 id=\"应用场景\"> 应用场景</h3>\n<ul>\n<li>多个子类有公有的方法，并且逻辑基本相同时。</li>\n<li>重要、复杂的算法，可以把核心算法设计为模板方法，周边的相关细节功能则由各个 子类实现。</li>\n<li>重构时，模板方法模式是一个经常使用的模式，把相同的代码抽取到父类中，然后通 过钩子函数（见“模板方法模式的扩展”）约束其行为。</li>\n</ul>\n<h2 id=\"中介者模式\"> 中介者模式</h2>\n<p>中介者模式（Mediator Pattern）是用来降低多个对象和类之间的通信复杂性。这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。中介者模式属于行为型模式。在MVC中的C（控制）就充当M（模型）和V（视图）之间的中介者</p>\n<p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/Java-DesignPatterns-BehavioralPatterns/中介者模式通用类图.png\" alt=\"image-20211122183621593\" /></p>\n<p>从类图中看，中介者模式由以下几部分组成：</p>\n<ul>\n<li>Mediator 抽象中介者角色 抽象中介者角色定义统一的接口，用于各同事角色之间的通信。</li>\n<li>Concrete Mediator 具体中介者角色 具体中介者角色通过协调各同事角色实现协作行为，因此它必须依赖于各个同事角色。</li>\n<li>Colleague 同事角色</li>\n</ul>\n<h3 id=\"优缺点\"> 优缺点</h3>\n<ul>\n<li>优点：中介者模式的优点就是减少类间的依赖，把原有的一对多的依赖变成了一对一的依赖， 同事类只依赖中介者，减少了依赖，当然同时也降低了类间的耦合。</li>\n<li>缺点：中介者模式的缺点就是中介者会膨胀得很大，而且逻辑复杂，原本N个对象直接的相互 依赖关系转换为中介者和同事类的依赖关系，同事类越多，中介者的逻辑就越复杂。</li>\n</ul>\n<h3 id=\"使用场景\"> 使用场景</h3>\n<ul>\n<li>机场调度中心</li>\n<li>MVC框架</li>\n</ul>\n",
      "image": "https://blog-1300186248.cos.ap-shanghai.myqcloud.com/Java-DesignPatterns-BehavioralPatterns/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E7%B1%BB%E5%9B%BE.png",
      "date_published": "2020-08-09T23:37:52.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": []
    },
    {
      "title": "设计模式之创建型设计模式",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/java/java-DesignPatterns/Java-DesignPatterns-CreationalPatterns/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/java/java-DesignPatterns/Java-DesignPatterns-CreationalPatterns/",
      "content_html": "<h2 id=\"参考\"> 参考</h2>\n<div><p>参考</p>\n<ul>\n<li>https://www.runoob.com/design-pattern/design-pattern-intro.html</li>\n<li>http://c.biancheng.net/view/1317.html</li>\n<li><a href=\"TheZen0fDesignPattern_2.pdf\">设计模式之禅</a></li>\n</ul>\n</div>\n<h2 id=\"_1-单例模式-创建型模式\"> 1. 单例模式（创建型模式）</h2>\n<p><code>创建型模式</code></p>\n<p>参考</p>\n<blockquote>\n<ul>\n<li>https://www.runoob.com/design-pattern/singleton-pattern.html</li>\n</ul>\n</blockquote>\n<p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>\n<p>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p>\n<p>单例模式保证了系统内存中只存在一个对象，节省了系统资源,对于一些需要<code>频繁创建销毁</code>的对象,使用单例模式可以提高系统性能。当想实例化一个单例类的时候,必须要记住使用相应的获取对象的方法,而不是使用new</p>\n<p>单例模式使用的场景:</p>\n<blockquote>\n<p>需要频繁的进行创建和销毁的对象，创建对象时耗时过多或耗费资源过多(即:重量级对象),但又经常用到的对象、工具类对象、频繁访问数据库或文件的对象(比如数据源、 session工厂等)</p>\n</blockquote>\n<ul>\n<li>1、单例类只能有一个实例。</li>\n<li>2、单例类必须自己创建自己的唯一实例。</li>\n<li>3、单例类必须给所有其他对象提供这一实例。</li>\n</ul>\n<h3 id=\"实现点\"> 实现点</h3>\n<ul>\n<li>是否线程安全</li>\n<li>是否懒加载</li>\n<li>是否反射可破坏</li>\n</ul>\n<h3 id=\"_1-1-步骤\"> 1.1 步骤</h3>\n<h4 id=\"步骤-1-创建一个-singleton-类\"> 步骤 1：创建一个 <code>Singleton</code> 类</h4>\n<div><pre><code><span>public</span> <span>class</span> <span>SingleObject</span> <span>{</span>\n \n   <span>//创建 SingleObject 的一个对象</span>\n   <span>private</span> <span>static</span> <span>SingleObject</span> instance <span>=</span> <span>new</span> <span>SingleObject</span><span>(</span><span>)</span><span>;</span>\n \n   <span>//让构造函数为 private，这样该类就不会被实例化</span>\n   <span>private</span> <span>SingleObject</span><span>(</span><span>)</span><span>{</span><span>}</span>\n \n   <span>//获取唯一可用的对象</span>\n   <span>public</span> <span>static</span> <span>SingleObject</span> <span>getInstance</span><span>(</span><span>)</span><span>{</span>\n      <span>return</span> instance<span>;</span>\n   <span>}</span>\n \n   <span>public</span> <span>void</span> <span>showMessage</span><span>(</span><span>)</span><span>{</span>\n      <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"Hello World!\"</span><span>)</span><span>;</span>\n   <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h4 id=\"步骤-2-从-singleton-类获取唯一的对象\"> 步骤 2：从 <code>singleton</code> 类获取唯一的对象</h4>\n<div><pre><code><span>public</span> <span>class</span> <span>SingletonPatternDemo</span> <span>{</span>\n   <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n \n      <span>//不合法的构造函数</span>\n      <span>//编译时错误：构造函数 SingleObject() 是不可见的</span>\n      <span>//SingleObject object = new SingleObject();</span>\n \n      <span>//获取唯一可用的对象</span>\n      <span>SingleObject</span> object <span>=</span> <span>SingleObject</span><span>.</span><span>getInstance</span><span>(</span><span>)</span><span>;</span>\n \n      <span>//显示消息</span>\n      object<span>.</span><span>showMessage</span><span>(</span><span>)</span><span>;</span>\n   <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h3 id=\"_1-2-懒汉式-线程不安全\"> 1.2 懒汉式，线程不安全</h3>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>是否 Lazy 初始化</td>\n<td>是</td>\n</tr>\n<tr>\n<td>是否多线程安全</td>\n<td>否</td>\n</tr>\n<tr>\n<td>实现难度</td>\n<td>易</td>\n</tr>\n</tbody>\n</table>\n<p>描述</p>\n<blockquote>\n<p>这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 <code>synchronized</code>，所以严格意义上它并不算单例模式。这种方式 lazy loading 很明显，不要求线程安全，在多线程不能正常工作。<strong>实际不推荐使用</strong></p>\n</blockquote>\n<div><pre><code><span>public</span> <span>class</span> <span>Singleton</span> <span>{</span>  \n    <span>private</span> <span>static</span> <span>Singleton</span> instance<span>;</span>  \n    <span>private</span> <span>Singleton</span> <span>(</span><span>)</span><span>{</span><span>}</span>  \n  \n    <span>public</span> <span>static</span> <span>Singleton</span> <span>getInstance</span><span>(</span><span>)</span> <span>{</span>  \n    <span>if</span> <span>(</span>instance <span>==</span> <span>null</span><span>)</span> <span>{</span>  \n        instance <span>=</span> <span>new</span> <span>Singleton</span><span>(</span><span>)</span><span>;</span>  \n    <span>}</span>  \n    <span>return</span> instance<span>;</span>  \n    <span>}</span>  \n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h3 id=\"_1-3-懒汉式-线程安全\"> 1.3 懒汉式，线程安全</h3>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>是否 Lazy 初始化</td>\n<td>是</td>\n</tr>\n<tr>\n<td>是否多线程安全</td>\n<td>是</td>\n</tr>\n<tr>\n<td>实现难度</td>\n<td>易</td>\n</tr>\n</tbody>\n</table>\n<p>描述</p>\n<blockquote>\n<p>这种方式具备很好的 lazy loading，能够在多线程中很好的工作，但是，效率很低，只有第一次创建的时候需要同步，99% 情况下不需要同步。优点：第一次调用才初始化，避免内存浪费。缺点：必须加锁 <code>synchronized</code> 才能保证单例，但加锁会影响效率。getInstance() 的性能对应用程序不是很关键（该方法使用不太频繁）。<strong>实际不推荐使用</strong></p>\n</blockquote>\n<div><pre><code><span>public</span> <span>class</span> <span>Singleton</span> <span>{</span>  \n    <span>private</span> <span>static</span> <span>Singleton</span> instance<span>;</span>  \n    <span>private</span> <span>Singleton</span> <span>(</span><span>)</span><span>{</span><span>}</span>  \n    <span>public</span> <span>static</span> <span>synchronized</span> <span>Singleton</span> <span>getInstance</span><span>(</span><span>)</span> <span>{</span>  \n    <span>if</span> <span>(</span>instance <span>==</span> <span>null</span><span>)</span> <span>{</span>  \n        instance <span>=</span> <span>new</span> <span>Singleton</span><span>(</span><span>)</span><span>;</span>  \n    <span>}</span>  \n    <span>return</span> instance<span>;</span>  \n    <span>}</span>  \n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h3 id=\"_1-4-饿汉式\"> 1.4 饿汉式</h3>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>是否 Lazy 初始化</td>\n<td>否</td>\n</tr>\n<tr>\n<td>是否多线程安全</td>\n<td>是</td>\n</tr>\n<tr>\n<td>实现难度</td>\n<td>易</td>\n</tr>\n</tbody>\n</table>\n<p>描述</p>\n<blockquote>\n<p>这种方式比较常用，但容易产生垃圾对象。它基于 classloader 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用 getInstance 方法， 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 显然没有达到 lazy loading 的效果。</p>\n<p>优点：没有加锁，执行效率会提高。</p>\n<p>缺点：类加载时就初始化，浪费内存。</p>\n</blockquote>\n<div><pre><code><span>public</span> <span>class</span> <span>Singleton</span> <span>{</span>\n    <span>private</span> <span>static</span> <span>Singleton</span> instance <span>=</span> <span>new</span> <span>Singleton</span><span>(</span><span>)</span><span>;</span>  \n    <span>private</span> <span>Singleton</span> <span>(</span><span>)</span><span>{</span><span>}</span>  \n    <span>public</span> <span>static</span> <span>Singleton</span> <span>getInstance</span><span>(</span><span>)</span> <span>{</span>  \n    <span>return</span> instance<span>;</span>  \n    <span>}</span>  \n<span>}</span>\n\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>静态代码块写法</p>\n<div><pre><code><span>public</span> <span>class</span> <span>Singleton_Hungry</span> <span>{</span>\n    <span>private</span> <span>static</span> <span>Singleton_Hungry</span> instance<span>;</span>\n    <span>static</span> <span>{</span>\n        instance <span>=</span> <span>new</span> <span>Singleton_Hungry</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n    <span>private</span> <span>Singleton_Hungry</span><span>(</span><span>)</span> <span>{</span>\n    <span>}</span>\n    <span>public</span> <span>static</span> <span>Singleton_Hungry</span> <span>getInstance</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> instance<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h3 id=\"_1-5-双重校验锁懒汉式-dcl-即-double-checked-locking\"> 1.5 双重校验锁懒汉式（DCL，即 double-checked locking）</h3>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>是否 Lazy 初始化</td>\n<td>是</td>\n</tr>\n<tr>\n<td>是否多线程安全</td>\n<td>是</td>\n</tr>\n<tr>\n<td>实现难度</td>\n<td>较复杂</td>\n</tr>\n</tbody>\n</table>\n<p>描述</p>\n<blockquote>\n<p>JDK1.5 起。这种方式采用双锁机制，安全且在多线程情况下能保持高性能。<code>getInstance()</code> 的性能对应用程序很关键。推荐使用</p>\n</blockquote>\n<div><pre><code><span>public</span> <span>class</span> <span>Singleton</span> <span>{</span>  \n    <span>private</span> <span>volatile</span> <span>static</span> <span>Singleton</span> singleton<span>;</span>  \n    <span>private</span> <span>Singleton</span> <span>(</span><span>)</span><span>{</span><span>}</span>  \n    <span>public</span> <span>static</span> <span>Singleton</span> <span>getSingleton</span><span>(</span><span>)</span> <span>{</span>  \n        <span>if</span> <span>(</span>singleton <span>==</span> <span>null</span><span>)</span> <span>{</span>  \n            <span>synchronized</span> <span>(</span><span>Singleton</span><span>.</span><span>class</span><span>)</span> <span>{</span>  \n                <span>if</span> <span>(</span>singleton <span>==</span> <span>null</span><span>)</span> <span>{</span>  \n                    singleton <span>=</span> <span>new</span> <span>Singleton</span><span>(</span><span>)</span><span>;</span>  \n                <span>}</span>  \n            <span>}</span>  \n        <span>}</span>  \n        <span>return</span> singleton<span>;</span>  \n    <span>}</span>  \n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>另外，需要注意 uniqueInstance 采⽤ <code>volatile</code> 关键字修饰也是很有必要。<code>volatile</code>作用是防止在new实例的时候,还没初始化完,有其他线程进来,实例此时已经不为空.多线程拿到的实例数据就不一致,加了该关键字后,先初始化完成后在赋值给实例。 uniqueInstance = new Singleton(); 这段代码其实是分为三步执⾏：</p>\n<ol>\n<li>为 uniqueInstance 分配内存空间</li>\n<li>初始化 uniqueInstance</li>\n<li>将 uniqueInstance 指向分配的内存地址</li>\n</ol>\n<p>但是由于 JVM 具有指令重排的特性，执⾏顺序有可能变成 1&gt;3&gt;2。指令重排在单线程环境下不会出 现问题，但是在多线程环境下会导致⼀个线程获得还没有初始化的实例。例如，线程 T1 执⾏了 1 和 3，此时 T2 调⽤ getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化。 使⽤ volatile 可以禁⽌ JVM 的指令重排，保证在多线程环境下也能正常运⾏。</p>\n<h3 id=\"_1-6-静态内部类\"> 1.6 静态内部类</h3>\n<p>参考</p>\n<blockquote>\n<ul>\n<li>https://blog.csdn.net/mnb65482/article/details/80458571</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>是否 Lazy 初始化</td>\n<td>是</td>\n</tr>\n<tr>\n<td>是否多线程安全</td>\n<td>是</td>\n</tr>\n<tr>\n<td>实现难度</td>\n<td>较复杂</td>\n</tr>\n</tbody>\n</table>\n<p>描述</p>\n<blockquote>\n<p>静态内部类的优点是：上升为顶级类，外部类加载时并不需要立即加载内部类，内部类不被加载则不去初始化<code>INSTANCE</code>，故而不占内存。即当<code>SingleTon</code>第一次被加载时，并不需要去加载<code>SingletonInstance</code>，只有当<code>getInstance()</code>方法第一次被调用时，才会去初始化<code>INSTANCE</code>,第一次调用<code>getInstance()</code>方法会导致虚拟机加载<code>SingleTonHoler</code>类，这种方法不仅能确保线程安全，也能保证单例的唯一性，同时也延迟了单例的实例化。</p>\n<p>这种方式采用了类装载的机制来保证初始化实例时只有一个线程。静态内部类方式在 <code>Singleton</code>类被装载时并不会立即<code>实例化</code>,而是在需要实例化时,调用 <code>getInstance</code>方法,才会装载 <code>Singletoninstance</code>类,从而完成 <code>Singleton</code>的实例化。类的静态属性只会在第一次加载类的时候初始化,所以在这里,帮助我们保证了线程的安全性,在类进行初始化时,别的线程是无法进入的。优点:避免了线程不安全,利用静态内部类特点实现延迟加载,效率高。结论:推荐使用</p>\n</blockquote>\n<div><pre><code><span>public</span> <span>class</span> <span>Singleton</span><span>{</span>\n    <span>private</span> <span>Singleton</span><span>(</span><span>)</span> <span>{</span>\n    <span>}</span>\n\n    <span>private</span> <span>static</span> <span>class</span> <span>SingletonInstance</span><span>{</span>\n        <span>private</span> <span>static</span> <span>final</span> <span>Singleton</span> INSTANCE <span>=</span> <span>new</span> <span>Singleton</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n\n\n    <span>public</span> <span>static</span> <span>Singleton</span> <span>getInstance</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>SingletonInstance</span><span>.</span>INSTANCE<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><blockquote>\n<p>我们再回头看下getInstance()方法，调用的是SingleTonHoler.INSTANCE，取的是SingleTonHoler里的INSTANCE对象，跟上面那个DCL方法不同的是，getInstance()方法并没有多次去new对象，故不管多少个线程去调用getInstance()方法，取的都是同一个INSTANCE对象，而不用去重新创建。当getInstance()方法被调用时，SingleTonHoler才在SingleTon的运行时常量池里，把符号引用替换为直接引用，这时静态对象INSTANCE也真正被创建，然后再被getInstance()方法返回出去，这点同饿汉模式。那么INSTANCE在创建过程中又是如何保证线程安全的呢？在《深入理解JAVA虚拟机》中，有这么一句话:</p>\n<p>虚拟机会保证一个类的&lt;\\clinit&gt;()方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的&lt;\\clinit&gt;()方法，其他线程都需要阻塞等待，直到活动线程执行&lt;\\clinit&gt;()方法完毕。如果在一个类的&lt;\\clinit&gt;()方法中有耗时很长的操作，就可能造成多个进程阻塞(需要注意的是，其他线程虽然会被阻塞，但如果执行&lt;\\clinit&gt;()方法后，其他线程唤醒之后不会再次进入&lt;\\clinit&gt;()方法。同一个加载器下，一个类型只会初始化一次。)，在实际应用中，这种阻塞往往是很隐蔽的。</p>\n<p>故而，可以看出INSTANCE在创建过程中是线程安全的，所以说静态内部类形式的单例可保证线程安全，也能保证单例的唯一性，同时也延迟了单例的实例化。</p>\n<p>那么，是不是可以说静态内部类单例就是最完美的单例模式了呢？其实不然，静态内部类也有着一个致命的缺点，就是传参的问题，由于是静态内部类的形式去创建单例的，故外部无法传递参数进去，例如Context这种参数，所以，我们创建单例时，可以在静态内部类与DCL模式里自己斟酌。</p>\n</blockquote>\n<h3 id=\"_1-7-枚举式-拒绝反射构造\"> 1.7 枚举式（拒绝反射构造）</h3>\n<div><pre><code><span>public</span> <span>enum</span> <span>SingleTon</span><span>{</span>\n  INSTANCE<span>;</span>\n        <span>public</span> <span>void</span> <span>method</span><span>(</span><span>)</span><span>{</span>\n        <span>//TODO</span>\n     <span>}</span>\n<span>}</span>\n\n<span>SingleTon</span><span>.</span>INSTANCE\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>描述</p>\n<blockquote>\n<p>枚举在java中与普通类一样，都能拥有字段与方法，而且枚举实例创建是线程安全的，在任何情况下，它都是一个单例。还能防止反序列化重新创建新的对象</p>\n</blockquote>\n<h2 id=\"_2-工厂模式-创建型模式\"> 2. 工厂模式（创建型模式）</h2>\n<p><code>创建型模式</code></p>\n<p>工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>\n<p>在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。</p>\n<p>工厂方法模式是典型的解耦框架。</p>\n<ul>\n<li>迪米特法则：高层模块值需要知道产品的抽象类，其他的实现类都不用关心，符合迪米特法则，</li>\n<li>依赖倒置原则：我不需要的就不要去交流；也符合依赖倒置原则，只依赖产品类的抽象；</li>\n<li>里氏替换原则：当然也符合里氏替换原则，使用产品子类替换产品父类，没问题！</li>\n</ul>\n<p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/Java-DesignPatterns-CreationalPatterns/工厂方法通用图.png\" alt=\"image-20211024164737188\" /></p>\n<p>参考</p>\n<blockquote>\n<ul>\n<li>https://www.runoob.com/design-pattern/factory-pattern.html</li>\n<li>反射在工厂模式的使用：https://www.cnblogs.com/ssrs-wanghao/articles/8993338.html</li>\n</ul>\n</blockquote>\n<p>用反射的工厂</p>\n<div><pre><code>    <span>public</span> <span>static</span> <span><span>&lt;</span><span>T</span> <span>extends</span> <span>Shape</span><span>></span></span> <span>T</span> <span>getShape</span><span>(</span><span>Class</span><span><span>&lt;</span><span>T</span><span>></span></span> clz<span>)</span><span>{</span>\n        <span>T</span> t <span>=</span> <span>null</span><span>;</span>\n        <span>try</span> <span>{</span>\n            t <span>=</span> <span>(</span><span>T</span><span>)</span> <span>Class</span><span>.</span><span>forName</span><span>(</span>clz<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>.</span><span>newInstance</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>Exception</span> e<span>)</span> <span>{</span>\n            e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>return</span> t<span>;</span>\n\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h3 id=\"简单工厂-静态工厂\"> 简单工厂（静态工厂）</h3>\n<p>没有抽象工厂类，而是工厂类使用静态方法来创建实体，也被称为静态工厂类，不符合开闭原则但是简单</p>\n<h3 id=\"延迟初始化\"> 延迟初始化</h3>\n<p>一个对象被消费完毕后，并不立刻释放，工厂类 保持其初始状态，等待再次被使用。延迟初始化是工厂方法模式的一个扩展应用。通常使用一个Map来缓存，并可指定存在系统中的实例化数量。</p>\n<h2 id=\"抽象工厂模式\"> 抽象工厂模式</h2>\n<p>相对于工厂模式只有一个工厂，抽象工厂模式定义一个工厂抽象类并实现多个工厂类</p>\n<h3 id=\"缺点\"> 缺点</h3>\n<p>抽象工厂本身违反开闭原则，当增加产品时抽象工厂要增加方法，实现类也要实现方法。</p>\n<blockquote>\n<p>在抽象工厂模式的缺点中，我们提到抽象工厂模式的产品族扩展比较困难，但是一定要 清楚，是产品族扩展困难，而不是产品等级。在该模式下，产品等级是非常容易扩展的，增 加一个产品等级，只要增加一个工厂类负责新增加出来的产品生产任务即可。也就是说横向 扩展容易，纵向扩展困难。以人类为例子，产品等级中只有男、女两个性别，现实世界还有 一种性别：双性人，既是男人也是女人（俗语就是阴阳人），那我们要扩展这个产品等级也 是非常容易的，增加三个产品类，分别对应不同的肤色，然后再创建一个工厂类，专门负责 不同肤色人的双性人的创建任务，完全通过扩展来实现需求的变更，从这一点上看，抽象工 厂模式是符合开闭原则的</p>\n</blockquote>\n<h3 id=\"使用场景\"> 使用场景</h3>\n<p>抽象工厂模式的使用场景定义非常简单：一个对象族（或是一组没有任何关系的对象） 都有相同的约束，则可以使用抽象工厂模式。</p>\n<h3 id=\"最佳实践\"> 最佳实践</h3>\n<p>涉及不同操作系统的时候， 都可以考虑使用抽象工厂模式，例如一个应用，需要在三个不同平台（Windows、Linux、 Android（Google发布的智能终端操作系统））上运行，你会怎么设计？分别设计三套不同 的应用？非也，通过抽象工厂模式屏蔽掉操作系统对应用的影响。三个不同操作系统上的软 件功能、应用逻辑、UI都应该是非常类似的，唯一不同的是调用不同的工厂方法，由不同的 产品类去处理与操作系统交互的信息</p>\n<h2 id=\"_3-建造者模式-创建型模式\"> 3. 建造者模式（创建型模式）</h2>\n<p><code>创建型模式</code></p>\n<div><p>参考</p>\n<ul>\n<li>https://www.runoob.com/design-pattern/builder-pattern.html</li>\n<li><a href=\"https://www.jianshu.com/p/3d1c9ffb0a28\" target=\"_blank\" rel=\"noopener noreferrer\">一篇文章就彻底弄懂建造者模式(Builder Pattern)</a></li>\n</ul>\n</div>\n<h3 id=\"_3-1-介绍\"> 3.1 介绍</h3>\n<p>建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。创建者模式隐藏了复杂对象的创建过程，它把复杂对象的创建过程加以抽象，通过<code>子类继承或者重载</code>的方式，动态的创建具有复合属性的对象。</p>\n<p>一个 <code>Builder</code> 类会一步一步构造最终的对象。该 <code>Builder</code> 类是独立于其他对象的。</p>\n<p><strong>介绍</strong></p>\n<div><p>介绍</p>\n<ul>\n<li><strong>意图</strong>：将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。</li>\n<li><strong>主要解决</strong>：主要解决在软件系统中，有时候面临着&quot;一个复杂对象&quot;的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。</li>\n<li><strong>何时使用</strong>：一些基本部件不会变，而其组合经常变化的时候。</li>\n<li><strong>如何解决</strong>：将变与不变分离开。</li>\n<li><strong>关键代码</strong>：建造者：创建和提供实例，导演：管理建造出来的实例的依赖关系。</li>\n<li><strong>应用实例</strong>： 1、去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的&quot;套餐&quot;。 2、JAVA 中的 StringBuilder。</li>\n<li><strong>优点</strong>： 1、建造者独立，易扩展。 2、便于控制细节风险。</li>\n<li><strong>缺点</strong>： 1、产品必须有共同点，范围有限制。 2、如内部变化复杂，会有很多的建造类。</li>\n<li><strong>使用场景</strong>： 1、需要生成的对象具有复杂的内部结构。 2、需要生成的对象内部属性本身相互依赖。</li>\n<li><strong>注意事项</strong>：与工厂模式的区别是：建造者模式更加关注与零件装配的顺序。</li>\n</ul>\n</div>\n<p><strong>使用场景</strong></p>\n<div><p>使用场景</p>\n<ul>\n<li>隔离复杂对象的创建和使用，相同的方法，不同执行顺序，产生不同事件结果</li>\n<li>多个部件都可以装配到一个对象中，但产生的运行结果不相同</li>\n<li>产品类非常复杂或者产品类因为调用顺序不同而产生不同作用</li>\n<li>初始化一个对象时，参数过多，或者很多参数具有默认值</li>\n<li>Builder模式不适合创建差异性很大的产品类\n产品内部变化复杂，会导致需要定义很多具体建造者类实现变化，增加项目中类的数量，增加系统的理解难度和运行成本</li>\n<li>需要生成的产品对象有复杂的内部结构，这些产品对象具备共性；</li>\n</ul>\n</div>\n<p><strong>主要作用</strong></p>\n<div><p>主要作用</p>\n<ul>\n<li>\n<p>在用户不知道对象的建造过程和细节的情况下就可以直接创建复杂的对象。</p>\n</li>\n<li>\n<p>用户只需要给出指定复杂对象的类型和内容；</p>\n</li>\n<li>\n<p>建造者模式负责按顺序创建复杂对象（把内部的建造过程和细节隐藏起来)</p>\n</li>\n</ul>\n</div>\n<p><strong>解决的问题</strong></p>\n<div><p>解决的问题</p>\n<ul>\n<li>方便用户创建复杂的对象（不需要知道实现过程）</li>\n<li>代码复用性 &amp; 封装性（将对象构建过程和细节进行封装 &amp; 复用）</li>\n</ul>\n<blockquote>\n<p>例子：造汽车 &amp; 买汽车。</p>\n<ol>\n<li>工厂（建造者模式）：负责制造汽车（组装过&gt;程和细节在工厂内）</li>\n<li>汽车购买者（用户）：你只需要说出你需要的&gt;型号（对象的类型和内容），然后直接购买就可&gt;&gt;以使用了\n（不需要知道汽车是怎么组装的（车轮、车门、&gt;发动机、方向盘等等））</li>\n</ol>\n</blockquote>\n</div>\n<p><strong>优点</strong></p>\n<div><p>优点</p>\n<ul>\n<li>使用建造者模式可以使客户端不必知道产品内部组成的细节。</li>\n<li>具体的建造者类之间是相互独立的，这有利于系统的扩展。</li>\n<li>具体的建造者相互独立，因此可以对建造的过程逐步细化，而不会对其他模块产生任何影响。</li>\n</ul>\n</div>\n<p><strong>缺点</strong></p>\n<div><p>缺点</p>\n<ul>\n<li>建造者模式所创建的产品一般具有较多的共同点，其组成部分相似；如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。</li>\n<li>如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。</li>\n</ul>\n</div>\n<h3 id=\"_3-2-原理\"> 3.2 原理</h3>\n<p><img src=\"./images/Java-DesignPatterns-CreationalPatterns/builder.png\" alt=\"建造者模式UML类图\" /></p>\n<div><p>原理模式</p>\n<ul>\n<li>指挥者（Director）直接和客户（Client）进行需求沟通；</li>\n<li>沟通后指挥者将客户创建产品的需求划分为各个部件的建造请求（Builder）；</li>\n<li>将各个部件的建造请求委派到具体的建造者（ConcreteBuilder）；</li>\n<li>各个具体建造者负责进行产品部件的构建；</li>\n<li>最终构建成具体产品（Product）。</li>\n</ul>\n</div>\n<h3 id=\"_3-3-案例\"> 3.3 案例</h3>\n<p>用 builder 模式创建<code>共享单车</code>为例子，示例代码：</p>\n<h4 id=\"产品product类\"> 产品Product类</h4>\n<p><code>Bike.java</code></p>\n<div><pre><code><span>@Data</span>\n<span>@ToString</span>\n<span>public</span> <span>class</span> <span>Bike</span> <span>{</span>\n    <span>/*框架*/</span>\n    <span>private</span> <span>String</span> frame<span>;</span>\n    <span>/*座椅*/</span>\n    <span>private</span> <span>String</span> seat<span>;</span>\n    <span>/*车胎*/</span>\n    <span>private</span> <span>String</span> tire<span>;</span>\n\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h4 id=\"建造者builder抽象类\"> 建造者Builder抽象类</h4>\n<p><code>Builder.java</code></p>\n<div><pre><code><span>public</span> <span>abstract</span> <span>class</span> <span>Builder</span> <span>{</span>\n    <span>// 创建产品对象</span>\n    <span>protected</span>  <span>Bike</span> bikeProduct <span>=</span> <span>new</span> <span>Bike</span><span>(</span><span>)</span><span>;</span>\n\n    <span>// 具体部件建造过程在具体Builder中实现</span>\n    <span>abstract</span> <span>void</span> <span>buildFrame</span><span>(</span><span>)</span><span>;</span>\n    <span>abstract</span> <span>void</span> <span>buildSeat</span><span>(</span><span>)</span><span>;</span>\n    <span>abstract</span> <span>void</span> <span>buildTire</span><span>(</span><span>)</span><span>;</span>\n\n    <span>// 定义工厂方法，返回一个完整产品对象</span>\n    <span>public</span> <span>Bike</span> <span>getProduct</span><span>(</span><span>)</span><span>{</span>\n        <span>return</span> bikeProduct<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h4 id=\"具体建造者concretebuilder类\"> 具体建造者ConcreteBuilder类</h4>\n<p><code>MobikeBuilder.java</code></p>\n<div><pre><code><span>public</span> <span>class</span> <span>MobikeBuilder</span> <span>extends</span> <span>Builder</span><span>{</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>buildFrame</span><span>(</span><span>)</span> <span>{</span>\n        bikeProduct<span>.</span><span>setFrame</span><span>(</span><span>\"MobikeFrame\"</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>buildSeat</span><span>(</span><span>)</span> <span>{</span>\n        bikeProduct<span>.</span><span>setSeat</span><span>(</span><span>\"MobikeSeat\"</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>buildTire</span><span>(</span><span>)</span> <span>{</span>\n        bikeProduct<span>.</span><span>setTire</span><span>(</span><span>\"MobikeTire\"</span><span>)</span><span>;</span>\n    <span>}</span>\n\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p><code>OfoBuilder.java</code></p>\n<div><pre><code><span>public</span> <span>class</span> <span>OfoBuilder</span> <span>extends</span> <span>Builder</span><span>{</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>buildFrame</span><span>(</span><span>)</span> <span>{</span>\n        bikeProduct<span>.</span><span>setFrame</span><span>(</span><span>\"OfoFrame\"</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>buildSeat</span><span>(</span><span>)</span> <span>{</span>\n        bikeProduct<span>.</span><span>setSeat</span><span>(</span><span>\"OfoSeat\"</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>buildTire</span><span>(</span><span>)</span> <span>{</span>\n        bikeProduct<span>.</span><span>setTire</span><span>(</span><span>\"OfoTire\"</span><span>)</span><span>;</span>\n    <span>}</span>\n\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h4 id=\"指挥者director类\"> 指挥者Director类</h4>\n<p><code>Director.java</code></p>\n<div><pre><code><span>public</span> <span>class</span> <span>Director</span> <span>{</span>\n    <span>private</span> <span>Builder</span> builder<span>;</span>\n\n    <span>// 方式一：通过构造函数设置实际的构造者</span>\n    <span>// 传入类型是基类，面向抽象编程，符合里氏替换原则</span>\n    <span>public</span> <span>Director</span><span>(</span><span>Builder</span> builder<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>builder <span>=</span> builder<span>;</span>\n    <span>}</span>\n\n    <span>// 方式二：通过setter方法设置实际的构造者</span>\n    <span>public</span> <span>void</span> <span>setBuilder</span><span>(</span><span>Builder</span> builder<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>builder <span>=</span> builder<span>;</span>\n    <span>}</span>\n\n    <span>// 构建复杂产品对象</span>\n    <span>public</span> <span>Bike</span> <span>construct</span><span>(</span><span>)</span> <span>{</span>\n        builder<span>.</span><span>buildTire</span><span>(</span><span>)</span><span>;</span>\n        builder<span>.</span><span>buildFrame</span><span>(</span><span>)</span><span>;</span>\n        builder<span>.</span><span>buildSeat</span><span>(</span><span>)</span><span>;</span>\n        <span>return</span> builder<span>.</span><span>getProduct</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><h4 id=\"客户端使用\"> 客户端使用</h4>\n<p><code>Client.java</code></p>\n<div><pre><code><span>public</span> <span>class</span> <span>Client</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n\n        <span>//根据Ofo建造者创建Mobike实体类</span>\n        <span>Director</span> <span>MobikeDirector</span> <span>=</span> <span>new</span> <span>Director</span><span>(</span><span>new</span> <span>MobikeBuilder</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>Bike</span> <span>MobikeBike</span> <span>=</span> <span>MobikeDirector</span><span>.</span><span>construct</span><span>(</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"MobikeBike = \"</span> <span>+</span> <span>MobikeBike</span><span>.</span><span>toString</span><span>(</span><span>)</span><span>)</span><span>;</span>\n\n        <span>//根据Ofo建造者创建Ofo实体类</span>\n        <span>Director</span> <span>OfoDirector</span> <span>=</span> <span>new</span> <span>Director</span><span>(</span><span>new</span> <span>OfoBuilder</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>Bike</span> <span>OfoBike</span> <span>=</span> <span>OfoDirector</span><span>.</span><span>construct</span><span>(</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"OfoBike = \"</span> <span>+</span> <span>OfoBike</span><span>.</span><span>toString</span><span>(</span><span>)</span><span>)</span><span>;</span>\n\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h3 id=\"使用场景-2\"> 使用场景</h3>\n<ul>\n<li>相同的方法，不同的执行顺序，产生不同的事件结果时，可以采用建造者模式。</li>\n<li>多个部件或零件，都可以装配到一个对象中，但是产生的运行结果又不相同时，则可 以使用该模式。</li>\n<li>产品类非常复杂，或者产品类中的调用顺序不同产生了不同的效能，这个时候使用建 造者模式非常合适。</li>\n<li>在对象创建过程中会使用到系统中的一些其他对象，这些对象在产品对象的创建过程 中不易得到时，也可以采用建造者模式封装该对象的创建过程。该种场景只能是一个补偿方 法，因为一个对象不容易获得，而在设计阶段竟然没有发觉，而要通过创建者模式柔化创建 过程，本身已经违反设计的最初目标。</li>\n</ul>\n<h3 id=\"_3-4-使用静态内部类build\"> 3.4 使用静态内部类Build</h3>\n<p>当一个类构造器需要传入很多参数时，如果创建这个类的实例，代码可读性会非常差，而且很容易引入错误，此时就可以利用 builder模式进行重构，插件<code>lombok</code>的注解<code>@Builder</code>也是同样原理，重构的代码如下：</p>\n<p><code>BikeWithBuild.java</code></p>\n<div><pre><code><span>public</span> <span>class</span> <span>BikeWithBuild</span> <span>{</span>\n    <span>/*框架*/</span>\n    <span>private</span> <span>String</span> frame<span>;</span>\n    <span>/*座椅*/</span>\n    <span>private</span> <span>String</span> seat<span>;</span>\n    <span>/*车胎*/</span>\n    <span>private</span> <span>String</span> tire<span>;</span>\n\n    <span>public</span> <span>BikeWithBuild</span><span>(</span><span>)</span> <span>{</span><span>}</span>\n\n  <span>// 构造方法范围设为private意味着只能通过内部即内部的Builder来创建对象</span>\n    <span>private</span> <span>BikeWithBuild</span><span>(</span><span>Builder</span> builder<span>)</span> <span>{</span>\n        frame <span>=</span> builder<span>.</span>frame<span>;</span>\n        seat <span>=</span> builder<span>.</span>seat<span>;</span>\n        tire <span>=</span> builder<span>.</span>tire<span>;</span>\n    <span>}</span>\n\n  <span>//设为静态，当类BikeWithBuild调用此静态方法后即BikeWithBuild.builder()返回Builder实体，</span>\n  <span>//即可以开始调用属性方法来构造，最后用Builder的build()返回实体类完成构造</span>\n    <span>public</span> <span>static</span> <span>BikeWithBuild<span>.</span>Builder</span> <span>builder</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>new</span> <span>BikeWithBuild<span>.</span>Builder</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n\n\n  <span>// 静态内部类Builder</span>\n    <span>public</span> <span>static</span> <span>final</span> <span>class</span> <span>Builder</span> <span>{</span>\n        <span>/*框架*/</span>\n        <span>private</span> <span>String</span> frame<span>;</span>\n        <span>/*座椅*/</span>\n        <span>private</span> <span>String</span> seat<span>;</span>\n        <span>/*车胎*/</span>\n        <span>private</span> <span>String</span> tire<span>;</span>\n\n      <span>// 空的构造方法</span>\n        <span>public</span> <span>Builder</span><span>(</span><span>)</span> <span>{</span><span>}</span>\n\n        <span>public</span> <span>BikeWithBuild<span>.</span>Builder</span> <span>frame</span><span>(</span><span>String</span> frame<span>)</span> <span>{</span>\n            frame <span>=</span> frame<span>;</span>\n            <span>return</span> <span>this</span><span>;</span>\n        <span>}</span>\n        <span>public</span> <span>BikeWithBuild<span>.</span>Builder</span> <span>seat</span><span>(</span><span>String</span> seat<span>)</span> <span>{</span>\n            seat <span>=</span> seat<span>;</span>\n            <span>return</span> <span>this</span><span>;</span>\n        <span>}</span>\n        <span>public</span> <span>BikeWithBuild<span>.</span>Builder</span> <span>tire</span><span>(</span><span>String</span> tire<span>)</span> <span>{</span>\n            tire <span>=</span> tire<span>;</span>\n            <span>return</span> <span>this</span><span>;</span>\n        <span>}</span>\n\n      <span>//最后调用build将想要的属性赋值后的Builder作为参数来返回BikeWithBuild对象</span>\n        <span>public</span> <span>BikeWithBuild</span> <span>build</span><span>(</span><span>)</span> <span>{</span>\n            <span>return</span> <span>new</span> <span>BikeWithBuild</span><span>(</span><span>this</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br></div></div><p>使用</p>\n<div><pre><code><span>BikeWithBuild</span> bikeWithBuild <span>=</span> <span>BikeWithBuild</span><span>.</span><span>builder</span><span>(</span><span>)</span>\n  <span>.</span><span>frame</span><span>(</span><span>\"frame\"</span><span>)</span>\n  <span>.</span><span>seat</span><span>(</span><span>\"seat\"</span><span>)</span>\n  <span>.</span><span>tire</span><span>(</span><span>\"tire\"</span><span>)</span>\n  <span>.</span><span>build</span><span>(</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面的示例代码只是传入三个参数，如果参数是十四个甚至更多，builder 模式的优势将会更加明显，传递参数更加灵活，代码具有更高的可读性.</p>\n<p>优点是可以将构造器的setter方法名取成类似注释的方式，这样我们可以很清晰的知道刚才究竟设置的什么值，可读性较高</p>\n<p>缺点是比较冗长。</p>\n<h3 id=\"_3-5-建造者模式与抽象工厂模式的比较\"> 3.5 建造者模式与抽象工厂模式的比较</h3>\n<div><p>建造者模式与抽象工厂模式的比较</p>\n<ul>\n<li>与<code>抽象工厂模式</code>相比，<code>建造者模式</code>返回一个<code>组装好的完整产品</code>，而<code>抽象工厂模式</code>返回<code>一系列相关的产品</code>，这些产品位于<code>不同产品等级结构</code>，构成了一个<code>产品族</code> 。</li>\n<li>在<code>抽象工厂模式</code>中，客户端实例化工厂类，然后调用工厂方法获取所需产品对象；而在<code>建造者模式</code>中，客户端可以不直接调用建造者的相关方法，而是通过指挥者类来指导如何生成对象，包括对象的组装过程和建造步骤，它侧重于一步步构造一个复杂对象，返回一个完整的对象 。</li>\n<li>如果将<code>抽象工厂模式</code>看成汽车配件生产工厂，生产一个产品族的产品；那么<code>建造者模式</code>就是一个汽车组装工厂，通过对部件的组装可以返回一辆完整的汽车</li>\n</ul>\n</div>\n<h2 id=\"_4-原型模式-创建型模式\"> 4. 原型模式（创建型模式）</h2>\n<p><code>创建型模式</code></p>\n<p>原型模式（Prototype Pattern）是用于<code>创建重复的对象</code>，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>\n<p>这种模式是实现了一个<code>原型接口</code>，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。</p>\n<p>例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。</p>\n<p>原型模式（Prototype Pattern）的简单程度仅次于单例模式和迭代器模式。正是由于简 单，使用的场景才非常地多，其定义如下：</p>\n<div><p>Info</p>\n<p>Specify the kinds of objects to create using a prototypical instance,and create new objects by copying this prototype.（用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对 象。）</p>\n</div>\n<p><img src=\"./images/Java-DesignPatterns-CreationalPatterns/General_class_diagram_of_the_prototype_pattern.jpg\" alt=\"图13-3 原型模式的通用类图\" /></p>\n<h3 id=\"_4-1-介绍\"> 4.1 介绍</h3>\n<div><p>介绍</p>\n<ul>\n<li>\n<p><strong>意图</strong>：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p>\n</li>\n<li>\n<p><strong>主要解决</strong>：在运行期建立和删除原型。</p>\n</li>\n<li>\n<p><strong>何时使用</strong></p>\n<blockquote>\n<ol>\n<li>当一个系统应该独立于它的产品创建，构成和表示时。</li>\n<li>当要实例化的类是在运行时刻指定时，例如，通过动态装载。</li>\n<li>为了避免创建一个与产品类层次平行的工厂类层次时。</li>\n<li>当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。</li>\n</ol>\n</blockquote>\n</li>\n<li>\n<p><strong>如何解决</strong>：利用已有的一个原型对象，快速地生成和原型对象一样的实例。</p>\n</li>\n<li>\n<p><strong>关键代码</strong>：</p>\n<blockquote>\n<ol>\n<li>实现<code>克隆操作</code>，在 JAVA <code>继承 Cloneable</code>，重写 <code>clone()</code>，在 .NET 中可以使用 Object 类的 MemberwiseClone() 方法来实现对象的浅拷贝或通过序列化的方式来实现深拷贝。</li>\n<li>原型模式同样用于隔离类对象的使用者和具体类型（易变类）之间的耦合关系，它同样要求这些&quot;易变类&quot;拥有稳定的接口。</li>\n</ol>\n</blockquote>\n</li>\n<li>\n<p><strong>应用实例</strong>：</p>\n<blockquote>\n<ol>\n<li>细胞分裂。</li>\n<li>JAVA 中的 <code>Object clone()</code> 方法。</li>\n</ol>\n</blockquote>\n</li>\n<li>\n<p><strong>优点</strong>：</p>\n<blockquote>\n<ol>\n<li>性能提高。</li>\n<li>逃避构造函数的约束。</li>\n</ol>\n</blockquote>\n</li>\n<li>\n<p><strong>缺点</strong>：</p>\n<blockquote>\n<ol>\n<li>配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候。</li>\n<li>必须实现 <code>Cloneable</code> 接口。</li>\n</ol>\n</blockquote>\n</li>\n<li>\n<p><strong>使用场景</strong>：</p>\n<blockquote>\n<ol>\n<li>资源优化场景。</li>\n<li>类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。</li>\n<li>性能和安全要求的场景。</li>\n<li>通过 new 产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。</li>\n<li>一个对象多个修改者的场景。</li>\n<li>一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用。</li>\n<li>在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过 clone 的方法创建一个对象，然后由工厂方法提供给调用者。原型模式已经与 Java 融为浑然一体，大家可以随手拿来使用。</li>\n</ol>\n</blockquote>\n</li>\n<li>\n<p><strong>注意事项</strong>：与通过对一个类进行实例化来构造新对象不同的是，原型模式是通过拷贝一个现有对象生成新对象的。浅拷贝实现 Cloneable，重写，深拷贝是通过实现 Serializable 读取二进制流。</p>\n</li>\n</ul>\n</div>\n<h3 id=\"_4-2-优缺点\"> 4.2 优缺点</h3>\n<div><p>优点</p>\n<ul>\n<li>\n<p>性能优良</p>\n<blockquote>\n<p>原型模式是在内存二进制流的拷贝，要比直接new一个对象性能好很多，特别是要在一 个循环体内产生大量的对象时，原型模式可以更好地体现其优点。</p>\n</blockquote>\n</li>\n<li>\n<p>逃避构造函数的约束</p>\n<blockquote>\n<p>这既是它的优点也是缺点即不会执行构造方法，Object类的 clone方法的原理是从内存中（具体地说就是堆内存）以二进制流的方式进行拷贝，重新分配 一个内存块，那构造函数没有被执行也是非常正常的了。构造函数是不会执行的（参见13.4 节）。优点就是减少了约束，缺点也是减少了约束，需要大家在实际应用时考虑。</p>\n</blockquote>\n</li>\n</ul>\n</div>\n<h3 id=\"_4-3-使用场景\"> 4.3 使用场景</h3>\n<div><p>使用场景</p>\n<ul>\n<li>资源优化场景 ：类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。</li>\n<li>性能和安全要求的场景：通过new产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。</li>\n<li>一个对象多个修改者的场景：一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑 使用原型模式拷贝多个对象供调用者使用。 在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过clone的 方法创建一个对象，然后由工厂方法提供给调用者。原型模式已经与Java融为一体，大家可 以随手拿来使用。</li>\n</ul>\n</div>\n<h3 id=\"浅拷贝和深拷贝\"> 浅拷贝和深拷贝</h3>\n<ul>\n<li>浅拷贝：Object类提供 的方法clone只是拷贝本对象，其对象内部的数组、引用对象等都不拷贝，还是指向原生对象的内部元素地址，这种拷贝就叫做浅拷贝。其他的例如String和数据类型int等都被会被拷贝。</li>\n<li>深拷贝：在浅拷贝基础上连引用数据类型都拷贝新的</li>\n</ul>\n",
      "image": "https://blog-1300186248.cos.ap-shanghai.myqcloud.com/Java-DesignPatterns-CreationalPatterns/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E9%80%9A%E7%94%A8%E5%9B%BE.png",
      "date_published": "2020-08-09T23:20:52.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": []
    },
    {
      "title": "设计模式之J2EE设计模式",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/java/java-DesignPatterns/Java-DesignPatterns-J2eePattern/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/java/java-DesignPatterns/Java-DesignPatterns-J2eePattern/",
      "content_html": "<h2 id=\"参考\"> 参考</h2>\n<div><p>参考</p>\n<ul>\n<li>https://www.runoob.com/design-pattern/design-pattern-intro.html</li>\n<li>http://c.biancheng.net/view/1317.html</li>\n<li><a href=\"TheZen0fDesignPattern_2.pdf\">设计模式之禅</a></li>\n</ul>\n</div>\n<p>J2EE设计模式</p>\n",
      "date_published": "2020-08-09T23:50:52.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": []
    },
    {
      "title": "设计模式七大原则",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/java/java-DesignPatterns/Java-DesignPatterns-SevenPrinciple/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/java/java-DesignPatterns/Java-DesignPatterns-SevenPrinciple/",
      "content_html": "<h2 id=\"参考\"> 参考</h2>\n<div><p>参考</p>\n<ul>\n<li>https://www.runoob.com/design-pattern/design-pattern-intro.html</li>\n<li>http://c.biancheng.net/view/1317.html</li>\n<li><a href=\"TheZen0fDesignPattern_2.pdf\">设计模式之禅</a></li>\n<li><a href=\"https://so.csdn.net/so/search/blog?q=%E5%85%AD%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99&amp;t=blog&amp;p=1&amp;s=0&amp;tm=0&amp;lv=-1&amp;ft=0&amp;l=&amp;u=hfreeman2008\" target=\"_blank\" rel=\"noopener noreferrer\">六大设计原则</a></li>\n<li><a href=\"https://www.bilibili.com/video/BV1G4411c7N4\" target=\"_blank\" rel=\"noopener noreferrer\">尚硅谷</a></li>\n</ul>\n</div>\n<p><img src=\"./images/Java-DesignPatterns-SixPrinciple/The_six_design_principles.jpg\" alt=\"六大设计原则\" /></p>\n<h2 id=\"_1-开闭原则-open-closed-principle-ocp\"> 1. 开闭原则(Open Closed Principle,OCP)</h2>\n<div><p>参考</p>\n<ul>\n<li>http://c.biancheng.net/view/1322.html</li>\n<li><a href=\"https://blog.csdn.net/hfreeman2008/article/details/52344022?ops_request_misc=%25257B%252522request%25255Fid%252522%25253A%252522160853876616780261982313%252522%25252C%252522scm%252522%25253A%25252220140713.130102334.pc%25255Fblog.%252522%25257D&amp;request_id=160853876616780261982313&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-4-52344022.pc_v2_rank_blog_default&amp;utm_term=%E5%85%AD%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99\" target=\"_blank\" rel=\"noopener noreferrer\">六大设计原则之开闭原则</a></li>\n</ul>\n</div>\n<h3 id=\"_1-1-介绍\"> 1.1 介绍</h3>\n<p><code>开闭原则（Open Closed Principle，OCP）</code>由勃兰特·梅耶（Bertrand Meyer）提出，他在 1988 年的著作《面向对象软件构造》（Object Oriented Software Construction）中提出：</p>\n<div><p>定义</p>\n<p>Software entities should be open for extension，but closed for modification。</p>\n<p>(一个软件实体如类，模块和函数应该对扩展开放，对修改关闭)</p>\n</div>\n<p>开闭原则明确的告诉我们：软件实现应该对扩展开放，对修改关闭，其含义是说一个软件实体应该通过扩展来实现变化，而不是通过修改已有的代码来实现变化的。那什么是软件实体呢？这里的软件实体包括以下几个部分：</p>\n<div><p>软件实体</p>\n<ol>\n<li>项目中划分出的模块</li>\n<li>类与接口</li>\n<li>方法</li>\n</ol>\n</div>\n<p>开闭原则的含义是</p>\n<div><p>开闭原则的含义</p>\n<p>当应用的需求改变时，在不修改软件实体的源代码或者二进制代码的前提下，可以扩展模块的功能，使其满足新的需求。一个软件产品只要在生命周期内，都会发生变化，即然变化是一个事实，我们就应该在设计时尽量适应这些变化，以提高项目的稳定性和灵活性，真正实现“拥抱变化”。开闭原则告诉我们应尽量通过扩展软件实体的行为来实现变化，而不是通过修改现有代码来完成变化，它是为软件实体的未来事件而制定的对现行开发设计进行约束的一个原则。</p>\n</div>\n<h3 id=\"_1-2-作用\"> 1.2 作用</h3>\n<p>开闭原则是面向对象程序设计的终极目标，它使软件实体拥有一定的适应性和灵活性的同时具备稳定性和延续性。具体来说，其作用如下。</p>\n<div><p>作用</p>\n<ol>\n<li>\n<p><strong>对软件测试的影响</strong>：</p>\n<p>软件遵守开闭原则的话，软件测试时<code>只需要对扩展的代码进行测试</code>就可以了，因为原有的测试代码仍然能够正常运行。</p>\n</li>\n<li>\n<p><strong>可以提高代码的可复用性</strong>：</p>\n<p>粒度越小，被复用的可能性就越大；在面向对象的程序设计中，根据原子和抽象编程可以提高代码的可复用性。</p>\n</li>\n<li>\n<p><strong>可以提高软件的可维护性</strong>：</p>\n<p>遵守开闭原则的软件，其稳定性高和延续性强，从而易于扩展和维护。</p>\n</li>\n</ol>\n</div>\n<h3 id=\"_1-3-示例\"> 1.3 示例</h3>\n<p>以书店销售书籍为例，其类图如下：</p>\n<p><img src=\"./images/Java-DesignPatterns-SixPrinciple/OpenClosedPrincipleDemo.jpg\" alt=\"开闭原则示例\" /></p>\n<p>书籍接口</p>\n<div><pre><code><span>public</span> <span>interface</span> <span>IBook</span><span>{</span>\n  <span>public</span> <span>String</span> <span>getName</span><span>(</span><span>)</span><span>;</span>\n  <span>public</span> <span>String</span> <span>getPrice</span><span>(</span><span>)</span><span>;</span>\n  <span>public</span> <span>String</span> <span>getAuthor</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>小说类书籍：</p>\n<div><pre><code><span>public</span> <span>class</span> <span>NovelBook</span> <span>implements</span> <span>IBook</span><span>{</span>\n   <span>private</span> <span>String</span> name<span>;</span>\n   <span>private</span> <span>int</span> price<span>;</span>\n   <span>private</span> <span>String</span> author<span>;</span>\n\n   <span>public</span> <span>NovelBook</span><span>(</span><span>String</span> name<span>,</span><span>int</span> price<span>,</span><span>String</span> author<span>)</span><span>{</span>\n     <span>this</span><span>.</span>name <span>=</span> name<span>;</span>\n     <span>this</span><span>.</span>price <span>=</span> price<span>;</span>\n     <span>this</span><span>.</span>author <span>=</span> author<span>;</span>\n   <span>}</span>\n\n   <span>public</span> <span>String</span> <span>getAutor</span><span>(</span><span>)</span><span>{</span>\n     <span>return</span> <span>this</span><span>.</span>author<span>;</span>\n   <span>}</span>\n\n   <span>public</span> <span>String</span> <span>getName</span><span>(</span><span>)</span><span>{</span>\n     <span>return</span> <span>this</span><span>.</span>name<span>;</span>\n   <span>}</span>  \n\n   <span>public</span> <span>int</span> <span>getPrice</span><span>(</span><span>)</span><span>{</span>\n     <span>return</span> <span>this</span><span>.</span>price<span>;</span>\n   <span>}</span> \n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p>Client类：</p>\n<div><pre><code><span>public</span> <span>class</span> <span>Client</span><span>{</span>\n   <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>Strings</span><span>[</span><span>]</span> args<span>)</span><span>{</span>\n     <span>IBook</span> novel <span>=</span> <span>new</span> <span>NovelBook</span><span>(</span><span>\"笑傲江湖\"</span><span>,</span><span>100</span><span>,</span><span>\"金庸\"</span><span>)</span><span>;</span>\n     <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"书籍名字：\"</span><span>+</span>novel<span>.</span><span>getName</span><span>(</span><span>)</span><span>+</span><span>\"书籍作者：\"</span><span>+</span>novel<span>.</span><span>getAuthor</span><span>(</span><span>)</span><span>+</span><span>\"书籍价格：\"</span><span>+</span>novel<span>.</span><span>getPrice</span><span>(</span><span>)</span><span>)</span><span>;</span>\n   <span>}</span>\n\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>项目投产生，书籍正常销售，但是我们经常因为各种原因，要打折来销售书籍，这是一个变化，我们要如何应对这样一个需求变化呢？</p>\n<p>我们有下面三种方法可以解决此问题：</p>\n<div><p>解决方案</p>\n<ul>\n<li><strong>修改接口</strong>\n在IBook接口中，增加一个方法getOffPrice(),专门用于进行打折处理，所有的实现类实现此方法。但是这样的一个修改方式，实现类NovelBook要修改，同时IBook接口应该是稳定且可靠，不应该经常发生改变，否则接口作为契约的作用就失去了。因此，此方案否定。</li>\n<li><strong>修改实现类</strong>\n修改NovelBook类的方法，直接在getPrice()方法中实现打折处理。此方法是有问题的，例如我们如果getPrice()方法中只需要读取书籍的打折前的价格呢？这不是有问题吗？当然我们也可以再增加getOffPrice()方法，这也是可以实现其需求，但是这就有二个读取价格的方法，因此，该方案也不是一个最优方案。</li>\n<li><strong>通过扩展实现变化</strong>\n我们可以增加一个子类OffNovelBook,覆写getPrice方法。此方法修改少，对现有的代码没有影响，风险少，是个好办法。</li>\n</ul>\n</div>\n<p><img src=\"./images/Java-DesignPatterns-SixPrinciple/OpenClosedPrincipleDemo_2.jpg\" alt=\"修改后的类图\" /></p>\n<p>打折类：</p>\n<div><pre><code><span>public</span> <span>class</span> <span>OffNovelBook</span> <span>extends</span> <span>NovelBook</span><span>{</span>\n\n   <span>public</span> <span>OffNovelBook</span><span>(</span><span>String</span> name<span>,</span><span>int</span> price<span>,</span><span>String</span> author<span>)</span><span>{</span>\n      <span>super</span><span>(</span>name<span>,</span>price<span>,</span>author<span>)</span><span>;</span>\n   <span>}</span>\n\n   <span>//覆写价格方法，当价格大于40，就打8析，其他价格就打9析</span>\n   <span>public</span> <span>int</span> <span>getPrice</span><span>(</span><span>)</span><span>{</span>\n     <span>if</span><span>(</span><span>this</span><span>.</span>price <span>></span> <span>40</span><span>)</span><span>{</span>\n        <span>return</span> <span>this</span><span>.</span>price <span>*</span> <span>0.8</span><span>;</span>\n     <span>}</span><span>else</span><span>{</span>\n        <span>return</span> <span>this</span><span>.</span>price <span>*</span> <span>0.9</span><span>;</span>\n     <span>}</span>     \n   <span>}</span> \n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h3 id=\"_1-4-实现方法\"> 1.4 实现方法</h3>\n<p>第一：<strong>抽象约束</strong>\n抽象是对一组事物的通用描述，没有具体的实现，也就表示它可以有非常多的可能性，可以跟随需求的变化而变化。因此，通过接口或抽象类可以约束一组可能变化的行为，并且能够实现对扩展开放，其包含三层含义：</p>\n<ul>\n<li>通过接口或抽象类约束扩散，对扩展进行边界限定，不允许出现在接口或抽象类中不存在的public方法。</li>\n<li>参数类型，引用对象尽量使用接口或抽象类，而不是实现类，这主要是实现里氏替换原则的一个要求</li>\n<li>抽象层尽量保持稳定，一旦确定就不要修改</li>\n</ul>\n<p>第二：<strong>元数据(metadata)控件模块行为</strong>\n编程是一个很苦很累的活，那怎么才能减轻压力呢？答案是尽量使用元数据来控制程序的行为，减少重复开发。什么是元数据？用来描述环境和数据的数据，通俗的说就是配置参数，参数可以从文件中获得，也可以从数据库中获得。</p>\n<p>第三：<strong>制定项目章程</strong>\n在一个团队中，建立项目章程是非常重要的，因为章程是所有人员都必须遵守的约定，对项目来说，约定优于配置。这比通过接口或抽象类进行约束效率更高，而扩展性一点也没有减少。</p>\n<p>第四：<strong>封装变化</strong>\n对变化封装包含两层含义：\n(1)将相同的变化封装到一个接口或抽象类中\n(2)将不同的变化封装到不同的接口或抽象类中，不应该有两个不同的变化出现在同一个接口或抽象类中。\n封装变化，也就是受保护的变化，找出预计有变化或不稳定的点，我们为这些变化点创建稳定的接口。</p>\n<h2 id=\"_2-依赖倒置原则-dependency-inversion-principle-dip\"> 2 依赖倒置原则(Dependency Inversion Principle,DIP)</h2>\n<div><p>参考</p>\n<p><a href=\"https://blog.csdn.net/hfreeman2008/article/details/52289571?ops_request_misc=%25257B%252522request%25255Fid%252522%25253A%252522160853876616780261982313%252522%25252C%252522scm%252522%25253A%25252220140713.130102334.pc%25255Fblog.%252522%25257D&amp;request_id=160853876616780261982313&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-2-52289571.pc_v2_rank_blog_default&amp;utm_term=%E5%85%AD%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99\" target=\"_blank\" rel=\"noopener noreferrer\">六大设计原则之依赖倒置原则</a></p>\n</div>\n<h3 id=\"_2-1-介绍\"> 2.1 介绍</h3>\n<p>依赖倒置原则(Dependence Inversion Principle ,DIP)定义如下：</p>\n<div><p>定义</p>\n<p><strong>High level modules should not depend upon low level modules,Both should depend upon abstractions.Abstractions should not depend upon details.Details should depend upon abstracts.</strong></p>\n</div>\n<p>翻译过来为：</p>\n<div><p>Info</p>\n<ul>\n<li>高层模块不应该依赖低层模块，两者都应该依赖抽象</li>\n<li>抽象不应该依赖细节</li>\n<li>细节应该依赖抽象</li>\n</ul>\n</div>\n<p><strong>也可以说高层模块，低层模块，细节都应该依赖抽象</strong></p>\n<div><p>Info</p>\n<p>每一个逻辑的实现都是由颗粒原子逻辑组成的，颗粒原子逻辑就是低层模块，而颗粒原子逻辑组成的模块就是高层模块。在java语言中，抽象就是接口或抽象类，两都都是不能直接被实例化的，细节就是实现类，实现接口或继承抽象类而产生的类就是细节，两者都可以直接被实例化。</p>\n</div>\n<p>依赖倒置原则在java语言中，表现是：</p>\n<div><p>Info</p>\n<ul>\n<li>模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的。</li>\n<li>接口或抽象类不依赖实现类</li>\n<li>实现类依赖接口或抽象类</li>\n</ul>\n</div>\n<p>更加精简的定义就是“面向接口编程”—OOD(Object-Oriented Design，面向对象设计)的精髓之一。</p>\n<h3 id=\"_2-2-好处\"> 2.2 好处</h3>\n<p>采用依赖倒置原则可以减少类间的耦合性，提高系统的稳定，降低并行开发引起的风险，提高代码的可读性和可维护性。</p>\n<h2 id=\"_3-迪米特原则-law-of-demeter-lod\"> 3. 迪米特原则(Law of Demeter,LoD)</h2>\n<div><p>参考</p>\n<p><a href=\"https://blog.csdn.net/hfreeman2008/article/details/52335601?ops_request_misc=%25257B%252522request%25255Fid%252522%25253A%252522160862280716780257419145%252522%25252C%252522scm%252522%25253A%25252220140713.130102334.pc%25255Fblog.%252522%25257D&amp;request_id=160862280716780257419145&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-3-52335601.pc_v2_rank_blog_default&amp;utm_term=%E5%85%AD%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99\" target=\"_blank\" rel=\"noopener noreferrer\">六大设计原则之迪米特原则</a></p>\n</div>\n<h3 id=\"_3-1-介绍\"> 3.1 介绍</h3>\n<p>迪米特原则(Law of Demeter,LoD)，也叫最少知识原则(Low knowledge Principle,LKP):</p>\n<p><strong>一个对象应该对其他对象有最少的了解。</strong></p>\n<p>通俗的讲：一个类对自己需要耦合或调用的类知道的最少，你(被耦合或调用的类)的内部是如何复杂和我没有关系，我就知道你提供的public方法，我只调用这些方法，其它的我不关心。</p>\n<h2 id=\"_4-里氏替换原则-liskov-substitution-principle-lsp\"> 4. 里氏替换原则(Liskov Substitution Principle,LSP)</h2>\n<div><p>参考</p>\n<p><a href=\"https://blog.csdn.net/hfreeman2008/article/details/52344343?ops_request_misc=%25257B%252522request%25255Fid%252522%25253A%252522160862280716780257419145%252522%25252C%252522scm%252522%25253A%25252220140713.130102334.pc%25255Fblog.%252522%25257D&amp;request_id=160862280716780257419145&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-1-52344343.pc_v2_rank_blog_default&amp;utm_term=%E5%85%AD%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99\" target=\"_blank\" rel=\"noopener noreferrer\">六大设计原则之里氏替换原则</a></p>\n</div>\n<h2 id=\"_5-单一职责原则-single-responsibility-principle-spr\"> 5. 单一职责原则(Single Responsibility Principle,SPR)</h2>\n<div><p>参考</p>\n<p><a href=\"https://blog.csdn.net/hfreeman2008/article/details/52234287?ops_request_misc=%25257B%252522request%25255Fid%252522%25253A%252522160862280716780257419145%252522%25252C%252522scm%252522%25253A%25252220140713.130102334.pc%25255Fblog.%252522%25257D&amp;request_id=160862280716780257419145&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-6-52234287.pc_v2_rank_blog_default&amp;utm_term=%E5%85%AD%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99\" target=\"_blank\" rel=\"noopener noreferrer\">六大设计原则之单一职责原则</a></p>\n</div>\n<h2 id=\"_6-接口隔离原则\"> 6. 接口隔离原则</h2>\n<div><p>参考</p>\n<p><a href=\"https://blog.csdn.net/hfreeman2008/article/details/52304172?ops_request_misc=%25257B%252522request%25255Fid%252522%25253A%252522160862280716780257419145%252522%25252C%252522scm%252522%25253A%25252220140713.130102334.pc%25255Fblog.%252522%25257D&amp;request_id=160862280716780257419145&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-5-52304172.pc_v2_rank_blog_default&amp;utm_term=%E5%85%AD%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99\" target=\"_blank\" rel=\"noopener noreferrer\">六大设计原则之接口隔离原则</a></p>\n</div>\n",
      "date_published": "2020-08-09T22:37:52.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": []
    },
    {
      "title": "设计模式七大原则",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/java/java-DesignPatterns/Java-DesignPatterns-SixPrinciple/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/java/java-DesignPatterns/Java-DesignPatterns-SixPrinciple/",
      "content_html": "<h2 id=\"参考\"> 参考</h2>\n<div><p>参考</p>\n<ul>\n<li>https://www.runoob.com/design-pattern/design-pattern-intro.html</li>\n<li>http://c.biancheng.net/view/1317.html</li>\n<li><a href=\"TheZen0fDesignPattern_2.pdf\">设计模式之禅</a></li>\n<li><a href=\"https://so.csdn.net/so/search/blog?q=%E5%85%AD%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99&amp;t=blog&amp;p=1&amp;s=0&amp;tm=0&amp;lv=-1&amp;ft=0&amp;l=&amp;u=hfreeman2008\" target=\"_blank\" rel=\"noopener noreferrer\">六大设计原则</a></li>\n<li><a href=\"https://www.bilibili.com/video/BV1G4411c7N4\" target=\"_blank\" rel=\"noopener noreferrer\">尚硅谷</a></li>\n</ul>\n</div>\n<h2 id=\"总览\"> 总览</h2>\n<div><p>七大原则</p>\n<ul>\n<li>单一职责原则</li>\n<li>接口隔离原则</li>\n<li>依赖倒置原则</li>\n<li>里氏替换原则</li>\n<li>开闭原则</li>\n<li>迪米特法则</li>\n<li>合成复用原则</li>\n</ul>\n</div>\n<p><img src=\"./images/Java-DesignPatterns-SixPrinciple/The_six_design_principles.jpg\" alt=\"六大设计原则\" /></p>\n<h2 id=\"_1-单一职责原则-single-responsibility-principle-spr\"> 1. 单一职责原则(Single Responsibility Principle,SPR)</h2>\n<div><p>参考</p>\n<p><a href=\"https://blog.csdn.net/hfreeman2008/article/details/52234287?ops_request_misc=%25257B%252522request%25255Fid%252522%25253A%252522160862280716780257419145%252522%25252C%252522scm%252522%25253A%25252220140713.130102334.pc%25255Fblog.%252522%25257D&amp;request_id=160862280716780257419145&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-6-52234287.pc_v2_rank_blog_default&amp;utm_term=%E5%85%AD%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99\" target=\"_blank\" rel=\"noopener noreferrer\">六大设计原则之单一职责原则</a></p>\n</div>\n<h2 id=\"_1-开闭原则-open-closed-principle-ocp\"> 1. 开闭原则(Open Closed Principle,OCP)</h2>\n<div><p>参考</p>\n<ul>\n<li>http://c.biancheng.net/view/1322.html</li>\n<li><a href=\"https://blog.csdn.net/hfreeman2008/article/details/52344022?ops_request_misc=%25257B%252522request%25255Fid%252522%25253A%252522160853876616780261982313%252522%25252C%252522scm%252522%25253A%25252220140713.130102334.pc%25255Fblog.%252522%25257D&amp;request_id=160853876616780261982313&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-4-52344022.pc_v2_rank_blog_default&amp;utm_term=%E5%85%AD%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99\" target=\"_blank\" rel=\"noopener noreferrer\">六大设计原则之开闭原则</a></li>\n</ul>\n</div>\n<h3 id=\"_1-1-介绍\"> 1.1 介绍</h3>\n<p><code>开闭原则（Open Closed Principle，OCP）</code>由勃兰特·梅耶（Bertrand Meyer）提出，他在 1988 年的著作《面向对象软件构造》（Object Oriented Software Construction）中提出：</p>\n<div><p>定义</p>\n<p>Software entities should be open for extension，but closed for modification。</p>\n<p>(一个软件实体如类，模块和函数应该对扩展开放，对修改关闭)</p>\n</div>\n<p>开闭原则明确的告诉我们：软件实现应该对扩展开放，对修改关闭，其含义是说一个软件实体应该通过扩展来实现变化，而不是通过修改已有的代码来实现变化的。那什么是软件实体呢？这里的软件实体包括以下几个部分：</p>\n<div><p>软件实体</p>\n<ol>\n<li>项目中划分出的模块</li>\n<li>类与接口</li>\n<li>方法</li>\n</ol>\n</div>\n<p>开闭原则的含义是</p>\n<div><p>开闭原则的含义</p>\n<p>当应用的需求改变时，在不修改软件实体的源代码或者二进制代码的前提下，可以扩展模块的功能，使其满足新的需求。一个软件产品只要在生命周期内，都会发生变化，即然变化是一个事实，我们就应该在设计时尽量适应这些变化，以提高项目的稳定性和灵活性，真正实现“拥抱变化”。开闭原则告诉我们应尽量通过扩展软件实体的行为来实现变化，而不是通过修改现有代码来完成变化，它是为软件实体的未来事件而制定的对现行开发设计进行约束的一个原则。</p>\n</div>\n<h3 id=\"_1-2-作用\"> 1.2 作用</h3>\n<p>开闭原则是面向对象程序设计的终极目标，它使软件实体拥有一定的适应性和灵活性的同时具备稳定性和延续性。具体来说，其作用如下。</p>\n<div><p>作用</p>\n<ol>\n<li>\n<p><strong>对软件测试的影响</strong>：</p>\n<p>软件遵守开闭原则的话，软件测试时<code>只需要对扩展的代码进行测试</code>就可以了，因为原有的测试代码仍然能够正常运行。</p>\n</li>\n<li>\n<p><strong>可以提高代码的可复用性</strong>：</p>\n<p>粒度越小，被复用的可能性就越大；在面向对象的程序设计中，根据原子和抽象编程可以提高代码的可复用性。</p>\n</li>\n<li>\n<p><strong>可以提高软件的可维护性</strong>：</p>\n<p>遵守开闭原则的软件，其稳定性高和延续性强，从而易于扩展和维护。</p>\n</li>\n</ol>\n</div>\n<h3 id=\"_1-3-示例\"> 1.3 示例</h3>\n<p>以书店销售书籍为例，其类图如下：</p>\n<p><img src=\"./images/Java-DesignPatterns-SixPrinciple/OpenClosedPrincipleDemo.jpg\" alt=\"开闭原则示例\" /></p>\n<p>书籍接口</p>\n<div><pre><code><span>public</span> <span>interface</span> <span>IBook</span><span>{</span>\n  <span>public</span> <span>String</span> <span>getName</span><span>(</span><span>)</span><span>;</span>\n  <span>public</span> <span>String</span> <span>getPrice</span><span>(</span><span>)</span><span>;</span>\n  <span>public</span> <span>String</span> <span>getAuthor</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>小说类书籍：</p>\n<div><pre><code><span>public</span> <span>class</span> <span>NovelBook</span> <span>implements</span> <span>IBook</span><span>{</span>\n   <span>private</span> <span>String</span> name<span>;</span>\n   <span>private</span> <span>int</span> price<span>;</span>\n   <span>private</span> <span>String</span> author<span>;</span>\n\n   <span>public</span> <span>NovelBook</span><span>(</span><span>String</span> name<span>,</span><span>int</span> price<span>,</span><span>String</span> author<span>)</span><span>{</span>\n     <span>this</span><span>.</span>name <span>=</span> name<span>;</span>\n     <span>this</span><span>.</span>price <span>=</span> price<span>;</span>\n     <span>this</span><span>.</span>author <span>=</span> author<span>;</span>\n   <span>}</span>\n\n   <span>public</span> <span>String</span> <span>getAutor</span><span>(</span><span>)</span><span>{</span>\n     <span>return</span> <span>this</span><span>.</span>author<span>;</span>\n   <span>}</span>\n\n   <span>public</span> <span>String</span> <span>getName</span><span>(</span><span>)</span><span>{</span>\n     <span>return</span> <span>this</span><span>.</span>name<span>;</span>\n   <span>}</span>  \n\n   <span>public</span> <span>int</span> <span>getPrice</span><span>(</span><span>)</span><span>{</span>\n     <span>return</span> <span>this</span><span>.</span>price<span>;</span>\n   <span>}</span> \n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p>Client类：</p>\n<div><pre><code><span>public</span> <span>class</span> <span>Client</span><span>{</span>\n   <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>Strings</span><span>[</span><span>]</span> args<span>)</span><span>{</span>\n     <span>IBook</span> novel <span>=</span> <span>new</span> <span>NovelBook</span><span>(</span><span>\"笑傲江湖\"</span><span>,</span><span>100</span><span>,</span><span>\"金庸\"</span><span>)</span><span>;</span>\n     <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"书籍名字：\"</span><span>+</span>novel<span>.</span><span>getName</span><span>(</span><span>)</span><span>+</span><span>\"书籍作者：\"</span><span>+</span>novel<span>.</span><span>getAuthor</span><span>(</span><span>)</span><span>+</span><span>\"书籍价格：\"</span><span>+</span>novel<span>.</span><span>getPrice</span><span>(</span><span>)</span><span>)</span><span>;</span>\n   <span>}</span>\n\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>项目投产生，书籍正常销售，但是我们经常因为各种原因，要打折来销售书籍，这是一个变化，我们要如何应对这样一个需求变化呢？</p>\n<p>我们有下面三种方法可以解决此问题：</p>\n<div><p>解决方案</p>\n<ul>\n<li><strong>修改接口</strong>\n在IBook接口中，增加一个方法getOffPrice(),专门用于进行打折处理，所有的实现类实现此方法。但是这样的一个修改方式，实现类NovelBook要修改，同时IBook接口应该是稳定且可靠，不应该经常发生改变，否则接口作为契约的作用就失去了。因此，此方案否定。</li>\n<li><strong>修改实现类</strong>\n修改NovelBook类的方法，直接在getPrice()方法中实现打折处理。此方法是有问题的，例如我们如果getPrice()方法中只需要读取书籍的打折前的价格呢？这不是有问题吗？当然我们也可以再增加getOffPrice()方法，这也是可以实现其需求，但是这就有二个读取价格的方法，因此，该方案也不是一个最优方案。</li>\n<li><strong>通过扩展实现变化</strong>\n我们可以增加一个子类OffNovelBook,覆写getPrice方法。此方法修改少，对现有的代码没有影响，风险少，是个好办法。</li>\n</ul>\n</div>\n<p><img src=\"./images/Java-DesignPatterns-SixPrinciple/OpenClosedPrincipleDemo_2.jpg\" alt=\"修改后的类图\" /></p>\n<p>打折类：</p>\n<div><pre><code><span>public</span> <span>class</span> <span>OffNovelBook</span> <span>extends</span> <span>NovelBook</span><span>{</span>\n\n   <span>public</span> <span>OffNovelBook</span><span>(</span><span>String</span> name<span>,</span><span>int</span> price<span>,</span><span>String</span> author<span>)</span><span>{</span>\n      <span>super</span><span>(</span>name<span>,</span>price<span>,</span>author<span>)</span><span>;</span>\n   <span>}</span>\n\n   <span>//覆写价格方法，当价格大于40，就打8析，其他价格就打9析</span>\n   <span>public</span> <span>int</span> <span>getPrice</span><span>(</span><span>)</span><span>{</span>\n     <span>if</span><span>(</span><span>this</span><span>.</span>price <span>></span> <span>40</span><span>)</span><span>{</span>\n        <span>return</span> <span>this</span><span>.</span>price <span>*</span> <span>0.8</span><span>;</span>\n     <span>}</span><span>else</span><span>{</span>\n        <span>return</span> <span>this</span><span>.</span>price <span>*</span> <span>0.9</span><span>;</span>\n     <span>}</span>     \n   <span>}</span> \n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h3 id=\"_1-4-实现方法\"> 1.4 实现方法</h3>\n<p>第一：<strong>抽象约束</strong>\n抽象是对一组事物的通用描述，没有具体的实现，也就表示它可以有非常多的可能性，可以跟随需求的变化而变化。因此，通过接口或抽象类可以约束一组可能变化的行为，并且能够实现对扩展开放，其包含三层含义：</p>\n<ul>\n<li>通过接口或抽象类约束扩散，对扩展进行边界限定，不允许出现在接口或抽象类中不存在的public方法。</li>\n<li>参数类型，引用对象尽量使用接口或抽象类，而不是实现类，这主要是实现里氏替换原则的一个要求</li>\n<li>抽象层尽量保持稳定，一旦确定就不要修改</li>\n</ul>\n<p>第二：<strong>元数据(metadata)控件模块行为</strong>\n编程是一个很苦很累的活，那怎么才能减轻压力呢？答案是尽量使用元数据来控制程序的行为，减少重复开发。什么是元数据？用来描述环境和数据的数据，通俗的说就是配置参数，参数可以从文件中获得，也可以从数据库中获得。</p>\n<p>第三：<strong>制定项目章程</strong>\n在一个团队中，建立项目章程是非常重要的，因为章程是所有人员都必须遵守的约定，对项目来说，约定优于配置。这比通过接口或抽象类进行约束效率更高，而扩展性一点也没有减少。</p>\n<p>第四：<strong>封装变化</strong>\n对变化封装包含两层含义：\n(1)将相同的变化封装到一个接口或抽象类中\n(2)将不同的变化封装到不同的接口或抽象类中，不应该有两个不同的变化出现在同一个接口或抽象类中。\n封装变化，也就是受保护的变化，找出预计有变化或不稳定的点，我们为这些变化点创建稳定的接口。</p>\n<h2 id=\"_2-依赖倒置原则-dependency-inversion-principle-dip\"> 2 依赖倒置原则(Dependency Inversion Principle,DIP)</h2>\n<div><p>参考</p>\n<p><a href=\"https://blog.csdn.net/hfreeman2008/article/details/52289571?ops_request_misc=%25257B%252522request%25255Fid%252522%25253A%252522160853876616780261982313%252522%25252C%252522scm%252522%25253A%25252220140713.130102334.pc%25255Fblog.%252522%25257D&amp;request_id=160853876616780261982313&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-2-52289571.pc_v2_rank_blog_default&amp;utm_term=%E5%85%AD%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99\" target=\"_blank\" rel=\"noopener noreferrer\">六大设计原则之依赖倒置原则</a></p>\n</div>\n<h3 id=\"_2-1-介绍\"> 2.1 介绍</h3>\n<p>依赖倒置原则(Dependence Inversion Principle ,DIP)定义如下：</p>\n<div><p>定义</p>\n<p><strong>High level modules should not depend upon low level modules,Both should depend upon abstractions.Abstractions should not depend upon details.Details should depend upon abstracts.</strong></p>\n</div>\n<p>翻译过来为：</p>\n<div><p>Info</p>\n<ul>\n<li>高层模块不应该依赖低层模块，两者都应该依赖抽象</li>\n<li>抽象不应该依赖细节</li>\n<li>细节应该依赖抽象</li>\n</ul>\n</div>\n<p><strong>也可以说高层模块，低层模块，细节都应该依赖抽象</strong></p>\n<div><p>Info</p>\n<ul>\n<li>每一个逻辑的实现都是由颗粒原子逻辑组成的，颗粒原子逻辑就是低层模块，而颗粒原子逻辑组成的模块就是高层模块。</li>\n<li>在java语言中，抽象就是接口或抽象类，两都都是不能直接被实例化的</li>\n<li>细节就是实现类，实现接口或继承抽象类而产生的类就是细节，两者都可以直接被实例化。</li>\n</ul>\n</div>\n<h3 id=\"倒置\"> 倒置</h3>\n<p>倒置最终指的是，如果我开奶茶店需要各种各样的奶茶，此时奶茶店作为高层逻辑依赖于底层逻辑各种各样的奶茶，而按照依赖倒置原则，将奶茶抽象分类为水果茶，奶茶的时候，这些奶茶就反过来依赖于这些抽象种类，也符合了都依赖于抽象这一原则，而此时奶茶店只需要关注奶茶种类的抽象接口。</p>\n<h3 id=\"三种写法\"> 三种写法</h3>\n<ul>\n<li>通过构造器</li>\n<li>通过setter</li>\n<li>通过接口注入(实现一个方法用接口作为参数接收)</li>\n</ul>\n<h3 id=\"_2-2-最佳实践\"> 2.2 最佳实践</h3>\n<p>依赖倒置原则的本质就是通过抽象（接口或抽象类）使各个类或模块的实现彼此独立， 不互相影响，实现模块间的松耦合，我们怎么在项目中使用这个规则呢？只要遵循以下的几 个规则就可以：</p>\n<ul>\n<li>每个类尽量都有接口或抽象类，或者抽象类和接口两者都具备：这是依赖倒置的基本要求，接口和抽象类都是属于抽象的，有了抽象才可能依赖倒置。</li>\n<li>变量的表面类型尽量是接口或者是抽象类</li>\n<li>任何类都不应该从具体类派生</li>\n<li>尽量不要覆写基类的方法</li>\n<li>结合里氏替换原则使用</li>\n</ul>\n<p>更加精简的定义就是“面向接口编程”—OOD(Object-Oriented Design，面向对象设计)的精髓之一。</p>\n<h3 id=\"_2-2-好处\"> 2.2 好处</h3>\n<p>采用依赖倒置原则可以减少类间的耦合性，提高系统的稳定，降低并行开发引起的风险，提高代码的可读性和可维护性。</p>\n<h2 id=\"_3-迪米特原则-law-of-demeter-lod\"> 3. 迪米特原则(Law of Demeter,LoD)</h2>\n<div><p>参考</p>\n<p><a href=\"https://blog.csdn.net/hfreeman2008/article/details/52335601?ops_request_misc=%25257B%252522request%25255Fid%252522%25253A%252522160862280716780257419145%252522%25252C%252522scm%252522%25253A%25252220140713.130102334.pc%25255Fblog.%252522%25257D&amp;request_id=160862280716780257419145&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-3-52335601.pc_v2_rank_blog_default&amp;utm_term=%E5%85%AD%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99\" target=\"_blank\" rel=\"noopener noreferrer\">六大设计原则之迪米特原则</a></p>\n</div>\n<h3 id=\"_3-1-介绍\"> 3.1 介绍</h3>\n<p>迪米特原则(Law of Demeter,LoD)，也叫最少知识原则(Low knowledge Principle,LKP):</p>\n<p><strong>一个对象应该对其他对象有最少的了解。</strong></p>\n<p>通俗的讲：一个类对自己需要耦合或调用的类知道的最少，你(被耦合或调用的类)的内部是如何复杂和我没有关系，我就知道你提供的public方法，我只调用这些方法，其它的我不关心。</p>\n<p>一个类公开的public属性或方法越多，修改时涉及的面也就越大，变更引起的风险扩散 也就越大。因此，为了保持朋友类间的距离，在设计时需要反复衡量：是否还可以再减少 public方法和属性，是否可以修改为private、package-private（包类型，在类、方法、变量前 不加访问权限，则默认为包类型）、protected等访问权限，是否可以加上final关键字等。 注意 迪米特法则要求类“羞涩”一点，尽量不要对外公布太多的public方法和非静态的 public变量，尽量内敛，多使用private、package-private、protected等访问权限。</p>\n<p>迪米特法则的核心观念就是类间解耦，弱耦合，只有弱耦合了以后，类的复用率才可以 提高。其要求的结果就是产生了大量的中转或跳转类，导致系统的复杂性提高，同时也为维 护带来了难度。读者在采用迪米特法则时需要反复权衡，既做到让结构清晰，又做到高内聚 低耦合。</p>\n<h2 id=\"_4-里氏替换原则-liskov-substitution-principle-lsp\"> 4. 里氏替换原则(Liskov Substitution Principle,LSP)</h2>\n<div><p>参考</p>\n<p><a href=\"https://blog.csdn.net/hfreeman2008/article/details/52344343?ops_request_misc=%25257B%252522request%25255Fid%252522%25253A%252522160862280716780257419145%252522%25252C%252522scm%252522%25253A%25252220140713.130102334.pc%25255Fblog.%252522%25257D&amp;request_id=160862280716780257419145&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-1-52344343.pc_v2_rank_blog_default&amp;utm_term=%E5%85%AD%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99\" target=\"_blank\" rel=\"noopener noreferrer\">六大设计原则之里氏替换原则</a></p>\n</div>\n<h3 id=\"定义\"> 定义</h3>\n<p>所有引用基类的地方必须能透明地使用其子类的对象。</p>\n<p>通俗点讲，只要父类能出现的地方子类就可以出现，而且 替换为子类也不会产生任何错误或异常，使用者可能根本就不需要知道是父类还是子类。但 是，反过来就不行了，有子类出现的地方，父类未必就能适应。即向上转型和向下转型。</p>\n<h2 id=\"_6-接口隔离原则\"> 6. 接口隔离原则</h2>\n<div><p>参考</p>\n<p><a href=\"https://blog.csdn.net/hfreeman2008/article/details/52304172?ops_request_misc=%25257B%252522request%25255Fid%252522%25253A%252522160862280716780257419145%252522%25252C%252522scm%252522%25253A%25252220140713.130102334.pc%25255Fblog.%252522%25257D&amp;request_id=160862280716780257419145&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-5-52304172.pc_v2_rank_blog_default&amp;utm_term=%E5%85%AD%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99\" target=\"_blank\" rel=\"noopener noreferrer\">六大设计原则之接口隔离原则</a></p>\n</div>\n<h3 id=\"定义-2\"> 定义</h3>\n<ul>\n<li>客户端不应该依赖它不需要的接口。</li>\n<li>类间的依赖关系应该建立在最小的接口上。</li>\n</ul>\n<p>我们可以把这两个定义概括为一句话：建立单一接口，不要建立臃肿庞大的接口。再通 俗一点讲：接口尽量细化，同时接口中的方法尽量少。看到这里大家有可能要疑惑了，这与 单一职责原则不是相同的吗？错，接口隔离原则与单一职责的审视角度是不相同的，单一职 责要求的是类和接口职责单一，注重的是职责，这是业务逻辑上的划分，而接口隔离原则要 求接口的方法尽量少。例如一个接口的职责可能包含10个方法，这10个方法都放在一个接口 中，并且提供给多个模块访问，各个模块按照规定的权限来访问，在系统外通过文档约 束“不使用的方法不要访问”，按照单一职责原则是允许的，按照接口隔离原则是不允许的， 因为它要求“尽量使用多个专门的接口”。专门的接口指什么？就是指提供给每个模块的都应 该是单一接口，提供给几个模块就应该有几个接口，而不是建立一个庞大的臃肿的接口，容 纳所有的客户端访问。</p>\n",
      "date_published": "2020-08-09T22:37:52.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": []
    },
    {
      "title": "设计模式之结构型设计模式",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/java/java-DesignPatterns/Java-DesignPatterns-StructuralPatterns/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/java/java-DesignPatterns/Java-DesignPatterns-StructuralPatterns/",
      "content_html": "<h2 id=\"参考\"> 参考</h2>\n<div><p>参考</p>\n<ul>\n<li>https://www.runoob.com/design-pattern/design-pattern-intro.html</li>\n<li>http://c.biancheng.net/view/1317.html</li>\n<li><a href=\"TheZen0fDesignPattern_2.pdf\">设计模式之禅</a></li>\n</ul>\n</div>\n<h2 id=\"代理模式\"> 代理模式</h2>\n<p>参考</p>\n<ul>\n<li><a href=\"https://www.jianshu.com/p/9bcac608c714\" target=\"_blank\" rel=\"noopener noreferrer\">JAVA动态代理</a></li>\n<li><a href=\"https://www.zhihu.com/question/20794107/answer/658139129\" target=\"_blank\" rel=\"noopener noreferrer\">JAVA动态代理</a></li>\n</ul>\n<h3 id=\"定义\"> 定义</h3>\n<p>Provide a surrogate or placeholder for another object to control access to it.（为其他对象提供 一种代理以控制对这个对象的访问。）</p>\n<p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/Java-DesignPatterns-StructuralPatterns/代理模式.png\" alt=\"image-20211114145043383\" /></p>\n<p>代理者要代理谁就产生该代理的实例，然后把被代理者传递进来，该模式在实际的项目应用中比较广泛。</p>\n<h3 id=\"静态代理\"> 静态代理</h3>\n<p>它的要求就是客户端只能访问代理角色，而不能访问真实角色，这是比较简单的。</p>\n<blockquote>\n<p>强制代理：当访问一个真实角色时，返回的都是代理角色，无论什么情况。</p>\n</blockquote>\n<p>1.为现有的每一个类都编写一个<strong>对应的</strong>代理类，并且让它实现和目标类相同的接口（假设都有）</p>\n<p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/Java-DesignPatterns-StructuralPatterns/静态代理.jpg\" alt=\"img\" /></p>\n<p>2.在创建代理对象时，通过构造器塞入一个目标对象，然后在代理对象的方法内部调用目标对象同名方法，并在调用前后打印日志。也就是说，<strong>代理对象 = 增强代码 + 目标对象（原对象）</strong>。有了代理对象后，就不用原对象了</p>\n<p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/Java-DesignPatterns-StructuralPatterns/静态代理2.jpg\" alt=\"img\" /></p>\n<p>缺陷</p>\n<p>程序员要手动为每一个目标类编写对应的代理类。如果当前系统已经有成百上千个类，工作量太大了。所以，现在我们的努力方向是：如何少写或者不写代理类，却能完成代理功能？</p>\n<h3 id=\"动态代理\"> 动态代理</h3>\n<p>要创建一个实例，最关键的就是得到对应的Class对象。能否不写代理类，而直接得到代理Class对象，然后根据它创建代理实例（反射）。</p>\n<p>动态代理是在实现阶段不用关心代理谁，而在运行阶段才指定代理哪一个对象，相对来说，自己写代理类的方式就是静态代理。本章节的核心部分 就在动态代理上，现在有一个非常流行的名称叫做面向横切面编程，也就是AOP（Aspect Oriented Programming），其核心就是采用了动态代理机制。</p>\n<p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/Java-DesignPatterns-StructuralPatterns/动态代理.png\" alt=\"image-20211114172114717\" /></p>\n<p>在类图中增加了一个InvocationHandler接口和GamePlayIH类，作用就是产生一个对象的 代理对象，其中<code>InvocationHandler</code>是JDK提供的动态代理接口，对被代理类的方法进行代理。</p>\n<p>其中invoke方法是接口InvocationHandler定义必须实现的，它完成对真实方法的调用。我 们来详细讲解一下InvocationHandler接口，动态代理是根据被代理的接口生成所有的方法， 也就是说给定一个接口，动态代理会宣称“我已经实现该接口下的所有方法了”，那各位读者 想想看，动态代理怎么才能实现被代理接口中的方法呢？默认情况下所有的方法返回值都是 空的，是的，代理已经实现它了，但是没有任何的逻辑含义，那怎么办？好办，通过 InvocationHandler接口，所有方法都由该Handler来进行处理，即所有被代理的方法都由 InvocationHandler接管实际的处理任务。</p>\n<p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/Java-DesignPatterns-StructuralPatterns/动态代理2.png\" alt=\"image-20211114181847364\" /></p>\n<p>动态调用过程</p>\n<p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/Java-DesignPatterns-StructuralPatterns/动态调用过程.png\" alt=\"image-20211114185027020\" /></p>\n<p>动态代理具体步骤：</p>\n<ol>\n<li>通过实现 InvocationHandler 接口创建自己的调用处理器；</li>\n<li>通过为 Proxy 类指定 ClassLoader 对象和一组 interface 来创建动态代理类；</li>\n<li>通过反射机制获得动态代理类的构造函数，其唯一参数类型是调用处理器接口类型；</li>\n<li>通过构造函数创建动态代理类实例，构造时调用处理器对象作为参数被传入。</li>\n</ol>\n<p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/Java-DesignPatterns-StructuralPatterns/动态代理流程图.png\" alt=\"img\" /></p>\n<h4 id=\"底层原理\"> 底层原理</h4>\n<ol>\n<li>创建一个<code>ProxyHandle</code>实现<code>InvocationHandler</code>接口的invoke方法，并在invoke方法中写好增强的逻辑</li>\n<li>通过<code>Proxy.newProxyInstance(ClassLoader c, Interface[] i, InvocationHandler handle)</code>方法传入实例对象的，根据实例对象的构造器和接口生成class文件通过反射创造一个代理类并创建代理对象</li>\n<li>代理类是实现<code>InvocationHandler</code>接口且内部有一个变量<code>invocationHandler</code>，代理对象也实现了原本实例对象的接口，但是代理对象的实现方法都是只调用<code>invocationHandler</code>的<code>invoke</code>方法</li>\n<li>最后我们用代理对象来执行方法，就会调用我们的invoke方法的增强逻辑</li>\n</ol>\n<p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/Java-DesignPatterns-StructuralPatterns/动态调用过程2.jpg\" alt=\"img\" /></p>\n<p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/Java-DesignPatterns-StructuralPatterns/动态代理过程3.jpg\" alt=\"img\" /></p>\n<h4 id=\"实例\"> 实例</h4>\n<p><code>HelloInterface</code></p>\n<div><pre><code><span>public</span> <span>interface</span> <span>HelloInterface</span> <span>{</span>\n    <span>void</span> <span>sayHello</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><code>Hello.class</code></p>\n<div><pre><code><span>public</span> <span>class</span> <span>Hello</span> <span>implements</span> <span>HelloInterface</span> <span>{</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>sayHello</span><span>(</span><span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"Hello world!\"</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p><code>ProxyHandle.class</code></p>\n<div><pre><code><span>public</span> <span>class</span> <span>ProxyHandler</span> <span>implements</span> <span>InvocationHandler</span> <span>{</span>\n\n    <span>private</span> <span>Object</span> object<span>;</span>\n\n    <span>public</span> <span>ProxyHandler</span><span>(</span><span>Object</span> object<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>object <span>=</span> object<span>;</span>\n    <span>}</span>\n\n    <span>//增强逻辑</span>\n    <span>@Override</span>\n    <span>public</span> <span>Object</span> <span>invoke</span><span>(</span><span>Object</span> proxy<span>,</span> <span>Method</span> method<span>,</span> <span>Object</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>Throwable</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"Before invoke \"</span> <span>+</span> method<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>Object</span> result <span>=</span> method<span>.</span><span>invoke</span><span>(</span>object<span>,</span> args<span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"After invoke \"</span> <span>+</span> method<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>return</span> result<span>;</span>\n    <span>}</span>\n\n    <span>//自定义方法返回代理类</span>\n    <span>public</span> <span>static</span> <span>Object</span> <span>getProxy</span><span>(</span><span>Object</span> object<span>)</span> <span>{</span>\n        <span>InvocationHandler</span> handler <span>=</span> <span>new</span> <span>ProxyHandler</span><span>(</span>object<span>)</span><span>;</span>\n        <span>return</span> <span>Proxy</span><span>.</span><span>newProxyInstance</span><span>(</span>object<span>.</span><span>getClass</span><span>(</span><span>)</span><span>.</span><span>getClassLoader</span><span>(</span><span>)</span><span>,</span> object<span>.</span><span>getClass</span><span>(</span><span>)</span><span>.</span><span>getInterfaces</span><span>(</span><span>)</span><span>,</span> handler<span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p><code>Main</code></p>\n<div><pre><code><span>@Test</span>\n<span>public</span> <span>void</span> <span>test2</span><span>(</span><span>)</span> <span>{</span>\n    <span>HelloInterface</span> hello <span>=</span> <span>new</span> <span>Hello</span><span>(</span><span>)</span><span>;</span>\n    <span>HelloInterface</span> helloProxy <span>=</span> <span>(</span><span>HelloInterface</span><span>)</span> <span>ProxyHandler</span><span>.</span><span>getProxy</span><span>(</span>hello<span>)</span><span>;</span>\n    helloProxy<span>.</span><span>sayHello</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>结果</p>\n<div><pre><code><span>Before</span> invoke sayHello\n<span>Hello</span> world<span>!</span>\n<span>After</span> invoke sayHello\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h4 id=\"cglib动态代理\"> CGLIB动态代理</h4>\n<p>参考</p>\n<ul>\n<li><a href=\"https://www.cnblogs.com/suizhikuo/p/13941272.html\" target=\"_blank\" rel=\"noopener noreferrer\">CGLib动态代理原理及实现</a></li>\n</ul>\n<p>JDK实现动态代理需要实现类通过接口定义业务方法，对于没有接口的类，如何实现动态代理呢，这就需要CGLib了。CGLib采用了非常底层的字节码技术，其原理是通过字节码技术为一个类创建子类，并在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑。JDK动态代理与CGLib动态代理均是实现Spring AOP的基础。</p>\n<p>CGLib创建的动态代理对象性能比JDK创建的动态代理对象的性能高不少，但是CGLib在创建代理对象时所花费的时间却比JDK多得多，所以对于单例的对象，因为无需频繁创建对象，用CGLib合适，反之，使用JDK方式要更为合适一些。</p>\n<p>失效情况</p>\n<p>同时，由于CGLib由于是采用动态创建子类的方法，对于<code>final</code>方法，无法进行代理增强，但是能调用原来的方法</p>\n<h4 id=\"jdk和cglib两种动态代理区别\"> jdk和cglib两种动态代理区别</h4>\n<ul>\n<li>JDK动态代理只能对实现了接口的类生成代理，而不能针对类</li>\n<li>CGLIB是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法因为是继承，所以该类或方法最好不要声明成final</li>\n</ul>\n<h4 id=\"spring\"> Spring</h4>\n<ol>\n<li>如果目标对象实现了接口，默认情况下会采用JDK的动态代理实现AOP</li>\n<li>如果目标对象实现了接口，可以强制使用CGLIB实现AOP</li>\n<li>如果目标对象没有实现了接口，必须采用CGLIB库，spring会自动在JDK动态代理和CGLIB之间转换</li>\n</ol>\n<p>如何强制使用CGLIB实现AOP？</p>\n<ul>\n<li>添加CGLIB库，SPRING_HOME/cglib/*.jar</li>\n<li>在spring配置文件中加入&lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;/&gt;</li>\n</ul>\n<h2 id=\"适配器模式\"> 适配器模式</h2>\n<h3 id=\"定义-2\"> 定义</h3>\n<p>适配器模式（Adapter Pattern）的定义如下：</p>\n<div><p>定义</p>\n<p>Convert the interface of a class into another interface clients expect.Adapter lets classes work together that couldn't otherwise because of incompatible interfaces.（将一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。）</p>\n</div>\n<div><p>介绍</p>\n<ul>\n<li>意图：将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</li>\n<li>主要解决：主要解决在软件系统中，常常要将一些&quot;现存的对象&quot;放到新的环境中，而新环境要求的接口是现对象不能满足的。</li>\n<li>何时使用： 1、系统需要使用现有的类，而此类的接口不符合系统的需要。 2、想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作，这些源类不一定有一致的接口。 3、通过接口转换，将一个类插入另一个类系中。（比如老虎和飞禽，现在多了一个飞虎，在不增加实体的需求下，增加一个适配器，在里面包容一个虎对象，实现飞的接口。）</li>\n<li>如何解决：继承或依赖（推荐）。</li>\n<li>关键代码：适配器继承或依赖已有的对象，实现想要的目标接口。</li>\n<li>应用实例： 1、美国电器 110V，中国 220V，就要有一个适配器将 110V 转化为 220V。 2、JAVA JDK 1.1 提供了 Enumeration 接口，而在 1.2 中提供了 Iterator 接口，想要使用 1.2 的 JDK，则要将以前系统的 Enumeration 接口转化为 Iterator 接口，这时就需要适配器模式。 3、在 LINUX 上运行 WINDOWS 程序。 4、JAVA 中的 jdbc。</li>\n<li>优点： 1、可以让任何两个没有关联的类一起运行。 2、提高了类的复用。 3、增加了类的透明度。 4、灵活性好。</li>\n<li>缺点： 1、过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。 2.由于 JAVA 至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类。</li>\n<li>使用场景：有动机地修改一个正常运行的系统的接口，这时应该考虑使用适配器模式。</li>\n<li>注意事项：适配器不是在详细设计时添加的，而是解决正在服役的项目的问题。</li>\n</ul>\n</div>\n<p>适配器模式又叫做变压器模式，也叫做包装模式（Wrapper），但是包装模式可不止一 个，还包括了第17章讲解的装饰模式。适配器模式的通用类图，如图19-4所示。</p>\n<p><img src=\"./images/Java-DesignPatterns-StructuralPatterns/Adapter_pattern_general_class_diagram.jpg\" alt=\"适配器模式通用类图\" /></p>\n<p>适配器模式在生活中还是很常见的，比如你笔记本上的电源适配器，可以使用在110～ 220V之间变化的电源，而笔记本还能正常工作，这也是适配器一个良好模式的体现，简单地 说，适配器模式就是把一个接口或类转换成其他的接口或类，从另一方面来说，适配器模式 也就是一个包装模式，为什么呢？它把Adaptee包装成一个Target接口的类，加了一层衣服， 包装成另外一个靓妞了。大家知道，设计模式原是为建筑设计而服务的，软件设计模式只是 借用了人家的原理而已，那我们来看看最原始的适配器是如何设计的，如图19-5所示。</p>\n<p>A、B两个图框代表已经塑模成型的物体A和物体B，那现在要求把A和B安装在一起使 用，如何安装？两者的接口不一致，是不可能安装在一起使用的，那怎么办？引入一个物体 C，如图19-6所示。</p>\n<p><img src=\"./images/Java-DesignPatterns-StructuralPatterns/19-6.jpg\" alt=\"举例\" /></p>\n<p>引入物体C后，C适应了物体A的接口，同时也适应了物体B的接口，然后三者就可以组 合成一个完整的物体，如图19-7所示。</p>\n<p><img src=\"./images/Java-DesignPatterns-StructuralPatterns/19-7.jpg\" alt=\"图19-7 完美组合\" /></p>\n<p>其中的物体C就是我们说的适配器，它在中间起到了角色转换的作用，把原有的长条形 接口转换了三角形接口。在我们软件业的设计模式中，适配器模式也是相似的功能，那我们 先来看看适配器模式的三个角色。</p>\n<div><p>三个角色</p>\n<ul>\n<li>\n<p><strong>Target目标角色</strong></p>\n<blockquote>\n<p>该角色定义把其他类转换为何种接口，也就是我们的期望接口，例子中的IUserInfo接口 就是目标角色。</p>\n</blockquote>\n</li>\n<li>\n<p><strong>Adaptee源角色</strong></p>\n<blockquote>\n<p>你想把谁转换成目标角色，这个“谁”就是源角色，它是已经存在的、运行良好的类或对 象，经过适配器角色的包装，它会成为一个崭新、靓丽的角色。</p>\n</blockquote>\n</li>\n<li>\n<p><strong>Adapter适配器角色</strong></p>\n<blockquote>\n<p>适配器模式的核心角色，其他两个角色都是已经存在的角色，而适配器角色是需要新建 立的，它的职责非常简单：把源角色转换为目标角色，怎么转换？通过<code>继承</code>或是<code>类关联</code>的方式。</p>\n</blockquote>\n</li>\n</ul>\n</div>\n<p>各个角色的职责都已经非常清楚，我们再来看看其通用源码，目标接口如代码清单19-8 所示。</p>\n<p>代码清单19-8 目标角色</p>\n<div><pre><code><span>public</span> <span>interface</span> <span>Target</span> <span>{</span>\n  <span>//目标角色有自己的方法</span>\n  <span>public</span> <span>void</span> <span>request</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>目标角色是一个已经在正式运行的角色，你不可能去修改角色中的方法，你能做的就是 如何去实现接口中的方法，而且通常情况下，目标角色是一个接口或者是抽象类，一般不会 是实现类。一个正在服役的目标角色，如代码清单19-9所示。</p>\n<p>代码清单19-9 目标角色的实现类</p>\n<div><pre><code><span>public</span> <span>class</span> <span>ConcreteTarget</span> <span>implements</span> <span>Target</span> <span>{</span>\n  <span>public</span> <span>void</span> <span>request</span><span>(</span><span>)</span> <span>{</span>\n    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"if you need any help,pls call me!\"</span><span>)</span><span>;</span> <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>源角色也是已经在服役状态（当然，非要新建立一个源角色，然后套用适配器模式，那 也没有任何问题），它是一个正常的类，其源代码如代码清单19-10所示。</p>\n<p>代码清单19-10 源角色</p>\n<div><pre><code><span>public</span> <span>class</span> <span>Adaptee</span> <span>{</span>\n  <span>//原有的业务逻辑</span>\n  <span>public</span> <span>void</span> <span>doSomething</span><span>(</span><span>)</span><span>{</span>\n    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"I'm kind of busy,leave me alone,pls!\"</span><span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>我们的核心角色要出场了，适配器角色如代码清单19-11所示。 代码清单19-11 适配器角色</p>\n<div><pre><code><span>public</span> <span>class</span> <span>Adapter</span> <span>extends</span> <span>Adaptee</span> <span>implements</span> <span>Target</span> <span>{</span>\n  <span>public</span> <span>void</span> <span>request</span><span>(</span><span>)</span> <span>{</span>\n    <span>super</span><span>.</span><span>doSomething</span><span>(</span><span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>所有的角色都已经在场了，那我们就开始看看这场演出，场景类如代码清单19-12所 示。</p>\n<div><pre><code><span>public</span> <span>class</span> <span>Client</span> <span>{</span>\n  <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n    <span>//原有的业务逻辑</span>\n    <span>Target</span> target <span>=</span> <span>new</span> <span>ConcreteTarget</span><span>(</span><span>)</span><span>;</span>\n    target<span>.</span><span>request</span><span>(</span><span>)</span><span>;</span>\n    <span>//现在增加了适配器角色后的业务逻辑</span>\n    <span>Target</span> target2 <span>=</span> <span>new</span> <span>Adapter</span><span>(</span><span>)</span><span>;</span>\n    target2<span>.</span><span>request</span><span>(</span><span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h3 id=\"优点\"> 优点</h3>\n<ul>\n<li>\n<p>适配器模式可以让两个没有任何关系的类在一起运行，只要适配器这个角色能够搞定 他们就成。</p>\n</li>\n<li>\n<p>增加了类的透明性</p>\n<blockquote>\n<p>想想看，我们访问的Target目标角色，但是具体的实现都委托给了源角色，而这些对高层次模块是透明的，也是它不需要关心的。</p>\n</blockquote>\n</li>\n<li>\n<p>提高了类的复用度</p>\n<blockquote>\n<p>当然了，源角色在原有的系统中还是可以正常使用，而在目标角色中也可以充当新的演 员。</p>\n</blockquote>\n</li>\n<li>\n<p>灵活性非常好</p>\n<blockquote>\n<p>某一天，突然不想要适配器，没问题，删除掉这个适配器就可以了，其他的代码都不用 修改，基本上就类似一个灵活的构件，想用就用，不想就卸载。</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"使用场景\"> 使用场景</h3>\n<p>适配器应用的场景只要记住一点就足够了：你有动机修改一个已经投产中的接口时，适 配器模式可能是最适合你的模式。比如系统扩展了，需要使用一个已有或新建立的类，但这 个类又不符合系统的接口，怎么办？使用适配器模式，这也是我们例子中提到的。</p>\n<h3 id=\"注意事项\"> 注意事项</h3>\n<p>适配器模式最好在详细设计阶段不要考虑它，它不是为了解决还处在开发阶段的问题， 而是解决正在服役的项目问题，没有一个系统分析师会在做详细设计的时候考虑使用适配器 模式，这个模式使用的主要场景是扩展应用中，就像我们上面的那个例子一样，系统扩展 了，不符合原有设计的时候才考虑通过适配器模式减少代码修改带来的风险。 再次提醒一点，项目一定要遵守依赖倒置原则和里氏替换原则，否则即使在适合使用适 配器的场合下，也会带来非常大的改造。</p>\n<h3 id=\"例子\"> 例子</h3>\n<p>2004年我带了一个项目，做一个人力资源管理项目，该项目是我们总公司发起的，公司 一共有700多号人。这个项目还是比较简单的，分为三大模块：人员信息管理、薪酬管理、 职位管理。当时开发时业务人员明确指明：人员信息管理的对象是所有员工的所有信息，所 有的员工指的是在职的员工，其他的离职的、退休的暂不考虑。根据需求我们设计了如图 19-1所示的类图。</p>\n<p><img src=\"./images/Java-DesignPatterns-StructuralPatterns/Personnel_Information_Class_Diagram.jpg\" alt=\"人员信息类图\" /></p>\n<p>非常简单，有一个对象UserInfo存储用户的所有信息（实际系统上还有很多子类，不多 说了），也就是BO（Business Object，业务对象），这个对象设计为贫血对象（Thin Business Object），不需要存储状态以及相关的关系，本人是反对使用充血对象（Rich Business Object），这里提到两个名词：贫血对象和充血对象，这两个名词很简单，在领域 模型中分别叫做贫血领域模型和充血领域模型，有什么区别呢？一个对象如果不存储实体状 态以及对象之间的关系，该对象就叫做贫血对象，对应的领域模型就是贫血领域模型，有实 体状态和对象关系的模型就是充血领域模型。看不懂没关系，都是糊弄人的东西，属于专用 名词。扯远了，我们继续说我们的人力资源管理项目，这个UserInfo对象，在系统中很多地 方使用，你可以查看自己的信息，也可以修改，当然这个对象是有setter方法的，我们这里用 不到就隐藏掉了。先来看接口，员工信息接口如代码清单19-1所示。</p>\n<p>代码清单19-1 员工信息接口</p>\n<div><pre><code><span>public</span> <span>interface</span> <span>IUserInfo</span> <span>{</span>\n  <span>//获得用户姓名</span>\n  <span>public</span> <span>String</span> <span>getUserName</span><span>(</span><span>)</span><span>;</span>\n  <span>//获得家庭地址</span>\n  <span>public</span> <span>String</span> <span>getHomeAddress</span><span>(</span><span>)</span><span>;</span>\n  <span>//手机号码，这个太重要，手机泛滥呀</span>\n  <span>public</span> <span>String</span> <span>getMobileNumber</span><span>(</span><span>)</span><span>;</span>\n  <span>//办公电话，一般是座机</span>\n  <span>public</span> <span>String</span> <span>getOfficeTelNumber</span><span>(</span><span>)</span><span>;</span>\n  <span>//这个人的职位是什么</span>\n  <span>public</span> <span>String</span> <span>getJobPosition</span><span>(</span><span>)</span><span>;</span>\n  <span>//获得家庭电话，这有点不好，我不喜欢打家庭电话讨论工作</span>\n  <span>public</span> <span>String</span> <span>getHomeTelNumber</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>员工信息接口有了，就需要设计一个实现类来容纳数据，如代码清单19-2所示。</p>\n<p>代码清单19-2 实现类</p>\n<div><pre><code><span>public</span> <span>class</span> <span>UserInfo</span> <span>implements</span> <span>IUserInfo</span> <span>{</span>\n  <span>/*\n* 获得家庭地址，下属送礼也可以找到地方\n*/</span>\n  <span>public</span> <span>String</span> <span>getHomeAddress</span><span>(</span><span>)</span> <span>{</span>\n    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"这里是员工的家庭地址...\"</span><span>)</span><span>;</span>\n    <span>return</span> <span>null</span><span>;</span>\n  <span>}</span>\n  <span>/*\n* 获得家庭电话号码\n*/</span>\n  <span>public</span> <span>String</span> <span>getHomeTelNumber</span><span>(</span><span>)</span> <span>{</span>\n    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"员工的家庭电话是...\"</span><span>)</span><span>;</span>\n    <span>return</span> <span>null</span><span>;</span>\n  <span>}</span>\n  <span>/*\n* 员工的职位，是部门经理还是普通职员\n*/</span>\n  <span>public</span> <span>String</span> <span>getJobPosition</span><span>(</span><span>)</span> <span>{</span>\n    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"这个人的职位是BOSS...\"</span><span>)</span><span>;</span>\n    <span>return</span> <span>null</span><span>;</span>\n  <span>}</span>\n  <span>/*\n* 手机号码\n*/</span>\n  <span>public</span> <span>String</span> <span>getMobileNumber</span><span>(</span><span>)</span> <span>{</span>\n    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"这个人的手机号码是0000...\"</span><span>)</span><span>;</span>\n    <span>return</span> <span>null</span><span>;</span>\n  <span>}</span>\n  <span>/*\n* 办公室电话，烦躁的时候最好\"不小心\"把电话线踢掉\n*/</span>\n  <span>public</span> <span>String</span> <span>getOfficeTelNumber</span><span>(</span><span>)</span> <span>{</span>\n    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"办公室电话是...\"</span><span>)</span><span>;</span>\n    <span>return</span> <span>null</span><span>;</span>\n  <span>}</span>\n  <span>/*\n* 姓名，这个很重要\n*/</span>\n  <span>public</span> <span>String</span> <span>getUserName</span><span>(</span><span>)</span> <span>{</span>\n    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"姓名叫做...\"</span><span>)</span><span>;</span>\n    <span>return</span> <span>null</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br></div></div><p>这个项目是2004年年底投产的，运行到2005年年底还是比较平稳的，中间修修补补也很 正常，2005年年底不知道是哪股风吹的，很多公司开始使用借聘人员的方式引进人员，我们 公司也不例外，从一个劳动资源公司借用了一大批的低技术、低工资的人员，分配到各个子 公司，总共有将近200人，然后人力资源部就找我们部门老大谈判，说要增加一个功能：借 用人员管理，老大一看有钱赚呀，一拍大腿，做！</p>\n<p>老大命令一下来，我立马带人过去调研，需求就一句话，但是真深入地调研还真不是那 么简单。借聘人员虽然在我们公司干活，和我们一个样，干活时没有任何的差别，但是他们 的人员信息、工资情况、福利情况等都是由劳动服务公司管理的，并且有一套自己的人员管 理系统，人力资源部门就要求我们系统同步劳动服务公司的信息，当然是只要在我们公司工 作的人员信息，其他人员信息是不需要的，而且还要求信息同步，也就是：劳动服务公司的 人员信息一变更，我们系统就应该立刻体现出来，为什么要即时而不批量呢？是因为我们公 司与劳动服务公司之间是按照人头收费的，甭管是什么人，只要我们公司借用，就这个价 格，我要一个研究生，你派了一个高中生给我，那算什么事？因此，了解了业务需求用后， 项目组决定采用RMI（Remote Method Invocation，远程对象调用）的方式进行联机交互，但 是深入分析后，一个重大问题立刻显现出来：劳动服务公司的人员对象和我们系统的对象不 相同，他们的对象如下所示。</p>\n<p><img src=\"./images/Java-DesignPatterns-StructuralPatterns/Personnel_information_class_diagram_of_labor_service_company.jpg\" alt=\"劳动服务公司的人员信息类图\" /></p>\n<p>劳动服务公司是把人员信息分为了三部分：基本信息、办公信息和个人家庭信息，并且 都放到了HashMap中，比如人员的姓名放到BaseInfo信息中，家庭地址放到HomeInfo中，这 也是一个可以接受的模式，我们来看看他们的代码，接口如代码清单19-3所示。 代码清单19-3 劳动服务公司的人员信息接口</p>\n<div><pre><code><span>public</span> <span>interface</span> <span>IOuterUser</span> <span>{</span>\n  <span>//基本信息，比如名称、性别、手机号码等</span>\n  <span>public</span> <span>Map</span> <span>getUserBaseInfo</span><span>(</span><span>)</span><span>;</span>\n  <span>//工作区域信息</span>\n  <span>public</span> <span>Map</span> <span>getUserOfficeInfo</span><span>(</span><span>)</span><span>;</span>\n  <span>//用户的家庭信息</span>\n  <span>public</span> <span>Map</span> <span>getUserHomeInfo</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>劳动服务公司的人员信息是这样存放的，如代码清单19-4所示。 代码清单19-4 劳动服务公司的人员实现</p>\n<div><pre><code><span>public</span> <span>class</span> <span>OuterUser</span> <span>implements</span> <span>IOuterUser</span> <span>{</span>\n  <span>/*\n* 用户的基本信息\n*/</span>\n  <span>public</span> <span>Map</span> <span>getUserBaseInfo</span><span>(</span><span>)</span> <span>{</span>\n    <span>HashMap</span> baseInfoMap <span>=</span> <span>new</span> <span>HashMap</span><span>(</span><span>)</span><span>;</span>\n    baseInfoMap<span>.</span><span>put</span><span>(</span><span>\"userName\"</span><span>,</span> <span>\"这个员工叫混世魔王...\"</span><span>)</span><span>;</span>\n    baseInfoMap<span>.</span><span>put</span><span>(</span><span>\"mobileNumber\"</span><span>,</span> <span>\"这个员工电话是...\"</span><span>)</span><span>;</span>\n    <span>return</span> baseInfoMap<span>;</span>\n  <span>}</span>\n  <span>/*\n* 员工的家庭信息\n*/</span>\n  <span>public</span> <span>Map</span> <span>getUserHomeInfo</span><span>(</span><span>)</span> <span>{</span>\n    <span>HashMap</span> homeInfo <span>=</span> <span>new</span> <span>HashMap</span><span>(</span><span>)</span><span>;</span>\n    homeInfo<span>.</span><span>put</span><span>(</span><span>\"homeTelNumbner\"</span><span>,</span> <span>\"员工的家庭电话是...\"</span><span>)</span><span>;</span>\n    homeInfo<span>.</span><span>put</span><span>(</span><span>\"homeAddress\"</span><span>,</span> <span>\"员工的家庭地址是...\"</span><span>)</span><span>;</span>\n    <span>return</span> homeInfo<span>;</span>\n  <span>}</span>\n  <span>/*\n* 员工的工作信息，比如，职位等\n*/</span>\n  <span>public</span> <span>Map</span> <span>getUserOfficeInfo</span><span>(</span><span>)</span> <span>{</span>\n    <span>HashMap</span> officeInfo <span>=</span> <span>new</span> <span>HashMap</span><span>(</span><span>)</span><span>;</span>\n    officeInfo<span>.</span><span>put</span><span>(</span><span>\"jobPosition\"</span><span>,</span><span>\"这个人的职位是BOSS...\"</span><span>)</span><span>;</span>\n    officeInfo<span>.</span><span>put</span><span>(</span><span>\"officeTelNumber\"</span><span>,</span> <span>\"员工的办公电话是...\"</span><span>)</span><span>;</span>\n    <span>return</span> officeInfo<span>;</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><p>看到这里，咱不好说他们系统设计得不好，问题是咱的系统要和他们的系统进行交互， 怎么办？我们不可能为了这一小小的功能而对我们已经运行良好系统进行大手术，那怎么 办？我们可以转化，先拿到对方的数据对象，然后转化为我们自己的数据对象，中间加一层 转换处理，按照这个思路，我们设计了如图19-3所示的类图。</p>\n<p><img src=\"./images/Java-DesignPatterns-StructuralPatterns/Added_a_class_diagram_of_personnel_information_for_transfer_processing.jpg\" alt=\"增加了中转处理的人员信息类图\" /></p>\n<p>大家可能会问，这两个对象都不在一个系统中，你如何使用呢？简单！RMI已经帮我们 做了这件事情，只要有接口，就可以把远程的对象当成本地的对象使用，这个大家有时间可 以去看一下RMI文档，不多说了。OuterUserInfo可以看做是“两面派”，实现了IUserInfo接口， 还继承了OuterUser，通过这样的设计，把OuterUser伪装成我们系统中一个IUserInfo对象，这 样，我们的系统基本不用修改，所有的人员查询、调用跟本地一样。</p>\n<div><p>Note</p>\n<p>我们之所以能够增加一个OuterUserInfo中转类，是因为我们在系统设计时严格遵守了<code>依赖倒置原则</code>和<code>里氏替换原则</code>，否则即使增加了中转类也无法解决问题。</p>\n</div>\n<p>代码清单19-5 中转角色</p>\n<div><pre><code><span>public</span> <span>class</span> <span>OuterUserInfo</span> <span>extends</span> <span>OuterUser</span> <span>implements</span> <span>IUserInfo</span> <span>{</span>\n  <span>private</span> <span>Map</span> baseInfo <span>=</span> <span>super</span><span>.</span><span>getUserBaseInfo</span><span>(</span><span>)</span><span>;</span> <span>//员工的基本信息</span>\n  <span>private</span> <span>Map</span> homeInfo <span>=</span> <span>super</span><span>.</span><span>getUserHomeInfo</span><span>(</span><span>)</span><span>;</span> <span>//员工的家庭信息</span>\n  <span>private</span> <span>Map</span> officeInfo <span>=</span> <span>super</span><span>.</span><span>getUserOfficeInfo</span><span>(</span><span>)</span><span>;</span> <span>//工作信息</span>\n  <span>/*\n* 家庭地址\n*/</span>\n  <span>public</span> <span>String</span> <span>getHomeAddress</span><span>(</span><span>)</span> <span>{</span>\n    <span>String</span> homeAddress <span>=</span> <span>(</span><span>String</span><span>)</span><span>this</span><span>.</span>homeInfo<span>.</span><span>get</span><span>(</span><span>\"homeAddress\"</span><span>)</span><span>;</span>\n    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>homeAddress<span>)</span><span>;</span>\n    <span>return</span> homeAddress<span>;</span>\n  <span>}</span>\n  <span>/*\n* 家庭电话号码\n*/</span>\n  <span>public</span> <span>String</span> <span>getHomeTelNumber</span><span>(</span><span>)</span> <span>{</span>\n    <span>String</span> homeTelNumber <span>=</span> <span>(</span><span>String</span><span>)</span><span>this</span><span>.</span>homeInfo<span>.</span><span>get</span><span>(</span><span>\"homeTelNumber\"</span><span>)</span><span>;</span>\n    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>homeTelNumber<span>)</span><span>;</span>\n    <span>return</span> homeTelNumber<span>;</span>\n  <span>}</span>\n  <span>/*\n*职位信息\n*/</span>\n  <span>public</span> <span>String</span> <span>getJobPosition</span><span>(</span><span>)</span> <span>{</span>\n    <span>String</span> jobPosition <span>=</span> <span>(</span><span>String</span><span>)</span><span>this</span><span>.</span>officeInfo<span>.</span><span>get</span><span>(</span><span>\"jobPosition\"</span><span>)</span><span>;</span>\n    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>jobPosition<span>)</span><span>;</span>\n    <span>return</span> jobPosition<span>;</span>\n  <span>}</span>\n  <span>/*\n* 手机号码\n*/</span>\n  <span>public</span> <span>String</span> <span>getMobileNumber</span><span>(</span><span>)</span> <span>{</span>\n    <span>String</span> mobileNumber <span>=</span> <span>(</span><span>String</span><span>)</span><span>this</span><span>.</span>baseInfo<span>.</span><span>get</span><span>(</span><span>\"mobileNumber\"</span><span>)</span><span>;</span>\n    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>mobileNumber<span>)</span><span>;</span>\n    <span>return</span> mobileNumber<span>;</span>\n  <span>}</span>\n  <span>/*\n* 办公电话\n*/</span>\n  <span>public</span> <span>String</span> <span>getOfficeTelNumber</span><span>(</span><span>)</span> <span>{</span>\n    <span>String</span> officeTelNumber <span>=</span> <span>(</span><span>String</span><span>)</span><span>this</span><span>.</span>officeInfo<span>.</span><span>get</span><span>(</span><span>\"officeTelNumber\"</span><span>)</span><span>;</span>\n    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>officeTelNumber<span>)</span><span>;</span>\n    <span>return</span> officeTelNumber<span>;</span>\n  <span>}</span>\n  <span>/*\n* 员工的名称\n*/</span>\n  <span>public</span> <span>String</span> <span>getUserName</span><span>(</span><span>)</span> <span>{</span>\n    <span>String</span> userName <span>=</span> <span>(</span><span>String</span><span>)</span><span>this</span><span>.</span>baseInfo<span>.</span><span>get</span><span>(</span><span>\"userName\"</span><span>)</span><span>;</span>\n    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>userName<span>)</span><span>;</span>\n    <span>return</span> userName<span>;</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br></div></div><p>大家看到没？中转的角色有很多的强制类型转换，就是(String)这个东西，如果使用泛型 的话，就可以完全避免这个转化（当然了，泛型当时还没有诞生）。我们要看看这个中转是 否真的起到了中转的作用，我们想象这样一个场景：公司大老板想看看我们自己公司年轻女 孩子的电话号码，那该场景类就如代码清单19-6所示。</p>\n<p>代码清单19-6 场景类</p>\n<div><pre><code><span>public</span> <span>class</span> <span>Client</span> <span>{</span>\n  <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n    <span>//没有与外系统连接的时候，是这样写的</span>\n    <span>IUserInfo</span> youngGirl <span>=</span> <span>new</span> <span>UserInfo</span><span>(</span><span>)</span><span>;</span>\n    <span>//从数据库中查到101个</span>\n    <span>for</span><span>(</span><span>int</span> i<span>=</span><span>0</span><span>;</span>i<span>&lt;</span><span>101</span><span>;</span>i<span>++</span><span>)</span><span>{</span>\n      youngGirl<span>.</span><span>getMobileNumber</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>这老板比较色呀。从数据库中生成了101个UserInfo对象，直接打印出来就成了。老板回 头一想，不对呀，兔子不吃窝边草，还是调取借用人员看看，于是要查询出借用人员中美女 的电话号码，如代码清单19-7所示。</p>\n<div><pre><code><span>public</span> <span>class</span> <span>Client</span> <span>{</span>\n  <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n    <span>//老板一想不对呀，兔子不吃窝边草，还是找借用人员好点</span>\n    <span>//我们只修改了这句话</span>\n    <span>IUserInfo</span> youngGirl <span>=</span> <span>new</span> <span>OuterUserInfo</span><span>(</span><span>)</span><span>;</span>\n    <span>//从数据库中查到101个</span>\n    <span>for</span><span>(</span><span>int</span> i<span>=</span><span>0</span><span>;</span>i<span>&lt;</span><span>101</span><span>;</span>i<span>++</span><span>)</span><span>{</span>\n      youngGirl<span>.</span><span>getMobileNumber</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>大家看，使用了适配器模式只修改了一句话，其他的业务逻辑都不用修改就解决了系统 对接的问题，而且在我们实际系统中只是增加了一个业务类的继承，就实现了可以查本公司 的员工信息，也可以查人力资源公司的员工信息，尽量少的修改，通过扩展的方式解决了该 问题。这就是适配模式。</p>\n<h3 id=\"适配器模式的扩展\"> 适配器模式的扩展</h3>\n<p>我们刚刚讲的人力资源管理的例子中，其实是一个比较幸运的例子，为什么呢？如果劳 动服务公司提供的人员接口不止一个，也就是说，用户基本信息是一个接口，工作信息是一 个接口，家庭信息是一个接口，总共有三个接口三个实现类，想想看如何处理呢？不能再使 用我们上面的方法了，为什么呢？Java是不支持多继承的，你难道想让OuterUserInfo继承三 个实现类？此路不通，再想一个办法，对哦，可以使用类关联的办法嘛！声明一个 OuterUserInfo实现类，实现IUserInfo接口，通过再关联其他三个实现类不就可以解决这个问 题了吗？是的，是的，好方法，我们先画出类图，如图19-8所示。</p>\n<p>OuterUserInfo通过关联的方式与外界的三个实现类通讯，当然也可以理解为是聚合关 系。IUserInfo和UserInfo代码如代码清单19-1和代码清单19-2所示，不再赘述。我们来看看拆 分后的三个接口和实现类，用户基本信息接口如代码清单19-13所示。</p>\n<p><img src=\"./images/Java-DesignPatterns-StructuralPatterns/19-8.jpg\" alt=\"图19-8 拆分接口后的类图\" /></p>\n<p>代码清单19-13 用户基本信息接口</p>\n<p><code>IOuterUserBaseInfo.java</code></p>\n<div><pre><code><span>public</span> <span>interface</span> <span>IOuterUserBaseInfo</span> <span>{</span>\n  <span>//基本信息，比如名称、性别、手机号码等</span>\n  <span>public</span> <span>Map</span> <span>getUserBaseInfo</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>代码清单19-14 用户家庭信息接口</p>\n<p><code>IOuterUserHomeInfo.java</code></p>\n<div><pre><code><span>public</span> <span>interface</span> <span>IOuterUserHomeInfo</span> <span>{</span>\n  <span>//用户的家庭信息</span>\n  <span>public</span> <span>Map</span> <span>getUserHomeInfo</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>代码清单19-15 用户工作信息接口</p>\n<p><code>IOuterUserOfficeInfo.java</code></p>\n<div><pre><code><span>public</span> <span>interface</span> <span>IOuterUserOfficeInfo</span> <span>{</span>\n  <span>//工作区域信息</span>\n  <span>public</span> <span>Map</span> <span>getUserOfficeInfo</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>读到这里，读者应该想到这样一个问题：系统这样设计是否合理呢？合理，绝对合理！ 想想<code>单一职责原则</code>是怎么说的，类和接口要保持职责单一，在实际的应用中类可以有多重职 责，但是接口一定要职责单一，因此，我们上面拆分接口的假想也是非常合乎逻辑的。我们 来看三个相关的实现类，用户基本信息如代码清单19-16所示。</p>\n<p>代码清单19-16 用户基本信息</p>\n<p><code>OuterUserBaseInfo.java</code></p>\n<div><pre><code><span>public</span> <span>class</span> <span>OuterUserBaseInfo</span> <span>implements</span> <span>IOuterUserBaseInfo</span> <span>{</span>\n  <span>/*\n* 用户的基本信息\n*/</span>\n  <span>public</span> <span>Map</span> <span>getUserBaseInfo</span><span>(</span><span>)</span> <span>{</span>\n    <span>HashMap</span> baseInfoMap <span>=</span> <span>new</span> <span>HashMap</span><span>(</span><span>)</span><span>;</span>\n    baseInfoMap<span>.</span><span>put</span><span>(</span><span>\"userName\"</span><span>,</span> <span>\"这个员工叫混世魔王...\"</span><span>)</span><span>;</span>\n    baseInfoMap<span>.</span><span>put</span><span>(</span><span>\"mobileNumber\"</span><span>,</span> <span>\"这个员工电话是...\"</span><span>)</span><span>;</span>\n    <span>return</span> baseInfoMap<span>;</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>代码清单19-17 用户家庭信息</p>\n<p><code>OuterUserHomeInfo.java</code></p>\n<div><pre><code><span>public</span> <span>class</span> <span>OuterUserHomeInfo</span> <span>implements</span> <span>IOuterUserHomeInfo</span> <span>{</span>\n  <span>/*\n* 员工的家庭信息\n*/</span>\n  <span>public</span> <span>Map</span> <span>getUserHomeInfo</span><span>(</span><span>)</span> <span>{</span>\n    <span>HashMap</span> homeInfo <span>=</span> <span>new</span> <span>HashMap</span><span>(</span><span>)</span><span>;</span>\n    homeInfo<span>.</span><span>put</span><span>(</span><span>\"homeTelNumbner\"</span><span>,</span> <span>\"员工的家庭电话是...\"</span><span>)</span><span>;</span>\n    homeInfo<span>.</span><span>put</span><span>(</span><span>\"homeAddress\"</span><span>,</span> <span>\"员工的家庭地址是...\"</span><span>)</span><span>;</span>\n    <span>return</span> homeInfo<span>;</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>代码清单19-18 用户工作信息</p>\n<p><code>OuterUserOfficeInfo.java</code></p>\n<div><pre><code><span>public</span> <span>class</span> <span>OuterUserOfficeInfo</span> <span>implements</span> <span>IOuterUserOfficeInfo</span> <span>{</span>\n  <span>/*\n* 员工的工作信息，比如，职位等\n*/</span>\n  <span>public</span> <span>Map</span> <span>getUserOfficeInfo</span><span>(</span><span>)</span> <span>{</span>\n    <span>HashMap</span> officeInfo <span>=</span> <span>new</span> <span>HashMap</span><span>(</span><span>)</span><span>;</span>\n    officeInfo<span>.</span><span>put</span><span>(</span><span>\"jobPosition\"</span><span>,</span><span>\"这个人的职位是BOSS...\"</span><span>)</span><span>;</span>\n    officeInfo<span>.</span><span>put</span><span>(</span><span>\"officeTelNumber\"</span><span>,</span> <span>\"员工的办公电话是...\"</span><span>)</span><span>;</span>\n    <span>return</span> officeInfo<span>;</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>这里又到我们的核心了——适配器。好，我们来看适配器代码，如代码清单19-19所 示。</p>\n<p>代码清单19-19 适配器</p>\n<div><pre><code><span>public</span> <span>class</span> <span>OuterUserInfo</span> <span>implements</span> <span>IUserInfo</span> <span>{</span>\n  <span>//源目标对象</span>\n  <span>private</span> <span>IOuterUserBaseInfo</span> baseInfo <span>=</span> <span>null</span><span>;</span> <span>//员工的基本信息</span>\n  <span>private</span> <span>IOuterUserHomeInfo</span> homeInfo <span>=</span> <span>null</span><span>;</span> <span>//员工的家庭信息</span>\n  <span>private</span> <span>IOuterUserOfficeInfo</span> officeInfo <span>=</span> <span>null</span><span>;</span> <span>//工作信息</span>\n  <span>//数据处理</span>\n  <span>private</span> <span>Map</span> baseMap <span>=</span> <span>null</span><span>;</span>\n  <span>private</span> <span>Map</span> homeMap <span>=</span> <span>null</span><span>;</span>\n  <span>private</span> <span>Map</span> officeMap <span>=</span> <span>null</span><span>;</span>\n  <span>//构造函数传递对象</span>\n  <span>public</span> <span>OuterUserInfo</span><span>(</span><span>IOuterUserBaseInfo</span> _baseInfo<span>,</span><span>IOuterUserHomeInfo</span> _homeInfo<span>,</span><span>IOuterUserOfficeInfo</span> _officeInfo<span>)</span><span>{</span>\n    <span>this</span><span>.</span>baseInfo <span>=</span> _baseInfo<span>;</span>\n    <span>this</span><span>.</span>homeInfo <span>=</span> _homeInfo<span>;</span>\n    <span>this</span><span>.</span>officeInfo <span>=</span> _officeInfo<span>;</span>\n    <span>//数据处理</span>\n    <span>this</span><span>.</span>baseMap <span>=</span> <span>this</span><span>.</span>baseInfo<span>.</span><span>getUserBaseInfo</span><span>(</span><span>)</span><span>;</span>\n    <span>this</span><span>.</span>homeMap <span>=</span> <span>this</span><span>.</span>homeInfo<span>.</span><span>getUserHomeInfo</span><span>(</span><span>)</span><span>;</span>\n    <span>this</span><span>.</span>officeMap <span>=</span> <span>this</span><span>.</span>officeInfo<span>.</span><span>getUserOfficeInfo</span><span>(</span><span>)</span><span>;</span>\n  <span>}</span>\n  <span>//家庭地址</span>\n  <span>public</span> <span>String</span> <span>getHomeAddress</span><span>(</span><span>)</span> <span>{</span>\n    <span>String</span> homeAddress <span>=</span> <span>(</span><span>String</span><span>)</span><span>this</span><span>.</span>homeMap<span>.</span><span>get</span><span>(</span><span>\"homeAddress\"</span><span>)</span><span>;</span>\n    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>homeAddress<span>)</span><span>;</span>\n    <span>return</span> homeAddress<span>;</span>\n  <span>}</span>\n  <span>//家庭电话号码</span>\n  <span>public</span> <span>String</span> <span>getHomeTelNumber</span><span>(</span><span>)</span> <span>{</span>\n    <span>String</span> homeTelNumber <span>=</span> <span>(</span><span>String</span><span>)</span><span>this</span><span>.</span>homeMap<span>.</span><span>get</span><span>(</span><span>\"homeTelNumber\"</span><span>)</span><span>;</span>\n    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>homeTelNumber<span>)</span><span>;</span>\n    <span>return</span> homeTelNumber<span>;</span>\n  <span>}</span>\n  <span>//职位信息</span>\n  <span>public</span> <span>String</span> <span>getJobPosition</span><span>(</span><span>)</span> <span>{</span>\n    <span>String</span> jobPosition <span>=</span> <span>(</span><span>String</span><span>)</span><span>this</span><span>.</span>officeMap<span>.</span><span>get</span><span>(</span><span>\"jobPosition\"</span><span>)</span><span>;</span>\n    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>jobPosition<span>)</span><span>;</span>\n    <span>return</span> jobPosition<span>;</span>\n  <span>}</span>\n  <span>//手机号码</span>\n  <span>public</span> <span>String</span> <span>getMobileNumber</span><span>(</span><span>)</span> <span>{</span>\n    <span>String</span> mobileNumber <span>=</span> <span>(</span><span>String</span><span>)</span><span>this</span><span>.</span>baseMap<span>.</span><span>get</span><span>(</span><span>\"mobileNumber\"</span><span>)</span><span>;</span>\n    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>mobileNumber<span>)</span><span>;</span>\n    <span>return</span> mobileNumber<span>;</span>\n  <span>}</span>\n  <span>//办公电话</span>\n  <span>public</span> <span>String</span> <span>getOfficeTelNumber</span><span>(</span><span>)</span> <span>{</span>\n    <span>String</span> officeTelNumber<span>=</span> <span>(</span><span>String</span><span>)</span><span>this</span><span>.</span>officeMap<span>.</span><span>get</span><span>(</span><span>\"officeTelNumber\"</span><span>)</span><span>;</span>\n    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>officeTelNumber<span>)</span><span>;</span>\n    <span>return</span> officeTelNumber<span>;</span>\n  <span>}</span>\n  <span>// 员工的名称</span>\n  <span>public</span> <span>String</span> <span>getUserName</span><span>(</span><span>)</span> <span>{</span>\n    <span>String</span> userName <span>=</span> <span>(</span><span>String</span><span>)</span><span>this</span><span>.</span>baseMap<span>.</span><span>get</span><span>(</span><span>\"userName\"</span><span>)</span><span>;</span>\n    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>userName<span>)</span><span>;</span>\n    <span>return</span> userName<span>;</span>\n  <span>}</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br></div></div><p>大家只要注意一下黑色字体的构造函数就可以了，它接收三个对象，其他部分变化不 大，只是变量名称进行了修改，我们再来看场景类，如代码清单19-20所示。</p>\n<div><pre><code><span>public</span> <span>class</span> <span>Client</span> <span>{</span>\n  <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n    <span>//外系统的人员信息</span>\n    <span>IOuterUserBaseInfo</span> baseInfo <span>=</span> <span>new</span> <span>OuterUserBaseInfo</span><span>(</span><span>)</span><span>;</span>\n    <span>IOuterUserHomeInfo</span> homeInfo <span>=</span> <span>new</span> <span>OuterUserHomeInfo</span><span>(</span><span>)</span><span>;</span>\n    <span>IOuterUserOfficeInfo</span> officeInfo <span>=</span> <span>new</span> <span>OuterUserOfficeInfo</span><span>(</span><span>)</span><span>;</span>\n    <span>//传递三个对象</span>\n    <span>IUserInfo</span> youngGirl <span>=</span> <span>new</span> <span>OuterUserInfo</span><span>(</span>baseInfo<span>,</span>homeInfo<span>,</span>officeInfo<span>)</span><span>;</span>\n    <span>//从数据库中查到101个</span>\n    <span>for</span><span>(</span><span>int</span> i<span>=</span><span>0</span><span>;</span>i<span>&lt;</span><span>101</span><span>;</span>i<span>++</span><span>)</span><span>{</span>\n      youngGirl<span>.</span><span>getMobileNumber</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div>",
      "image": "https://blog-1300186248.cos.ap-shanghai.myqcloud.com/Java-DesignPatterns-StructuralPatterns/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.png",
      "date_published": "2020-08-09T23:47:52.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": []
    },
    {
      "title": "Java-设计模式",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/java/java-DesignPatterns/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/java/java-DesignPatterns/",
      "content_html": "<h2 id=\"参考\"> 参考</h2>\n<div><p>参考</p>\n<ul>\n<li>https://www.runoob.com/design-pattern/design-pattern-intro.html</li>\n<li>http://c.biancheng.net/view/1317.html</li>\n<li><a href=\"TheZen0fDesignPattern_2.pdf\">设计模式之禅</a></li>\n</ul>\n</div>\n<h2 id=\"_1-总览\"> 1. 总览</h2>\n<p>根据设计模式的参考书 <strong>Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素）</strong> 中所提到的，总共有 23 种设计模式。这些模式可以分为三大类：创建型模式（Creational Patterns）、结构型模式（Structural Patterns）、行为型模式（Behavioral Patterns）。当然，我们还会讨论另一类设计模式：J2EE 设计模式。</p>\n<ul>\n<li>\n<p><strong>创建型模式</strong></p>\n<blockquote>\n<p>这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。</p>\n</blockquote>\n</li>\n<li>\n<p><strong>结构型模式</strong></p>\n<blockquote>\n<p>这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。</p>\n</blockquote>\n</li>\n<li>\n<p><strong>行为型模式</strong></p>\n<blockquote>\n<p>这些设计模式特别关注对象之间的通信。</p>\n</blockquote>\n</li>\n<li>\n<p><strong>J2EE 模式</strong></p>\n<blockquote>\n<p>这些设计模式特别关注表示层。这些模式是由 Sun Java Center 鉴定的。</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"_1-1-创建型模式\"> 1.1 创建型模式</h3>\n<p>这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。</p>\n<div><p>创建型模式</p>\n<ul>\n<li>工厂模式（Factory Pattern）</li>\n<li>抽象工厂模式（Abstract Factory Pattern）</li>\n<li>单例模式（Singleton Pattern）</li>\n<li>建造者模式（Builder Pattern）</li>\n<li>原型模式（Prototype Pattern）</li>\n</ul>\n</div>\n<h3 id=\"_1-2-结构型模式\"> 1.2 结构型模式</h3>\n<p>这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。</p>\n<div><p>结构型模式</p>\n<ul>\n<li>适配器模式（Adapter Pattern）</li>\n<li>桥接模式（Bridge Pattern）</li>\n<li>过滤器模式（Filter、Criteria Pattern）</li>\n<li>组合模式（Composite Pattern）</li>\n<li>装饰器模式（Decorator Pattern）</li>\n<li>外观模式（Facade Pattern）</li>\n<li>享元模式（Flyweight Pattern）</li>\n<li>代理模式（Proxy Pattern）</li>\n</ul>\n</div>\n<h3 id=\"_1-3-行为型模式\"> 1.3 行为型模式</h3>\n<p>这些设计模式特别关注对象之间的通信。</p>\n<div><p>行为型模式</p>\n<ul>\n<li>责任链模式（Chain of Responsibility Pattern）</li>\n<li>命令模式（Command Pattern）</li>\n<li>解释器模式（Interpreter Pattern）</li>\n<li>迭代器模式（Iterator Pattern）</li>\n<li>中介者模式（Mediator Pattern）</li>\n<li>备忘录模式（Memento Pattern）</li>\n<li>观察者模式（Observer Pattern）</li>\n<li>状态模式（State Pattern）</li>\n<li>空对象模式（Null Object Pattern）</li>\n<li>策略模式（Strategy Pattern）</li>\n<li>模板模式（Template Pattern）</li>\n<li>访问者模式（Visitor Pattern）</li>\n</ul>\n</div>\n<h3 id=\"_1-4-j2ee-模式\"> 1.4 J2EE 模式</h3>\n<p>这些设计模式特别关注表示层。这些模式是由 Sun Java Center 鉴定的。</p>\n<div><p>J2EE 模式</p>\n<ul>\n<li>MVC 模式（MVC Pattern）</li>\n<li>业务代表模式（Business Delegate Pattern）</li>\n<li>组合实体模式（Composite Entity Pattern）</li>\n<li>数据访问对象模式（Data Access Object Pattern）</li>\n<li>前端控制器模式（Front Controller Pattern）</li>\n<li>拦截过滤器模式（Intercepting Filter Pattern）</li>\n<li>服务定位器模式（Service Locator Pattern）</li>\n<li>传输对象模式（Transfer Object Pattern）</li>\n</ul>\n</div>\n<h2 id=\"_2-目录\"> 2. 目录</h2>\n<div><p>目录</p>\n<ul>\n<li><a href=\"./Java-DesignPatterns-SixPrinciple.html\">Java模式设计之六大原则</a></li>\n<li><a href=\"./Java-DesignPatterns-CreationalPatterns.html\">Java模式设计之创建型模式</a></li>\n<li><a href=\"./Java-DesignPatterns-StructuralPatterns.html\">Java模式设计之结构型模式</a></li>\n<li><a href=\"./Java-DesignPatterns-BehavioralPatterns.html\">Java模式设计之行为性模式</a></li>\n<li><a href=\"./Java-DesignPatterns-J2eePattern.html\">Java模式设计之J2EE模式</a></li>\n</ul>\n</div>\n",
      "date_published": "2020-08-09T23:57:52.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": []
    },
    {
      "title": "JVM-类加载子系统",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/java/java-JVM/Java-JVM-Classloader/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/java/java-JVM/Java-JVM-Classloader/",
      "content_html": "<h2 id=\"jvm概述\"> JVM概述</h2>\n<h3 id=\"jvm跨平台原理\"> JVM跨平台原理</h3>\n<ol>\n<li>\n<p>跨平台：由Java编写的程序可以在不同的操作系统上运行：一次编写，多处运行</p>\n</li>\n<li>\n<p>原理：编译之后的字节码文件和平台无关，需要在不同的操作系统上安装一个对应版本的虚拟机(JVM)\n(Java虚拟机不和包括java在内的任何语言绑定，它只与class文件这种二进制文件格式所关联。无论使用何种语言进行软件开发，只要将源文件编译为正确的Class文件，那么这种语言就可以在Java虚拟机上执行，可以说，统一而强大的Class文件结构，就是Java虚拟机的基石、桥梁)</p>\n</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/20201004103315879.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center\" alt=\"\" /></p>\n<h3 id=\"jvm位置\"> JVM位置</h3>\n<p><img src=\"https://user-gold-cdn.xitu.io/2020/3/18/170ec702fcca6b37?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"\" /></p>\n<h3 id=\"jvm运行流程\"> JVM运行流程</h3>\n<p><img src=\"https://user-gold-cdn.xitu.io/2020/3/18/170ec7cd31581d15?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"\" /></p>\n<h3 id=\"jvm生命周期\"> JVM生命周期</h3>\n<h4 id=\"_1-启动\"> 1.启动</h4>\n<p>通过引导类加载器（bootstrap class loader）创建一个初始类（initial class）来完成的，这个类是由虚拟机的具体实现指定的.</p>\n<h4 id=\"_2-执行\"> 2.执行</h4>\n<ul>\n<li>一个运行中的java虚拟机有着一个清晰的任务：执行Java程序；</li>\n<li>程序开始执行的时候他才运行，程序结束时他就停止；</li>\n<li>执行一个所谓的Java程序的时候，真真正正在执行的是一个叫做Java虚拟机的进程。</li>\n</ul>\n<h4 id=\"_3-退出\"> 3.退出</h4>\n<ul>\n<li>程序正常执行结束</li>\n<li>程序异常或错误而异常终止</li>\n<li>操作系统错误导致终止</li>\n<li>某线程调用Runtime类或System类的exit方法，或Runtime类的halt方法，并且java安全管理器也允许这次exit或halt操作</li>\n<li>除此之外，JNI规范描述了用JNI Invocation API来加载或卸载Java虚拟机时，Java虚拟机的退出情况</li>\n</ul>\n<h2 id=\"类加载子系统\"> 类加载子系统</h2>\n<p><img src=\"./images/Java-JVM-Classloader/Jvm_function.jpg\" alt=\"\" /></p>\n<h3 id=\"作用\"> 作用</h3>\n<ul>\n<li>类加载子系统负责从文件系统或者网络中加载Class文件，class文件在文件开头有特定的文件标识；</li>\n<li><code>ClassLoader</code>只负责class文件的加载，至于它是否可以运行，则由``Execution Engine`决定</li>\n<li>加载的类信息存放于一块成为方法区的内存空间。除了类信息之外，方法区还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射）</li>\n</ul>\n<h3 id=\"加载过程\"> 加载过程</h3>\n<p>当程序要使用某个类时，如果该类还未被加载到内存中，则系统会通过</p>\n<div><p>Info</p>\n<ul>\n<li>类的加载</li>\n<li>类的链接（验证，准备，解析）</li>\n<li>类的初始化</li>\n</ul>\n</div>\n<p>这三个步骤来对类进行初始化。如果不出现意外，JVM将会连续完成这三个步骤，所以有时也把这三个步骤统称为类加载或者初始化</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2020/3/18/170ec7daeca85a52?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"类加载过程\" /></p>\n<h4 id=\"加载-loading\"> 加载（Loading）</h4>\n<p>由<code>ClassLoader</code>负责，将class字节码文件加载到内存中</p>\n<ul>\n<li>通过一个类的全限定明获取定义此类的二进制字节流；</li>\n<li>将这个字节流所代表的的<code>静态存储结构（静态变量，静态代码块，常量池等）</code>转化为<code>方法区的运行时数据</code>；</li>\n<li>在内存中生成一个对应这个类的<code>java.lang.Class</code>对象（用于反射），作为方法区这个类的各种数据的访问入口</li>\n</ul>\n<h4 id=\"链接-linking\"> 链接（Linking）</h4>\n<p>包含验证，准备，解析</p>\n<p><strong>验证</strong></p>\n<div><p>Info</p>\n<ul>\n<li>目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。</li>\n<li>主要包括四种验证，文件格式验证，源数据验证，字节码验证，符号引用验证。</li>\n</ul>\n</div>\n<p><strong>准备</strong></p>\n<p>在方法区进行</p>\n<div><p>Info</p>\n<ul>\n<li>为类变量（static变量）分配内存并且设置该类变量的默认初始化值，具体赋值在初始化阶段完</li>\n<li>这里不包含用<code>final</code>修饰的<code>static</code>，因为final在编译的时候就会分配了，准备阶段会显式初始化；</li>\n<li>这里不会为实例变量分配初始化,类变量会分配在方法区中,而实例变量会随着对象一起分配到Java堆中</li>\n</ul>\n</div>\n<p><strong>解析</strong></p>\n<p>将常量池内的<code>符号引用</code>转换为<code>直接引用</code>的过程。</p>\n<div><p>Info</p>\n<ul>\n<li>事实上，解析操作网晚会伴随着jvm在执行完初始化之后再执行</li>\n<li>符号引用就是一组符号来描述所引用的目标。符号应用的字面量形式明确定义在《java虚拟机规范》的class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄</li>\n<li>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT_Class_info/CONSTANT_Fieldref_info、CONSTANT_Methodref_info等。</li>\n</ul>\n</div>\n<ul>\n<li>虚拟机在加载Class文件时才会进行动态链接,也就是说,Class文件中不会保存各个方法和字段的最终内存布局信息,因此,这些字段和方法的符号引用不经过转换是无法直接被虚拟机使用的。当虚拟机运行起来时,需要从常量池中获得对应的符号引用,再在类加载过程中(初始化阶段)将其替换直接引用,并翻译到具体的内存地址中</li>\n<li>符号引用：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到了内存中</li>\n<li>直接引用：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是与虚拟机实现的内存布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那说明引用的目标必定已经存在于内存之中了。</li>\n</ul>\n<p>解释什么是符号引号和直接引用?\n教室里有个空的位子没坐人，座位上边牌子写着小明的座位（符号引用），后来小明进来坐下去掉牌子（符号引用换成直接引用）</p>\n<h4 id=\"初始化-initialization\"> 初始化（Initialization）</h4>\n<p>为类变量赋予正确的初始化值</p>\n<div><p>Info</p>\n<ul>\n<li>初始化阶段就是执行类构造器方法<code>&lt; clinit &gt;()</code>的过程。此方法不需要定义，是javac编译器自动收集<code>类中的所有类变量的赋值动作</code>和<code>静态代码快</code>中的语句合并而来（如果没有则不回生成clinit方法）</li>\n<li>若该类具有父类，jvm会保证子类的clinit()执行前，父类的clinit()已经执行完毕</li>\n<li>clinit()不同于类的构造器。（关联：构造器是虚拟机视角下的方法init()）</li>\n<li>虚拟机必须保证一个类的clinit()方法在多线程下被同步加锁。</li>\n</ul>\n</div>\n<div><pre><code><span>public</span> <span>class</span> <span>ClassInitTest</span> <span>{</span>\n    <span>private</span>  <span>static</span> <span>int</span> num<span>=</span><span>1</span><span>;</span>\n    <span>static</span><span>{</span>\n        num<span>=</span><span>2</span><span>;</span>\n        number<span>=</span><span>20</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>num<span>)</span><span>;</span>\n        <span>//System.out.println(number); 报错:非法的前向引用，只能赋值不能调用</span>\n    <span>}</span>\n    <span>//Linking之prepare: number=0 -->initial:20-->10</span>\n    <span>private</span> <span>static</span> <span>int</span> number<span>=</span><span>10</span><span>;</span>\n\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>ClassInitTest</span><span>.</span>num<span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>ClassInitTest</span><span>.</span>number<span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p><img src=\"https://img-blog.csdnimg.cn/20210426221549496.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70\" alt=\"\" /></p>\n<p>虚拟机必须保证一个类的clinit()方法在多线程下被同步加锁。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2020/3/18/170ec8415e75466b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"\" /></p>\n<h2 id=\"类加载器-classloader\"> 类加载器（ClassLoader）</h2>\n<div><p>参考</p>\n<ul>\n<li><a href=\"https://www.cnblogs.com/makai/p/11081879.html\" target=\"_blank\" rel=\"noopener noreferrer\">老大难的 Java ClassLoader，到了该彻底理解它的时候了</a></li>\n<li><a href=\"https://blog.csdn.net/briblue/article/details/54973413\" target=\"_blank\" rel=\"noopener noreferrer\">一看你就懂，超详细java中的ClassLoader详解</a></li>\n</ul>\n</div>\n<h3 id=\"概述\"> 概述</h3>\n<p>JVM支持两种类型的加载器，分别为</p>\n<ul>\n<li><strong>引导类加载器（BootStrap ClassLoader）</strong></li>\n<li><strong>自定义类加载器（User-Defined ClassLoader）</strong></li>\n</ul>\n<p>从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是java虚拟机规范却没有这么定义，而是<strong>将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器</strong></p>\n<p>sum.misc.Launcher:它是一个java虚拟机的入口应用</p>\n<p>无论类加载器的类型如何划分，在程序中我们最常见的类加载器始终只有三个，如下所示：</p>\n<p><strong>①启动类加载器（引导类加载器，BootStrap ClassLoader）</strong></p>\n<ul>\n<li>这个类加载使用<strong>C/C++语言实现的</strong>，嵌套在JVM内部</li>\n<li>它用来加载java的核心库（JAVA_HOME/jre/lib/rt.jar/resources.jar或sun.boot.class.path路径下的内容），用于提供JVM自身需要的类</li>\n<li>并不继承自java.lang.ClassLoader,没有父加载器</li>\n<li>加载拓展类和应用程序类加载器，并指定为他们的父加载器</li>\n<li>处于安全考虑，BootStrap启动类加载器只加载包名为java、javax、sun等开头的类</li>\n</ul>\n<p><strong>②拓展类加载器（Extension ClassLoader）</strong></p>\n<ul>\n<li>java语言编写 ，由sun.misc.Launcher$ExtClassLoader实现。</li>\n<li>派生于ClassLoader类</li>\n<li>父类加载器为启动类加载器</li>\n<li>从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/lib/ext子目录（扩展目录）下加载类库。<strong>如果用户创建的JAR放在此目录下，也会由拓展类加载器自动加载</strong></li>\n</ul>\n<p><strong>③应用程序类加载器（系统类加载器，AppClassLoader）</strong></p>\n<ul>\n<li>java语言编写， 由sun.misc.Launcher$AppClassLoader实现。</li>\n<li>派生于ClassLoader类</li>\n<li>父类加载器为拓展类加载器</li>\n<li>它负责加载环境变量classpath或系统属性 java.class.path指定路径下的类库</li>\n<li><strong>该类加载器是程序中默认的类加载器</strong>，一般来说，java应用的类都是由它来完成加载</li>\n<li>通过ClassLoader#getSystemClassLoader()方法可以获取到该类加载器</li>\n</ul>\n<p><img src=\"https://user-gold-cdn.xitu.io/2020/3/18/170ec88cffd157f0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"\" /></p>\n<p><img src=\"https://img-blog.csdnimg.cn/20191207090719392.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70\" alt=\"\" /></p>\n<h3 id=\"classloader的常用方法及获取方法\"> ClassLoader的常用方法及获取方法</h3>\n<p>ClassLoader类，它是一个抽象类，其后所有的类加载器都继承自ClassLoader（不包括启动类加载器）</p>\n<table>\n<thead>\n<tr>\n<th>方法名称</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>getParent（）</td>\n<td>返回该类加载器的超类加载器</td>\n</tr>\n<tr>\n<td>loadClass（String name）</td>\n<td>加载名称为name的类，返回结果为java.lang.Class类的实例</td>\n</tr>\n<tr>\n<td>findClass（String name）</td>\n<td>查找名称为name的类，返回结果为java.lang.Class类的实例</td>\n</tr>\n<tr>\n<td>findLoadedClass（String name）</td>\n<td>查找名称为name的已经被加载过的类，返回结果为java.lang.Class类的实例</td>\n</tr>\n<tr>\n<td>defineClass（String name，byte[] b,int off,int len）</td>\n<td>把字节数组b中的内容转换为一个Java类 ，返回结果为java.lang.Class类的实例</td>\n</tr>\n<tr>\n<td>resolveClass（Class&lt;?&gt; c）</td>\n<td>连接指定的一个java类</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"测试获取加载器\"> 测试获取加载器</h3>\n<div><pre><code><span>/**\n * ClassLoader加载\n */</span>\n<span>public</span> <span>class</span> <span>ClassLoaderTest</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>//获取系统类加载器</span>\n        <span>ClassLoader</span> systemClassLoader <span>=</span> <span>ClassLoader</span><span>.</span><span>getSystemClassLoader</span><span>(</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>systemClassLoader<span>)</span><span>;</span><span>//sun.misc.Launcher$AppClassLoader@18b4aac2</span>\n\n        <span>//获取其上层  扩展类加载器</span>\n        <span>ClassLoader</span> extClassLoader <span>=</span> systemClassLoader<span>.</span><span>getParent</span><span>(</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>extClassLoader<span>)</span><span>;</span><span>//sun.misc.Launcher$ExtClassLoader@610455d6</span>\n\n        <span>//获取其上层 获取不到引导类加载器</span>\n        <span>ClassLoader</span> bootStrapClassLoader <span>=</span> extClassLoader<span>.</span><span>getParent</span><span>(</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>bootStrapClassLoader<span>)</span><span>;</span><span>//null</span>\n\n        <span>//对于用户自定义类来说：使用系统类加载器进行加载</span>\n        <span>ClassLoader</span> classLoader <span>=</span> <span>ClassLoaderTest</span><span>.</span><span>class</span><span>.</span><span>getClassLoader</span><span>(</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>classLoader<span>)</span><span>;</span><span>//sun.misc.Launcher$AppClassLoader@18b4aac2</span>\n\n        <span>//String 类使用引导类加载器进行加载的  -->java核心类库都是使用引导类加载器加载的</span>\n        <span>ClassLoader</span> classLoader1 <span>=</span> <span>String</span><span>.</span><span>class</span><span>.</span><span>getClassLoader</span><span>(</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>classLoader1<span>)</span><span>;</span><span>//null</span>\n\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><h3 id=\"用户自定义加载器\"> 用户自定义加载器</h3>\n<h4 id=\"好处\"> 好处</h4>\n<div><p>好处</p>\n<ul>\n<li>隔离加载类</li>\n<li>修改类加载的方式</li>\n<li>拓展加载源</li>\n<li>防止源码泄漏</li>\n</ul>\n</div>\n<h4 id=\"步骤\"> 步骤</h4>\n<p><img src=\"https://user-gold-cdn.xitu.io/2020/3/18/170ec89d3903bfb7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"\" /></p>\n<p>在<code>findClass()</code>中调用<code>defineClass()</code>方法，它能将class二进制内容转换成Class对象，如果不符合要求会抛出各种异常。</p>\n<h3 id=\"双亲委派机制\"> 双亲委派机制</h3>\n<h4 id=\"原理\"> 原理</h4>\n<p>Java虚拟机对class文件采用的是按需加载的方式，也就是说当需要使用该类时才会将她的class文件加载到内存生成的class对象。而且加载某个类的class文件时，java虚拟机采用的是双亲委派模式，即先把请求交由父类处理，它是一种任务委派模式</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2020/3/18/170ec8cbbe16af0c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"\" /></p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2020/3/18/170ec8e47d7e861b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"img\" /></p>\n<p>如图，虽然我们自定义了一个java.lang包下的String尝试覆盖核心类库中的String，但是由于双亲委派机制，启动加载器会加载java核心类库的String类（BootStrap启动类加载器只加载包名为java、javax、sun等开头的类），而核心类库中的String并没有main方法</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2020/3/18/170ec8d5358f0991?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"img\" /></p>\n<h4 id=\"优势\"> 优势</h4>\n<ul>\n<li>避免类的重复加载</li>\n<li>保护程序安全，防止核心API被随意篡改</li>\n</ul>\n<p>例如</p>\n<ul>\n<li>自定义类：java.lang.String</li>\n<li>自定义类：java.lang.MeDsh（java.lang包需要访问权限，阻止我们用包名自定义类</li>\n</ul>\n<p>如图，虽然我们自定义了一个java.lang包下的String尝试覆盖核心类库中的String，但是由于双亲委派机制,启动加载器会加载java核心类库的String类(BootStrap启动类加载器只加载包名为java、javax、sun等开头的类),而核心类库中的String并没有main方法</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2020/3/18/170ec8ddb41c5559?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"img\" /></p>\n<h3 id=\"classloader的传递性\"> ClassLoader的传递性</h3>\n<p>程序在运行过程中，遇到了一个未知的类，它会选择哪个 ClassLoader 来加载它呢？虚拟机的策略是使用调用者 Class 对象的 ClassLoader 来加载当前未知的类。何为调用者 Class 对象？就是在遇到这个未知的类时，虚拟机肯定正在运行一个方法调用（静态方法或者实例方法），这个方法挂在哪个类上面，那这个类就是调用者 Class 对象。前面我们提到每个 Class 对象里面都有一个 classLoader 属性记录了当前的类是由谁来加载的。</p>\n<p>因为 ClassLoader 的传递性，所有延迟加载的类都会由初始调用 main 方法的这个 ClassLoader 全全负责，它就是 AppClassLoader。</p>\n<h3 id=\"线程上下文类加载器contextclassloader\"> 线程上下文类加载器ContextClassLoader</h3>\n<p>只是一个概念</p>\n<div><pre><code><span>public</span> <span>class</span> <span>Thread</span> <span>implements</span> <span>Runnable</span> <span>{</span>\n\n<span>/* The context ClassLoader for this thread */</span>\n   <span>private</span> <span>ClassLoader</span> contextClassLoader<span>;</span>\n   \n   <span>public</span> <span>void</span> <span>setContextClassLoader</span><span>(</span><span>ClassLoader</span> cl<span>)</span> <span>{</span>\n       <span>SecurityManager</span> sm <span>=</span> <span>System</span><span>.</span><span>getSecurityManager</span><span>(</span><span>)</span><span>;</span>\n       <span>if</span> <span>(</span>sm <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n           sm<span>.</span><span>checkPermission</span><span>(</span><span>new</span> <span>RuntimePermission</span><span>(</span><span>\"setContextClassLoader\"</span><span>)</span><span>)</span><span>;</span>\n       <span>}</span>\n       contextClassLoader <span>=</span> cl<span>;</span>\n   <span>}</span>\n\n   <span>public</span> <span>ClassLoader</span> <span>getContextClassLoader</span><span>(</span><span>)</span> <span>{</span>\n       <span>if</span> <span>(</span>contextClassLoader <span>==</span> <span>null</span><span>)</span>\n           <span>return</span> <span>null</span><span>;</span>\n       <span>SecurityManager</span> sm <span>=</span> <span>System</span><span>.</span><span>getSecurityManager</span><span>(</span><span>)</span><span>;</span>\n       <span>if</span> <span>(</span>sm <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n           <span>ClassLoader</span><span>.</span><span>checkClassLoaderPermission</span><span>(</span>contextClassLoader<span>,</span>\n                                                  <span>Reflection</span><span>.</span><span>getCallerClass</span><span>(</span><span>)</span><span>)</span><span>;</span>\n       <span>}</span>\n       <span>return</span> contextClassLoader<span>;</span>\n   <span>}</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><p>Contextclassloadel只是一个<code>成员变量</code>，通方法设置，通过<code>setContextCloassloader()</code>设置，通过<code>getContextCloassloader()</code>，他会自动检查调用的方法对应的加载器，通过ClassLoader的传递性。</p>\n<h3 id=\"沙箱安全机制\"> 沙箱安全机制</h3>\n<p>自定义String类，但是在加载自定义String类的时候先使用引导类加载器加载，而引导类加载器在加载过程中会先加载jdk自带的文件（rt.jar包中的java\\lang\\String.class）,报错信息说没有main方法就是因为加载的是rt.jar包中的String类。这样可以保证对java核心源代码的保护，这就是<strong>沙箱安全机制</strong>.</p>\n<h2 id=\"判断两个对象对应的类是否相等\"> 判断两个对象对应的类是否相等</h2>\n<p>在jvm中表示两个class对象是否为同一个类存在的两个必要条件</p>\n<ul>\n<li>类的完整类名必须一致，包括包名</li>\n<li>加载这个类的ClassLoader（指ClassLoader实例对象）必须相同</li>\n</ul>\n<p>换句话说，在jvm中，即使这两个类对象（class对象）来源同一个Class文件，被同一个虚拟机所加载，但只要加载它们的<code>ClassLoader</code>实例对象不同，那么这两个类对象也是不相等的.</p>\n<h2 id=\"类的主动使用和被动使用\"> 类的主动使用和被动使用</h2>\n<p><strong>java程序对类的使用方式分为：主动使用和被动使用</strong></p>\n<ul>\n<li>主动使用，分为七种情况\n<ul>\n<li>创建类的实例</li>\n<li>访问某各类或接口的静态变量，或者对静态变量赋值</li>\n<li>调用类的静态方法</li>\n<li>反射 比如Class.forName(com.dsh.jvm.xxx)</li>\n<li>初始化一个类的子类</li>\n<li>java虚拟机启动时被标明为启动类的类</li>\n<li>JDK 7 开始提供的动态语言支持：\njava.lang.invoke.MethodHandle实例的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic句柄对应的类没有初始化，则初始化</li>\n</ul>\n</li>\n<li>除了以上七种情况，其他使用java类的方式都被看作是对类的被动使用，都不会导致类的初始化。</li>\n</ul>\n",
      "image": "https://img-blog.csdnimg.cn/20201004103315879.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center",
      "date_published": "2021-05-10T00:19:12.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": []
    },
    {
      "title": "JVM-运行时数据区",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/java/java-JVM/Java-JVM-Run/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/java/java-JVM/Java-JVM-Run/",
      "content_html": "<h2 id=\"参考\"> 参考</h2>\n<div><p>Tips</p>\n<ul>\n<li>https://juejin.cn/post/6844904096059621390</li>\n</ul>\n</div>\n<h2 id=\"内存分区与线程\"> 内存分区与线程</h2>\n<p>内存是非常重要的系统资源，是硬盘和cpu的中间仓库及桥梁，承载着操作系统和应用程序的实时运行。JVM内存布局规定了JAVA在运行过程中内存申请、分配、管理的策略，保证了JVM的高效稳定运行。<strong>不同的jvm对于内存的划分方式和管理机制存在着部分差异</strong>（对于Hotspot主要指方法区）</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2020/3/18/170ecae266df65ba?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"jdk8以后 ，方法区就是元数据区\" /></p>\n<p>（图源阿里）JDK8的元数据区+JIT编译产物 就是JDK8以前的方法区</p>\n<p>JVM组成图2</p>\n<h3 id=\"线程共享-私有\"> 线程共享/私有</h3>\n<ul>\n<li>线程共享：堆，方法区</li>\n<li>线程私有：程序计数器，虚拟机栈，本地方法栈</li>\n</ul>\n<h3 id=\"方法区-永久代-元空间\"> 方法区 | 永久代 | 元空间</h3>\n<blockquote>\n<p>《Java虚拟机规范》只是规定了有⽅法区这么个概念和它的作⽤，并没有规定如何去实现它。那 么，在不同的 JVM 上⽅法区的实现肯定是不同的了。 ⽅法区和永久代的关系很像Java中接⼝和类 的关系，类实现了接⼝，⽽永久代就是HotSpot虚拟机对虚拟机规范中⽅法区的⼀种实现⽅式。 也 就是说，永久代是HotSpot的概念，⽅法区是Java虚拟机规范中的定义，是⼀种规范，⽽永久代是⼀ 种实现，⼀个是标准⼀个是实现，其他的虚拟机实现并没有永久带这⼀说法。</p>\n<p>目前实现方法区的方式是元空间（Meta Space）</p>\n</blockquote>\n<ul>\n<li>\n<p>在<strong>JDK1.7之前</strong>：永久代</p>\n<blockquote>\n<p>运行时常量池逻辑包含字符串常量池存放在方法区, 此时hotspot虚拟机对方法区的实现为<strong>永久代</strong></p>\n</blockquote>\n</li>\n<li>\n<p>在<strong>JDK1.7</strong>：永久代和堆</p>\n<blockquote>\n<p>字符串常量池被从方法区拿到了<strong>堆</strong>中, 这里没有提到运行时常量池,也就是说<strong>字符串常量池</strong>被单独拿到<strong>堆</strong>,<strong>运行时常量池剩下的东西</strong>还在<strong>方法区</strong>, 也就是hotspot中的<strong>永久代</strong></p>\n</blockquote>\n</li>\n<li>\n<p>在<strong>JDK1.8</strong>： 元空间和堆</p>\n<blockquote>\n<p>hotspot移除了<strong>永久代</strong>用<strong>元空间(Metaspace)<strong>取而代之, 这时候</strong>字符串常量池还在堆</strong>, <strong>运行时常量池还在方法区</strong>, 只不过方法区的实现从永久代变成了元空间(Metaspace) ，元空间并不在虚拟机中，而是在本地内存(Direct Memory)</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"为什么要将永久代-permgen-替换为元空间-metaspace-呢\"> 为什么要将永久代(PermGen)替换为元空间(MetaSpace)呢?</h4>\n<p>整个永久代有⼀个 JVM 本身设置固定⼤⼩上线，⽆法进⾏调整，⽽元空间使⽤的是直接内存，受本机 可⽤内存的限制，并且永远不会得到<code>java.lang.OutOfMemoryError</code>。你可以使⽤ -XX： MaxMetaspaceSize 标志设置最⼤元空间⼤⼩，默认值为 unlimited，这意味着它只受系统内存的限 制。 -XX：MetaspaceSize 调整标志定义元空间的初始⼤⼩如果未指定此标志，则 Metaspace 将根 据运⾏时的应⽤程序需求动态地重新调整⼤⼩。 当然这只是其中⼀个原因，还有很多底层的原因，这⾥就不提了。</p>\n<h3 id=\"线程\"> 线程</h3>\n<ul>\n<li>线程是一个程序里的运行单元，JVM允许一个程序有多个线程并行的执行；</li>\n<li>在HotSpot JVM，每个线程都与操作系统的本地线程直接映射。\n<ul>\n<li>当一个java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。java线程执行终止后。本地线程也会回收。</li>\n</ul>\n</li>\n<li>操作系统负责所有线程的安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，它就会调用java线程中的run（）方法.</li>\n</ul>\n<h4 id=\"jvm系统线程\"> JVM系统线程</h4>\n<ul>\n<li>如果你使用jconsole或者任何一个调试工具，都能看到在后台有许多线程在运行。这些后台线程不包括调用main方法的main线程以及所有这个main线程自己创建的线程；</li>\n<li>这些主要的后台系统线程在HotSpot JVM里主要是以下几个：\n<ul>\n<li><strong>虚拟机线程</strong>：这种线程的操作时需要JVM达到安全点才会出现。这些操作必须在不同的线程中发生的原因是他们都需要JVM达到安全点，这样堆才不会变化。这种线程的执行包括“stop-the-world”的垃圾收集，线程栈收集，线程挂起以及偏向锁撤销</li>\n<li><strong>周期任务线程</strong>：这种线程是时间周期事件的提现（比如中断），他们一般用于周期性操作的调度执行。</li>\n<li><strong>GC线程</strong>：这种线程对于JVM里不同种类的垃圾收集行为提供了支持</li>\n<li><strong>编译线程</strong>：这种线程在运行时会降字节码编译成本地代码</li>\n<li><strong>信号调度线程</strong>：这种线程接收信号并发送给JVM,在它内部通过调用适当的方法进行处理。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"程序计数器-线程私有\"> 程序计数器（线程私有）</h2>\n<p>JVM中的程序计数寄存器（Program Counter Register）中，Register的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。CPU只有把数据装载到寄存器才能够运行。JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟。</p>\n<p>PC寄存器是用来存储<code>指向下一条指令的地址</code>，也即将将要执行的指令代码，<code>字节码解释器</code>工作时修改PC寄存器中的值，由<code>执行引擎</code>从里面读取下一条指令。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2020/3/18/170ecaecbef6c19d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"img\" /></p>\n<h3 id=\"特点\"> 特点</h3>\n<ul>\n<li>它是一块很小的内存空间，几乎可以忽略不计。也是运行速度最快的存储区域</li>\n<li>在jvm规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致</li>\n<li>任何时间一个线程都只有一个方法在执行，也就是所谓的<strong>当前方法</strong>。程序计数器会存储当前线程正在执行的java方法的JVM指令地址；或者，如果实在执行native方法，则是未指定值（undefined）。</li>\n<li>字节码解释器工作时就是通过改变这个计数器的值来选取吓一跳需要执行的字节码指令</li>\n<li>它是唯一一个在java虚拟机规范中没有规定任何<code>OOM</code>情况的区域</li>\n</ul>\n<h3 id=\"作用\"> 作用</h3>\n<ul>\n<li>字节码解释器通过改变程序计数器来依次读取指令，从⽽实现代码的流程控制，如：顺序执⾏、 选择、循环、异常处理。</li>\n<li>在多线程的情况下，<strong>程序计数器⽤于记录当前线程执⾏的位置</strong>，从⽽当线程被切换回来的时候能 够知道该线程上次运⾏到哪⼉了。</li>\n</ul>\n<h3 id=\"代码示例\"> 代码示例</h3>\n<p>利用<code>javap -v xxx.class</code>反编译字节码文件，查看指令等信息</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2020/3/18/170ecaef254ef627?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"img\" /></p>\n<h3 id=\"pc寄存器为什么线程私有\"> PC寄存器为什么线程私有</h3>\n<p>我们都知道所谓的多线程在一个特定的时间段内指回执行其中某一个线程的方法，CPU会不停滴做任务切换，这样必然会导致经常中断或恢复，如何保证分毫无差呢？**为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器,**这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。</p>\n<p>由于CPU时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。</p>\n<p>这样必然导致经常中断或恢复，如何保证分毫无差呢？每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。</p>\n<h3 id=\"cpu时间片\"> CPU时间片</h3>\n<p>CPU时间片即CPU分配各各个程序的时间，每个线程被分配一个时间段。称作它的时间片。\n在宏观上：我们可以同时打开多个应用程序，每个程序并行不悖，同时运行。 但在微观上：由于只有一个CPU，一次只能处理程序要求的一部分，如何处理公平，一种方法就是引入时间片，每个程序轮流执行。</p>\n<h2 id=\"虚拟机栈-线程私有\"> 虚拟机栈（线程私有）</h2>\n<h3 id=\"介绍\"> 介绍</h3>\n<p>由于跨平台性的设计，java的指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的。\n<strong>优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。</strong></p>\n<p>与程序计数器⼀样，Java虚拟机栈也是线程私有的，它的⽣命周期和线程相同，描述的是 Java ⽅法执行的内存模型，每次⽅法调⽤的数据都是通过栈传递的。</p>\n<p>Java 内存可以粗糙的区分为堆内存（Heap）和栈内存(Stack),其中栈就是现在说的虚拟机栈，或者说 是虚拟机栈中局部变量表部分。 （实际上，Java虚拟机栈是由⼀个个<strong>栈帧</strong>组成，⽽每个栈帧中都拥 有：<strong>局部变量表、操作数栈、动态链接、⽅法出⼝信息。</strong>）</p>\n<p>无论是本地方法栈，还是虚拟机栈，都是线程私有的，当一个线程启动的时候，jvm就会给这个线程分配一个栈，然后每当你调用一个方法的时候，jvm就会往这个栈压入一个栈帧，方法调用完毕，栈帧出栈。注意，一个栈能容纳的栈帧是固定的，有默认的值，当然你也可以通过-Xss去调。但这个栈里面的引用所指向堆内存空间是可以扩展的。简而言之，一个栈的栈帧数目是确定的，而与该栈相关联的堆内存是可以动态扩展的，这些是前提。</p>\n<p>局部变量表主要存放了编译器可知的各种数据类型（boolean、byte、char、short、int、float、 long、double）、对象引⽤（reference类型，它不同于对象本身，可能是⼀个指向对象起始地址的引 ⽤指针，也可能是指向⼀个代表对象的句柄或其他与此对象相关的位置）。</p>\n<h3 id=\"特点-2\"> 特点</h3>\n<ul>\n<li>栈是一种快速有效的分配存储方式，访问速度仅次于PC寄存器（程序计数器）</li>\n<li>JVM直接对java栈的操作只有两个\n<ul>\n<li>每个方法执行，伴随着进栈（入栈，压栈）</li>\n<li>执行结束后的出栈工作</li>\n</ul>\n</li>\n<li>对于栈来说不存在垃圾回收问题</li>\n</ul>\n<h3 id=\"出现的异常\"> 出现的异常</h3>\n<p>java虚拟机规范允许<strong>Java栈的大小是动态的或者是固定不变的</strong></p>\n<p>Java 虚拟机栈会出现两种异常：<code>StackOverFlowError</code> 和 <code>OutOfMemoryError</code>。</p>\n<blockquote>\n<ul>\n<li>\n<p><strong>StackOverFlowError</strong>： 若Java虚拟机栈的内存⼤⼩<code>不允许</code>动态扩展，那么当线程请求栈的深度 超过当前Java虚拟机栈的最⼤深度的时候，就抛出StackOverFlowError异常。</p>\n<div><pre><code><span>/**\n * 演示栈中的异常\n */</span>\n<span>public</span> <span>class</span> <span>StackErrorTest</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>main</span><span>(</span>args<span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div></li>\n<li>\n<p><strong>OutOfMemoryError</strong>： 若 Java 虚拟机栈的内存⼤⼩<code>允许</code>动态扩展，且当线程请求栈时内存⽤完 了，⽆法再动态扩展了，此时抛出OutOfMemoryError异常。</p>\n</li>\n</ul>\n</blockquote>\n<h3 id=\"设置大小\"> 设置大小</h3>\n<p>我们可以使用参数-Xss选项来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度。 （IDEA设置方法：Run-EditConfigurations-VM options 填入指定栈的大小-Xss256k）</p>\n<div><pre><code><span>/**\n * 演示栈中的异常\n *\n * 默认情况下：count 10818\n * 设置栈的大小： -Xss256k count 1872\n */</span>\n<span>public</span> <span>class</span> <span>StackErrorTest</span> <span>{</span>\n    <span>private</span> <span>static</span> <span>int</span> count <span>=</span> <span>1</span><span>;</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>count<span>)</span><span>;</span>\n        count<span>++</span><span>;</span>\n        <span>main</span><span>(</span>args<span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h3 id=\"存储结构和运行原理\"> 存储结构和运行原理</h3>\n<ul>\n<li>\n<p>每个线程都有自己的栈，栈中的数据都是以**栈帧(Stack Frame)**的格式存在</p>\n</li>\n<li>\n<p>在这个线程上正在执行的每个方法都对应各自的一个栈帧</p>\n</li>\n<li>\n<p>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息</p>\n</li>\n<li>\n<p>JVM直接对java栈的操作只有两个，就是对栈帧的压栈和出栈，遵循先进后出/后进先出的和原则。</p>\n</li>\n<li>\n<p>在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的，这个栈帧被称为<strong>当前栈帧(Current Frame)</strong>,与当前栈帧对应的方法就是<strong>当前方法（Current Frame）</strong></p>\n</li>\n<li>\n<p>执行引擎运行的所有字节码指令只针对当前栈帧进行操作</p>\n</li>\n<li>\n<p>如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前栈帧。</p>\n</li>\n<li>\n<p>不同线程中所包含的栈帧是不允许相互引用的，即不可能在另一个栈帧中引用另外一个线程的栈帧</p>\n</li>\n<li>\n<p>如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧</p>\n</li>\n<li>\n<p>Java方法有两种返回函数的方式</p>\n<p><strong>一种是正常的函数返回，使用return指令</strong></p>\n<p><strong>另外一种是抛出异常。不管使用哪种方式，都会导致栈帧被弹出</strong></p>\n</li>\n</ul>\n<p><img src=\"https://user-gold-cdn.xitu.io/2020/3/18/170ecafb0c5ada68?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"img\" /></p>\n<h3 id=\"栈帧内部结构\"> 栈帧内部结构</h3>\n<ul>\n<li>局部变量表（Local Variables）</li>\n<li>操作数栈（Operand Stack）(或表达式栈)</li>\n<li>动态链接（Dynamic Linking）(或执行运行时常量池的方法引用)</li>\n<li>方法返回地址（Return Adress）（或方法正常退出或者异常退出的定义）</li>\n<li>一些附加信息</li>\n</ul>\n<p><img src=\"https://user-gold-cdn.xitu.io/2020/3/18/170ecafe0fab0cb2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"img\" /></p>\n<h3 id=\"栈帧-局部变量表-local-variables\"> 栈帧：局部变量表（Local Variables）</h3>\n<ul>\n<li><strong>定义为一个数字数组</strong>：主要用于存储<code>方法参数</code>和定义在方法体内的<code>局部变量</code>,这些数据类型包括各类基本数据类型、对象引用（reference），以及returnAddressleixing</li>\n<li><strong>线程安全</strong>：由于局部变量表是建立在线程的栈上，是线程私有的数据，因此不存在数据安全问题</li>\n<li><strong>大小确定不会改变</strong>：<strong>局部变量表所需的容量大小是在编译期确定下来的</strong>,并保存在方法的Code属性的maximum local variables数据项中。在方法运行期间是不会改变局部变量表的大小的</li>\n<li>**方法嵌套调用的次数由栈的大小决定。一般来说，栈越大，方法嵌套调用次数越多。**对一个函数而言，他的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。</li>\n</ul>\n<p>利用javap命令对字节码文件进行解析查看局部变量表，如图：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2020/3/18/170ecb01f86381ee?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"img\" /></p>\n<h4 id=\"变量槽slot的理解与演示\"> 变量槽slot的理解与演示</h4>\n<ul>\n<li>参数值的存放总是在局部变量数组的index0开始，到数组长度-1的索引结束，但需要注意，0索引<code>默认</code>是用来传递该方法所属对象实例的引用<code>this</code></li>\n<li>局部变量表，<strong>最基本的存储单元是Slot(变量槽)</strong></li>\n<li>局部变量表中存放编译期可知的各种基本数据类型（8种），引用类型（reference），returnAddress类型的变量。</li>\n<li>在局部变量表里，<strong>32位以内的类型只占用一个slot（包括returnAddress类型），64位的类型（long和double）占用两个slot。</strong>\n<ul>\n<li>byte、short、char、float在存储前被转换为int，boolean也被转换为int，0表示false，非0表示true；</li>\n<li>long和double则占据两个slot。</li>\n</ul>\n</li>\n<li>栈帧中的局部变量表中的槽位是可以<code>重复利用</code>的，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变量就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的。</li>\n</ul>\n<p><img src=\"https://user-gold-cdn.xitu.io/2020/3/18/170ecb1565b0252f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"img\" /></p>\n<ul>\n<li>JVM会为局部变量表中的每一个slot都分配一个<code>访问索引</code>，通过这个索引即可成功访问到局部变量表中指定的局部变量值</li>\n<li>当一个实例方法被调用的时候，它的方法参数和方法体定义的局部变量将会<strong>按照顺序被复制到局部变量表中的每一个slot上</strong></li>\n<li><strong>如果需要访问局部变量表中一个64bit的局部变量值时，只需要使用签一个索引即可。</strong></li>\n<li>如果当前帧是由构造方法或者实例方法创建的，那么<strong>该对象引用this将会存放在index为0的slot处</strong>,其余的参数按照参数表顺序排列。</li>\n</ul>\n<div><pre><code><span>public</span> <span>class</span> <span>LocalVariablesTest</span> <span>{</span>\n\n    <span>private</span> <span>int</span> count <span>=</span> <span>1</span><span>;</span>\n    <span>//静态方法不能使用this</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>testStatic</span><span>(</span><span>)</span><span>{</span>\n        <span>//编译错误，因为this变量不存在与当前方法的局部变量表中！！！</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>this</span><span>.</span>count<span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><ul>\n<li>在栈帧中，与性能调优关系最为密切的部分就是<code>局部变量表</code>。在方法执行时，虚拟机使用局部变量表完成方法的传递</li>\n<li><strong>局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收</strong></li>\n</ul>\n<h3 id=\"栈帧-操作数栈-operand-stack\"> 栈帧：操作数栈（Operand Stack）</h3>\n<p>操作数栈，<strong>主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。</strong></p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2020/3/18/170ecb180342dcf0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"img\" /></p>\n<ul>\n<li>\n<p>操作数栈就是jvm执行引擎的一个工作区，当一个方法开始执行的时候，一个新的栈帧也会随之被创建出来，这个方法的</p>\n<p>操作数栈是空的</p>\n</li>\n<li>\n<p>每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译器就定义好了，保存在方法的<code>code属性</code>中，为<code>max_stack</code>的值。</p>\n</li>\n<li>\n<p>栈中的任何一个元素都是可以任意的java数据类型</p>\n<ul>\n<li>\n<p>32bit的类型占用一个栈单位深度</p>\n</li>\n<li>\n<p>64bit的类型占用两个栈深度单位</p>\n</li>\n</ul>\n</li>\n<li>\n<p>操作数栈<strong>并非采用访问索引的方式来进行数据访问</strong>的，而是只能通过标准的入栈push和出栈pop操作来完成一次数据访问</p>\n</li>\n<li>\n<p>**如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，**并更新PC寄存器中下一条需要执行的字节码指令。</p>\n</li>\n<li>\n<p>操作数栈中的元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译期间进行验证，同时在类加载过程中的类验证阶段的数据流分析阶段要再次验证。</p>\n</li>\n</ul>\n<h4 id=\"过程\"> 过程</h4>\n<ul>\n<li>\n<p>结合上图结合下面的图来看一下一个方法（栈帧）的执行过程</p>\n<p>①15入栈；②存储15，15进入局部变量表</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2020/3/18/170ecb1c4797b788?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"img\" /></p>\n<p>③压入8；④存储8，8进入局部变量表；</p>\n</li>\n</ul>\n<p><img src=\"https://user-gold-cdn.xitu.io/2020/3/18/170ecb53336d048b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"img\" /></p>\n<p><strong>⑤从局部变量表中把索引为1和2的是数据取出来，放到操作数栈；⑥iadd相加操作，8和15出栈</strong></p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2020/3/18/170ecb55fd42e99f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"img\" /></p>\n<p><strong>⑦iadd操作结果23入栈；⑧将23存储在局部变量表索引为3的位置上</strong></p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2020/3/18/170ecb5802369d83?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"img\" /></p>\n<h4 id=\"i-和-i的区别\"> i++ 和 ++i的区别</h4>\n<p><img src=\"https://user-gold-cdn.xitu.io/2020/3/18/170ecb6e2832562f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"img\" /></p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2020/3/18/170ecb702e020973?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"img\" /></p>\n<h4 id=\"栈顶缓存技术tos-top-of-stack-cashing\"> 栈顶缓存技术ToS（Top-of-Stack Cashing）</h4>\n<ul>\n<li>基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派（instruction dispatch）次数和内存读/写次数</li>\n<li>由于操作数是存储在内存中的，因此频繁地执行内存读/写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们提出了栈顶缓存技术，<strong>将栈顶元素全部缓存在屋里CPU的寄存器中，以此降低对内存的读/写次数，提升执行的执行效率</strong></li>\n</ul>\n",
      "image": "https://user-gold-cdn.xitu.io/2020/3/18/170ecae266df65ba?imageView2/0/w/1280/h/960/format/webp/ignore-error/1",
      "date_published": "2021-05-12T15:59:28.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": []
    },
    {
      "title": "JVM",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/java/java-JVM/Java-JVM/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/java/java-JVM/Java-JVM/",
      "content_html": "<h2 id=\"jvm组成\"> JVM组成</h2>\n<p>总共分为三大区域</p>\n<ul>\n<li>类加载子系统</li>\n<li>运行时数据区</li>\n<li>执行引擎</li>\n</ul>\n<p><img src=\"./images/Java-JVM/JVM_composition_diagram_1.png\" alt=\"JVM组成图1\" /></p>\n<p><img src=\"./images/Java-JVM/JVM_composition_diagram_2.jpg\" alt=\"JVM组成图2\" /></p>\n<h3 id=\"_1-1-线程共享\"> 1.1 线程共享</h3>\n<ul>\n<li>**方法区：**用于存储虚拟机加载的类信息，常量，静态变量等数据</li>\n<li>**堆：**存放对象实例，所有的对象和数组都要在堆上分配。是JVM所管理的</li>\n</ul>\n<h4 id=\"_1-1-1-方法区\"> 1.1.1 方法区</h4>\n<p>方法区是一个概念，属于共享内存区域，规范为存储<code>已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码</code>等数据。虽然Java虚拟机规范把⽅法区描述为堆的⼀个逻辑部分，但 是它却有⼀个别名叫做 Non-Heap（⾮堆），⽬的应该是与 Java 堆区分开来。</p>\n<h5 id=\"方法区和永久代的关系\"> ⽅法区和永久代的关系</h5>\n<blockquote>\n<p>《Java虚拟机规范》只是规定了有⽅法区这么个概念和它的作⽤，并没有规定如何去实现它。那 么，在不同的 JVM 上⽅法区的实现肯定是不同的了。 ⽅法区和永久代的关系很像Java中接⼝和类 的关系，类实现了接⼝，⽽永久代就是HotSpot虚拟机对虚拟机规范中⽅法区的⼀种实现⽅式。 也 就是说，永久代是HotSpot的概念，⽅法区是Java虚拟机规范中的定义，是⼀种规范，⽽永久代是⼀ 种实现，⼀个是标准⼀个是实现，其他的虚拟机实现并没有永久带这⼀说法。</p>\n</blockquote>\n<h5 id=\"版本迭代\"> 版本迭代：</h5>\n<ul>\n<li>\n<p>在<strong>JDK1.7之前</strong>：永久代</p>\n<blockquote>\n<p>运行时常量池逻辑包含字符串常量池存放在方法区, 此时hotspot虚拟机对方法区的实现为<strong>永久代</strong></p>\n</blockquote>\n</li>\n<li>\n<p>在<strong>JDK1.7</strong>：永久代和堆</p>\n<blockquote>\n<p>字符串常量池被从方法区拿到了<strong>堆</strong>中, 这里没有提到运行时常量池,也就是说<strong>字符串常量池</strong>被单独拿到<strong>堆</strong>,<strong>运行时常量池剩下的东西</strong>还在<strong>方法区</strong>, 也就是hotspot中的<strong>永久代</strong></p>\n</blockquote>\n</li>\n<li>\n<p>在<strong>JDK1.8</strong>： 元空间和堆</p>\n<blockquote>\n<p>hotspot移除了<strong>永久代</strong>用<strong>元空间(Metaspace)<strong>取而代之, 这时候</strong>字符串常量池还在堆</strong>, <strong>运行时常量池还在方法区</strong>, 只不过方法区的实现从永久代变成了元空间(Metaspace) ，元空间并不在虚拟机中，而是在本地内存(Direct Memory)</p>\n</blockquote>\n</li>\n</ul>\n<h5 id=\"为什么要将永久代-permgen-替换为元空间-metaspace-呢\"> 为什么要将永久代(PermGen)替换为元空间(MetaSpace)呢?</h5>\n<p>整个永久代有⼀个 JVM 本身设置固定⼤⼩上线，⽆法进⾏调整，⽽元空间使⽤的是直接内存，受本机 可⽤内存的限制，并且永远不会得到<code>java.lang.OutOfMemoryError</code>。你可以使⽤ -XX： MaxMetaspaceSize 标志设置最⼤元空间⼤⼩，默认值为 unlimited，这意味着它只受系统内存的限 制。 -XX：MetaspaceSize 调整标志定义元空间的初始⼤⼩如果未指定此标志，则 Metaspace 将根 据运⾏时的应⽤程序需求动态地重新调整⼤⼩。 当然这只是其中⼀个原因，还有很多底层的原因，这⾥就不提了。</p>\n<h4 id=\"_1-1-2-堆\"> 1.1.2 堆</h4>\n<p>Java 虚拟机所管理的内存中最⼤的⼀块，Java 堆是所有线程共享的⼀块内存区域，在虚拟机启动时创 建。此内存区域的唯⼀⽬的就是存放对象实例，⼏乎所有的对象实例以及数组都在这⾥分配内存。 Java 堆是垃圾收集器管理的主要区域，因此也被称作GC堆（<code>Garbage Collected Heap</code>）.从垃圾回收的 ⻆度，由于现在收集器基本都采⽤分代垃圾收集算法，所以Java堆还可以细分为：新⽣代和⽼年代：再 细致⼀点有：Eden空间、From Survivor、To Survivor空间等。进⼀步划分的⽬的是更好地回收内存， 或者更快地分配内存。</p>\n<p><img src=\"./images/Java-JVM/Heap_memory_model.jpg\" alt=\"\" /></p>\n<p>上图所示的 eden区、s0区、s1区都属于新⽣代，tentired 区属于⽼年代。⼤部分情况，对象都会⾸先 在 Eden 区域分配，在⼀次新⽣代垃圾回收后，如果对象还存活，则会进⼊ s0 或者 s1，并且对象的 年龄还会加 1(Eden区i&gt;Survivor 区后对象的初始年龄变为1)，当它的年龄增加到⼀定程度（默认为15 岁），就会被晋升到⽼年代中。对象晋升到⽼年代的年龄阈值，可以通过参数 - XX:MaxTenuringThreshold 来设置。</p>\n<h3 id=\"_1-2-常量池\"> 1.2 常量池</h3>\n<p><img src=\"./images/Java-JVM/Constant_pool.png\" alt=\"常量池\" /></p>\n<h3 id=\"_1-3-线程私有\"> 1.3 线程私有</h3>\n<ul>\n<li>**虚拟机栈：**Java方法执行的内存模型，存储局部变量表(包括成员变量，对象地址，即引用类型)，操作数栈，动态链接，方法出口信息。随线程创建和销毁</li>\n<li>**本地方法栈：**与虚拟机栈相似，不同点本地方法栈为native方法执行服务，虚拟机栈为虚拟机栈执行的Java方法服务</li>\n<li>**程序计数器：**当前线程所执行的行号指示器。是JVM内存区域最小的一块区域。执行字节码工作时就是利用程序计数器来选取下一条需要执行的字节码指令</li>\n</ul>\n<h4 id=\"_1-3-1-虚拟机栈\"> 1.3.1 虚拟机栈</h4>\n<p>与程序计数器⼀样，Java虚拟机栈也是线程私有的，它的⽣命周期和线程相同，描述的是 Java ⽅法执 ⾏的内存模型，每次⽅法调⽤的数据都是通过栈传递的。</p>\n<p>Java 内存可以粗糙的区分为堆内存（Heap）和栈内存(Stack),其中栈就是现在说的虚拟机栈，或者说 是虚拟机栈中局部变量表部分。 （实际上，Java虚拟机栈是由⼀个个<strong>栈帧</strong>组成，⽽每个栈帧中都拥 有：<strong>局部变量表、操作数栈、动态链接、⽅法出⼝信息。</strong>）</p>\n<p>无论是本地方法栈，还是虚拟机栈，都是线程私有的，当一个线程启动的时候，jvm就会给这个线程分配一个栈，然后每当你调用一个方法的时候，jvm就会往这个栈压入一个栈帧，方法调用完毕，栈帧出栈。注意，一个栈能容纳的栈帧是固定的，有默认的值，当然你也可以通过-Xss去调。但这个栈里面的引用所指向堆内存空间是可以扩展的。简而言之，一个栈的栈帧数目是确定的，而与该栈相关联的堆内存是可以动态扩展的，这些是前提。</p>\n<p>局部变量表主要存放了编译器可知的各种数据类型（boolean、byte、char、short、int、float、 long、double）、对象引⽤（reference类型，它不同于对象本身，可能是⼀个指向对象起始地址的引 ⽤指针，也可能是指向⼀个代表对象的句柄或其他与此对象相关的位置）。</p>\n<p>Java 虚拟机栈会出现两种异常：<code>StackOverFlowError</code> 和 <code>OutOfMemoryError</code>。</p>\n<blockquote>\n<ul>\n<li><strong>StackOverFlowError</strong>： 若Java虚拟机栈的内存⼤⼩不允许动态扩展，那么当线程请求栈的深度 超过当前Java虚拟机栈的最⼤深度的时候，就抛出StackOverFlowError异常。</li>\n<li><strong>OutOfMemoryError</strong>： 若 Java 虚拟机栈的内存⼤⼩允许动态扩展，且当线程请求栈时内存⽤完 了，⽆法再动态扩展了，此时抛出OutOfMemoryError异常。</li>\n</ul>\n</blockquote>\n<p>Java 虚拟机栈也是线程私有的，每个线程都有各⾃的Java虚拟机栈，⽽且随着线程的创建⽽创建，随 着线程的死亡⽽死亡。</p>\n<p>扩展：那么⽅法/函数如何调⽤？ Java 栈可⽤类⽐数据结构中栈，Java 栈中保存的主要内容是栈帧，每⼀次函数调⽤都会有⼀个对应的 栈帧被压⼊Java栈，每⼀个函数调⽤结束后，都会有⼀个栈帧被弹出。 Java⽅法有两种返回⽅式：</p>\n<ol>\n<li>return 语句。</li>\n<li>抛出异常。</li>\n</ol>\n<p>管哪种返回⽅式都会导致栈帧被弹出。</p>\n<h4 id=\"_1-3-2-本地方法栈\"> 1.3.2 本地方法栈</h4>\n<p>和虚拟机栈所发挥的作⽤⾮常相似，区别是： 虚拟机栈为虚拟机执⾏ Java ⽅法 （也就是字节码）服 务，⽽本地⽅法栈则为虚拟机使⽤到的 Native ⽅法服务。</p>\n<p>在 HotSpot 虚拟机中和 Java 虚拟机栈合 ⼆为⼀。 本地⽅法被执⾏的时候，在本地⽅法栈也会创建⼀个栈帧，⽤于存放该本地⽅法的局部变量表、操作数 栈、动态链接、出⼝信息。</p>\n<p>⽅法执⾏完毕后相应的栈帧也会出栈并释放内存空间，也会出现 <code>StackOverFlowError</code> 和 <code>OutOfMemoryError</code> 两种异常。</p>\n<h4 id=\"_1-3-3-程序计数器\"> 1.3.3 程序计数器</h4>\n<p>程序计数器是⼀块较⼩的内存空间，可以看作是当前线程所执⾏的字节码的⾏号指示器。字节码解释器 ⼯作时通过改变这个计数器的值来选取下⼀条需要执⾏的字节码指令，分⽀、循环、跳转、异常处理、 线程恢复等功能都需要依赖这个计数器来完。 另外，为了线程切换后能恢复到正确的执⾏位置，每条线程都需要有⼀个独⽴的程序计数器，各线程之 间计数器互不影响，独⽴存储，我们称这类内存区域为“线程私有”的内存。</p>\n<p>程序计数器主要有下⾯两个作⽤：</p>\n<ol>\n<li>字节码解释器通过改变程序计数器来依次读取指令，从⽽实现代码的流程控制，如：顺序执⾏、 选择、循环、异常处理。</li>\n<li>在多线程的情况下，<strong>程序计数器⽤于记录当前线程执⾏的位置</strong>，从⽽当线程被切换回来的时候能 够知道该线程上次运⾏到哪⼉了。</li>\n</ol>\n<p>需要注意的是，如果执⾏的是 <strong>native</strong> ⽅法，那么程序计数器记录的是 <strong>undefined</strong> 地址，只有执⾏的 是 Java 代码时程序计数器记录的才是下⼀条指令的地址。 所以，程序计数器私有主要是为了线程切换后能恢复到正确的执⾏位置。程序计数器是唯⼀⼀个不会出现 OutOfMemoryError 的内存区域，它的⽣命周期随着线程的创建 ⽽创建，随着线程的结束⽽死亡。</p>\n<h3 id=\"_1-4-虚拟机栈和本地方法栈为什么是线程私有的\"> 1.4 虚拟机栈和本地⽅法栈为什么是线程私有的?</h3>\n<ul>\n<li><strong>虚拟机栈：</strong> 每个 Java ⽅法在执⾏的同时会创建⼀个栈帧⽤于<strong>存储局部变量表、操作数栈、常量池</strong>引⽤等信息。从⽅法调⽤直⾄执⾏完成的过程，就对应着⼀个栈帧在 Java 虚拟机栈中⼊栈 和出栈的过程。</li>\n<li><strong>本地⽅法栈：</strong> 和虚拟机栈所发挥的作⽤⾮常相似，区别是： 虚拟机栈为虚拟机执⾏ Java ⽅法 （也就是字节码）服务，⽽本地⽅法栈则为虚拟机使⽤到的 Native ⽅法服务。 在 HotSpot 虚 拟机中和 Java 虚拟机栈合⼆为⼀。</li>\n</ul>\n<p>所以，<strong>为了保证线程中的局部变量不被别的线程访问到</strong>，虚拟机栈和本地⽅法栈是线程私有的。</p>\n<h3 id=\"_1-5-对象的访问定位-引用机制-句柄池-直接指针\"> 1.5 对象的访问定位/引用机制(句柄池 | 直接指针)</h3>\n<h4 id=\"_1-5-1-通过句柄访问\"> 1.5.1 通过句柄访问</h4>\n<p>使用对象时，通过栈上的 reference 数据来操作堆上的具体对象。Java 堆中会分配一块内存作为句柄池。reference 存储的是句柄地址。详情见图。</p>\n<p><img src=\"./images/Java-JVM/Access_by_handle.jpg\" alt=\"\" /></p>\n<h4 id=\"_1-5-2-使用直接指针访问\"> 1.5.2 使用直接指针访问</h4>\n<p><img src=\"./images/Java-JVM/Direct_pointer_access.jpg\" alt=\"直接指针访问\" /></p>\n<h4 id=\"_1-5-3-比较\"> 1.5.3 比较</h4>\n<blockquote>\n<ul>\n<li>使用句柄的最大好处是 <code>reference</code> 中存储的是稳定的句柄地址，在对象移动(GC)是只改变实例数据指针地址，<code>reference</code> 自身不需要修改。</li>\n<li>直接指针访问的最大好处是速度快，节省了一次指针定位的时间开销。</li>\n<li>如果是对象频繁 GC 那么句柄方法好，如果是对象频繁访问则直接指针访问好。</li>\n</ul>\n</blockquote>\n<h3 id=\"_1-6-java引用类型-强度\"> 1.6 Java引用类型/强度</h3>\n<blockquote>\n<ul>\n<li>https://www.cnblogs.com/yaowen/p/6292984.html</li>\n<li>https://blog.csdn.net/u011277123/article/details/78830391</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th style=\"text-align:center\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>强引用</td>\n<td style=\"text-align:center\">类似于 <code>Object obj = new Object();</code> 创建的，只要强引用在就不回收。</td>\n</tr>\n<tr>\n<td>软引用</td>\n<td style=\"text-align:center\"><code>SoftReference</code> 。在系统要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行二次回收。</td>\n</tr>\n<tr>\n<td>弱引用</td>\n<td style=\"text-align:center\"><code>WeakReference</code> 。对象只能生存到下一次垃圾收集之前。在垃圾收集器工作时，无论内存是否足够都会回收掉只被弱引用关联的对象。</td>\n</tr>\n<tr>\n<td>虚引用</td>\n<td style=\"text-align:center\"><code>PhantomReference</code> 。无法通过虚引用获取一个对象的实例，为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时有系统通知。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"_2-堆和栈的区别联系\"> 2. 堆和栈的区别联系？</h2>\n<p>参考</p>\n<blockquote>\n<ul>\n<li>https://www.cnblogs.com/weichunguang/p/wei6.html</li>\n</ul>\n</blockquote>\n<p>Java把内存划分成两种：一种是栈内存，一种是堆内存。</p>\n<h3 id=\"_2-1-作用\"> 2.1 作用</h3>\n<ul>\n<li><strong>堆</strong>：存放对象实例，所有的对象和数组都要在堆上分配。是JVM所管理的</li>\n<li><strong>栈</strong>：Java方法执行的内存模型，存储局部变量表，操作数栈，动态链接，方法出口信息。随线程创建和销毁</li>\n</ul>\n<h3 id=\"_2-2-私有或共享\"> 2.2 私有或共享</h3>\n<ul>\n<li><strong>堆</strong>：内存中的对象对所有线程可见。堆内存中的对象可以被所有线程访问。线程共享</li>\n<li><strong>栈</strong>：内存归属于单个线程，每个线程都会有一个栈内存，其存储的变量只能在其所属线程中可见，即栈内存可以理解成线程的私有内存。线程私有</li>\n</ul>\n<h3 id=\"_2-3-异常错误\"> 2.3 异常错误</h3>\n<ul>\n<li><strong>堆内存</strong>：没有可用的空间存储生成的对象，JVM会抛出<strong>java.lang.OutOfMemoryError</strong>。</li>\n<li><strong>栈内存</strong>：没有可用的空间存储方法调用和局部变量，JVM会抛出<strong>java.lang.StackOverFlowError</strong>。</li>\n</ul>\n<h3 id=\"_2-4-空间大小\"> 2.4 空间大小</h3>\n<h2 id=\"_3-gc-garbage-collection-垃圾回收策略\"> 3. GC(Garbage Collection)垃圾回收策略</h2>\n<p>参考</p>\n<blockquote>\n<ul>\n<li>https://blog.csdn.net/laomo_bible/article/details/83112622</li>\n</ul>\n</blockquote>\n<h3 id=\"_3-1-需要gc的区域\"> 3.1 需要GC的区域</h3>\n<p>jvm 中，<code>程序计数器</code>、<code>虚拟机栈</code>、<code>本地方法栈</code>都是随线程而生随线程而灭，栈帧随着方法的进入和退出做入栈和出栈操作，实现了自动的内存清理，因此，我们的内存垃圾回收主要集中于 java <code>堆</code>和<code>方法区</code>中，在程序运行期间，这部分内存的分配和使用都是动态的。</p>\n<h3 id=\"_3-2-gc的对象\"> 3.2 GC的对象</h3>\n<p>参考</p>\n<blockquote>\n<ul>\n<li>https://blog.csdn.net/u010253968/article/details/51160703</li>\n</ul>\n</blockquote>\n<p>需要进行回收的对象就是已经没有存活的对象，判断一个对象是否存活常用的有两种办法：</p>\n<blockquote>\n<ul>\n<li>\n<p><strong>引用计数</strong></p>\n</li>\n<li>\n<p><strong>可达分析</strong></p>\n</li>\n</ul>\n</blockquote>\n<h4 id=\"_3-2-1-引用计数\"> 3.2.1 引用计数</h4>\n<p>每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。此方法简单，无法解决<code>对象相互循环引用</code>的问题，而且计数器需要维护，需要消耗，<strong>所以主流的java虚拟机很少用</strong>。</p>\n<p><img src=\"./images/Java-JVM/Circular_reference.jpg\" alt=\"循环引用\" /></p>\n<p>在这里，obj1中拿着对obj2的引用，obj2中拿着对obj1的引用。如果obj1要被回收，前提是obj2被先回收，这样才能释放对obj1的引用。但是反回过来，obj2要被回收的前提是obj1要被先回收。当build函数退出后，看起来垃圾回收管理似乎就始终无法回收这两个实际已经不再需要的对象。</p>\n<p>垃圾回收机制究竟能否解决循环引用这一困境，带着这个疑问找了一些资料，找到了一个比较满意的解释。在《Java Platform Performance: Strategies and Tactics》这本书的附录A中有一处说明，这本书出自sun公司java团队员工，应该算比较权威的。其中有这样一段</p>\n<blockquote>\n<p>可以简单的理解就是强引用并不能保证对象不被回收。垃圾回收机制除了检查对象是否被引用外，还要看对象是否被至少一个GC roots对象直接或者间接引用</p>\n</blockquote>\n<p>所以，上面例子中两个循环引用的对象，虽然都存在一个强引用，但是不被任何<code>GC root</code>对象直接或者间接引用到(<code>可达性分析</code>)，垃圾回收机制能够发现这个问题。</p>\n<h4 id=\"_3-2-2-可达性分析-主流算法\"> 3.2.2 可达性分析(主流算法)</h4>\n<p>从GC Roots开始向下搜索，搜索所走过的路径称为<code>引用链</code>。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。不可达对象。</p>\n<p><img src=\"./images/Java-JVM/Accessibility_analysis.jpg\" alt=\"可达性分析法\" /></p>\n<p>在Java语言中，可作为 GC Roots 的对象：</p>\n<blockquote>\n<ul>\n<li>虚拟机栈中引用的对象。</li>\n<li>方法区中类静态属性实体引用的对象。</li>\n<li>方法区中常量引用的对象。</li>\n<li>本地方法栈中JNI(即一般说的 <code>Native</code> 方法) 引用的对象。</li>\n</ul>\n</blockquote>\n<p>补充：<code>finalize()</code>方法</p>\n<blockquote>\n<p><code>finalize()</code>是Object中的方法，当垃圾回收器将要回收对象所占内存之前被调用，即当一个对象在<code>可达性分析</code>后被虚拟机宣告死亡时会先调用它<code>finalize()</code>方法，让此对象处理它生前的最后事情（这个对象可以趁这个时机挣脱死亡的命运）</p>\n</blockquote>\n<p>上面提到了判断死亡的依据，但被判断死亡后，还有生还的机会。\n如何自我救赎：</p>\n<blockquote>\n<ul>\n<li>对象覆写了<code>finalize()</code>方法（这样在被判死后才会调用此方法，才有机会做最后的救赎）</li>\n<li>在<code>finalize()</code>方法中重新引用到&quot;<code>GC Roots</code>&quot;链上（如把当前对象的引用this赋值给某对象的类变量/成员变量，重新建立可达的引用）</li>\n</ul>\n</blockquote>\n<p>finalize() 方法只会被系统自动调用一次。虽然以上以对象救赎举例，但<code>finalize()</code>的作用往往被认为是用来做最后的资源回收。\n基于在自我救赎中的表现来看，此方法有很大的不确定性（不保证方法中的任务执行完）而且运行代价较高。所以用来回收资源也不会有什么好的表现。</p>\n<h3 id=\"_3-3-什么时候触发gc\"> 3.3 什么时候触发GC</h3>\n<ul>\n<li>程序调用<code>System.gc()</code>时可以触发</li>\n<li>系统自身来决定GC触发的时机（根据<code>Eden</code>区和<code>From Space</code>区的内存大小来决定。当内存大小不足时，则会启动GC线程并停止应用线程）</li>\n</ul>\n<p>GC又分为 <code>Minor GC</code> 和 <code>Full GC</code> (也称为 <code>Major GC</code> )</p>\n<h4 id=\"_3-3-1-minor-gc触发条件\"> 3.3.1 Minor GC触发条件</h4>\n<p>当Eden区满时，触发Minor GC。</p>\n<h4 id=\"_3-3-2-full-gc触发条件\"> 3.3.2 Full GC触发条件</h4>\n<ul>\n<li>调用System.gc时，系统建议执行Full GC，但是不必然执行</li>\n<li>老年代空间不足</li>\n<li>方法区空间不足</li>\n<li>通过Minor GC后进入老年代的平均大小大于老年代的可用内存</li>\n<li>由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</li>\n</ul>\n<h3 id=\"_3-4-gc常用算法\"> 3.4 GC常用算法</h3>\n<ul>\n<li>标记-清除算法（Mark-Sweep）</li>\n<li>标记-压缩算法</li>\n<li>复制算法</li>\n<li>分代收集算法。</li>\n</ul>\n<p>目前主流的JVM（HotSpot）采用的是<strong>分代收集算法</strong>。</p>\n<h4 id=\"_3-4-1-标记-清除算法\"> 3.4.1 标记-清除算法</h4>\n<p>为每个对象存储一个标记位，记录对象的状态（活着或是死亡）。标记-清除算法执行分两阶段。</p>\n<ul>\n<li><strong>第一阶段标记</strong>：从<code>引用根节点</code>开始标记所有被引用的对象，为每个对象更新标记位，检查对象是否死亡</li>\n<li><strong>第二阶段清除</strong>：该阶段对死亡的对象进行清除，执行 GC 操作。遍历<code>整个堆</code>，把未标记的对象清除。此算法需要暂停整个应用，并且会产生内存碎片。</li>\n</ul>\n<p><img src=\"./images/Java-JVM/Mark-clear_algorithm.png\" alt=\"标记-清除算法\" /></p>\n<h5 id=\"优点\"> 优点</h5>\n<p>最大的优点是，标记—清除算法中每个活着的对象的引用只需要找到一个即可，找到一个就可以判断它为活的。此外，更重要的是，这个算法并不移动对象的位置。</p>\n<h5 id=\"缺点\"> 缺点</h5>\n<ul>\n<li><strong>效率比较低（递归与全堆对象遍历）</strong>：每个活着的对象都要在标记阶段遍历一遍；</li>\n<li><strong>释放空间不连续容易导致内存碎片</strong>：所有对象都要在清除阶段扫描一遍，因此算法复杂度较高。没有移动对象，导致可能出现很多碎片空间无法利用的情况，标记清除后会有大量的不连续的内存碎片，空间碎片太多就会导致无法分配较大对象，无法找到足够大的连续内存，而发生gc。</li>\n<li><strong>清除时会暂停应用</strong>。</li>\n</ul>\n<h4 id=\"_3-4-2-标记-整理算法\"> 3.4.2 标记-整理算法</h4>\n<p>标记-整理算法结合了<code>“标记-清除”</code>和<code>“复制”</code>两个算法的优点。也是分两阶段：</p>\n<ul>\n<li><strong>第一阶段标记</strong>：该算法也将所有对象从<code>根节点</code>标记为<code>存活</code>和<code>死亡</code>两种状态</li>\n<li><strong>第二阶段</strong>：在第二个阶段，该算法并没有直接对死亡的对象进行清理，而是将<code>所有存活的对象</code>整理一下压缩在一块，放到另一处空间，然后把剩下的所有对象全部清除。</li>\n</ul>\n<p><img src=\"./images/Java-JVM/Mark-up_algorithm.png\" alt=\"标记-整理算法\" /></p>\n<h5 id=\"优点-2\"> 优点</h5>\n<p>该算法不会像<code>标记-清除</code>算法那样产生大量的碎片空间，避免了<code>内存碎片</code>，也避免了<code>复制</code>算法的<code>空间利用不足</code>问题。</p>\n<h5 id=\"缺点-2\"> 缺点</h5>\n<p>如果存活的对象过多，整理阶段将会执行较多复制操作，导致算法效率降低。</p>\n<h4 id=\"_3-4-3-复制算法\"> 3.4.3 复制算法</h4>\n<p>该算法将内存平均分成两部分，然后每次只使用其中的一部分，当这部分内存满的时候，将内存中<code>所有存活的对象</code>复制到另一个内存中，然后将之前的内存清空，只使用这部分内存，循环下去。复制算法每次只处理正在使用中的对象，因此复制成本比较小，同时复制过去以后还能进行相应的内存整理，不会出现<code>“碎片”</code>问题。当然，此算法的缺点也是很明显的，就是<code>需要两倍内存空间</code>。</p>\n<blockquote>\n<p>这个算法与<code>标记-整理算法</code>的区别在于，该算法不是在同一个区域复制，而是将所有存活的对象复制到另一个区域内。</p>\n</blockquote>\n<p><img src=\"./images/Java-JVM/Copy_algorithm.png\" alt=\"复制算法\" /></p>\n<h5 id=\"优点-3\"> 优点</h5>\n<p>不会出现内存碎片问题</p>\n<h5 id=\"缺点-3\"> 缺点</h5>\n<p>空间利用率低，只有一半的内存空间能使用</p>\n<h4 id=\"_3-4-4-分代收集算法\"> 3.4.4 分代收集算法</h4>\n<p>现在的虚拟机垃圾收集大多采用这种方式，它根据对象的生存周期，将堆分为：</p>\n<ul>\n<li>\n<p><strong>新生代(Young)</strong>：由于对象生存期短，每次回收都会有大量对象死去，空间较多，那么这时就采用<code>复制算法</code></p>\n<blockquote>\n<p>例如：方法的局部变量引用的对象等</p>\n</blockquote>\n</li>\n<li>\n<p><strong>老年代(Tenure)</strong>：老年代里的对象存活率较高，没有额外的空间进行分配担保，空间较少，所以可以使用<code>标记-整理</code> 或者 <code>标记-清除</code>。</p>\n<blockquote>\n<p>例如：缓存对象、单例对象等</p>\n</blockquote>\n</li>\n<li>\n<p><strong>永久代</strong>：对象生成后几乎不灭的对象</p>\n<blockquote>\n<p>例如：加载过的类信息</p>\n</blockquote>\n</li>\n</ul>\n<p>堆大小=新生代+老年代；（新生代占堆空间的1/3、老年代占堆空间2/3）</p>\n<h5 id=\"新生代\"> 新生代</h5>\n<p>组成</p>\n<ul>\n<li>\n<p>Eden（伊甸园）：这是对象最初诞生的区域，并且对大多数对象来说，这里是它们唯一存在过的区域。</p>\n</li>\n<li>\n<p>Survivor（幸存者乐园）：从伊甸园幸存下来的对象会被挪到这里</p>\n<blockquote>\n<ul>\n<li>From Survivor</li>\n<li>To Survivor</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n<p>比例：Eden ：From Survivor：To Survivor = <code>8：1：1</code></p>\n<p><img src=\"./images/Java-JVM/Heap_memory_model.jpg\" alt=\"堆内存模型\" /></p>\n<p>新生代这样划分是为了更好的管理堆内存中的对象，方便GC算法---<code>复制算法</code>来进行垃圾回收。</p>\n<p>JVM每次只会使用eden和其中一块survivor来为对象服务，所以无论什么时候，都会有一块survivor空间，因此新生代实际可用空间只有<code>90%</code>。</p>\n<h5 id=\"为什么要有survivor区\"> 为什么要有Survivor区</h5>\n<p>参考</p>\n<blockquote>\n<ul>\n<li>https://www.jianshu.com/p/2caad185ee1f</li>\n</ul>\n</blockquote>\n<p>为什么需要Survivor空间。我们看看如果没有 Survivor 空间的话，垃圾收集将会怎样进行：一遍新生代 Minor gc 过后，不管三七二十一，活着的对象全部进入老年代，即便它在接下来的几次 gc 过程中极有可能被回收掉。这样的话老年代很快被填满， Full GC 的频率大大增加。我们知道，老年代一般都会被规划成比新生代大很多，对它进行垃圾收集会消耗比较长的时间；如果收集的频率又很快的话，那就更糟糕了。基于这种考虑，虚拟机引进了“幸存区”的概念：如果对象在某次新生代 gc 之后任然存活，让它暂时进入幸存区；以后每熬过一次 gc ，让对象的年龄＋1，直到其年龄达到某个设定的值（比如15岁）， JVM 认为它很有可能是个“老不死的”对象，再呆在幸存区没有必要（而且老是在两个幸存区之间反复地复制也需要消耗资源），才会把它转移到老年代。</p>\n<p>总之，设置Survivor空间的目的是让那些中等寿命的对象尽量在 Minor GC 时被干掉，最终在总体上减少虚拟机的垃圾收集过程对用户程序的影响。Survivor的存在意义，<strong>就是减少被送到老年代的对象，进而减少Full GC的发生，Survivor的预筛选保证，只有经历16次Minor GC还能在新生代中存活的对象，才会被送到老年代。</strong></p>\n<h5 id=\"为什么-survivor-分区不能是-1-个\"> 为什么 Survivor 分区不能是 1 个？</h5>\n<p>答：回答这个问题有一个前提，就是新生代一般都采用复制算法进行垃圾收集。原始的复制算法是把一块内存一分为二，gc时把存活的对象从一块空间（From space）复制到另外一块空间（To space），再把原先的那块内存（From space）清理干净，最后调换 From space 和 To space 的逻辑角色（这样下一次 gc 的时候还可以按这样的方式进行）。</p>\n<p>我们知道，在HotSpot虚拟机里， Eden 空间和 Survivor 空间默认的比例是 8:1 。我们来看看在只有一个 Survivor 空间的情况下，这个 8:1 会有什么问题。此处为了方便说明，我们假设新生代一共为 9 MB 。对象优先在 Eden 区分配，当 Eden 空间满 8 MB 时，触发第一次 Minor GC 。比如说有 0.5 MB 的对象存活，那这 0.5 MB 的对象将由 Eden 区向 Survivor 区复制。这次 Minor GC 过后， Eden 区被清理干净， Survivor 区被占用了 0.5 MB ，还剩 0.5 MB 。到这里一切都很美好，但问题马上就来了：从现在开始所有对象将会在这剩下的 0.5 MB 的空间上被分配，很快就会发现空间不足，于是只好触发下一次 Minor GC 。可以看出在这种情况下，当 Survivor 空间作为对象“出生地”的时候，很容易触发 Minor GC ，这种 8:1 的不对称分配不但没能在总体上降低 Minor GC 的频率，还会把 gc 的时间间隔搞得很不平均。把 Eden : Survivor 设成 1 : 1 也一样，每当对象总大小满 5 MB 的时候都必须触发一次 Minor GC ，唯一的变化是 gc 的时间间隔相对平均了。</p>\n<p>上面的论述都是以“新生代使用复制算法”这个既定事实作为前提来讨论的。如果不是这样，比如说新生代采用“标记-清除”或者“标记-整理”算法来实现幸存对象的移动，好像确实是只需要一个 Survivor 就够了。至于主流的虚拟机实现为什么不考虑采用这种方式，我也不是很清楚，或许有实现难度、内存碎片或者执行效率方面的考虑吧。</p>\n<h5 id=\"为什么有两个survivor区\"> 为什么有两个Survivor区</h5>\n<p>问题很清楚了，无论Eden和 Survivor 的比例怎么设置，在只有一个 Survivor 的情况下，总体上看在新生代空间满一半的时候就会触发一次 Minor GC 。那有没有提升的空间呢？比如说永远在新生代空间满 80% 的时候才触发 Minor GC ？</p>\n<p>事实上是可以做到的：我们可以设两个Survivor空间（ From Survivor 和 To Survivor ）。比如，我们把 Eden : From Survivor : To Survivor 空间大小设成 8 : 1 : 1 ，对象总是在 Eden 区出生， From Survivor 保存当前的幸存对象， To Survivor 为空。一次 gc 发生后：</p>\n<p>1）Eden 区活着的对象 ＋ From Survivor 存储的对象被复制到 To Survivor ；</p>\n<p>2)清空 Eden 和 From Survivor ；</p>\n<p>3)颠倒 From Survivor 和 To Survivor 的逻辑关系： From 变 To ， To 变 From 。</p>\n<p>可以看出，只有在Eden空间快满的时候才会触发 Minor GC 。而 Eden 空间占新生代的绝大部分，所以 Minor GC 的频率得以降低。当然，使用两个 Survivor 这种方式我们也付出了一定的代价，如 10% 的空间浪费、复制对象的开销等。</p>\n<h4 id=\"_3-5-minor-gc-full-gc-major-gc\"> 3.5 Minor GC || Full GC(Major GC)</h4>\n<p>参考</p>\n<blockquote>\n<ul>\n<li>https://cloud.tencent.com/developer/article/1336605</li>\n</ul>\n</blockquote>\n<h4 id=\"_3-5-1-minor-gc\"> 3.5.1 Minor GC</h4>\n<p>当分配内存在<code>Eden</code>区，Eden区满时会触发</p>\n<h5 id=\"minor-gc流程\"> Minor GC流程</h5>\n<ol>\n<li>\n<p>假设现在Heap内存大小为20M，其中年轻代为10M，老年代为10M，年轻代中Eden区6M，From区2M，To区2M，新创建的对象首先往Eden区分配，当再次分配一个对象，假设大小为1M，此时Eden区已经没有足够空间来给这个对象分配内存，如图所示：</p>\n<p><img src=\"./images/Java-JVM/Minor-GC_1.png\" alt=\"Minor-GC_1\" /></p>\n</li>\n<li>\n<p>这时候触发一次<code>Minor GC</code>，把<code>Eden</code>区的存活对象转移到<code>From</code>区，<code>非存活对象</code>进行清理，然后给新创建的对象分配空间，存入<code>Eden</code>区</p>\n<p><img src=\"./images/Java-JVM/Minor-GC_2.png\" alt=\"Minor-GC_2\" /></p>\n</li>\n<li>\n<p>随着分配对象的增多，<code>Eden</code>区的空间又不足了：</p>\n<p><img src=\"./images/Java-JVM/Minor-GC_3.png\" alt=\"Minor-GC_3\" /></p>\n</li>\n<li>\n<p>这时候再触发一次<code>Minor GC</code>，清理掉<code>Eden</code>区和<code>S1</code>区的死亡对象，把<code>Eden</code>区和<code>S1</code>存活对象转移到<code>S2</code>区，然后再给新对象分配内存：</p>\n<p><img src=\"./images/Java-JVM/Minor-GC_4.png\" alt=\"Minor-GC_4\" /></p>\n</li>\n<li>\n<p><code>From</code>区和<code>To</code>区是相对的关系，哪个区中有对象，哪个区就是<code>From</code>区，比如，再进行一次<code>Minor GC</code>，会把存活对象转移到<code>S1</code>区，再为转移之前，<code>S2</code>区是<code>From</code>区，<code>S1</code>区是<code>To</code>区，转移后，<code>S2</code>区中没有存活对象，变为<code>To</code>区，而<code>S1</code>区变为<code>From</code>区。如果存活的对象是从<code>Eden</code>区到<code>To Survivor</code>，那么将<code>Age</code>设为1，如果是<code>From Survivor</code>中移动过去，则<code>Age++</code>。</p>\n<p><img src=\"./images/Java-JVM/Minor-GC_5.png\" alt=\"Minor-GC_5\" /></p>\n</li>\n</ol>\n<h5 id=\"对象进入老年代的4种情况\"> 对象进入老年代的4种情况</h5>\n<ol>\n<li>\n<p>假如进行Minor GC时发现，存活的对象在<code>ToSpace</code>区中存不下，那么把存活的对象存入老年代</p>\n<p><img src=\"./images/Java-JVM/Object_enters_old_age_1.png\" alt=\"对象进入老年代-1\" /></p>\n</li>\n<li>\n<p><strong>大对象直接进入老年代</strong>：假设新创建的对象很大，比如为5M(这个值可以通过<code>PretenureSizeThreshold</code>这个参数进行设置，默认3M)，那么即使<code>Eden区</code>有足够的空间来存放，也不会存放在<code>Eden区</code>，而是直接存入<code>老年代</code></p>\n<p>!对象进入老年代-2<a href=\"./images/Java-JVM/Object_enters_old_age_2.png\"></a></p>\n</li>\n<li>\n<p><strong>长期存活的对象将进入老年代</strong>：此外，如果对象在<code>Eden</code>出生并且经过1次<code>Minor GC</code>后仍然存活，并且能被<code>To区</code>容纳，那么将被移动到<code>To区</code>，并且把对象的年龄设置为<code>1</code>，对象没&quot;熬过&quot;一次<code>Minor GC</code>(没有被回收，也没有因为<code>To区</code>没有空间而被移动到<code>老年代</code>中)，年龄就<code>增加一岁</code>，当它的年龄增加到一定程度(默认<code>15岁</code>，也可以配置参数<code>-XX:MaxTenuringThreshold</code>)，就会被晋升到<code>老年代</code>中</p>\n</li>\n<li>\n<p><strong>动态对象年龄判定</strong>：还有一种情况，如果在<code>From空间</code>中，相同年龄所有对象的大小总和大于<code>From</code>和<code>To空间</code>总和的一半，那么年龄大于等于该年龄的对象就会被移动到<code>老年代</code>，而不用等到<code>15岁</code>(默认)：</p>\n<p><img src=\"./images/Java-JVM/Object_enters_old_age_3.png\" alt=\"对象进入老年代-3\" /></p>\n</li>\n</ol>\n<h4 id=\"_3-5-2-full-gc\"> 3.5.2 Full GC</h4>\n<p>当触发GC时，会有<code>STW</code>（Stop The World）,即会暂停程序，无法响应</p>\n<p>触发条件：</p>\n<ul>\n<li>调用<code>System.gc()</code>时，系统建议执行Full GC，但是不必然执行</li>\n<li>老年代空间不足</li>\n<li>方法区空间不足</li>\n<li>通过Minor GC后进入老年代的平均大小大于老年代的可用内存</li>\n<li>由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</li>\n</ul>\n<p>如果<code>Full GC</code>后还有无法给新创建的对象分配内存，或者无法移动那些需要进入<code>老年代</code>中的对象，那么<code>JVM</code>抛出<code>OutOfMemoryError</code></p>\n<h4 id=\"_3-5-3-空间分配担保\"> 3.5.3 空间分配担保</h4>\n<p>在发生<code>Minor GC</code>之前，虚拟机会先检查<code>老年代最大可用的连续空间</code>是否大于<code>新生代所有对象总空间</code>：</p>\n<ul>\n<li>\n<p>如果成立：那么<code>Minor GC</code>可以确保是<code>安全</code>的。</p>\n</li>\n<li>\n<p>如果不成立：则虚拟机会查看<code>HandlerPromotionFailure</code>这个参数设置的值(<code>true</code>或<code>flase</code>)是否允许担保失败(如果这个值为true，代表着JVM说，我允许在这种条件下尝试执行<code>Minor GC</code>，出了事我负责)。如果允许，那么会继续检查<code>老年代最大可用的连续空间</code>是否大于<code>历次晋升到老年代对象的平均大小</code>，如果大于，将尝试进行一次<code>Minor GC</code>，尽管这次<code>Minor GC</code>是有风险的；如果小于，或者<code>HandlerPromotionFailure</code>为<code>false</code>，那么这次<code>Minor GC</code>将升级为<code>Full GC</code></p>\n</li>\n</ul>\n<p>如果<code>老年代最大可用的连续空间</code>大于<code>历次晋升到老年代对象的平均大小</code>，那么在<code>HandlerPromotionFailure</code>为<code>true</code>的情况下，可以尝试进行一次<code>Minor GC</code>，但这是有风险的，如果本次将要晋升到老年代的对象很多，那么<code>Minor GC</code>还是无法执行，此时还得改为<code>Full GC</code>。</p>\n<p><code>HandlerPromotionFailure</code>为<code>true</code>时，如果某次需要转移到老年代中的对象确实很多，老年代无法容纳，那么也会先尝试进行一次<code>Minor GC</code>，<code>Minor GC</code>无法执行时再进行<code>Full GC</code>，这样虽然绕了圈子，但我们还是建议把这个参数设置为<code>true</code>，因为我们要尽量避免<code>Full GC</code>。</p>\n<h4 id=\"_3-5-4-为什么要进行空间担保-风险是什么\"> 3.5.4 为什么要进行空间担保/风险是什么？</h4>\n<p>前面提到过，新生代使用复制收集算法，但是为了内存利用率。只使用其中一个Survivor空间来作为轮换备份，因此当出现大量对象在Minor GC后仍然存活的情况（最极端的情况是内存回收之后，新生代中所有的对象都存活），就需要老年代进行分配担保，把Survivor无法容纳的对象直接进入老年代。老年代要进行这样的担保，前提是老年代本身还有容纳这些对象的剩余空间，一共有多少对象存活下来在实际完成内存回收之前是无法明确知道的，所以只好取之前每一次回收晋升到老年代对象容量的平均大小值作为经验值，与老年代的剩余空间进行比较，决定是否进行Full GC来让老年代腾出更多空间。</p>\n<p>取平均值进行比较其实仍然是一种动态概率的手段，也就是说，如果某次Minor GC存活后的对象突增，远远高于平均值的话，依然会导致担保失败。如果出现<code>HandlerPromotionFailure</code>失败，那就只好在失败后重新发起一次FULL GC。虽然担保失败时绕的圈子是最大的，但大部分情况下都还是将<code>HandlerPromotionFailure</code>开关打开，避免<code>Full GC</code>过于频繁。</p>\n<h2 id=\"_4-收集器\"> 4. 收集器</h2>\n<p>参考</p>\n<blockquote>\n<ul>\n<li>https://blog.csdn.net/michaelgo/article/details/82226733</li>\n<li>https://blog.csdn.net/u013030086/article/details/85065049</li>\n</ul>\n</blockquote>\n<p>如果说收集算法是内存回收的方法论，垃圾收集器就是内存回收的具体实现</p>\n<p><img src=\"./images/Java-JVM/GC_collector.png\" alt=\"GC收集器\" /></p>\n<h3 id=\"_4-1-新生代垃圾收集器\"> 4.1 新生代垃圾收集器</h3>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>串行/并行/并发</th>\n<th>回收算法</th>\n<th>适用场景</th>\n<th>可以与cms配合</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>SerialGC</td>\n<td>串行</td>\n<td>复制</td>\n<td>单cpu</td>\n<td>是</td>\n</tr>\n<tr>\n<td>ParNewGC</td>\n<td>并行</td>\n<td>复制</td>\n<td>多cpu</td>\n<td>是</td>\n</tr>\n<tr>\n<td>ParallelScavengeGC</td>\n<td>并行</td>\n<td>复制</td>\n<td>多cpu且关注吞吐量</td>\n<td>否</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"_4-1-1-serial-new串行收集器-复制算法\"> 4.1.1 Serial New串行收集器-复制算法</h4>\n<p>Serial收集器是新生代<code>单线程收集器</code>。这是最早的新生代收集器，也是jdk1.5之前默认的收集器，它是基于复制算法实现</p>\n<p><img src=\"./images/Java-JVM/Serial_Collector-Copy_Algorithm.jpg\" alt=\"Serial串行收集器-复制算法\" /></p>\n<p>优缺点</p>\n<blockquote>\n<ul>\n<li><strong>优点</strong>：简单高效，算是最基本、发展历史最悠久的收集器。</li>\n<li><strong>缺点</strong>：由于<code>单线程</code>，它在进行垃圾收集时，<code>必须暂停其他所有的工作线程（STW）</code>，所以新生代不能太大，否则对于停顿来讲是比较影响交互响应的。</li>\n</ul>\n</blockquote>\n<p>Serial收集器依然是虚拟机运行在<code>Client模式</code>下默认新生代收集器，对于运行在<code>Client模式下的虚拟机</code>来说是一个很好的选择。</p>\n<h4 id=\"_4-1-2-parnew收集器-复制算法\"> 4.1.2 ParNew收集器-复制算法</h4>\n<p>ParNew收集器是新生代<code>并行收集器</code>，其实就<strong>是Serial收集器的多线程版本</strong>。</p>\n<p><img src=\"./images/Java-JVM/ParNew_Collector-Copy_Algorithm.jpg\" alt=\"ParNew收集器-复制算法\" /></p>\n<p>除了使用多线程进行垃圾收集之外，其余行为包括Serial收集器可用的所有控制参数、收集算法、Stop The World、对象分配规则、回收策略等都与Serial 收集器完全一样。</p>\n<p>优缺点</p>\n<blockquote>\n<ul>\n<li><strong>优点</strong>：ParNew收集器是并行的，在多CPU的场景下会有比串行收集器更好的性能</li>\n<li><strong>缺点</strong>：需要注意的是，如果CPU数量为1个或者少于4个时，该种收集器的性能并不会比Serial要好。因为除去上下文切换，以及占用用户线程CPU时间片，导致用户线程被拖慢</li>\n</ul>\n</blockquote>\n<h4 id=\"_4-1-3-parallel-scavenge-并行回收-收集器-复制算法\"> 4.1.3 Parallel Scavenge（并行回收）收集器-复制算法</h4>\n<p>这也是一种新生代垃圾收集器，PSYoungGen它采用的也是复制算法，它与前两种收集器最大的区别是，它关注的是<code>吞吐量</code>而不是<code>延迟</code>。也被称为是吞吐量优先的收集器</p>\n<blockquote>\n<p>吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)</p>\n</blockquote>\n<p>主要使用场景：主要适合在后台运算而不是太多交互的任务，高吞吐量则可以最高效率的利用CPU时间,尽快的完成程序的运算任务。当然，如果想要降低停顿时间，相应的也会影响吞吐量</p>\n<p>参数</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-XX:MaxGCPauseMillis</td>\n<td>控制最大垃圾收集停顿时间。MaxGCPauseMillis参数允许的值是一个大于0的毫秒数，收集器将尽力保证内存回收花费的时间不超过设定值。不过大家不要异想天开地认为如果把这个参数的值设置得稍小一点就能使得系统的垃圾收集速度变得更快，GC停顿时间缩短是以牺牲<code>吞吐量</code>和<code>新生代空间</code>来换取的：系统把新生代调小一些，收集300MB新生代肯定比收集500MB快吧，这也直接导致垃圾收集发生得更频繁一些，原来10秒收集一次、每次停顿100毫秒，现在变成5秒收集一次、每次停顿70毫秒。停顿时间的确在下降，但吞吐量也降下来了</td>\n</tr>\n<tr>\n<td>-XX:GCTimeRatio</td>\n<td>设置吞吐量大小。GCTimeRatio参数的值应当是一个大于0小于100的整数，也就是垃圾收集时间占总时间的比率，相当于是吞吐量的倒数。如果把此参数设置为19，那允许的最大GC时间就占总时间的5%（即1 /（1+19）），默认值为99，就是允许最大1%（即1 /（1+99））的垃圾收集时间</td>\n</tr>\n<tr>\n<td>-XX:+UseAdaptiveSizePolicy</td>\n<td>自适应策略开关。是一个开关参数，当这个参数打开之后，就不需要手工指定新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX:SurvivorRatio）、晋升老年代对象年龄（-XX:PretenureSizeThreshold）等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或最大的吞吐量，这种调节方式称为GC自适应的调节策略（GC Ergonomics）</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"_4-2-老年代垃圾收集器\"> 4.2 老年代垃圾收集器</h3>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>串行/并行/并发</th>\n<th>回收算法</th>\n<th>适用场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>SerialOldGC</td>\n<td>串行</td>\n<td>标记整理</td>\n<td>单cpu</td>\n</tr>\n<tr>\n<td>ParNewOldGC</td>\n<td>并行</td>\n<td>标记整理</td>\n<td>多cpu</td>\n</tr>\n<tr>\n<td>CMS</td>\n<td>并发，几乎不会暂停用户线程</td>\n<td>标记清除</td>\n<td>多cpu且与用户线程共存</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"_4-2-1-serial-old串行收集器-标记整理算法\"> 4.2.1 Serial Old串行收集器-标记整理算法</h4>\n<p>Serial Old是Serial收集器的老年代版本，它同样是一个<code>单线程(串行)收集器</code>，使用标记整理算法。这个收集器的主要意义也是在于给<strong>Client模式下的虚拟机使用</strong>。</p>\n<p>如果在Server模式下，主要两大用途：</p>\n<blockquote>\n<ul>\n<li>在JDK1.5以及之前的版本中与<code>Parallel Scavenge</code>收集器搭配使用</li>\n<li>作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用</li>\n</ul>\n</blockquote>\n<h4 id=\"_4-2-2-parallel-old-收集器-标记整理算法\"> 4.2.2 Parallel Old 收集器-标记整理算法</h4>\n<p>Parallel Old 是<strong>Parallel Scavenge收集器的老年代版本</strong>，使用多线程和“标记-整理”算法。这个收集器在1.6中才开始提供。这个是<code>Serial</code>的多线程版本，同样的使用了<code>标记-整理</code>算法。但是如果CPU数量少的话性能一样不好。但是现在无论是PC还是server CPU数量都不再是性能瓶颈限制了，所以目前它跟<code>Parallel Scavenge</code>的配合是吞吐量优先场景的优先收集器选择。</p>\n<h4 id=\"_4-2-3-cms-收集器-标记清除算法\"> 4.2.3 CMS 收集器-标记清除算法</h4>\n<p>CMS(Concurrent Mark Sweep)收集器是一种<code>以获取最短回收停顿时间为目标</code>的收集器。</p>\n<p>目前很大一部分的Java应用集中在互联网站或者B/S系统的服务端上，这类应用尤其重视服务器的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS收集器就非常符合这类应用的需求。</p>\n<p>CMS收集器是基于“<code>标记-清除</code>”算法实现的，它的运作过程相对前面几种收集器来说更复杂一些，整个过程分为4个步骤：</p>\n<blockquote>\n<ul>\n<li>初始标记</li>\n<li>并发标记</li>\n<li>重新标记</li>\n<li>并发清除</li>\n</ul>\n</blockquote>\n<p>其中，<code>初始标记</code>、<code>重新标记</code>这两个步骤仍然需要“<code>Stop The World</code>”。</p>\n<p><img src=\"./images/Java-JVM/CMS_collector-mark_removal_algorithm.jpg\" alt=\"\" /></p>\n<p>优点：</p>\n<blockquote>\n<ul>\n<li>并发收集：能够全局上与用户线程并发执行。是第一款真正意义上的并发收集器。</li>\n<li>低停顿</li>\n</ul>\n</blockquote>\n<p>缺点：</p>\n<blockquote>\n<ul>\n<li>CMS收集器对<code>CPU资源非常敏感</code>：CPU个数少于4个时，CMS对于用户程序的影响就可能变得很大，为了应付这种情况，虚拟机提供了一种称为“增量式并发收集器”的CMS收集器变种。</li>\n<li>CMS收集器无法处理<code>浮动垃圾</code>：由于清除的时候是<code>并发清除</code>的，这时候用户态产生的垃圾必然无法在本次收集过程中收集掉。也就会产生<code>浮动垃圾</code>。可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。在JDK1.5的默认设置下，<strong>CMS收集器当老年代使用了68%的空间后就会被激活</strong>。</li>\n<li>CMS是基于“标记-清除”算法实现的收集器，会有大量<code>空间碎片</code>产生：空间碎片过多，可能会出现老年代还有很大空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前出发<code>FullGC</code>。对于空间碎片，CMS提供了<code>-XX:+UseCMSCompactAtFullCollection</code>参数，应用于在FULL GC后再进行一个碎片整理过程。<code>-XX:CMSFullGCsBeforeCompaction</code>,多少次不压缩的full gc后来一次带压缩的。</li>\n</ul>\n</blockquote>\n<h3 id=\"_4-3-新生代和老年代收集器\"> 4.3 新生代和老年代收集器</h3>\n<h4 id=\"_4-3-1-g1收集器-标记整理算法\"> 4.3.1 G1收集器-标记整理算法</h4>\n<p><code>JDK1.7</code>后全新的回收器, 用于取代CMS收集器。是比前面的更优秀，真正有突破的一款垃圾收集器。</p>\n<p>其实在G1中还是保留了分代的概念，但是实际上已经在<code>新生代</code>和<code>老年代</code>中没有物理隔离了。在G1中，内存空间被分割成一个个的<code>Region</code>区，所谓<code>新生代</code>和<code>老年代</code>，都是由一个个<code>region</code>组成的。同时G1也不需要跟别的收集器一起配合使用，自己就可以搞定所有内存区域。整体上来讲不是一个分代收集器，是一个<code>通吃收集器</code>。这也是JVM内存管理和垃圾收集的一个发展趋势。从后面<code>zgc</code>中我们可以更清晰的看到这个变化。</p>\n<p>G1收集器的优势：</p>\n<blockquote>\n<ul>\n<li>独特的分代垃圾回收器,分代GC: 分代收集器, 同时兼顾<code>年轻代</code>和<code>老年代</code></li>\n<li>使用分区算法, 不要求Eden, 年轻代或老年代的空间都连续</li>\n<li>并行性: 回收期间, 可由多个线程同时工作, 有效利用多核cpu资源</li>\n<li>空间整理: 回收过程中, 会进行适当对象移动, 减少空间碎片</li>\n<li>可预见性: G1可选取部分区域进行回收, 可以缩小回收范围, 减少全局停顿</li>\n</ul>\n</blockquote>\n<p>G1收集器的步骤</p>\n<p><img src=\"./images/Java-JVM/G1_collector_steps.jpg\" alt=\"G1收集器步骤\" /></p>\n<p>共四个步骤：</p>\n<blockquote>\n<ol>\n<li>初始标记（它标记了从GC Root开始直接可达的对象）：与CMS第一步骤差不多</li>\n<li>并发标记（从GC Roots开始对堆中对象进行<code>可达性分析</code>，找出存活对象）：这个过程时间比较久，分析<code>GC Root</code>到所有对象的<code>可达性分析</code>。如果从<code>GC Root</code>节点开始遍历所有对象会比较耗时，实际上JVM也不是这么做的。JVM是使用<code>Remembered Set</code>保存了对象引用的调用信息，在可达性分析的时候只需要同时遍历<code>remembered set</code>就好了，不需要从根节点开始挨个遍历。</li>\n<li>最终标记（标记那些在并发标记阶段发生变化的对象，将被回收）：由于并发标记阶段，用户线程仍然在工作，会对标记产生一些偏差，这时候需要通过remembered set log来记录这些改变，在这个阶段将改变合并到remembered set中。完成最终标记。</li>\n<li>筛选回收（首先对各个<code>Regin</code>的<code>回收价值</code>和<code>成本</code>进行<code>排序</code>，根据用户所期待的GC停顿时间指定回收计划，回收一部分<code>Region</code>）：通过标记整理的算法，根据用户配置的回收时间，和维护的优先级列表，优先收集价值最大的region。收集阶段是基于标记-整理和复制算法实现。</li>\n</ol>\n</blockquote>\n<h4 id=\"_4-3-2-zgc收集器\"> 4.3.2 ZGC收集器</h4>\n<p>zgc是<code>jdk11</code>中要发布的最新垃圾收集器。完全没有分代的概念，先说下它的优点吧，官方给出的是<code>无碎片</code>，<code>时间可控</code>，<code>超大堆</code>。</p>\n<blockquote>\n<p>与标记对象的传统算法相比，ZGC在指针上做标记，在访问指针时加入Load Barrier（读屏障），比如当对象正被GC移动，指针上的颜色就会不对，这个屏障就会先把指针更新为有效地址再返回，也就是，永远只有单个对象读取时有概率被减速，而不存在为了保持应用与GC一致而粗暴整体的Stop The World。</p>\n</blockquote>\n<p>具体参考</p>\n<blockquote>\n<ul>\n<li>https://blog.csdn.net/michaelgo/article/details/82226733</li>\n<li>https://mp.weixin.qq.com/s/KUCs_BJUNfMMCO1T3_WAjw</li>\n</ul>\n</blockquote>\n<h2 id=\"_5-classloader\"> 5. ClassLoader</h2>\n<p>::: tips 参考</p>\n<ul>\n<li><a href=\"https://www.cnblogs.com/makai/p/11081879.html\" target=\"_blank\" rel=\"noopener noreferrer\">老大难的 Java ClassLoader，到了该彻底理解它的时候了</a></li>\n<li><a href=\"https://blog.csdn.net/briblue/article/details/54973413\" target=\"_blank\" rel=\"noopener noreferrer\">一看你就懂，超详细java中的ClassLoader详解</a></li>\n</ul>\n<p>:::</p>\n",
      "date_published": "2021-05-10T00:19:12.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": []
    },
    {
      "title": "概述/参考",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/java/java-JVM/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/java/java-JVM/",
      "content_html": "<h2 id=\"参考\"> 参考</h2>\n<div><p>参考</p>\n<ul>\n<li>https://blog.csdn.net/qq_41701956/article/details/81664921</li>\n<li><a href=\"https://www.bilibili.com/video/BV1PJ411n7xZ\" target=\"_blank\" rel=\"noopener noreferrer\">尚硅谷</a></li>\n<li><a href=\"https://blog.csdn.net/TZ845195485/article/details/93238857\" target=\"_blank\" rel=\"noopener noreferrer\">笔记参考</a></li>\n<li><a href=\"https://juejin.cn/post/6844904095937986567\" target=\"_blank\" rel=\"noopener noreferrer\">笔记参考2</a></li>\n<li><a href=\"https://juejin.cn/post/6844904095937986567\" target=\"_blank\" rel=\"noopener noreferrer\">笔记参考3</a></li>\n</ul>\n</div>\n<h3 id=\"官方规范参考\"> 官方规范参考</h3>\n<div><p>官方规范参考</p>\n<ul>\n<li>https://docs.oracle.com/javase/specs/index.html</li>\n</ul>\n</div>\n<h2 id=\"学习思维导图\"> 学习思维导图</h2>\n<p>参考</p>\n<ul>\n<li><a href=\"https://blog.csdn.net/CSDN_WHS/article/details/102728250?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-2.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-2.control\" target=\"_blank\" rel=\"noopener noreferrer\">jvm学习路线</a></li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/20191024174120206.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fV0hT,size_16,color_FFFFFF,t_70\" alt=\"\" /></p>\n<p><img src=\"https://img-blog.csdnimg.cn/2020052921054496.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNDMxMTcx,size_16,color_FFFFFF,t_70\" alt=\"\" /></p>\n",
      "image": "https://img-blog.csdnimg.cn/20191024174120206.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fV0hT,size_16,color_FFFFFF,t_70",
      "date_published": "2021-05-10T00:20:01.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": []
    },
    {
      "title": "Java多线程-1",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/java/java-MultiThread/Java-MultiThread-1/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/java/java-MultiThread/Java-MultiThread-1/",
      "content_html": "<h2 id=\"进程-线程-多线程多进程\"> 进程 | 线程 | 多线程多进程</h2>\n<h3 id=\"线程和进程区别\"> 线程和进程区别</h3>\n<p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/Java-MultiThread-1/线程和进程区别.png\" alt=\"线程、程序、进程\" /></p>\n<ul>\n<li>进程是系统资源分配和调度的基本单位，有独立的内存空间；而线程是CPU调度的基本单位，是操作系统能够进行运算调度的最小单位，没有独立内存空间，但有独立的栈，寄存器，局部变量等，其他线程可以读写栈内存。</li>\n<li>创建进程开销大，包括创建虚拟地址空间等需要大量内存资源；而创建线程开销小，基本上只需要一个内核对象和一个堆栈。</li>\n<li>一个进程无法直接访问其他进程的资源；但是同一进程内多个线程可以共享进程的资源。</li>\n<li>进程切换开销大，线程切换开销小。</li>\n<li>进程通信开销大，线程通信开销小。</li>\n<li>线程属于进程，不能独立执行。每个进程应该至少要有一个线程，称为其主线程。</li>\n<li>进程与线程之间最主要的区别就是：同一进程内的多个线程可以共享部分状态，多个线程可以读写同一块内存（而进程无法直接访问其他进程的内存），同时每个线程还用自己的独立的栈和寄存器，其他线程还可以读写这些栈内存。</li>\n</ul>\n<h3 id=\"多线程和多进程\"> 多线程和多进程</h3>\n<p>多线程是指从软件或硬件上实现多个线程并发执行的技术。多线程是为了同步完成多项任务，不是为了提高运行效率，而是为了提高资源使用效率来提高系统的效率。线程是在同一时间需要完成多项任务的时候实现的。</p>\n<p>多进程是指：多个任务同时运行。</p>\n<p>区别</p>\n<ul>\n<li>\n<p>多进程之间不共享数据，程序上下文区分开。多线程之间共享数据，在数据处理上要谨慎。</p>\n</li>\n<li>\n<p>一个进程死掉不会影响其他进程；但同一个进程里的一个线程死掉，等于整个进程死掉，所以多进程的健壮性高于多线程的。</p>\n</li>\n<li>\n<p>线程的尺度划分小于进程，使得多线程程序的并发性高。</p>\n</li>\n<li>\n<p>多线程是为了同步完成多项任务，不是为了提高运行效率，而是为了提高资源使用效率来提高系统的效率。</p>\n</li>\n</ul>\n<h2 id=\"线程的创建\"> 线程的创建</h2>\n<p>Java多线程，皆始于Thread。Thread是多线程的根，每一个线程的开启都始于Thread的<code>start()</code>方法</p>\n<p>参考</p>\n<blockquote>\n<ul>\n<li>https://www.cnblogs.com/felixzh/p/6036074.html</li>\n<li>https://www.jianshu.com/p/7950ea349dbb</li>\n</ul>\n</blockquote>\n<p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/Java-MultiThread-1/线程类图.jpg\" alt=\"线程类图\" /></p>\n<p>一共有四种</p>\n<div><p>Info</p>\n<p><strong>无返回值</strong>，run()返回为void</p>\n<ul>\n<li>继承Thread类创建线程（Thread本身就实现Runnable）</li>\n<li>实现Runnable接口，并实例作为<code>Thread(Runnable r)</code>构造器的参数</li>\n</ul>\n<p><strong>有返回值</strong>，通过Callable接口，就要实现call方法，这个方法的返回值是Object</p>\n<ul>\n<li>实现Callable接口通过FutureTask包装器来创建Thread线程</li>\n<li>线程池，使用<strong>ExecutorService</strong>、Callable、Future实现有返回结果的多线程</li>\n</ul>\n</div>\n<h3 id=\"第一种-继承thread类创建线程\"> 第一种：继承Thread类创建线程</h3>\n<p>Thread类本质上是实现了Runnable接口的一个实例，代表一个线程的实例。启动线程的唯一方法就是通过Thread类的start()实例方法。start()方法是一个native方法，它将启动一个新线程，并执行run()方法。这种方式实现多线程很简单，通过自己的类直接extend Thread，并复写run()方法，就可以启动新线程并执行自己定义的run()方法。例如：</p>\n<div><pre><code><span>public</span> <span>class</span> <span>MyThread</span> <span>extends</span> <span>Thread</span> <span>{</span>  \n   <span>@Override</span>\n　　<span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>  \n　　 <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"MyThread.run()\"</span><span>)</span><span>;</span>  \n　　<span>}</span>  \n<span>}</span>  \n \n<span>MyThread</span> myThread1 <span>=</span> <span>new</span> <span>MyThread</span><span>(</span><span>)</span><span>;</span>  \n<span>MyThread</span> myThread2 <span>=</span> <span>new</span> <span>MyThread</span><span>(</span><span>)</span><span>;</span>  \nmyThread1<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>  \nmyThread2<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>这种实现方式是显示的继承了Thread，但从类图中我们可以看到，Thread类本身就继承自Runnable，所以继承Thread的本质依然是实现Runnable接口定义的run方法。</p>\n<p>需要注意的是继承Thread方式，target对象为null，重写了run方法，导致方式1中的Thread原生的run方法失效，因此并不会调用到target.run()的逻辑，而是直接调用子类重写的run方法。</p>\n<p><code>Thread</code>里面的<code>run()</code>方法</p>\n<div><pre><code><span>@Override</span>\n<span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>target <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n        target<span>.</span><span>run</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>总体来说分两种情况</p>\n<ul>\n<li><strong>直接使用Thread</strong>：在new时可以指定<code>Runnable</code>接口类型的构造参数<code>target</code>，如果有则调用<code>target</code>的run方法，如果没有则调用默认的（即什么都不干）或自己重写的run方法</li>\n<li><strong>通过继承Thread</strong>：没有对应构造器，所以<code>target</code>为<code>null</code>，所以会调用默认的<code>run()</code>方法或调用重写的<code>run()</code>方法</li>\n</ul>\n<blockquote>\n<p>因为java是单根继承，此方式一般不常用。</p>\n</blockquote>\n<h3 id=\"第二种-实现runnable接口\"> 第二种：实现Runnable接口</h3>\n<p>Runnable接口只有一个无返回值的run方法</p>\n<div><pre><code><span>public</span> <span>interface</span> <span>Runnable</span> <span>{</span>\n    <span>public</span> <span>abstract</span> <span>void</span> <span>run</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>实现run方法，接口的实现类的实例作为<code>Thread</code>的<code>target</code>作为参数传入带参的<code>Thread</code>构造函数，通过调用<code>start()</code>方法启动线程。适用于已经有继承的父类无法继承Thread类的时候</p>\n<div><pre><code><span>public</span> <span>class</span> <span>ThreadDemo02</span> <span>{</span>\n \n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span><span>{</span> \n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>Thread</span> t1 <span>=</span> <span>new</span> <span>Thread</span><span>(</span><span>new</span> <span>MyThread</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        t1<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span> \n    <span>}</span>\n<span>}</span>\n\n\n<span>class</span> <span>MyThread</span> <span>implements</span> <span>Runnable</span><span>{</span>\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>\n        <span>// TODO Auto-generated method stub</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span><span>+</span><span>\"-->我是通过实现接口的线程实现方式！\"</span><span>)</span><span>;</span>\n    <span>}</span>   \n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>是较常用且最本质实现。此构造方法相当于对<code>Runnable</code>实例进行一层包装，在<code>线程t</code>启动时，调用<code>Thread</code>的<code>run</code>方法从而间接调用<code>target.run()</code>：</p>\n<div><pre><code><span>public</span> <span>class</span> <span>Thread</span> <span>implements</span> <span>Runnable</span> <span>{</span>\n    <span>/* What will be run. */</span>\n    <span>private</span> <span>Runnable</span> target<span>;</span>\n\n    <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>target <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n            target<span>.</span><span>run</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n   <span>}</span>\n     <span>.</span><span>.</span><span>.</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h3 id=\"第三种-实现callable接口通过futuretask包装器来创建thread线程\"> 第三种：实现Callable接口通过FutureTask包装器来创建Thread线程</h3>\n<div><p>参考</p>\n<ul>\n<li>https://blog.csdn.net/yucaixiang/article/details/89241435</li>\n<li>https://blog.csdn.net/ghsau/article/details/7451464</li>\n<li>https://blog.csdn.net/javazejian/article/details/50896505</li>\n</ul>\n</div>\n<p>Callable接口相对于Runnable接口无返回值的run方法，是有返回值的run方法，通过泛型指定返回的类型</p>\n<div><pre><code><span>public</span> <span>interface</span> <span>Callable</span><span><span>&lt;</span><span>V</span><span>></span></span> <span>{</span>\n    <span>/**\n     * Computes a result, or throws an exception if unable to do so.\n     *\n     * @return computed result\n     * @throws Exception if unable to compute a result\n     */</span>\n    <span>V</span> <span>call</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>FutureTask可用于<code>异步获取执行结果</code>或<code>取消执行任务</code>的场景</p>\n<ul>\n<li>创建<code>Callable</code>接口的实现类 ，并实现<code>Call</code>方法</li>\n<li>创建<code>Callable</code>实现类的实现，使用<code>FutureTask</code>类包装<code>Callable</code>对象，该<code>FutureTask</code>对象封装了Callable对象的Call方法的返回值</li>\n<li>使用FutureTask对象作为Thread对象的target创建并启动线程</li>\n<li>调用FutureTask对象的get()来获取子线程执行结束的返回值（get方法是阻塞的，可以设定阻塞时间，没获取到则返回null）</li>\n</ul>\n<div><pre><code><span>public</span> <span>class</span> <span>DemoCallable</span> <span>implements</span> <span>Callable</span><span><span>&lt;</span><span>String</span><span>></span></span><span>{</span>\n    <span>@Override</span>\n    <span>public</span> <span>String</span> <span>call</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>// TODO Auto-generated method stub</span>\n        <span>return</span> <span>null</span><span>;</span>\n    <span>}</span>\n    \n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>DemoCallable</span> c <span>=</span> <span>new</span> <span>DemoCallable</span><span>(</span><span>)</span><span>;</span>\n        <span>FutureTask</span><span><span>&lt;</span><span>String</span><span>></span></span> future <span>=</span> <span>new</span> <span>FutureTask</span><span><span>&lt;</span><span>></span></span><span>(</span>c<span>)</span><span>;</span> \n        <span>Thread</span> t <span>=</span> <span>new</span> <span>Thread</span><span>(</span>future<span>)</span><span>;</span>\n        t<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n        <span>.</span><span>.</span><span>.</span>\n        <span>String</span> result <span>=</span> future<span>.</span><span>get</span><span>(</span><span>)</span><span>;</span> <span>//同步获取返回结果</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>result<span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>另外，FutrueTask的构造器除了接收Callable外，还有接收<code>Runnable</code>和<code>返回类型result</code>：</p>\n<div><pre><code><span>public</span> <span>FutureTask</span><span>(</span><span>Runnable</span> runnable<span>,</span> <span>V</span> result<span>)</span> <span>{</span>\n    <span>this</span><span>.</span>callable <span>=</span> <span>Executors</span><span>.</span><span>callable</span><span>(</span>runnable<span>,</span> result<span>)</span><span>;</span>\n    <span>this</span><span>.</span>state <span>=</span> NEW<span>;</span>       <span>// ensure visibility of callable</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>Future接口方法</p>\n<div><pre><code><span>public</span> <span>interface</span> <span>Future</span><span><span>&lt;</span><span>V</span><span>></span></span> <span>{</span>\n    <span>boolean</span> <span>cancel</span><span>(</span><span>boolean</span> mayInterruptIfRunning<span>)</span><span>;</span>\n    <span>boolean</span> <span>isCancelled</span><span>(</span><span>)</span><span>;</span>\n    <span>boolean</span> <span>isDone</span><span>(</span><span>)</span><span>;</span>\n    <span>V</span> <span>get</span><span>(</span><span>)</span> <span>throws</span> <span>InterruptedException</span><span>,</span> <span>ExecutionException</span><span>;</span>\n    <span>V</span> <span>get</span><span>(</span><span>long</span> timeout<span>,</span> <span>TimeUnit</span> unit<span>)</span> <span>throws</span> <span>InterruptedException</span><span>,</span> <span>ExecutionException</span><span>,</span> <span>TimeoutException</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><ul>\n<li><strong>V get()</strong> ：获取异步执行的结果，如果没有结果可用，此方法会阻塞直到异步计算完成。</li>\n<li><strong>V get(Long timeout , TimeUnit unit)</strong> ：获取异步执行结果，如果没有结果可用，此方法会阻塞，但是会有时间限制，如果阻塞时间超过设定的timeout时间，该方法将抛出异常。</li>\n<li><strong>boolean isDone()</strong> ：如果任务执行结束，无论是正常结束或是中途取消还是发生异常，都返回true。</li>\n<li><strong>boolean isCanceller()</strong> ：如果任务完成前被取消，则返回true。</li>\n<li><strong>boolean cancel(boolean mayInterruptRunning)</strong> ：如果任务还没开始，执行cancel(...)方法将返回false；如果任务已经启动，执行cancel(true)方法将以中断执行此任务线程的方式来试图停止任务，如果停止成功，返回true；当任务已经启动，执行cancel(false)方法将不会对正在执行的任务线程产生影响(让线程正常执行到完成)，此时返回false；当任务已经完成，执行cancel(...)方法将返回false。mayInterruptRunning参数表示是否中断执行中的线程。\n通过方法分析我们也知道实际上Future提供了4种功能：\n<ol>\n<li>能够中断执行中的任务</li>\n<li>判断任务是否执行完成</li>\n<li>判断任务是否被取消</li>\n<li>获取任务执行完成后的结果。</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"第四种-通过线程池创建线程\"> 第四种：通过线程池创建线程</h3>\n<p>ExecutorService、Callable都是属于Executor框架。返回结果的线程是在JDK1.5中引入的新特征，还有Future接口也是属于这个框架，有了这种特征得到返回值就很方便了。\n通过分析可以知道，他同样也是实现了Callable接口，实现了Call方法，所以有返回值。这也就是正好符合了前面所说的两种分类</p>\n<p>通过<code>submit()</code>（execute()方法无返回值）方法执行Callable任务后，可以获取一个Future的返回对象，在该对象上调用get就可以获取到Callable任务返回的Object了。get方法是阻塞的，即：线程无返回结果，get方法会一直等待。</p>\n<div><pre><code><span>public</span> <span>class</span> <span>ThreadDemo05</span><span>{</span>\n \n    <span>//线程池数量</span>\n    <span>private</span> <span>static</span> <span>int</span> POOL_NUM <span>=</span> <span>10</span><span>;</span>     \n \n    <span>/**\n     * @param args\n     * @throws InterruptedException \n     */</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>InterruptedException</span> <span>{</span>\n        <span>// TODO Auto-generated method stub</span>\n        <span>ExecutorService</span> executorService <span>=</span> <span>Executors</span><span>.</span><span>newFixedThreadPool</span><span>(</span><span>5</span><span>)</span><span>;</span>\n        <span>for</span><span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i<span>&lt;</span>POOL_NUM<span>;</span> i<span>++</span><span>)</span>  \n        <span>{</span>  \n            <span>RunnableThread</span> thread <span>=</span> <span>new</span> <span>RunnableThread</span><span>(</span><span>)</span><span>;</span>\n \n            <span>//Thread.sleep(1000);</span>\n            <span>//无返回值</span>\n            <span>/</span>executorService<span>.</span><span>execute</span><span>(</span>thread<span>)</span><span>;</span>\n            \n            <span>//有返回值</span>\n            <span>Future</span><span><span>&lt;</span><span>String</span><span>></span></span> future <span>=</span> executorService<span>.</span><span>submit</span><span>(</span>thread<span>)</span><span>;</span>  \n        <span>}</span>\n        <span>//关闭线程池</span>\n        executorService<span>.</span><span>shutdown</span><span>(</span><span>)</span><span>;</span> \n    <span>}</span>   \n \n<span>}</span>\n \n<span>class</span> <span>RunnableThread</span> <span>implements</span> <span>Callable</span><span><span>&lt;</span><span>String</span><span>></span></span>  \n<span>{</span>     \n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>call</span><span>(</span><span>)</span>  \n    <span>{</span>  \n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"通过线程池方式创建的线程：\"</span> <span>+</span> <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>\" \"</span><span>)</span><span>;</span>\n        <span>return</span> <span>\"线程结束后的返回值：\"</span> <span>+</span> <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>\" \"</span><span>;</span>\n \n    <span>}</span>  \n<span>}</span>  \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br></div></div><h3 id=\"future-futuretask\"> Future | FutureTask</h3>\n<h3 id=\"继承和组合两种创建方式的不同\"> 继承和组合两种创建方式的不同</h3>\n<ol>\n<li>继承方式和接口方式，后者属于组合的技术，耦合性更低</li>\n<li>后者的一个Runnable实例可以被<code>多个线程实例共享</code></li>\n<li>继承的方式创建线程，Java虚拟机会为其分配调用栈空间、内核线程等资源，成本更加昂贵</li>\n</ol>\n<h2 id=\"线程的启动\"> 线程的启动</h2>\n<div><p>参考</p>\n<ul>\n<li><a href=\"https://www.jianshu.com/p/8c16aeea7e1a\" target=\"_blank\" rel=\"noopener noreferrer\">线程启动原理</a></li>\n</ul>\n</div>\n<h3 id=\"一些概念\"> 一些概念</h3>\n<ul>\n<li>Java多线程，皆始于Thread。Thread是多线程的根，每一个线程的开启都始于Thread的start()方法。</li>\n<li>start方法调用结束并不意味着相应的线程已经开始运行，运行时间有<code>线程调度器</code>决定</li>\n<li>线程属于“一次性用品”,我们不能通过重新调用一个已经运行结束的线程的<code>start</code>方法来使其重新运行。事实上, start方法也只能够被调用一次,多次调用同一个 Thread实例的start方法会导致其抛出<code>IllegalThreadState Exception</code>异常。</li>\n</ul>\n<h3 id=\"调用start和run方法区别\"> 调用start和run方法区别</h3>\n<p>new ⼀个 Thread，线程进⼊了新建状态;调⽤ start() ⽅法，会启动⼀个线程并使线程进⼊了就绪状 态，当分配到时间⽚后就可以开始运⾏了。 start() 会执⾏线程的相应准备⼯作，然后⾃动执⾏ run() ⽅法的内容，这是真正的多线程⼯作。 ⽽直接执⾏ run() ⽅法，会把 run ⽅法当成⼀个 main 主线程下的普通⽅法去执⾏，并不会在某个线程中执⾏它，所以这并不是多线程⼯作。 总结： 调⽤ start ⽅法⽅可启动线程并使线程进⼊就绪状态，⽽ run ⽅法只是 thread 的⼀个普通 ⽅法调⽤，还是在主线程⾥执⾏。</p>\n<h3 id=\"thread-start\"> Thread.start()</h3>\n<div><pre><code> <span>/**\n     * Causes this thread to begin execution; the Java Virtual Machine\n     * calls the &lt;code>run&lt;/code> method of this thread.\n     * \n     * 1、start方法将导致this thread开始执行。由JVM调用this thread的run方法。\n     * \n     * The result is that two threads are running concurrently: the\n     * current thread (which returns from the call to the\n     * &lt;code>start&lt;/code> method) and the other thread (which executes its\n     * &lt;code>run&lt;/code> method).\n     * \n     * 2、结果是 调用start方法的当前线程 和 执行run方法的另一个线程 同时运行。\n     * \n     * It is never legal to start a thread more than once.\n     * In particular, a thread may not be restarted once it has completed\n     * execution.\n     *\n     * 3、多次启动线程永远不合法。 特别是，线程一旦完成执行就不会重新启动。\n     * \n     * @exception  IllegalThreadStateException  if the thread was already started.\n     * 如果线程已启动，则抛出异常。\n     * @see        #run()\n     * @see        #stop()\n     */</span>\n    <span>public</span> <span>synchronized</span> <span>void</span> <span>start</span><span>(</span><span>)</span> <span>{</span>\n        <span>/**\n         * This method is not invoked for the main method thread or \"system\"\n         * group threads created/set up by the VM. Any new functionality added\n         * to this method in the future may have to also be added to the VM.\n         * \n         * 4、对于由VM创建/设置的main方法线程或“system”组线程，不会调用此方法。 \n         *    未来添加到此方法的任何新功能可能也必须添加到VM中。\n         * \n         * A zero status value corresponds to state \"NEW\".\n         * 5、status=0 代表是 status 是 \"NEW\"。\n         */</span>\n        <span>if</span> <span>(</span>threadStatus <span>!=</span> <span>0</span><span>)</span>\n            <span>throw</span> <span>new</span> <span>IllegalThreadStateException</span><span>(</span><span>)</span><span>;</span>\n\n        <span>/* Notify the group that this thread is about to be started\n         * so that it can be added to the group's list of threads\n         * and the group's unstarted count can be decremented. \n         * \n         * 6、通知组该线程即将启动，以便将其添加到线程组的列表中，\n         *    并且减少线程组的未启动线程数递减。\n         * \n         * */</span>\n        group<span>.</span><span>add</span><span>(</span><span>this</span><span>)</span><span>;</span>\n\n        <span>boolean</span> started <span>=</span> <span>false</span><span>;</span>\n        <span>try</span> <span>{</span>\n            <span>//7、调用native方法，底层开启异步线程，并调用run方法。</span>\n            <span>start0</span><span>(</span><span>)</span><span>;</span>\n            started <span>=</span> <span>true</span><span>;</span>\n        <span>}</span> <span>finally</span> <span>{</span>\n            <span>try</span> <span>{</span>\n                <span>if</span> <span>(</span><span>!</span>started<span>)</span> <span>{</span>\n                    group<span>.</span><span>threadStartFailed</span><span>(</span><span>this</span><span>)</span><span>;</span>\n                <span>}</span>\n            <span>}</span> <span>catch</span> <span>(</span><span>Throwable</span> ignore<span>)</span> <span>{</span>\n                <span>/* do nothing. If start0 threw a Throwable then it will be passed up the call stack \n                 * 8、忽略异常。 如果start0抛出一个Throwable，它将被传递给调用堆栈。\n                 */</span>\n            <span>}</span>\n        <span>}</span>\n    <span>}</span>\n\n <span>//native方法，JVM创建并启动线程，并调用run方法</span>\n <span>private</span> <span>native</span> <span>void</span> <span>start0</span><span>(</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br></div></div><h3 id=\"thread-run\"> Thread.run()</h3>\n<div><pre><code><span>@Override</span>\n<span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>target <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n        target<span>.</span><span>run</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>可见, Thread类的run方法中实现的逻辑是如果 target不为null,那么就调用 target. run0,否则它什么也不做。其中,实例变量 target的类型为 Runnable。如果相应的线程实例是通过构造器 Thread(Runnable target)创建的,那么 target的值为构造器中的参数值,否则 target的值为null。因此, Thread类所实现的任务处理逻辑是要么什么也不做( target为nul),\n要么直接执行 target所引用的 Runnable实例所实现的任务处理逻辑。</p>\n<p>Thread类的run方法的这种处理逻辑决定了创建线程的两种方式:</p>\n<ul>\n<li>一种是在 Thread子类的run方法中直接实现任务处理逻辑</li>\n<li>另一种是在一个 Runnable实例中实现任务处理逻辑,该逻辑由 Thread类的run方法负责调用。</li>\n</ul>\n<h2 id=\"线程的属性\"> 线程的属性</h2>\n<p>线程的属性包括线程的</p>\n<ul>\n<li>编号(Id)：不可读写</li>\n<li>名称(Name)：可读写</li>\n<li>线程类别(Daemon)：可读写</li>\n<li>优先级(Priority)：可读写</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>类型</th>\n<th>用途</th>\n<th>只读</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>编号(ID)</td>\n<td>long</td>\n<td>用于标识不同的线程，不同的线程拥有 不同的编号</td>\n<td>是</td>\n<td>某个编号的线程运行结束后，该编号可能被后续创建的线程使用。不同线程  拥有的编号虽然不同，但是这种编号的唯一性只在Java虚拟机的一次运行有  效。也就是说重启个Java虚拟机(如重启Web服务器)后，某些线程的编号可能 与上次Java虚拟机运行的某个线程的编号一样，因此该属性的值不适合用作  某种唯一标识，特别是作为数据库中的唯一标识(如主键)</td>\n</tr>\n<tr>\n<td>名称    (Name)</td>\n<td>String</td>\n<td>用于区分不同的线程，默认值与线程的 编号有关，默认值的格式为:“Thread-  线程编号”，如“Thread-0”</td>\n<td>否</td>\n<td>Java并不禁止我们将不同的线程的名称属性设置为相同的值，尽管如此，设 置线程的名称属性有助于代码调试和问题定位</td>\n</tr>\n<tr>\n<td>线程类别  (Daemon)</td>\n<td>boolean</td>\n<td>值为tnue表示相应的线程为守护线程， 否则表示相应的线程为用户线程。该属性的默认值与相应线程的父线程的该属性的值相同。默认为false。</td>\n<td>否</td>\n<td>该属性必须在相应线程启动之前设置，即对setDaemon方法的调用必须在对start方法的调用之前，否则setDaemon方法会抛出             IllegalThreadStateException异常。负责一些关键任务处理的线程不适宜设 置为守护线程</td>\n</tr>\n<tr>\n<td>优先级   (Priority)</td>\n<td>int</td>\n<td>该属性本质上是给线程调度器的提示， 用于表示应用程序希望哪个线程能够优 先得以运行。Java定义了1~10的10个优 先级，默认值一般为5(表示普通优先级 )。对于具体的一个线程而言，其优先  级的默认值与其父线程(创建该线程的  线程)的优先级值相等。</td>\n<td>否</td>\n<td>一般使用默认优先级即可，不恰当地设置该属性值可能导致严重的问题(线程饥饿)</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"优先级的设定\"> 优先级的设定</h3>\n<p>Java线程的优先级属性本质上只是一个给<code>线程调度器</code>的提示信息，以便于线程调度器决定优先调度哪些线程运行。 它并不能保证线程按照其优先级高低的顺序运行。另外，Java线程的优先级使用不当或者滥用则可能导致某些线程永远无法得到运行， 即产生了<code>线程饥饿(Thread Starvation)</code>。</p>\n<blockquote>\n<p>因此，线程的优先级并不是设置得越高越好； 一般情况下使用普通优先级即可，即不必设置线程的优先级属性。</p>\n</blockquote>\n<h3 id=\"守护线程和用户线程-非守护线程\"> 守护线程和用户线程（非守护线程）</h3>\n<p>按照线程是否会阻止Java虚拟机正常停止,我们可以将Java中的线程分为守护线程( Daemon Thread)和用户线程( User Thread,也称非守护线程)。</p>\n<p>线程的 daemon属性用于表示相应线程是否为守护线程。</p>\n<ul>\n<li>用户线程会阻止Java虚拟机的正常停止,即一个Java虚拟机只有在其所有用户线程都运行结束(即 Thread runo调用未结束)的情况下才能正常停止。</li>\n<li>而守护线程则不会影响Java虚拟机的正常停止,即应用程序中有守护线程在运行也不影响Java虚拟机的正常停止。</li>\n</ul>\n<p>因此,守护线程通常用于执行一些重要性不是很高的任务,例如用于监视其他线程的运行情况。</p>\n<p>如果Java虚拟机是被强制停止的,比如在 Linux系统下使用kill命令强制终止一个Java虚拟机进程,那么即使是用户线程也无法阻止Java虚拟机的停止。</p>\n<h2 id=\"线程的常用方法\"> 线程的常用方法</h2>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>功能</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>static Thread    currentThread()</td>\n<td>返回当前线程，即当前代码的执行线程(对象)</td>\n<td>同一段代码在不同时刻对Thread.currentThread的调用,其返回值可能不同</td>\n</tr>\n<tr>\n<td>void run()</td>\n<td>线程的任务处理逻辑</td>\n<td>该方法是由Java虚拟机直接调用的，一般情况下应用程序不应该调用该方法</td>\n</tr>\n<tr>\n<td>void start()</td>\n<td>启动线程</td>\n<td>该方法的返回并不代表相应的线程已经被启动；一个Thread实例的start方法  只能够被调用一次，多次调用会抛出异常</td>\n</tr>\n<tr>\n<td>void join()</td>\n<td>等待线程运行结束</td>\n<td>线程A调用线程B的join方法，那么线程A的运行会被暂停，直到线程B运行结束</td>\n</tr>\n<tr>\n<td>static void yield()</td>\n<td>使当前线程主动放弃其对处理器的占用，这可能导致当前线程被暂停</td>\n<td>这个方法是不可靠的，该方法被调用时当前线程可能仍然继续运行(视系统当前的运行状况而定)  。会使线程为READY状态</td>\n</tr>\n<tr>\n<td>static void     sleep(long millis)</td>\n<td>使当前线程休眠(暂停运行)指定的时间</td>\n<td></td>\n</tr>\n<tr>\n<td>isAlive()</td>\n<td>判断线程是否处于活动状态</td>\n<td>线程调用start后，即处于活动状态</td>\n</tr>\n<tr>\n<td>interrupt()</td>\n<td>中断线程</td>\n<td>该方法只是把设置当前线程一个属性标记为true，需要用户自己获取然后判断决定接下来的操作</td>\n</tr>\n<tr>\n<td>static interrupted</td>\n<td>自己中断自己</td>\n<td>静态方法，只能自己中断自己</td>\n</tr>\n<tr>\n<td>wait()</td>\n<td>导致线程等待，进入堵塞状态。释放锁。</td>\n<td>该方法要在同步方法或者同步代码块中才使用的</td>\n</tr>\n<tr>\n<td>notify()</td>\n<td>唤醒当前线程，进入运行状态。不释放锁。</td>\n<td>该方法要在同步方法或者同步代码块中才使用的</td>\n</tr>\n<tr>\n<td>notifyAll()</td>\n<td>唤醒所有等待的线程。</td>\n<td>该方法要在同步方法或者同步代码块中才使用的</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"stop-suspend\"> stop&amp;suspend</h3>\n<p>禁用原因</p>\n<ul>\n<li>stop：,是因为它不安全。它会解除由线程获取的所有锁定,而且如果对象处于一 种不连贯状态,那么其他线程能在那种状态下检查和修改它们。结果很难检查出真正的问题 所在</li>\n<li>suspend：suspend()方法容易发生死锁。调用 suspend()的时候,目标线程会停下来,但却仍 然持有在这之前获得的锁定</li>\n</ul>\n<h3 id=\"interrupt-interrupted\"> interrupt&amp;interrupted</h3>\n<ul>\n<li>只是把设置当前线程一个属性标记为true，并不会直接中断，即使抛出异常也会执行完剩下的操作，需要用户自己获取然后判断决定接下来的操作。</li>\n<li>当线程发送中断请求后，sleep()方法抛出了<code>InterruptedException</code>异常，并且将线程的中断状态重置为``false`</li>\n<li>抛出异常是为了线程从阻塞状态醒过来，并在结束线程前让程序员有足够的时间来处理中断请求。</li>\n<li>处于等待的线程，即在执行Object对象的wait()、wait(long)、wait(long, int)，或者线程类的join()、join(long)、join(long, int)、sleep(long)、sleep(long,int)方法后线程的状态，当线程调用interrupt()方法后，会立即退出被阻塞状态，这些方法将抛出<code>InterruptedException</code>异常，并清空线程的中断状态，即<code>isInterrupted()</code>返回false</li>\n<li>在阻塞状态，synchronized在获锁的过程中是不能被中断的，意思是说如果产生了死锁，则不可能被中断（请参考后面的测试例子）。与synchronized功能相似的reentrantLock.lock()方法也是一样，它也不可中断的，即如果发生死锁，那么reentrantLock.lock()方法无法终止，如果调用时被阻塞，则它一直阻塞到它获取到锁为止</li>\n</ul>\n<p>但是如果调用带<code>超时</code>的tryLock方法reentrantLock.tryLock(long timeout, TimeUnit unit)，那么如果线程在等待时被中断，将抛出一个<code>InterruptedException</code>异常，这是一个非常有用的特性，因为它允许程序打破死锁。你也可以调用<code>reentrantLock.lockInterruptibly()</code>方法，在阻塞时可以立即响应<code>interrupt</code>。</p>\n<p><strong>食用方法</strong></p>\n<p>可以通过捕获异常的方式来处理被中断的线程</p>\n<h2 id=\"线程的层次关系\"> 线程的层次关系</h2>\n<h3 id=\"父线程与子线程\"> 父线程与子线程</h3>\n<p>Java平台中的线程不是孤立的，线程与线程之间总是存在一些联系。假设线程A所执行的代码创建了线程B， 那么，习惯上我们称线程B为线程A的子线程，相应地线程A就被称为线程B的父线程。不过Java平台中并没有API用于获取一个线程的父线程， 或者获取一个线程的所有子线程。</p>\n<h3 id=\"父子线程的daemon值\"> 父子线程的Daemon值</h3>\n<p>默认情况下，父线程是守护线程，则子线程也是守护线程，父线程是用户线程，则子线程也是用户线程。 另外，父线程在创建子线程后启动子线程之前可以调用该线程的<code>setDaemon</code>方法，将相应的线程设置为守护线程(或者用户线程)。</p>\n<h3 id=\"父子线程的优先级\"> 父子线程的优先级</h3>\n<p>一个线程的优先级默认值为该线程的父线程的优先级，即如果我们没有设置或者更改一个线程的优先级， 那么这个线程的优先级的值与父线程的优先级的值相等。</p>\n<h3 id=\"父子线程的生命周期\"> 父子线程的生命周期</h3>\n<p>父线程和子线程之间的生命周期也没有必然的联系。比如父线程运行结束后，子线程可以继续运行， 子线程运行结束也不妨碍其父线程继续运行。</p>\n<h3 id=\"工作者线程\"> 工作者线程</h3>\n<p>习惯上，我们也称某些子线程为工作者线程(Worker Thread)或者后台线程(Background Thread)。 工作者线程通常是其父线程创建来用于专门负责某项特定任务的执行的。 例如，Java虚拟机中对内存进行回收的线程通常被称为GC工作者线程。</p>\n<h2 id=\"线程的生命周期状态\"> 线程的生命周期状态</h2>\n<p>Java 线程在运⾏的⽣命周期中的指定时刻只可能处于下⾯ 6 种不同状态的其中⼀个状态（图源《Java 并发编程艺术》4.1.4 节）。</p>\n<p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/Java-MultiThread-1/线程生命周期状态.jpg\" alt=\"线程生命周期状态\" /></p>\n<p>线程在⽣命周期中并不是固定处于某⼀个状态⽽是随着代码的执⾏在不同状态之间切换。Java 线程状 态变迁如下图所示（图源《Java 并发编程艺术》4.1.4 节）：</p>\n<p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/Java-MultiThread-1/线程生命周期状态2.jpg\" alt=\"线程生命周期状态2\" /></p>\n<p>由上图可以看出：线程创建之后它将处于 <strong>NEW（新建） 状态</strong>，<strong>调⽤ start() ⽅法后开始运⾏</strong>，线程 这时候处于 <strong>READY（可运⾏） 状态</strong>。可运⾏状态的线程获得了 **CPU 时间⽚（timeslice）**后就处于 <strong>RUNNING（运⾏）</strong> 状态。</p>\n<h3 id=\"new\"> NEW</h3>\n<p>一个已创建而未启动的线程处于该状态。由于一个线程实例只能够被启动次，因此一个线程只可能有一次处于该状态。</p>\n<h3 id=\"runnable\"> RUNNABLE</h3>\n<p>该状态可以被看成一个复合状态，它包括两个子状态：<code>READY</code>和<code>RUNNING</code>。 前者表示处于该状态的线程可以被<code>线程调度器(Scheduler)</code>进行调度而使之处于<code>RUNNING</code>状态； 后者表示处于该状态的线程正在运行，即相应线程对象的run方法所对应的指令正在由处理器执行。 执行<code>Thread.yield()</code>的线程，其状态可能会由<code>RUNNING</code>转换为<code>READY</code>。处于<code>READY</code>子状态的线程也被称为活跃线程。</p>\n<h3 id=\"blocked\"> BLOCKED</h3>\n<p>一个线程发起一个阻塞式I/O(Blocking I/O)操作后，或者申请一个由其他线程持有的独占资源(比如锁)时，相应的线程会处于该状态， 处于Blocked状态的线程并不会占用处理器资源。当阻塞式1O操作完成后，或者线程获得了其申请的资源， 该线程的状态又可以转换为RUNNABLE。</p>\n<h3 id=\"waiting\"> WAITING</h3>\n<p>一个线程执行了某些特定方法之后，就会处于这种等待其他线程执行另外一些特定操作的状态。 能够使其<code>执行线程</code>变更为WAITING状态的方法包括：Object.wait()、Thread.join()和LockSupport.park(Object)。 能够使相应线程从WAITING变更为RUNNABLE的对应方法包括：Object.notify()、notifyAll()和LockSupport.unpark(Objec)</p>\n<h3 id=\"timed-waiting\"> TIMED WAITING</h3>\n<p>该状态和WAITING类似，差别在于处于该状态的线程并非无限制地等待其他线程执行特定操作，而是处于带有时间限制的等待状态。 当其他线程没有在指定时间内执行该线程所期望的特定操作时，该线程的状态自动转换为RUNNABLE。</p>\n<h3 id=\"terminated\"> TERMINATED</h3>\n<p>已经执行结束的线程处于该状态。由于一个线程实例只能够被启动一次，因此一个线程也只可能有一次处于该状态。 Thread.run()正常返回或者由于抛出异常而提前终止都会导致相应线程处于该状态。</p>\n<p>当线程执⾏ wait() ⽅法之后，线程进⼊ WAITING（等待） 状态。进⼊等待状态的线程需要依靠其他 线程的通知才能够返回到运⾏状态，⽽ TIME_WAITING(超时等待) 状态相当于在等待状态的基础上增加 了超时限制，⽐如通过 sleep（long millis） ⽅法或 wait（long millis） ⽅法可以将 Java 线程置于 TIMED WAITING 状态。当超时时间到达后 Java 线程将会返回到 RUNNABLE 状态。当线程调 ⽤同步⽅法时，在没有获取到锁的情况下，线程将会进⼊到 BLOCKED（阻塞） 状态。线程在执⾏ Runnable 的 run() ⽅法之后将会进⼊到 TERMINATED（终⽌） 状态。</p>\n<h2 id=\"线程的监视\"> 线程的监视</h2>\n<p>真实的Java系统运行时往往有上百个线程在运行,如果没有相应的工具能够对这 些线程进行监视,那么这些线程对于我们来说就成了黑盒。而我们在开发过程中进行代码 调试、定位问题甚至是定位线上环境(生产环境)中的问题时往往都需要将线程变为白盒, 即我们要能够知道系统中特定时刻存在哪些线程、这些线程处于什么状态以及这些线程具 体是在做什么事情这些信息。</p>\n<p>对线程进行监视的主要途径是获取并查看程序的<code>线程转储( Thread Dump)</code>一个程序 的线程转储包含了获取这个线程转储的那一刻该程序的线程信息。这些信息包括程序中有 哪些线程以及这些线程的具体信息。Java程序的线程转储(如图14所示)包含的线程具 体信息包括线程的属性(ID、名称、优先级等)、生命周期状态、线程的调用栈( Call stack) 以及锁(第3章会介绍这个概念)的相关信息等。通过查看调用栈我们就能够了解线程的 执行情况(具体在干些什么)。</p>\n<p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/Java-MultiThread-1/线程转储示例.png\" alt=\"线程转储示例\" /></p>\n<h3 id=\"获取方法\"> 获取方法</h3>\n<p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/Java-MultiThread-1/获取线程转储方法.png\" alt=\"获取线程转储方法\" /></p>\n<h3 id=\"jmc\"> JMC</h3>\n<p>JMC打开性能日志后，主要包括7部分性能报告，分别是一般信息、内存、代码、线程、I/O、系统、事件。其中，内存、代码、线程及I/O是系统分析的主要部分</p>\n<p>参考</p>\n<blockquote>\n<p><a href=\"https://www.cnblogs.com/duanxz/p/8533174.html\" target=\"_blank\" rel=\"noopener noreferrer\">Java性能调优：利用JMC分析性能</a></p>\n</blockquote>\n<h2 id=\"多线程编程\"> 多线程编程</h2>\n<h3 id=\"好处坏处\"> 好处坏处</h3>\n<p>好处</p>\n<ol>\n<li>提高系统的吞吐率</li>\n<li>提高响应性</li>\n<li>充分利用多核处理器资源</li>\n<li>最小化对系统资源的使用</li>\n<li>简化程序的结构</li>\n</ol>\n<p>坏处</p>\n<ol>\n<li>线程安全</li>\n<li>线程活性\n<ol>\n<li>死锁</li>\n<li>活锁：一个线程一直在尝试某个操作但就是没有进展</li>\n</ol>\n</li>\n<li>上下文切换\n<ol>\n<li>这是属于额外的资源消耗</li>\n</ol>\n</li>\n<li>可靠性</li>\n</ol>\n<h2 id=\"串行-并发-并行\"> 串行 | 并发 | 并行</h2>\n<p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/Java-MultiThread-1/串行|并发|并行.jpg\" alt=\"串行,并发和并行\" /></p>\n<h3 id=\"串行-sequential\"> 串行(Sequential)</h3>\n<p>先开始做事情A，待其完成之后再开始做事情B，依次类推，直到事情C完成。这实际上顺序逐一完成几件事情，只需要投入一个人。 在这种方式下3件事情总共耗时35(15+10+10)分钟。</p>\n<h3 id=\"并发-concurrent\"> 并发(Concurrent)</h3>\n<p>这种方式也可以只投入一个人，这个人先开始做事情A，事情A的准备活动做好后(此时消耗了5分钟)， 在等待事情A完成的这段时间内他开始做事情B，为事情B的准备活动花了2分钟之后，在等待事情B完成的这段时间内他开始做事情C， 直到10分钟之后事情C完成。这整个过程实际上是以交替的方式利用等待某件事情完成的时间来做其他事情， 在这种方式下3件事情总共耗时17(5+2+10)分钟，这比串行方式节约了一半多的时间。</p>\n<h3 id=\"并行-parallel\"> 并行(Parallel)</h3>\n<p>这种方式需要投入3个人，每个人负责完成其中一件事情，这3个人在同一时刻开始齐头并进地完成这些事情。 在这种方式下3件事情总共耗时15分钟(取决于耗时最长的那件事情所需的时间)，比并发的方式节约了2分钟的时间。</p>\n<h2 id=\"竞态\"> 竞态</h2>\n<p>竞态是指<code>计算的正确性</code>依赖于<code>相对时间顺序</code>或者<code>线程的交错</code>。竞态往往伴随着读取脏数据问题(即读取到一个过时的数据)， 以及丢失更新问题(即一个线程对数据所做的更新没有体现在后续其他线程对该数据的读取上)。</p>\n<blockquote>\n<p>竞态不一定就导致计算结果的不正确,它只是不排除计算结果时而正确时而错误的可能。</p>\n</blockquote>\n<h3 id=\"举例\"> 举例</h3>\n<div><pre><code><span>public</span> <span>class</span> <span>Main</span> <span>{</span>\n    <span>static</span> <span>class</span> <span>IndexGen</span> <span>{</span>\n        <span>private</span> <span>int</span> index<span>;</span>\n \n        <span>int</span> <span>nextIndex</span><span>(</span><span>)</span> <span>{</span>\n            <span>return</span> index<span>++</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n \n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>InterruptedException</span> <span>{</span>\n        <span>IndexGen</span> indexGen <span>=</span> <span>new</span> <span>IndexGen</span><span>(</span><span>)</span><span>;</span>\n        <span>final</span> <span>int</span> num <span>=</span> <span>100</span><span>;</span>\n        <span>final</span> <span>int</span><span>[</span><span>]</span> visited <span>=</span> <span>new</span> <span>int</span><span>[</span>num<span>]</span><span>;</span>\n        <span>final</span> <span>List</span><span><span>&lt;</span><span>Thread</span><span>></span></span> threads <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> num<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n            threads<span>.</span><span>add</span><span>(</span><span>new</span> <span>Thread</span><span>(</span><span>(</span><span>)</span> <span>-></span> visited<span>[</span>indexGen<span>.</span><span>nextIndex</span><span>(</span><span>)</span><span>]</span> <span>++</span><span>)</span><span>)</span><span>;</span>\n        <span>}</span>\n        threads<span>.</span><span>forEach</span><span>(</span><span>Thread</span><span>::</span><span>start</span><span>)</span><span>;</span>\n        <span>for</span> <span>(</span><span>Thread</span> thread <span>:</span> threads<span>)</span> <span>{</span>\n            thread<span>.</span><span>join</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>10</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>\n            <span>for</span> <span>(</span><span>int</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> <span>10</span><span>;</span> j<span>++</span><span>)</span> <span>{</span>\n                <span>System</span><span>.</span>out<span>.</span><span>printf</span><span>(</span><span>\"%d\\t\"</span><span>,</span> visited<span>[</span>i <span>*</span> <span>10</span> <span>+</span> j<span>]</span><span>)</span><span>;</span>\n            <span>}</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><p>参考上述程序，我们创建一百个线程，每次通过IndexGen获取下一个index，并将其访问次数加一。我们期望的结果是每个index都只被访问一次， 但多次运行后，却发现可能出现下面的结果，其中，0,62,85被访问了两次，导致97,98,99未被访问：</p>\n<div><pre><code>2\t1\t1\t1\t1\t1\t1\t1\t1\t1\t\n1\t1\t1\t1\t1\t1\t1\t1\t1\t1\t\n1\t1\t1\t1\t1\t1\t1\t1\t1\t1\t\n1\t1\t1\t1\t1\t1\t1\t1\t1\t1\t\n1\t1\t1\t1\t1\t1\t1\t1\t1\t1\t\n1\t1\t2\t1\t1\t1\t1\t1\t1\t1\t\n1\t1\t1\t1\t1\t1\t1\t1\t1\t1\t\n1\t1\t1\t1\t1\t2\t1\t1\t1\t1\t\n1\t1\t1\t1\t1\t1\t1\t1\t1\t1\t\n1\t1\t1\t1\t1\t1\t1\t0\t0\t0\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>上述例子中，依照nextIndex()方法实现的逻辑，下标总是递增的，因此不同的线程它们所“拿到”的index也不应该相同才对。 但从结果来看，不同线程却“拿到”了重复的index，即nextIndex()所返回的下标值重复了。且如果我们多次重复运行代码，所得到的结果也不完全相同。</p>\n<p><strong>这个现象说明，当多个线程在没有采取任何控制措施的情况下并发地更新、读取同一个共享变量时，是不安全的，可能出现意料之外的结果。</strong></p>\n<h3 id=\"原因\"> 原因</h3>\n<p>上述例子中的 <code>index++</code> 看起来像是一个操作，实际上相当于如下3个指令：</p>\n<div><pre><code><span>//指令①:将变量index的值从内存读到寄存器r1</span>\n<span>load</span><span>(</span>index<span>,</span>r1<span>)</span><span>;</span>\n<span>//指令②:将寄存器r1的值增加1</span>\n<span>increment</span><span>(</span>r1<span>)</span><span>;</span>\n<span>//指令③:将奇存器r1的内容写入变量index所对应的内存空间</span>\n<span>store</span><span>(</span>index<span>,</span>r1<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><table>\n<thead>\n<tr>\n<th style=\"text-align:left\"></th>\n<th style=\"text-align:left\">thread-0</th>\n<th style=\"text-align:left\">thread-1</th>\n<th style=\"text-align:left\">thread-2</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">t1</td>\n<td style=\"text-align:left\">未运行</td>\n<td style=\"text-align:left\">执行其他操作</td>\n<td style=\"text-align:left\">执行其他操作</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">t2</td>\n<td style=\"text-align:left\">执行其他操作</td>\n<td style=\"text-align:left\">[index=0]执行指令①</td>\n<td style=\"text-align:left\">[index=0]执行指令①</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">t3</td>\n<td style=\"text-align:left\">执行其他操作</td>\n<td style=\"text-align:left\">[r1=0]执行指令②</td>\n<td style=\"text-align:left\">[r1=0]执行指令②</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">t4</td>\n<td style=\"text-align:left\">[index=0]执行指令①</td>\n<td style=\"text-align:left\">[r1=1][index=0]执行指令③</td>\n<td style=\"text-align:left\">[r1=1][index=0]执行指令③</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">t5</td>\n<td style=\"text-align:left\">[r1=0]执行指令②</td>\n<td style=\"text-align:left\">[index=1]执行其他操作</td>\n<td style=\"text-align:left\">[index=1]执行其他操作</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">t6</td>\n<td style=\"text-align:left\">[r1=1][index=0]执行指令③</td>\n<td style=\"text-align:left\">运行结束</td>\n<td style=\"text-align:left\">运行结束</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">t7</td>\n<td style=\"text-align:left\">[index=1]执行其他操作</td>\n<td style=\"text-align:left\">运行结束</td>\n<td style=\"text-align:left\">运行结束</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"竞态的模式-条件\"> 竞态的模式/条件</h3>\n<p>从上述竞态典型实例中我们可以提炼出竞态的两种模式</p>\n<div><p>Info</p>\n<ul>\n<li><strong>read-modify-write(读-改-写)</strong>：读取个共享变量的值(read)，然后根据该值做一些计算(modify)，接着更新该共享变量的值(write)</li>\n<li><strong>check-then-act(检测-执行)</strong>：读取(read)某个共享变量的值，根据该变量的值(如if语句)决定下一步的动作(act)是什么。</li>\n</ul>\n</div>\n<p>从上述分析中我们可以总结出竞态产生的一般条件。设O1和O2是并发访问共享变量V的两个操作,这两个操作并非都是读操作。如果一个线程在执行O1期间(开始执行而未执行结束)另外一个线程正在执行O2,<strong>那么无论O2是在读取还是更新V都会导致竞态</strong>。</p>\n<p>从这个角度来看,竞态可以被看作访问(读取、更新)同一组共享变量的多个线程所执行的操作相互交错( Interleave),此如一个线程读取共享变量并以该共享变量为基础进行计算</p>\n<blockquote>\n<p>对于方法中的局部变量，由于方法栈是线程私有，不会产生竞态</p>\n</blockquote>\n<h2 id=\"线程安全性\"> 线程安全性</h2>\n<p>一般而言，如果一个类在单线程环境下能够运作正常，并且在多线程环境下，如果使用方不必做任何改变的情况下也能运作正常， 那么我们就称其是线程安全的，相应地我们称这个类具有线程安全性。</p>\n<p>线程安全问题包括三个方面</p>\n<div><p>Info</p>\n<ul>\n<li><strong>原⼦性</strong> : ⼀个的操作或者多次操作，要么所有的操作全部都得到执⾏并且不会收到任何因素的 ⼲扰⽽中断，要么所有的操作都执⾏，要么都不执⾏。 <strong>synchronized 可以保证代码⽚段的原⼦性。</strong></li>\n<li><strong>可⻅性</strong> ：当⼀个变量对共享变量进⾏了修改，那么另外的线程都是⽴即可以看到修改后的最新值。 <strong>volatile 关键字可以保证共享变量的可⻅性。</strong></li>\n<li><strong>有序性</strong> ：代码在执⾏的过程中的先后顺序，Java 在编译器以及运⾏期间的优化，代码的执⾏顺序未必就是编写代码时候的顺序。 <strong>volatile 关键字可以禁⽌指令进⾏重排序优化。</strong></li>\n</ul>\n</div>\n<h3 id=\"三大特性-原子性-automicity\"> 三大特性：原子性（Automicity）</h3>\n<p>原子的字面意思是不可分割的。对于涉及共享变量访问的操作，若该操作从其执行线程以外的任意线程来看是不可分割的， 那么该操作就是原子操作，相应地我们称该操作具有原子性。</p>\n<p>许多资料都会提及原子操作的定义中的“不可分割”,但是很少有资料会对其含义做 进一步的解释。而弄清楚“不可分割”的具体含义是理解原子性的关键所在。所谓“不可 分割”,其中一个含义是指访问(读、写)某个共享变量的操作从其执行线程以外的任何 线程来看,该操作要么<code>已经执行结束</code>要么<code>尚未发生</code>,即其他线程不会“看到”该操作执行 了部分的中间效果。</p>\n<blockquote>\n<p>原子性只有在操作<code>共享变量</code>或<code>多线程</code>的情况下才有意义</p>\n</blockquote>\n<h4 id=\"实现方式\"> 实现方式</h4>\n<p>总的来说，Java中有两种方式来实现原子性：<code>锁(Lock)</code>和<code>CAS(Compare-And-Swap)</code>指令。</p>\n<p><strong>锁（Lock）</strong></p>\n<div><p>Info</p>\n<p>锁具有<code>排他性</code>，即它能够保障一个共享变量在任意一个时刻只能够被一个线程访问， 这就排除了多个线程在同一时刻访问同一个共享变量而导致干扰与冲突的可能，即消除了竞态。</p>\n</div>\n<p><strong>CAS</strong></p>\n<div><p>Info</p>\n<p>CAS指令实现原子性的方式与锁实现原子性的方式实质上是相同的，差别在于<code>锁</code>通常是在<code>软件</code>这一层次实现的， 而<code>CAS</code>是直接在<code>硬件（处理器和内存）</code>这一层次实现的，它可以被看作<code>“硬件锁”</code>。</p>\n</div>\n<h4 id=\"基本数据类型原子性\"> 基本数据类型原子性</h4>\n<p>在Java语言中，<code>long</code>型和<code>double</code>型以外的任何类型的变量的写操作都是原子操作，包括：byte、boolean、short、char、foat、int和引用型变量，long和double的读写是<code>分开两个32位操作</code>的，不保证原子性，</p>\n<p>对long/double型变量的写操作由于Java语言规范并不保障其具有原子性，因此在多个线程并发访问同一long/double型变量的情况下， 一个线程可能会读取到其他线程更新该变量的“中间结果”。这是因为Java中的long/double型变量会占用64位的存储空间， 而32位的Java虚拟机对这种变量的写操作可能会被分解为两个步骤来实施，比如先写低32位，再写高32位。 那么，在多个线程试图共享同一个这样的变量时就可能出现一个线程在写高32位的时候，另外一个线程正在写低32位的情形。</p>\n<p>Java语言中针对任何变趾的读操作都是原子操作。</p>\n<h3 id=\"三大特性-可见性-visibility\"> 三大特性：可见性（Visibility）</h3>\n<p>在多线程环境下，一个线程对某个共享变量进行更新之后，后续访问该变量的线程可能无法立刻读取到这个更新的结果， 甚至永远也无法读取到这个更新的结果。</p>\n<p>如果一个线程对某个共享变量进行更新之后，后续访问该变量的线程可以读取到该更新的结果， 那么我们就称这个线程对该共享变量的更新对其他线程可见，否则我们就称这个线程对该共享变量的更新对其他线程不可见。</p>\n<p>多线程程序在可见性方面存在问题意味着某些线程读取到了旧数据(Stale Data)，而这可能导致程序出现我们所不期望的结果。</p>\n<h4 id=\"寄存器和高速缓存带导致的不可见\"> 寄存器和高速缓存带导致的不可见</h4>\n<p>程序中的变量可能会被分配到<code>寄存器(Register)</code>而不是<code>主内存</code>中进行存储，每个<code>处理器</code>都有其自己的<code>寄存器</code>， 而一个<code>处理器</code>无法读取另外一个<code>处理器</code>上的<code>寄存器</code>中的内容。因此，如果<code>两个线程</code>分别运行在不同的<code>处理器</code>上， 且这两个线程所共享的变量却被分配到寄存器上进行存储，那么可见性问题就会产生。</p>\n<p>另外，即便某个<code>共享变量</code>是被分配到<code>主内存</code>中进行存储的，也不能保证该变量的可见性。这是因为处理器对主内存的访问<code>并不是直接访问</code>， 而是通过其<code>高速缓存（cache）子系统</code>进行的。一个处理器上运行的线程对变量的更新可能只是更新到该处理器的<code>写缓冲器</code>中，还没有到达该处理器的<code>高速缓存</code>中， 更不用说到<code>主内存</code>中了。而一个处理器的<code>写缓冲器</code>中的内容无法被另外一个<code>处理器</code>读取， 因此运行在另外一个处理器上的线程无法看到这个线程对某个共享变量的更新。及时通知了，其他处理器可能仅仅将该更新加入到<code>无效化队列</code>中去</p>\n<blockquote>\n<p>处理器并不是直接与主内存(RAM)打交道而执行内存的读、写操作,而是通过 寄存器( Register)、高速缓存( Cache)写缓冲器( Store Buffer,也称 Write Buffer) 和无效化队列( Invalidate Queue)等部件执行内存的读、写操作的。从这个角度来看, 这些部件相当于主内存的副本,因此本书为了叙述方便将这些部件统称为处理器对主 内存的缓存,简称处理器缓存。</p>\n</blockquote>\n<p><strong>解决方案</strong></p>\n<p><code>缓存一致性协议(Cache Coherence Protocol)</code></p>\n<p>通过缓存一致性协议可以让一个处理器来读取其他处理器的<code>高速缓存</code>中的数据，并将读到的数据更新到该处理器的<code>高速缓存</code>中。这种一个处理器从其自身处理器缓存以外的其他存储部件中读取数据， 并将其更新到该处理器的高速缓存的过程，我们称之为<code>缓存同步</code>。相应地，我们称这些存储部件的内容是可同步的， 可同步的存储部件包括处理器的高速缓存、主内存。</p>\n<p><code>冲刷处理器缓存</code>（更新后）</p>\n<p>为了保障可见性，我们必须使一个<code>处理器</code>对<code>共享变量</code>所做的更新最终被写入该处理器的高速缓存或者主内存中,而不是始终停留在其写缓冲器中，这个过程被称为<code>冲刷处理器缓存</code>。</p>\n<p><code>刷新处理器缓存</code>（读取时）</p>\n<p>同样，为了保障可见性，一个<code>处理器</code>在读取<code>共享变量</code>的时候，如果其他处理器在此之前已经更新了该变量，那么该处理器必须从其他处理器的高速缓存或者主内存中，对相应的变量进行<code>缓存同步</code>，这个过程被称为<code>刷新处理器缓存</code>。</p>\n<h4 id=\"jit优化导致的不可见\"> JIT优化导致的不可见</h4>\n<div><pre><code><span>public</span> <span>class</span> <span>Main</span> <span>{</span>\n    <span>static</span> <span>/**volatile**/</span> <span>boolean</span> isCanceled <span>=</span> <span>false</span><span>;</span>\n \n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>InterruptedException</span> <span>{</span>\n        <span>new</span> <span>Thread</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>{</span>\n            <span>while</span> <span>(</span><span>!</span>isCanceled<span>)</span> <span>{</span>\n                <span>// System.out.println(\"hello\");</span>\n            <span>}</span>\n        <span>}</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"come here\"</span><span>)</span><span>;</span>\n        <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>1000</span><span>)</span><span>;</span>\n        isCanceled <span>=</span> <span>true</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>JIT为了优化避免重复读取<code>Canceled</code>的值，会将代码优化为与如下代码等效果的机器码：</p>\n<div><pre><code><span>if</span> <span>(</span><span>!</span>isCanceled<span>)</span> <span>{</span>\n    <span>while</span><span>(</span><span>true</span><span>)</span><span>{</span>\n        <span>// System.out.println(\"hello\");</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h4 id=\"作用\"> 作用</h4>\n<p><code>volatile</code>该关键字所起到的一个作用就是提示JIT编译器被修饰的变量可能被多个线程共享，以阻止JT编译器做出可能导致程序运行<code>不正常的优化</code>；另外一个作用就是读取一个volatile关键字修饰的变量会使相应的处理器执行刷新处理器缓存的动作， 写个 volatile关键字修饰的变量会使相应的处理器执行冲刷处理器缓存的动作，从而保障了可见性。</p>\n<h4 id=\"jvm的可见性保证\"> JVM的可见性保证</h4>\n<ul>\n<li>Java语言规范保证，父线程在启动子线程之前对共享变量的更新对于子线程来说是可见的</li>\n<li>Java语言规范保证，一个线程终止后，该线程对共享变量的更新对于调用该线程的<code>join</code>方法的线程而言是可见的</li>\n</ul>\n<h4 id=\"其他问题\"> 其他问题</h4>\n<ol>\n<li>\n<p>可见性得以保障，并不意味着一个线程能够看到另外一个线程更新的所有变量的值。如果一个线程在某个时刻更新了<code>多个共享变量的值</code>， 那么此后其他线程再来读取这些变量时，这些线程所读取到的变量值有些是其他线程更新过的值，而有些则可能仍然是其他线程更新之前的值（旧值）。</p>\n</li>\n<li>\n<p>另一方面，可见性的保障仅仅意味着一个线程能够读取到共享变量的<code>相对新值</code>，而不能保障该线程能够读取到相应变量的<code>最新值</code>。</p>\n</li>\n</ol>\n<p>相对新值</p>\n<blockquote>\n<p>对于一个共享变量而言，一个线程更新了该变量的值之后，其他线程能够读取到这个更新后的值，那么这个值就被称为该变量的相对新值。</p>\n</blockquote>\n<p>最新值</p>\n<blockquote>\n<p>如果读取共享变量的线程，在读取并使用该变量的时候其他线程无法更新该变量的值，那么该线程读取到的相对新值就被称为该变量的最新值。</p>\n</blockquote>\n<ol start=\"3\">\n<li>可见性问题是多线程衍生出来的问题，它与程序的目标运行环境是单核处理器还是多核处理器无关。 也就是说，单处理器系统中实现的多线程编程也可能出现可见性问题：在目标运行环境是单处理器的情况下， 多线程的并发执行实际上是通过时间片分配实现的。此时，虽然多个线程是运行在同一个处理器上的， 但是由于在发生上下文切換的时候，一个线程对寄存器变量的修改会被作为该线程的线程上下文保存起来， 这导致另外一个线程无法“看到”该线程对这个变量的修政，因此，单处理器系统中实现的多线程编程也可能出现可见性问题。</li>\n</ol>\n<h3 id=\"三大特性-有序性-ordering\"> 三大特性：有序性（Ordering）</h3>\n<h4 id=\"重排序\"> 重排序</h4>\n<p>重排序(Reordering)</p>\n<p>在多核处理器的环境下，代码的执行顺序可能是没有保障的：编译器可能改变两个操作的先后顺序； 工处理器可能不是完全依照程序的目标代码所指定的顺序执行指令；</p>\n<p>另外，在一个处理器上执行的多个操作， 从其他处理器的角度来看其顺序可能与目标代码所指定的顺序不一致。这种现象就叫作重排序。</p>\n<p>重排序是对<code>内存访问有关</code>的操作（读和写）所做的一种<code>优化</code>，它可以在<code>不影响单线程程序正确性</code>的情况下提升程序的性能。 但是，它可能对<code>多线程程序的正确性</code>产生影响，即它可能导致<code>线程安全问题</code>。</p>\n<h4 id=\"排序顺序\"> 排序顺序</h4>\n<div><p>Info</p>\n<ul>\n<li>\n<p><strong>源代码顺序</strong></p>\n<p>源代码中所指定的内存访问操作顺序。</p>\n</li>\n<li>\n<p><strong>程序顺序</strong></p>\n<p>在给定处理器上运行的目标代码所指定的内存访问操作顺序。尽管Java虚拟机执行代码有两种方式： 解释执行（被执行的是字节码）和编译执行（被执行的是机器码），里的目标代码是指字节码。</p>\n</li>\n<li>\n<p><strong>执行顺序</strong></p>\n<p>内存访问操作在给定处理器上的<code>实际执行顺序</code>。</p>\n</li>\n<li>\n<p><strong>感知顺序</strong></p>\n<p>给定处理器所感知到（看到）的该处理器及其他处理器的内存访问操作发生的顺序。</p>\n</li>\n</ul>\n</div>\n<p>在此基础上，我们可以将重排序可以分为两类：<code>指令重排序</code>和<code>存储子系统重排序</code>。</p>\n<table>\n<thead>\n<tr>\n<th>重排序类型</th>\n<th>重排序表现</th>\n<th>重排序来源</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>指令重排序</td>\n<td>程序顺序与源代码顺序不一致</td>\n<td>JIT编译器</td>\n</tr>\n<tr>\n<td></td>\n<td>执行顺序与程序顺序不一致</td>\n<td>JIT编译器、处理器</td>\n</tr>\n<tr>\n<td>存储子系统重排序</td>\n<td>源代码顺序、程序顺序和执行顺序这三者保持一致,但是感知顺序与执行顺序不一致</td>\n<td>高速缓存、写缓冲器</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"指令重排序\"> 指令重排序</h4>\n<p>在<code>源代码顺序</code>与<code>程序顺序</code>不一致，或者<code>程序顺序</code>与<code>执行顺序</code>不一致的情况下，我们就说发生了指令重排序。 指令重排序是一种动作，它<code>确确实实</code>地对指令的顺序做了调整，其重排序的对象是<code>指令</code>。</p>\n<blockquote>\n<p>Java平台包含两种编译器:<code>静态编译器(Javac)</code>和<code>动态编译器(JIT编译器)</code>，</p>\n<ul>\n<li><strong>静态编译器(Javac)</strong>：是将Java源代码(java文本文件)编译为字节码(. class二进制文件),它 是在代码编译阶段介入的。</li>\n<li><strong>动态编译器(JIT编译器)</strong>：是将字节码动态编译为Java虚拟机宿主机的本地代码(机器码,它是在Java程序运行过程中介入的。</li>\n</ul>\n<p>**静态编译器(Javac)<strong>基本不会指令重排序，而</strong>动态编译器(JIT编译器)**则可能。</p>\n</blockquote>\n<p><strong>特征</strong></p>\n<ol>\n<li><strong>重排序可能导致线程安全问题</strong>：在本Demo中，重排序使得sum方法的返回值可能既不是-1(此时helper实例为null)，也不是4。 当然，这并不表示重排序本身是错误的，而是说我们的程序本身有问题──我们的程序没有使用或者没有正确地使用线程同步机制。</li>\n<li><strong>重排序不是必然出现的</strong>：本Demo运行时重复调用createHelper和sum共200000次才出现7次重排序，比率为0.035%。</li>\n</ol>\n<h4 id=\"处理器乱序执行\"> 处理器乱序执行</h4>\n<p>处理器也可能执行指令重排序，这使得执行顺序与程序顺序不一致。这是因为现代处理器为了提高指令执行效率， 往往不是按照程序顺序逐一执行指令的，而是动态调整指令的顺序，做到哪条指令就绪就先执行哪条指令， 这就是处理器处理器对指令进行的重排序，也被称为<code>处理器的乱序执行</code>。</p>\n<p><strong>乱序执行的机制</strong>\n在乱序执行的处理器中，指令是一条一条按照程序顺序被处理器读取的（即“顺序读取”）， 然后这些指令中哪条就绪了哪条就会先被执行，而不是完全按照程序顺序执行（即“乱序执行”）。 这些指令执行的结果会被先存入重排序缓冲器，而不是直接被写入寄存器或者主内存。 重排序缓冲器会将各个指令的执行结果按照相应指令被处理器读取的顺序提交到寄存器或者内存中去(即“顺序提交”)。 在乱序执行的情况下，尽管指令的执行顺序可能没有完全依照程序顺序， 但是由于指令的执行结果的提交（即反映到寄存器和内存中）仍然是按照程序顺序来的， 因此处理器的指令重排序并不会对单线程程序的正确性产生影响。</p>\n<p><strong>猜测执行(Speculation)</strong>\n猜测执行技术就好比没有卫星导航时代在陌生地方开车遇到岔路口的情形： 虽然我们不确定其中哪条路能够通往目的地，但是我们可以凭猜测走其中一条路， 万一猜错了（前路不通）可以掉头重新走另外一条路。</p>\n<p>猜测执行能够造if语句的语句体先于其条件语句被执行的效果，即先执行if语句块中结果再去判断if条件，如果if条件不通过直接丢弃结果，否则写入内存中，从而可能导致指令重排序现象。</p>\n<h4 id=\"存储子系统重排序\"> 存储子系统重排序</h4>\n<ol>\n<li>\n<p>存储子系统\n主内存(RAM)相对于处理器是一个慢速设备，为了避免其拖后腿，处理器并不是直接访问主内存， 而是通过<code>高速缓存</code>访问主内存的。在此基础上，现代处理器还引人了<code>写缓冲器(Store Buffer，也称Write Buffer)</code>， 以提高写高速缓存操作的效率。有的处理器(如Intel的x86处理器)对所有的写主内存的操作都是通过写缓冲器进行的。 这里，我们将<code>写缓冲器</code>和<code>高速缓存</code>统称为<code>存储子系统</code>。需要注意的是，存储子系统并不是内存的子系统，而是处理器的子系统。</p>\n</li>\n<li>\n<p>内存重排序(Memory Ordering)\n即使在处理器严格依照程序顺序执行两个内存访问操作的情况下， 在<code>存储子系统</code>的作用下，其他处理器对这两个操作的感知顺序仍然可能与程序顺序不一致， 即这两个操作的执行顺序看起来像是发生了变化。这种现象就是存储子系统重排序，也被称为内存重排序。</p>\n</li>\n<li>\n<p>与指令重排序的区别\n指令重排序的重排序对象是<code>指令</code>，它实实在在地对指令的顺序进行调整， 而存储子系统重排序是一种<code>现象</code>而不是一种动作，<strong>它并没有真正对指令执行顺序进行调整</strong>， 而只是造成了一种指令的执行顺序像是被调整过一样的现象，其重排序的对象是<code>内存操作的结果</code>。</p>\n</li>\n<li>\n<p>指令重排序的类型\n从处理器的角度来说，读内存操作的实质，是从指定的RAM地址(通过高速缓存)加载数据到寄存器， 因此读内存操作通常被称为Load操作；写内存操作的实质， 是将数据(指令中的操作数或寄存器中的值)存储到指定地址表示的RAM存储单元中，因此写内存操作通常被称为Store。 这样，我们可以把内存重排序分为以下4种。</p>\n</li>\n</ol>\n<h4 id=\"貌似串行语义-as-if-serial-semantics\"> 貌似串行语义(As-if-serial Semantics)</h4>\n<p>定义\n重排序并非随意地对指令、内存操作的结果进行杂乱无章的排序或者顺序调整，而是遵循一定的规则。 编译器（主要是JIT编译器）、处理器（包括其存储子系统）都会遵守这些规则， 从而给单线程程序创造一种假象──指令是按照源代码顺序执行的。这种假象就被称为<code>貌似串行语义</code>。 貌似串行语义只是从<strong>单线程程序的角度</strong>保证重排序后的运行结果不影响程序的正确性，它并不保证多线程环境下程序的正确性。</p>\n<p><strong>数据依赖关系(Data Dependency)</strong></p>\n<div><p>Info</p>\n<p>为了保证貌似串行语义，<strong>存在数据依赖关系的语句不会被重排序，只有不存在数据依赖关系的语句才会被重排序</strong>。 如果两个操作(指令)访问同一个变量(地址)，且其中一个操作(指令)为写操作， 那么这两个操作之间就存在数据依赖关系，这些操作包括：写后读(WAR)、读后写(RAW)、写后写(WAW)三种操作。</p>\n</div>\n<p><strong>控制依赖关系(Control Dependency)</strong></p>\n<div><p>Info</p>\n<p>如果一条语句（指令）的执行结果会决定另外一条语句（指令）能否被执行， 那么这两条语句（指令）之间就存在控制依赖关系。存在控制依赖关系的语句是可以允许被重排序的， 存在控制依赖关系的语句最典型的就是if语句中的条件表达式和相应的语句体。 允许这种重排序意味着处理器可能先执行f语句体所涉及的内存访问操作，然后再执行相应的条件判断。 允许对存在控制依赖关系的语句进行重排序同样也是出于性能考虑， 这是因为存在控制依赖关系的语句(如if语句)会影响处理器对指令序列执行的并行程度。</p>\n</div>\n<h4 id=\"保障内存访问的顺序\"> 保障内存访问的顺序</h4>\n<p>貌似串行语义<strong>只是保障重排序不影响单线程程序的正确性</strong>，从这个角度出发， 多线程程序的有序性的保障可以理解为通过某些措施使得貌似串行语义扩展到多线程程序。<strong>即重排序要么不发生， 要么即使发生了也不会影响多线程程序的正确性</strong>，这样有序性的保障也可以理解为从逻辑上部分禁止重排序。</p>\n<p>从底层的角度来说，禁止重排序是通过调用处理器提供相应的指令（<code>内存屏障</code>）来实现的。 当然，Java作为一个跨平台的语言，它会替我们与这类指令打交道，而我们只需要使用语言本身提供的机制即可。</p>\n<h4 id=\"可见性与有序性\"> 可见性与有序性</h4>\n<p>可见性是有序性的基础\n可见性描述的是一个线程对共享变量的更新对于另外一个线程是否可见， 或者说什么情况下可见的问题。有序性描述的是，一个处理器上运行的线程对共享变量所做的更新， 在其他处理器上运行的其他线程看来，这些线程是以什么样的顺序观察到这些更新的问题。 因此，可见性是有序性的基础。另一方面，二者又是相互区分的。</p>\n<h3 id=\"上下文切换\"> 上下文切换</h3>\n<p>上下文切换(Context Switch)在某种程度上可以被看作多个线程共享同一个处理器的产物,它是多线程编程中的一个重要概念。</p>\n<h4 id=\"描述\"> 描述</h4>\n<p>当一个进程中的一个线程由于其<code>时间片</code>用完，或者因其自身原因（比如稍后再继续运行）被迫或者主动暂停其运行时， 另外一个线程（可能是同一个进程或者其他进程中的一个线程）可以被操作系统（<code>线程调度器</code>）选中， <code>占用处理器</code>开始或者继续其运行。这种一个线程被暂停，另外一个线程被选中开始或者继续运行的过程就叫作线程上下文切换。 也可简单地称为上下文切换。</p>\n<p>从Java应用的角度来看,一个线程的生命周期状态在 <code>RUNNABLE</code>状态与<code>非 RUNNABLE状态</code>(包括 BLOCKED、 WAITING和 TIMED WAITING中的任意一个子状态)之间切换的过程就是一个上下文切换的过程。</p>\n<h4 id=\"上下文\"> 上下文</h4>\n<p>切出和切入的时候，操作系统需要保存和恢复相应线程的进度信息， 即切入和切出那一刻相应线程所执行的任务状态信息（如计算的中间结果以及执行到了哪条指令）。 <strong>这个进度信息就被称为上下文</strong>。 它一般包括<code>通用寄存器(General Purpose Register</code>)和<code>程序计数器(Program Counter)</code>中的内容。</p>\n<h4 id=\"切出和切入\"> 切出和切入</h4>\n<ul>\n<li>一个线程被剥夺处理器的使用权而被暂停运行就被称为切出</li>\n<li>一个线程被操作系统选中占用处理器开始或者继续其运行就被称为切入。</li>\n</ul>\n<h4 id=\"上下文切换分类\"> 上下文切换分类</h4>\n<p>按照导致上下文切换的因素划分，我们可以将上下文切换分为</p>\n<ul>\n<li><strong>自发性上下文切换</strong></li>\n<li><strong>非自发性上下文切换</strong></li>\n</ul>\n<p><strong>自发性上下文切换(Voluntary Context Switch)</strong></p>\n<p>自发性上下文切换指线程由于其自身因素导致的切出。</p>\n<div><pre><code><span>Thread</span><span>.</span> <span>sleep</span><span>(</span><span>long</span> millis<span>)</span><span>;</span>\n<span>Object</span><span>.</span><span>wait</span><span>(</span><span>)</span><span>;</span>\n<span>Object</span><span>.</span><span>wait</span><span>(</span><span>long</span> timeout<span>)</span><span>;</span>\n<span>Object</span><span>.</span><span>wait</span><span>(</span><span>long</span> timeout<span>,</span> <span>int</span> nanos<span>)</span><span>;</span>\n<span>Thread</span><span>.</span><span>yield</span><span>(</span><span>)</span><span>;</span>\n<span>Thread</span><span>.</span><span>join</span><span>(</span><span>)</span><span>;</span>\n<span>Thread</span><span>.</span><span>join</span><span>(</span><span>long</span> timeout<span>)</span><span>;</span>\n<span>LockSupport</span><span>.</span><span>park</span><span>(</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><blockquote>\n<p>另外,线程发起了IO操作(如读取文件)或者等待其他线程持有的锁(锁的概念在 第3章会介绍)也会导致自发性上下文切换。</p>\n</blockquote>\n<p><strong>非自发性上下文切换(Involuntary Context Switch)</strong></p>\n<p>线程由于<code>线程调度器</code>的原因被迫切出。 导致非自发性上下文切换的常见因素包括：</p>\n<ul>\n<li>被切出线程的时间片用完</li>\n<li>有一个比被切出线程优先级更高的线程需要被运行。</li>\n</ul>\n<p>从Java平台的角度来看，Java虚拟机的垃圾回收(Garbage Collect)动作也可能导致非自发性上下文切换。 这是因为垃圾回收器在执行垃圾回收的过程中，可能需要暂停所有应用线程才能完成其工作， 比如在主要回收(Major Collection)过程中，垃圾回收器在对Java虚拟机堆内存区域进行整理的时候需要先停止所有应用线程。</p>\n<h4 id=\"上下文切换的开销\"> 上下文切换的开销</h4>\n<p>上下文切换的开销包括<code>直接开销</code>和<code>间接开销</code>。</p>\n<p><strong>直接开销</strong></p>\n<ul>\n<li>操作系统保存和恢复上下文所需的开销，这主要是处理器时间开销。</li>\n<li>线程调度器进行线程调度的开销：比如，按照一定的规则决定哪个线程会占用处理器运行。</li>\n</ul>\n<p><strong>间接开销</strong></p>\n<ul>\n<li>处理高速缓存重新加载的开销：一个被切出的线程可能稍后在<strong>另外一个处理器</strong>上被切入继续运行。 由于这个处理器之前可能未运行过该线程，那么这个线程在其继续运行过程中需访问的变量， 仍然需要被该处理器重新从主内存或者通过缓存致性协议从其他处理器加载到高速缓存之中，这是有一定时间消耗的。</li>\n<li>高速缓存内容冲刷(Flush)的开销：️上下文切换也可能导致整个一级高速缓存中的内容被冲刷， 即一级高速缓存中的内容会被写入下一级高速缓存（如二级高速缓存），或者主内存(RAM)中</li>\n</ul>\n<p>线程的数量越多，可能导致的上下文切换的开销也就可能越大。也就是说，多线程编程中使用的线程数量越多， 程序的计算效率可能反而越低。因此，在设计多线程程序的时候，减少上下文切换也是一个重要的考量因素。</p>\n<h3 id=\"线程的活性故障\"> 线程的活性故障</h3>\n<p>事实上，线程并不是一直处于<code>RUNNABLE</code>状态，导致一个线程可能处于非RUNNABLE状态的因素， 除了资源（主要是处理器资源有限而导致的上下文切换）限制之外，还有<code>程序自身的错误和缺陷</code>。 由资源稀缺性或者程序自身的问题和缺陷导致线程一直处于<code>非RUNNABLE</code>状态， 或线程虽然处于RUNNABLE状态，但是其要执行的任务却一直无法进展，这种现象被称为线程活性故障。</p>\n<p>常见的线程活性故障包括以下几种：</p>\n<ul>\n<li>死锁(Deadlock)</li>\n<li>锁死(Lockout)</li>\n<li>活锁(Livelock)</li>\n<li>饥饿(Starvation)</li>\n</ul>\n<h4 id=\"死锁-deadlock\"> 死锁(Deadlock)</h4>\n<p>死锁只会出现在一组线程集合中，如果集合中的每一个线程都持有其他线程需要的资源， 导致所有线程因等待资源而被永暂停，这种现象就称之为死锁。 死锁产生的典型场景是线程X持有资源A的时候等待线程Y释放资源B， 同时线程Y在持有资源B的时候却等待线程X释放资源A，这就好比鹬蚌相争故事中的情形。</p>\n<h4 id=\"锁死-lockout\"> 锁死(Lockout)</h4>\n<p>锁死与死锁类似，<strong>锁死是指线程在等待一个永远不会发生的事件</strong>；与死锁不同的是， 锁死的线程可能不持有任何资源。一个较典型的例子就是信号丢失导致的锁死， 比如对 \t<code>CountDownLatch.countDown()</code> 方法的调用没有放在 <code>finally</code> 块中时， 可能因为异常抛出导致执行 <code>CountDownLatch.await()</code> 的线程永远处于等待状态。</p>\n<h4 id=\"活锁-livelock\"> 活锁(Livelock)</h4>\n<p>指线程一直处于运行状态,但是其任务却一直无法进展的一种活性故障。 活锁的一个重要特征就是线程一直处于运行状态，区别于死锁、锁死的线程处于等待状态。 同样以鹬蚌相争故事为例，不同的是两者商量好如果同时咬住对方，则两者都松开口， 但松口后两者又同时咬住了对方，于是两者在不停的咬住与松口，直至累死。</p>\n<h4 id=\"饥饿-starvation\"> 饥饿(Starvation)</h4>\n<p>线程一直无法获得其所需的资源而导致其任务直无法进展的一种活性故障。 比如由于当前线程的优先级极低，导致资源一直被其他线程抢占。</p>\n<h3 id=\"资源争用\"> 资源争用</h3>\n<ul>\n<li>\n<p>线程间的资源共享</p>\n<p>由于资源的稀缺性（例如有限的处理器资源）及资源本身的特性 （例如打印机一次 只能打印一个文件），往往需要在多个线程间共享同一个资源。</p>\n</li>\n<li>\n<p>排他性资源</p>\n<p>一次只能够被一个线程占用的资源被称为排他性资源， 常见的排他性资源包括处理器、数据库连接、文件等。</p>\n</li>\n<li>\n<p>资源争用(Resource Contention)</p>\n<p>在一个线程占用一个排他性资源进行访问（读、写操作）， 而未释放其对资源所有权的时候，其他线程试图访问该资源的现象就被称为资源争用， 简称争用。显然，争用是在并发环境下产生的一种现象。</p>\n</li>\n<li>\n<p>争用程度</p>\n<p>同时试图访问同个已经被其他线程占用的资源的线程数量越多，争用的程度就越高， 反之争用的程度就越低。相应的争用就被分别称为高争用和低争用。</p>\n</li>\n<li>\n<p>资源调度</p>\n<p>在多个线程申请同一个排他性资源的情况下，决定哪个线程会被授予该资源的独占权， 即选择哪个申请者占用该资源的过程就是资源的调度。 获得资源的独占权而又未释放其独占权的线程就被称为该资源的持有线程。</p>\n</li>\n</ul>\n<h3 id=\"资源调度策略\"> 资源调度策略</h3>\n<p>资源调度的一种常见策略就是<code>排队</code>。<code>资源调度器</code>内部维护一个<code>等待队列</code>，在存在资源争用的情况下， <code>申请失败的线程</code>会被存入该队列。通常，被存入等待队列的线程会被暂停。当相应的资源被其持有线程释放时， 等待队列中的一个线程会被选中并被唤醒而获得再次申请资源的机会。 被唤醒的线程如果申请到资源的独占权，那么该线程会从等待队列中移除； 否则，该线程仍然会停留在等待队列中等待再次申请的机会，即该线程会再次被暂停。 因此，等待队列中的等待线程可能经历若干次暂停与唤醒才获得相应资源的独占权。可见，资源的调度可能导致上下文切换。</p>\n<h4 id=\"资源调度的公平性\"> 资源调度的公平性</h4>\n<p>资源调度策略的一个常见特性就是它能否保证公平性。</p>\n<p>所谓公平性，是指资源的申请者（线程），是否按照其<code>申请（请求）资源的顺序</code>而被授予资源的独占权。 如果资源的任何一个先申请者，总是能够比任何一个后申请者先获得该资源的独占权， 那么相应的资源调度策略就被称为是公平的； 如果资源的后申请者可能比先申请者先获得该资源的独占权，那么相应的资源调度策略就被称为是非公平的。</p>\n<p>需要注意的是，非公平的资源调度策略往往只是说明它并不保证资源调度的公平性， <strong>即它允许不公平的资源调度的出现</strong>，而不是表示它刻意造就不公平的资源调度。</p>\n<h4 id=\"公平的调度策略\"> 公平的调度策略</h4>\n<p>公平的调度策略不允许插队现象的出现，即只有在资源未被其他任何线程占用， 并且没有其他活跃线程申请该资源情况下，队列中的线程才被允许被唤醒，抢占相应资源的独占权。 其中，抢占成功的申请者获得相应资源的独占权，而抢占失败的申请者会进入等待队列。 因此，公平调度策略中的资源申请者总是按照<code>先来后到</code>的顺序来获得资源的独占权。</p>\n<h4 id=\"非公平的调度策略\"> 非公平的调度策略</h4>\n<p>而非公平的调度策略则<code>允许插队现象</code>，即一个线程释放其资源独占权的时候，等待队列中的一个线程会被唤醒申请相应的资源。而在这个过程中，可能存在另一个活跃线程与这个被唤醒的线程共同参与相应资源的抢占。 因此，非公平调度策略中被唤醒的线程不一定就能够成功申请到资源。因此，在极端的情况下， 非公平调度策略可能导致等待队列中的线程永远无法获得其所需的资源，即出现<code>饥饿现象</code>。</p>\n<h4 id=\"对比\"> 对比</h4>\n<ul>\n<li>从申请者个体的角度来看：使用公平调度策略时，申请者获得相应资源的独占权所需时间的偏差可能比较小， 即每个申请者成功申请到资源所需的时间基本相同；而使用非公平的调度策略时，申请者获得相应资源的独占权所需时间的偏差可能比较大，有的线程很快就申请到资源， 而有的线程则要经历若干次暂停与唤醒才成功申请到资源。</li>\n<li>从效率上看：在非公平调度策略中，资源的持有线程释放该资源的时候，等待队列中的一个线程会被唤醒， 而该线程从被唤醒到其继续运行可能需要一段时间。<strong>在该时间内，如果使用非公平的调度策略， 新来的线程（活跃线程）可以先被授予该资源的独占权</strong>，如果这个新来的线程占用该资源的时间不长，那么它完全有可能在被唤醒的线程继续其运行前释放相应的资源，从而不影响该被唤醒的线程申请资源。 这种情形下，非公平调度策略可以减少上下文切换的次数。 但是，如果多数（甚至每个）线程占用资源的时间相当长，那么允许新来的线程抢占资源不会带来任何好处， 反而会导致被唤醒的线程需要再次经历暂停和唤醒，从而增加了上下文切換。 因此，多数线程占用资源的时间相当长的情况下不适合使用非公平调度策略。</li>\n</ul>\n<p>综上，在没有特别需要的情况下，我们默认选择非公平调度策略即可。 在资源的持有线程占用资源的时间相对长，或线程申请资源的平均间隔时间相对长， 或对资源申请所需的时间偏差有所要求（即时间偏差较小）的情况下可以考虑使用公平调度策略。</p>\n",
      "image": "https://blog-1300186248.cos.ap-shanghai.myqcloud.com/Java-MultiThread-1/%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E5%8C%BA%E5%88%AB.png",
      "date_published": "2021-05-11T21:18:29.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": []
    },
    {
      "title": "Java多线程-2",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/java/java-MultiThread/Java-MultiThread-2/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/java/java-MultiThread/Java-MultiThread-2/",
      "content_html": "<h2 id=\"java线程同步机制\"> Java线程同步机制</h2>\n<h3 id=\"同步机制简介\"> 同步机制简介</h3>\n<p>对于同一个个许可证所保护的共享数据而言，任何线程访问这些共享数据前必须先持有该许可证。</p>\n<ul>\n<li>一个线程只有在持有许可证的情况下才能够对这些共享数据进行访问；</li>\n<li>一个许可证一 一次只能够被个线程持有；</li>\n<li>许可证的持有线程在其结束对这些共享数据的访问后必须让出（释放） 其持有的许可证， 以便其他线程能够对这些共享数据进行访问。</li>\n</ul>\n<p>一个线程在访间共享数据前必须申请相应的锁（许可证）， 线程的这个动作被称为锁的获得 (Acquire)。一个线程获得某个锁（持有许可证），我们就称该线程为相应锁的持 有线程（线程持有许可证），一个锁一次只能被一个线程持有。锁的持有线程可以对该锁所保护的共享数据进行访问，访问结束后该线程必须释放 (Release) 相应的锁。锁的持有 线程在其获得锁之后和 释放锁之前这段时间内所执行的代码被称为临界区 (Critical Section)。因此，共享数据只允许在临界区内进行访问，临界区一次只能被一个线程执行。</p>\n<h3 id=\"临界区\"> 临界区</h3>\n<p>锁的持有线程在获得锁之后和释放锁之前这段时间内所执行的代码被称为临界区。共享数据只能在临界区内进行访问，临界区一次只能被一个线程执行。</p>\n<h3 id=\"锁简介\"> 锁简介</h3>\n<p>锁具有<code>排他性</code>，一次只能被一个线程持有，被称为<code>排它锁</code>或<code>互斥锁</code>。</p>\n<p>按照虚拟机对锁的实现划分，分为</p>\n<ul>\n<li>内部锁（Intrinsic Lock）：非公平锁，例如<code>sychronized</code></li>\n<li>显示锁（Explicit Lock）支持<code>非公平锁</code>和<code>公平锁</code>，例如JUC包下的<code>Lock</code>等实现类<code>ReentrenLock</code></li>\n</ul>\n<p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/Java-MultiThread-2/互斥锁示意图.png\" alt=\"互斥锁示意图\" /></p>\n<h2 id=\"锁的概念\"> 锁的概念</h2>\n<h3 id=\"可重入性\"> 可重入性</h3>\n<p>一个线程在持有一个锁的时候还能够继续成功申请该锁，就称该锁具有可重入性，反之则称为非可重入性。</p>\n<div><pre><code><span>void</span> <span>methodA</span><span>(</span><span>)</span> <span>{</span> \n  <span>acquireLock</span><span>(</span>lock<span>)</span><span>;</span>／／申请锁lock\n  ／／省略其他代码\n  <span>methodB</span><span>(</span><span>)</span><span>;</span> \n  <span>releaseLock</span><span>(</span>lock<span>)</span><span>;</span>／／释放锁lock\n<span>}</span>\n\n<span>void</span> <span>methodB</span><span>(</span><span>)</span> <span>{</span> \n  <span>acquireLock</span><span>(</span>lock<span>)</span><span>;</span>／／申请锁lock\n  <span>releaseLock</span><span>(</span>lock<span>)</span><span>;</span>／／释放锁lock\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>方法methodA使用了锁lock，该锁引导的临界区代码又调用了另外一个方法methodB,而方法methodB也使用了lock。那么， 这就产生了一个问题：methodA的执行线程持有锁 lock 的时候调用了methodB, 而methodB执行的时候又去申请锁lock, 而lock此时正被当前线程持有（未被释放）。那么，此时methodB究竟能否获得（申请成功） lock呢？可重入性就描述了这样一个问题。</p>\n<h4 id=\"实现原理\"> 实现原理</h4>\n<p>可重入锁可以被理解为一个对象，该对象包含一个<code>计数器属性</code>。计数器属性的初始值为 0, 表示相应的锁还没有被任何线程持有。</p>\n<ul>\n<li>每次线程获得一个可重入锁的时候， 该锁的 计数器值会被增加1。</li>\n<li>每次一个线程释放锁的时候， 该锁的计数器属性值就会被减1。</li>\n</ul>\n<p>可重入锁的持有线程初次获得该锁时相应的开销相对大，这是因为该锁的持有线程必须与其他线程 ”竞争” 以获得锁。</p>\n<p>可重入锁的持有线程继续荻得相应锁所产生的开销要小得 多，这是因为此时Java虚拟机只需要将相应锁的计数器属性值增加1即可以实现锁的获得。</p>\n<h3 id=\"锁的粒度\"> 锁的粒度</h3>\n<p>一个锁实例可以保护一个或者多个共享数据，一个实例所保护的共享数据的数量大小就被称为该锁的粒度，锁保护的共享数据越大，我们就称该锁的粒度越粗，反之则称粒度细。</p>\n<h2 id=\"锁的开销\"> 锁的开销</h2>\n<ul>\n<li>锁的申请和释放所产生的开销（主要是时间开销）</li>\n<li>锁的上下文切换（主要是时间开销）：锁作为一种排他性资源，一旦被争用就可能导致上下文切换，而没有被争用的锁则可能不会导致上下文切换</li>\n<li>锁泄露</li>\n<li>死锁锁死活锁饿死等线程其他活性故障。</li>\n</ul>\n<h3 id=\"锁泄露\"> 锁泄露</h3>\n<p>锁泄露指一个线程获得该锁之后，由于程序的错误、缺陷导致该锁一直无法被释放而其他线程一直无法获得该锁的现象。因此，锁泄露会导致同步在该锁上的所有线程都无法进展。</p>\n<h2 id=\"sychronized-内部锁\"> Sychronized（内部锁）</h2>\n<h3 id=\"参考\"> 参考</h3>\n<ul>\n<li><a href=\"https://www.pdai.tech/md/java/thread/java-thread-x-key-synchronized.html\" target=\"_blank\" rel=\"noopener noreferrer\">关键字: synchronized详解</a></li>\n<li><a href=\"https://blog.csdn.net/zwjyyy1203/article/details/106217887\" target=\"_blank\" rel=\"noopener noreferrer\">jvm：ObjectMonitor源码</a></li>\n<li><a href=\"https://blog.csdn.net/yinwenjie/article/details/84922958\" target=\"_blank\" rel=\"noopener noreferrer\">Java并发基石——所谓“阻塞”：Object Monitor和AQS（1）</a></li>\n<li><a href=\"https://blog.csdn.net/zzti_erlie/article/details/103997713?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-3.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-3.control\" target=\"_blank\" rel=\"noopener noreferrer\">锁升级过程</a></li>\n</ul>\n<h3 id=\"简介\"> 简介</h3>\n<p>Java平台中的任何一个对象都有唯一一个与之关联的锁。 这种锁被称为<code>监视器 (Monitor)</code>或者<code>内部锁 (Intrinsic Lock)</code>。内部锁是一种<code>排他锁</code>，它能够保障</p>\n<ul>\n<li>原子性</li>\n<li>可见性</li>\n<li>有序性</li>\n</ul>\n<p>内部锁是通过 synchronized 关键字实现的。</p>\n<h3 id=\"使用方法\"> 使用方法</h3>\n<ul>\n<li>synchronized修饰的实例方法：多线程并发访问时，只能有一个线程进入，获得<code>对象内置锁</code>，其他线程阻塞等待，但在此期间线程仍然可以访问其他方法。</li>\n<li>synchronized修饰的静态方法：多线程并发访问时，只能有一个线程进入，获得<code>类锁</code>，其他线程阻塞等待，但在此期间线程仍然可以访问其他方法。</li>\n<li>synchronized修饰的代码块，：多线程并发访问时，只能有一个线程进入，根据<code>括号中的对象或者是类</code>，获得相应的对象内置锁或者是类锁</li>\n<li>同步方法的整个方法体就是一个临界区。</li>\n</ul>\n<blockquote>\n<p>每个类都有一个类锁，类的每个对象也有一个内置锁，它们是互不干扰的，也就是说一个线程可以同时获得<code>类锁</code>和该类实例化<code>对象的内置锁</code>，当线程访问非synchronzied修饰的方法时，并不需要获得锁，因此不会产生阻塞。</p>\n</blockquote>\n<div><pre><code><span>Synchronized</span><span>(</span>锁句柄<span>)</span><span>{</span>\n    <span>//在此代码块访问共享数据</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>synchronized关键字所引导的代码块就是临界区 。锁句柄是一个对象的引用（或者能够返回对象的表达式）。例如，锁句柄可以填写为this 关键字（表示当前对象）。</p>\n<p>习惯上我们也直接称锁句柄为锁。锁句柄对应的监视器就被称为相应同步块的引导锁。相应地， 我们称呼相应的同步块为该锁引导的同步块。</p>\n<blockquote>\n<p>锁句柄通常采用final修饰（private final）。这是因为锁句柄的值一旦改变，会导致同一个代码块的多个线程实际上使用不同的锁，而导致竞态。</p>\n</blockquote>\n<h3 id=\"同步静态方法\"> 同步静态方法</h3>\n<div><pre><code><span>public</span> <span>class</span> <span>SynchronizedMethodExample</span> <span>{</span>\n    <span>public</span> <span>static</span> sysnchronized <span>void</span> <span>staticMethod</span><span>(</span><span>)</span><span>{</span>\n        <span>//在此访问共享数据</span>\n    <span>}</span>\n    <span>//...</span>\n<span>}</span>\n\n<span>//相当于</span>\n<span>public</span> <span>class</span> <span>SynchronizedMethodExample</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>staticMethod</span><span>(</span><span>)</span><span>{</span>\n        <span>sysnchronized</span><span>(</span><span>SynchronizedMethodExample</span><span>.</span><span>class</span><span>)</span><span>{</span>\n             <span>//在此访问共享数据</span>\n        <span>}</span>\n    <span>}</span>\n    <span>//...</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>线程在执行临界区代码的时候必须持有该临界区的<code>引导锁</code>。一个线程执行到同步代码块必须申请该同步块的引导锁，只有申请成功该锁的线程才能够执行相的应临界区。</p>\n<p>一旦执行完临界区代码，引导该临界区的锁就会被自动释放。整个内部锁申请和释放的过程都是由<code>java虚拟机</code>负责实施的，所以synchronized实现的锁被称为<code>内部锁</code>。</p>\n<p><strong>内部锁不会导致锁泄露</strong>，java编译器在将同步代码块编译成字节码的时候，对临界区可能抛出的异常（未被捕获）进行了处理，所以即使临界区代码抛出异常也不会妨碍内部锁的释放。</p>\n<h3 id=\"内部锁的调度\"> 内部锁的调度</h3>\n<p>概念</p>\n<ul>\n<li>监控区（Entry Set）：锁已被其他线程获取，期待获取锁的线程就进入Monitor对象的监控区</li>\n<li>待授权区（Wait Set）：曾经获取到锁，但是调用了wait方法，线程进入待授权区</li>\n</ul>\n<p>Java虚拟机会为每个内部锁分配一个<code>入口集(Entry List)</code>， 用于记录等待获得相应内部锁的线程。</p>\n<p>多个线程申请同一个锁的时候，只有一个申请者能够成为该锁的持有线程（即申请锁的操作成功）， 而其他申请者的申请操作会失败。 这些申请失败的线程并不会抛出异常， 而是会被暂停（生命周期状态变为<code>BLOCKED</code>) 并被存入相应锁的入口集中等待再次申请锁的机会。</p>\n<p>入口集中的线程就被称为相应内部锁的等待线程。当这些线程申请的锁被其持有线程释放的时候， <strong>该锁的入口集中的一个任意线程会被Java虚拟机唤醒</strong>， 从而得到再次申请锁的机会。</p>\n<p>由于Java虚拟机对内部锁的调度<code>仅支持非公平调度</code>， 被唤醒的等待线程占用处理器运行时可能还有其他新的活跃线程 （处于 RUNNABLE状态，且未进入过入口集）与该线程抢占这个被释放锁， 因此被唤醒的线程不一定就能成为该锁的持有 线程。</p>\n<p>另外，Java虚拟机如何从一个锁的入口集中选择一个等待线程，作为下一个可以参与再次申请相应锁的线程，这个细节与Java虚拟机的具体实现有关：这个被选中的线程有可能是入口集中等待时间最长的线程， 也可能是等待时间最短的线程，或者完全是随机。</p>\n<p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/Java-MultiThread-2/内部锁状态转换图.png\" alt=\"img\" /></p>\n<h3 id=\"锁原理\"> 锁原理</h3>\n<p>//TODO:monitor markword objectMonitor</p>\n<p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/Java-MultiThread-2/Mark Word.png\" alt=\"img\" /></p>\n<h3 id=\"锁升级过程\"> 锁升级过程</h3>\n<ul>\n<li><a href=\"https://blog.csdn.net/zzti_erlie/article/details/103997713?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-3.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-3.control\" target=\"_blank\" rel=\"noopener noreferrer\">锁升级过程</a></li>\n<li>https://blog.csdn.net/zwjyyy1203/article/details/106217887</li>\n</ul>\n<p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/Java-MultiThread-2/锁升级过程.jpg\" alt=\"preview\" /></p>\n<h2 id=\"lock接口-显示锁\"> Lock接口（显示锁）</h2>\n<p>jdk1.5引入的排他锁，其作用于内部锁相同， 但是它提供了一些内部锁所不具备的特性。显示锁是<code>java.util.concurrent.locks.Lock</code>接口的实例，<code>java.util.concurrent.locks.Lock</code>是它的默认实现类</p>\n<h3 id=\"常用方法\"> 常用方法</h3>\n<table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>void lock()</td>\n<td>获取锁</td>\n</tr>\n<tr>\n<td>void lockInterruptibly()</td>\n<td>如果当前线程未被中断，则获取锁</td>\n</tr>\n<tr>\n<td>newCondition()</td>\n<td>返回绑定到此Lock实例的新Conditon实例</td>\n</tr>\n<tr>\n<td>tryLock()</td>\n<td>仅在调试时锁为空闲状态才获取锁</td>\n</tr>\n<tr>\n<td>tryLock(long time, TimeUnit uinit)</td>\n<td>如果说在给定的时间空闲，并且当前线程未被中断，则获取锁</td>\n</tr>\n<tr>\n<td>unlock()</td>\n<td>释放锁</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"显示锁的调度\"> 显示锁的调度</h3>\n<p>可以根据<code>ReentrantLock(boolean fail)</code> 指定公平和非公平锁，true为公平锁</p>\n<p>公平锁保障锁调度的公平性往往是以增加上下文切换为代价的，因此显式锁默认非公平调度策略，适合``````锁被持有时间相对长<code>和</code>线程申请锁的平均间隔时间相对长``的情形。</p>\n<p>总的来说，公平锁开销大于非公平锁.</p>\n<h2 id=\"synchronized-和-reentrantlock\"> Synchronized 和 ReenTrantLock</h2>\n<h3 id=\"对比\"> 对比</h3>\n<p><strong>1. 锁的实现</strong></p>\n<p>synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的。</p>\n<p><strong>2. 性能</strong></p>\n<p>新版本 Java 对 synchronized 进行了很多优化，例如自旋锁等，synchronized 与 ReentrantLock 大致相同。</p>\n<p><strong>3. 等待可中断</strong></p>\n<p>ReentrantLock 可中断，而 synchronized 不行</p>\n<p>当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。</p>\n<p><strong>4. 公平锁</strong></p>\n<p>synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但是也可以是公平的。</p>\n<p>公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。</p>\n<p><strong>5. 锁绑定多个条件</strong></p>\n<p>一个 ReentrantLock 可以同时绑定多个 Condition 对象，通过调用<code>newCondition()</code>方法来创建。</p>\n<p><strong>6. 是否可重入</strong></p>\n<p>两者都是可重入锁。</p>\n<p>“可重入锁”概念是：自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。</p>\n<p><strong>7. 异常处理&amp;锁泄露</strong></p>\n<p>synchronized 异常就会自动释放锁来避免<code>锁泄露</code>，而 ReenTrantLock 异常需要在 finally 里 unlock。</p>\n<p>通过反编译可以看到sychronized有两个释放锁标志<code>monitorexit</code>，最后一个<code>monitorexit</code>是用于如果同步代码块中出现``Exception或者Error<code>，则会调用第二个</code>monitorexit`指令来保证释放锁</p>\n<p><strong>8. 灵活性</strong></p>\n<p>内部锁是基于代码块的锁，灵活性较差，要么使用，用么不使用；</p>\n<p>而显示锁是基于对象的锁，灵活性强，比如可以在一个方法内申请锁，在另一个方法释放锁，而内部锁是无法做到的。</p>\n<p>还有如果一个内部锁的持有线程一直不释放这个锁(这通常是由于代码错误导致的),那 么同步在该锁之上的所有线程就会一直被暂停而使其任务无法进展。而显式锁则可以轻松 地避免这样的问题。Lock接口定义了一个 <code>try Lock</code>方法。该方法的作用是尝试申请相应 Lock实例锁表示的锁。如果相应的锁未被其他任何线程持有,那么该方法会返回true,表 示其获得了相应的锁;否则,该方法并不会导致其执行线程被暂停而是直接返回 false, 表示其未获得相应的锁。更高级可以使用带参数超时等待的try lock方法。</p>\n<p><strong>9. 监控定位</strong></p>\n<p>在问题定位方面,尤其是定位生产环境上的问题的时候,<code>线程转储( Thread dump 参见第1章)</code>就像是线程的“工作报告”一样可以告诉我们Java虚拟机中关于线程的详 细信息。</p>\n<p>线程转储中会包含内部锁的相关信息,包括一个线程等待哪些锁以及这些锁的当 前(获取相应线程转储那一刻)持有线程。</p>\n<p>而在JDK1.5下,线程转储中并不包含显式锁 的相关信息。不过,JDK1.6提供的工具 <code>jstack</code>所产生的线程转储中可以包含显式锁的信 息5。</p>\n<h3 id=\"reentrantlock的高级功能\"> ReenTrantLock的高级功能</h3>\n<p>ReenTrantLock 比 synchronized 增加了一些高级功能。主要有三点</p>\n<ol>\n<li>等待可中断</li>\n<li>可指定公平和非公平锁</li>\n<li>可实现选择性通知（锁可以绑定多个条件）</li>\n</ol>\n<ul>\n<li><strong>ReenTrantLock提供了一种能够中断等待锁的线程的机制</strong>，通过**lock.lockInterruptibly()**来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。</li>\n<li><strong>ReenTrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。</strong> ReenTrantLock默认情况是非公平的，可以通过 ReenTrantLock类的<code>ReentrantLock(boolean fair)</code>构造方法来制定是否是公平的。</li>\n<li><strong>synchronized关键字与wait()和notify/notifyAll()方法相结合可以实现等待/通知机制</strong>，ReentrantLock类当然也可以实现，但是需要借助于Condition接口与newCondition() 方法。Condition是JDK1.5之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个Lock对象中可以创建多个Condition实例（即对象监视器），<strong>线程对象可以注册在指定的Condition中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用notify/notifyAll()方法进行通知时，被通知的线程是由 JVM 选择的，用ReentrantLock类结合Condition实例可以实现“选择性通知”</strong> ，这个功能非常重要，而且是Condition接口默认提供的。而synchronized关键字就相当于整个Lock对象中只有一个Condition实例，所有的线程都注册在它一个身上。如果执行notifyAll()方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，而Condition实例的signalAll()方法 只会唤醒注册在该Condition实例中的所有等待线程。</li>\n</ul>\n<p>如果你想使用上述功能，那么选择ReenTrantLock是一个不错的选择。</p>\n<h3 id=\"使用选择\"> 使用选择</h3>\n<p>除非需要灵活的使用锁，去使用 ReentrantLock 的高级功能，否则优先使用 synchronized。这是因为 synchronized 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。并且使用 synchronized 不用担心没有释放锁而导致死锁或锁泄露问题，因为 JVM 会确保锁的释放。</p>\n<p>内部锁的优点是简单易用,显式锁的优点是功能强大,这两种锁各自都存在一些弱势。</p>\n<ul>\n<li>一般来说,新开发的代码中我们可以选用显式锁。但是选用显式锁的时候需要注意 显式锁的不正确使用会导致锁泄漏这样严重的问题;线程转储可能无法包含显式锁的相关 信息,从而导致问题定位的困难。</li>\n<li>另外,我们也可以使用相对保守的策略——默认情况下选用内部锁,仅在需要显式锁 所提供的特性的时候才选用显式锁。比如,在多数线程持有一个锁的时间相对长或者线程 申请锁的平均时间间隔相对长的情况下使用非公平锁是不太恰当的,因此我们可考虑使用 公平锁(显式锁)。</li>\n</ul>\n<h3 id=\"性能已不是选择标准\"> 性能已不是选择标准</h3>\n<p>在JDK1.6之前，synchronized 的性能是比 ReenTrantLock 差很多。<strong>具体表示为：synchronized 关键字吞吐量随线程数的增加，下降得非常严重。而ReenTrantLock 基本保持一个比较稳定的水平</strong>。我觉得这也侧面反映了， synchronized 关键字还有非常大的优化余地。后续的技术发展也证明了这一点，我们上面也讲了在 JDK1.6 之后 JVM 团队对 synchronized 关键字做了很多优化。<strong>JDK1.6 之后，synchronized 和 ReenTrantLock 的性能基本是持平了。所以网上那些说因为性能才选择 ReenTrantLock 的文章都是错的！JDK1.6之后，性能已经不是选择synchronized和ReenTrantLock的影响因素了！而且虚拟机在未来的性能改进中会更偏向于原生的synchronized，所以还是提倡在synchronized能满足你的需求的情况下，优先考虑使用synchronized关键字来进行同步！优化后的synchronized和ReenTrantLock一样，在很多地方都是用到了CAS操作</strong>。</p>\n<h2 id=\"锁优化与选择\"> 锁优化与选择</h2>\n<p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/Java-MultiThread-2/锁优化.png\" alt=\"img\" /></p>\n<h2 id=\"改进锁-读写锁\"> 改进锁：读写锁</h2>\n<p>读写锁( Read/Write Lock)是一种改进型的排他锁,也被称为共享/排他( Shared Exclusive)锁。读写锁允许多个线程可以同时读取(只读)共享变量,但是一次只允许个线程对共享变量进行更新(<code>包括读取后再更新</code>)。任何线程读取共享变量的时候,其他 线程无法更新这些变量;一个线程更新共享变量的时候,其他任何线程都无法访问该变量。</p>\n<p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/Java-MultiThread-2/读写锁的两种角色.png\" alt=\"读写锁的两种角色\" /></p>\n<p>总的来说,<strong>读锁之间可以变法访问，读锁和写锁直接互斥，写锁和写锁之间互斥</strong></p>\n<ul>\n<li>读锁对于读线 程来说起到保护其访问的共享变量在其访问期间不被修改的作用,并使多个读线程可以同 时读取这些变量从而提高了并发性;</li>\n<li>而写锁保障了写线程能够以独占的方式安全地更新共 享变量。写线程对共享变量的更新对读线程是可见的。</li>\n</ul>\n<h3 id=\"对比-2\"> 对比</h3>\n<p>与普通的排他锁(如内部锁和 Reentrantlock)相比,读写锁在排他性方面比较弱(这是我们所期望的)。在原子性、可见性和有序性保障方面,它所起到的作用与普通的排他锁是一致的，</p>\n<ul>\n<li>写线程<code>释放写锁</code>所起到的作用相当于一个线程释放一个普通排他锁;</li>\n<li>读线程<code>获得读锁</code>所起到的作用相当于一个线程获得一个普通排他锁。</li>\n</ul>\n<h3 id=\"适用场景\"> 适用场景</h3>\n<p>由于内部实现较为复杂， 只有同时满足下面两个条件的时候,读写锁才是适宜的选择。否则,使用读写锁会得 不偿失(开销)。</p>\n<ul>\n<li>只读操作比写(更新)操作要频繁得多</li>\n<li>读线程持有锁的时间比较长</li>\n</ul>\n<h3 id=\"读写锁的升级降级\"> 读写锁的升级降级</h3>\n<p>ReentrantReadWriteLock所实现的读写锁是个<code>可重入锁</code>。</p>\n<ul>\n<li>锁降级：支持。即一个线程持有读写锁的<code>写锁</code>的情况下可以继续获得相应的<code>读锁</code>。</li>\n<li>锁升级：不支持。目前获取<code>读锁</code>后需要释放<code>读锁</code>才能获取<code>写锁</code>。</li>\n</ul>\n<p><strong>锁降级</strong></p>\n<div><pre><code><span>//锁降级</span>\n<span>public</span> <span>void</span> <span>downGrade</span><span>(</span><span>)</span> <span>{</span>\n  <span>boolean</span> readLockAcquired <span>=</span> <span>false</span><span>;</span>\n  writeLock<span>.</span><span>lock</span><span>(</span><span>)</span><span>;</span>\n  <span>try</span> <span>{</span>\n    <span>//在此区域访问(读，写)共享变量</span>\n    <span>//...</span>\n    <span>//当线程在持有写锁的情况下申请读锁readLock</span>\n    readLock<span>.</span><span>lock</span><span>(</span><span>)</span><span>;</span>\n    readLockAcquired <span>=</span> <span>true</span><span>;</span>\n  <span>}</span> <span>catch</span> <span>(</span><span>Exception</span> e<span>)</span> <span>{</span>\n    e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n  <span>}</span> <span>finally</span> <span>{</span>\n    writeLock<span>.</span><span>unlock</span><span>(</span><span>)</span><span>;</span>\n  <span>}</span>\n\n  <span>if</span><span>(</span>readLockAcquired<span>)</span><span>{</span>\n    <span>try</span> <span>{</span>\n      <span>//读取共享数据</span>\n\n    <span>}</span> <span>catch</span> <span>(</span><span>Exception</span> e<span>)</span> <span>{</span>\n      e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span> <span>finally</span> <span>{</span>\n      readLock<span>.</span><span>unlock</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><p><strong>锁升级</strong></p>\n<div><pre><code><span>//锁升级</span>\n<span>public</span> <span>void</span> <span>upGrade</span><span>(</span><span>)</span> <span>{</span>\n  readLock<span>.</span><span>lock</span><span>(</span><span>)</span><span>;</span>\n  <span>try</span> <span>{</span>\n    <span>// Must release read lock before acquiring write lock</span>\n    readLock<span>.</span><span>unlock</span><span>(</span><span>)</span><span>;</span>\n    writeLock<span>.</span><span>lock</span><span>(</span><span>)</span><span>;</span>\n    <span>try</span> <span>{</span>\n      <span>//在此区域访问(读，写)共享变量</span>\n      <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>\"写操作正在执行。。。\"</span><span>)</span><span>;</span>\n      <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>1000</span><span>)</span><span>;</span>\n      <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>\"写操作结束。。。\"</span><span>)</span><span>;</span>\n    <span>}</span> <span>catch</span> <span>(</span><span>Exception</span> e<span>)</span> <span>{</span>\n      e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span> <span>finally</span> <span>{</span>\n      writeLock<span>.</span><span>unlock</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n  <span>}</span> <span>catch</span> <span>(</span><span>Exception</span> e<span>)</span> <span>{</span>\n    e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n  <span>}</span> <span>finally</span> <span>{</span>\n    readLock<span>.</span><span>unlock</span><span>(</span><span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><h2 id=\"内存屏障\"> 内存屏障</h2>\n<p>可见性的两个动作</p>\n<ul>\n<li><strong>刷新处理器</strong>：获得锁前，保证了该锁的当前持有线程能够读取到前一个持有线程对这些数\n据所做的更新</li>\n<li><strong>冲刷处理器</strong>：释放锁后，保证了该锁的持有线程对这些数据所做的更新对该锁的后续持\n有线程可见</li>\n</ul>\n<p>底层是借助<code>内存屏障</code>实现的上述动作。</p>\n<h3 id=\"定义\"> 定义</h3>\n<p>内存屏障是对一类仅针对内存读丶写操作指令的跨处理器架构的比较底层的抽象。<code>内存屏障</code>是被插入到<code>两个指令之间</code>使用的，其作用是禁止编译器丶处理器重排序从而保证<code>有序性</code>，但放的位置不同作用也有不同。</p>\n<p>它在指令序列(如指令1;指令2;指令3)中就像是一堵墙(因此被称为屏障)一样使其两侧(之前和之后)的指令无法“穿越”它(一旦穿越了就是重排序了)。</p>\n<p>但是,为了实现禁止重排序的功能,这些指令也往往具有一个副作用——刷新处理器缓存、冲刷处理器缓存,从而保证可见性。不同微架构的处理器所提供的这样的指令是不同的,并且出于不同的目的使用的相应指令也是不同的。</p>\n<h3 id=\"按可见性保障划分\"> 按可见性保障划分</h3>\n<ul>\n<li>加载屏障：刷新处理器缓存</li>\n<li>存储屏障：冲刷处理器缓存</li>\n</ul>\n<h4 id=\"加载屏障\"> 加载屏障</h4>\n<ul>\n<li>用法：Java虚拟机会在 <code>Monitorenter(申请锁)</code>对应的机器码指令之后<code>临界区开始之前</code>的地方插人一个<code>加载屏障</code>。</li>\n<li>作用：这使得读线程的执行处理器能够将写线程对相应共享变量所做的更新从其他处理器同步到该处理器的高速缓存中。</li>\n</ul>\n<h4 id=\"存储屏障\"> 存储屏障</h4>\n<ul>\n<li>用法：Java虚拟机会在 <code>MonitorExit(释放锁)</code>对应的<code>机器码指令之后</code>插入一个<code>存储屏障</code></li>\n<li>作用：这就保障了写线程在释放锁之前在临界区中对共享变量所做的更新对读线程的执行处理器来说是可同步的</li>\n</ul>\n<p><strong>因此,可见性的保障是通过写线程和读线程成对地使用<code>存储屏障</code>和<code>加载屏障</code>实现的。</strong></p>\n<p>这有点像高考成绩查询:高考阅卷完毕之后虽然每个考生的分数都已经确定,但是这些分数对于考生来说仍然是未知的。只有当分数公布的时候,考生才能够去查询自己的分数。这里</p>\n<ul>\n<li>考试成绩就相当于阅卷方和考生之间需要共享的数据:</li>\n<li>阅卷方公布成绩相当于执行存储屏障,它使得考生的分数可以被查询;</li>\n<li>考生查询其考试成绩相当于执行加载屏障,它使得考生可以得知自己的考试成绩</li>\n</ul>\n<h3 id=\"按有序性保障划分\"> 按有序性保障划分</h3>\n<ul>\n<li>获取屏障</li>\n<li>释放屏障</li>\n</ul>\n<h4 id=\"获取屏障\"> 获取屏障</h4>\n<ul>\n<li>用法：Java虚拟机会在 <code>Monitorenter之后</code>(它包含了读操作)和<code>临界区开始之前</code>的地方插人一个<code>获取屏障</code></li>\n<li>作用：其作用是禁止该读操作与其后的任何读写操作之间进行<code>重排序</code>，这相当于在进行后续操作<code>之前</code>先要获得相应共享数据的<code>所有权</code>(这也是该屏障的名称来源)，<code>获取屏障</code>禁止了临界区中的任何读、写操作被重排序到<code>临界区之前</code>的可能性,</li>\n</ul>\n<h4 id=\"释放屏障\"> 释放屏障</h4>\n<ul>\n<li>用法：<code>Monitorexit之前</code>(它包含了写操作)和<code>临界区之后</code>的地方插入一个<code>释放屏障</code>。</li>\n<li>作用：禁止该写操作与其前面的任何读写操作之间进行<code>重排序</code>，这相当于在对相应共享数据<code>操作结束后</code>释放所有权(这也是该屏障的名称来源)，<code>释放屏障</code>又禁止了临界区中的任何读、写操作被重排序到<code>临界区之后</code>的可能性。</li>\n</ul>\n<p>因此,这两种屏障就像是三明治的两层面包片把火腿夹住一样把临界区中 的代码(指令序列)包括起来,如图3-4所示</p>\n<p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/Java-MultiThread-2/内存屏障在锁中的使用.png\" alt=\"内存屏障在锁中的使用\" /></p>\n<h3 id=\"总结\"> 总结</h3>\n<p>因此临界 区内的任何读、写操作都无法被重排序到临界区之外。在锁的排他性的作用下,这使得临 界区中执行的操作序列具有<code>原子性</code>。因此,写线程在临界区中对各个共享变量所做的更新 会同时对读线程可见,即在读线程看来各个共享变量就像是“一下子”被更新的,于是这 些线程无从(也无必要)区分这些共享变量是以何种顺序被更新的。这使得写线程在临界 区中执行的操作自然而然地具有有序性—读线程对这些操作的感知顺序与源代码顺序一致</p>\n<p><strong>可见,锁对有序性的保障是通过写线程和读线程配对使用释放屏障与加载屏障实现的</strong></p>\n<h2 id=\"轻量级同步机制-volatile关键字\"> 轻量级同步机制：volatile关键字</h2>\n<h3 id=\"定义-2\"> 定义</h3>\n<p>volatile字面有“易挥发”的意思,引申开来就是有“不稳定”的意思。</p>\n<p>volatile关键字用于修饰共享可变变量,即没有使用 <code>final</code>关键字修饰的实例变量或静态变量,如下所示</p>\n<div><pre><code><span>private</span> <span>volatile</span> <span>int</span> logLevel\n</code></pre>\n<div><span>1</span><br></div></div><ul>\n<li>volatile关键字表示被修饰的变量的值容易变化(即被其他线程更改),因而不稳定。</li>\n<li>volatile变量的不稳定性意味着对这种变量的读和写操作都必须从<code>高速缓存</code>或者<code>主内存</code> （也是通过高速缓存读取）中读取，以读取<code>变量的相对新值</code>。</li>\n<li>因此, volatile变量不会被编译器分配到<code>寄存器</code>进行存储，对volatile变量的读写操作都是内存访问(访问高速缓存相当于主内存)操作。</li>\n</ul>\n<p>保证了</p>\n<ul>\n<li>可见性</li>\n<li>有序性</li>\n<li>原子性：仅能保障<code>写volatile</code>变量操作的原子性，但没有锁的排他性，所以不会引起<code>上下文切换</code>（因为变量在主内存）</li>\n</ul>\n<h3 id=\"作用\"> 作用</h3>\n<ul>\n<li>可见性</li>\n<li>有序性</li>\n<li>保障long/double型变量的<code>读写操作</code>的原子性</li>\n</ul>\n<p>当有“中间结果”进行操作，比如使用共享变量count2的赋值操作</p>\n<div><pre><code><span>private</span> <span>volatile</span> <span>int</span> count1<span>;</span>\n<span>private</span> <span>int</span> count2<span>;</span>\ncount1 <span>=</span> count2 <span>+</span> <span>1</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>该赋值操作为<code>read-modify-write</code>操作，在执行过程可能有其他线程更新了<code>count2</code>的值，但如果<code>count2</code>是<code>局部变量</code>那么整个就是<code>原子性</code>的。</p>\n<p>volatile仅仅保障对其修饰的变量的写操作(以及读操作)本身的原子性，如果赋值操作的是局部变量，那么也认为是<code>原子性</code>的。</p>\n<ul>\n<li>写线程对 volatile变量的写操作会产生类似于释放锁的效果。</li>\n<li>读线程对 volatile变量的读操作会产生类似于获得锁的效果。</li>\n</ul>\n<p>因此, volatile具有保障有性和可见性的作用</p>\n<h3 id=\"存储屏障-2\"> 存储屏障</h3>\n<h4 id=\"写操作\"> 写操作</h4>\n<ul>\n<li>该操作<code>之前</code>插入一个<code>释放屏障</code></li>\n<li>在该操作<code>之后</code>插入一个<code>存储屏障</code></li>\n</ul>\n<p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/Java-MultiThread-2/volatile插入屏障.png\" alt=\"volatile写操作屏障.png\" /></p>\n<p>其中,<code>释放屏障</code>禁止了 volatile写操作与该操作之前的仼何读、写操作进行重排序 从而保证了 volatile写操作之前的任何读、写操作会先于 volatile写操作被提交,即其他线 程看到写线程对 volatile变量的更新时,写线程在更新 volatile变量之前所执行的内存操作 的结果对于读线程必然也是可见的。这就保障了读线程对写线程在更新 volatile变量前对 共享变量所执行的更新操作的感知顺序与相应的源代码顺序一致,即保障了有序性。</p>\n<p>volatileε虽然能够保障有序性,但是它不像锁那样具备排他性,所以并不能保障其他操作的原子性,而<code>只能够保障对被修饰变量的写操作的原子性</code>。因此, volatile变量写操作之前的操作如果涉及共享可变变量,那么竞态仍可能产生。这是因为共享变量被赋值给volatile变量的时候其他线程可能已经更新了该共享变量的值。</p>\n<h4 id=\"读操作\"> 读操作</h4>\n<ul>\n<li>该操作<code>之前</code>插入一个<code>加载屏障</code></li>\n<li>在该操作<code>之后</code>插入一个<code>获取屏障</code></li>\n</ul>\n<p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/Java-MultiThread-2/volatile读操作屏障.png\" alt=\"volatile读操作屏障\" /></p>\n<p>综上所述</p>\n<ul>\n<li>写 volatile变量操作与该操作之前的任何读、写操作不会被重排序</li>\n<li>读 volatile变量操作与该操作之后的任何读、写操作不会被重排序。</li>\n</ul>\n<p>volatile关键字的作用体现在对修饰变量的读写操作上。</p>\n<h3 id=\"数组\"> 数组</h3>\n<p>如果被修饰的变量是个数组,那么 volatile关键字只能够对<code>数组引用本</code>身的操作(读 取数组引用和更新数组引用)起作用，而无法对<code>数组元素的操作(读取、更新数组元素)</code> 起作用。</p>\n<p>对数组的操作可分为读取数组元素、写数组元素和读取数组引用这几种类型</p>\n<div><pre><code>inti<span>=</span> anArray<span>[</span><span>0</span><span>]</span><span>;</span><span>//操作类型①:读取数组元素</span>\n\naRray<span>[</span><span>1</span><span>]</span><span>=</span><span>1</span><span>;</span><span>//操作类型②:写数组元素</span>\n\n<span>volatile</span> <span>int</span><span>[</span><span>]</span> anotherArray<span>=</span> anArray<span>;</span><span>//操作类型③:读取数组引用</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>仅能保证第一个操作读取到的引用内存地址是最新的，但不能保证操作二读取到的数组元素是最新的。</p>\n<p>如果要保证数组的读取元素也是最新的，可以用<code>AtomicIntegerArray</code>等</p>\n<h3 id=\"开销\"> 开销</h3>\n<ul>\n<li>写：介于普通写取和临界区写之间，不用申请锁和上下文切换</li>\n<li>读：介于普通写取和临界区写之间，需要从主内存中读取</li>\n</ul>\n<h3 id=\"适用场景-2\"> 适用场景</h3>\n<p>条件</p>\n<ul>\n<li>对变量的写操作不依赖于当前值。</li>\n<li>该变量没有包含在具有其他变量的不变式中</li>\n</ul>\n<blockquote>\n<p>volatile关键字在可见性方面仅仅是保证读线程能够读取到共享变量的相对新值。 对于<code>引用型变量</code>和<code>数组变量</code>, volatile关键字并不能保证读线程能够读取到相应对象的 字段(实例变量、静态变量)、元素的相对新值。</p>\n</blockquote>\n<p>场景</p>\n<ul>\n<li>状态标志：不用申请锁，且同步</li>\n<li>保证可见性：其他线程能在不加锁的情况下看到变量的更新</li>\n<li>替代锁：对volatile变量的写操作是原子性的，比较适合多线程共享<code>一个</code>状态变量而不是多线程共享<code>一组</code>变量。某些情形下,我们可以将多个线程共享的一组状态变量合并成一个对象,用个 volatile变量来引用该对象,从而使我们不必要使用锁。</li>\n<li>简易的读写锁：在该场景中,读写锁是通过混合使用 锁和 volatile变量而实现的,其中锁用于保障共享变量写操作的原子性, volatile 变量用于保障共享变量的可见性。因此,与 Reentrantread writelock所实现的读 写锁不同的是,这种简易版读写锁仅涉及一个共享变量并且允许一个线程读取这 个共享变量时其他线程可以更新该变量(这是因为读线程并没有加锁)。因此 这种读写锁允许读线程可以读取到共享变量的非最新值。该场景的一个典型例子 是实现一个计数器,如清单3-7所示3。</li>\n</ul>\n<div><pre><code><span>public</span> <span>class</span> <span>Counter</span><span>{</span>\n    <span>private</span> <span>volatile</span> <span>long</span> count<span>;</span>\n    <span>public</span> <span>long</span> <span>vaule</span><span>(</span><span>)</span><span>{</span>\n        <span>return</span> count<span>;</span>\n    <span>}</span>\n    <span>public</span> <span>void</span> <span>increment</span><span>(</span><span>)</span><span>{</span>\n        <span>synchronized</span> <span>(</span><span>this</span><span>)</span><span>{</span>\n            count<span>++</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h2 id=\"cas\"> CAS</h2>\n<p>参考</p>\n<blockquote>\n<ul>\n<li>https://blog.csdn.net/v123411739/article/details/79561458</li>\n<li>https://www.jianshu.com/p/ab2c8fce878b</li>\n</ul>\n</blockquote>\n<h3 id=\"概述\"> 概述</h3>\n<p><code>CAS（Compare-and-Swap）</code>，即比较并替换，是一种实现并发算法时常用到的技术，Java并发包中的很多类都使用了<code>CAS</code>技术。CAS是一种<code>无锁算法</code>，CAS有3个操作数</p>\n<blockquote>\n<ul>\n<li>内存值V</li>\n<li>旧的预期值A</li>\n<li>要修改的新值B</li>\n</ul>\n</blockquote>\n<p>当且仅当<code>预期值A</code>和<code>内存值V</code>相同时(说明此时内存中的值没有被其他线程改变)，将<code>内存值V</code>修改为<code>B</code>，否则什么都不做。</p>\n<p>CAS比较与交换的伪代码可以表示为：</p>\n<blockquote>\n<p>do{</p>\n<p>备份旧数据；</p>\n<p>基于旧数据构造新数据；</p>\n<p>}while(!CAS( 内存地址，备份的旧数据，新数据 ))</p>\n</blockquote>\n<p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/Java-MultiThread-2/CAS_algorithm.jpg\" alt=\"CAS算法理解\" /></p>\n<p>参考<code>getAndAddInt</code>方法源码</p>\n<div><pre><code>    <span>public</span> <span>final</span> <span>int</span> <span>getAndAddInt</span><span>(</span><span>Object</span> var1<span>,</span> <span>long</span> var2<span>,</span> <span>int</span> var4<span>)</span> <span>{</span>\n        <span>int</span> var5<span>;</span>\n        <span>do</span> <span>{</span>\n            var5 <span>=</span> <span>this</span><span>.</span><span>getIntVolatile</span><span>(</span>var1<span>,</span> var2<span>)</span><span>;</span>\n        <span>}</span> <span>while</span><span>(</span><span>!</span><span>this</span><span>.</span><span>compareAndSwapInt</span><span>(</span>var1<span>,</span> var2<span>,</span> var5<span>,</span> var5 <span>+</span> var4<span>)</span><span>)</span><span>;</span>\n\n        <span>return</span> var5<span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>注：t1，t2线程是同时更新<code>同一变量56的值</code></p>\n<p>因为t1和t2线程都同时去访问<code>同一变量56</code>，所以他们会把<strong>主内存的值完全拷贝一份到自己的工作内存空间</strong>，所以t1和t2线程的预期值都为<code>56</code>。</p>\n<p>假设t1在与t2线程竞争中线程t1能去更新变量的值，而其他线程都失败。（失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次发起尝试）。t1线程去更新变量值改为57，然后写到内存中。此时对于t2来说，内存值变为了57，与预期值56不一致，就操作失败了（想改的值不再是原来的值）。</p>\n<p>（上图通俗的解释是：CPU去更新一个值，但如果想改的值不再是原来的值，操作就失败，因为很明显，有其它操作先改变了这个值。）</p>\n<p>就是指当两者进行比较时</p>\n<blockquote>\n<ul>\n<li>如果相等，则证明共享数据没有被修改，替换成新值，然后继续往下运行；</li>\n<li>如果不相等，说明共享数据已经被修改，放弃已经所做的操作，然后重新执行刚才的操作。</li>\n</ul>\n</blockquote>\n<p>容易看出 CAS 操作是基于共享数据不会被修改的假设，采用了类似于数据库的<code>commit-retry</code> 的模式。当同步冲突出现的机会很少时，这种假设能带来较大的性能提升。</p>\n<h3 id=\"使用例子-源码\"> 使用例子/源码</h3>\n<p>创建一个<code>AtomicInteger</code>类型来测试多线程多同一个变量的自增操作</p>\n<div><pre><code>    <span>public</span> <span>static</span> <span>AtomicInteger</span> race <span>=</span> <span>new</span> <span>AtomicInteger</span><span>(</span><span>0</span><span>)</span><span>;</span>\n\n    <span>public</span> <span>static</span> <span>void</span> <span>increase</span><span>(</span><span>)</span> <span>{</span>\n        <span>/*race++;并非原子操作，经过下面三个步骤，取值，+1，写值*/</span>\n        race<span>.</span><span>getAndIncrement</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>getAndIncrement()源码</p>\n<div><pre><code>    <span>public</span> <span>final</span> <span>int</span> <span>getAndIncrement</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> unsafe<span>.</span><span>getAndAddInt</span><span>(</span><span>this</span><span>,</span> valueOffset<span>,</span> <span>1</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>getAndAddInt源码</p>\n<div><pre><code>    <span>public</span> <span>final</span> <span>int</span> <span>getAndAddInt</span><span>(</span><span>Object</span> var1<span>,</span> <span>long</span> var2<span>,</span> <span>int</span> var4<span>)</span> <span>{</span>\n        <span>int</span> var5<span>;</span>\n        <span>do</span> <span>{</span>\n            var5 <span>=</span> <span>this</span><span>.</span><span>getIntVolatile</span><span>(</span>var1<span>,</span> var2<span>)</span><span>;</span>\n        <span>}</span> <span>while</span><span>(</span><span>!</span><span>this</span><span>.</span><span>compareAndSwapInt</span><span>(</span>var1<span>,</span> var2<span>,</span> var5<span>,</span> var5 <span>+</span> var4<span>)</span><span>)</span><span>;</span>\n\n        <span>return</span> var5<span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>可以看到最后底层调用的是<code>compareAndSwapInt()</code>，如果 CAS 失败，会一直进行尝试</p>\n<h3 id=\"cas缺点\"> CAS缺点</h3>\n<p>CAS虽然很高效的解决了原子操作问题，但是CAS仍然存在三大问题。</p>\n<div><p>CAS缺点</p>\n<ol>\n<li>\n<p><strong>循环时间长开销很大</strong>：CAS 通常是配合无限循环一起使用的，我们可以看到 <code>getAndAddInt</code> 方法执行时，如果 CAS 失败，会一直进行尝试。如果 CAS 长时间一直不成功，可能会给 CPU 带来很大的开销。</p>\n</li>\n<li>\n<p><strong>只能保证一个变量的原子操作</strong>：当对一个变量执行操作时，我们可以使用<code>循环 CAS</code> 的方式来保证原子操作，但是对<code>多个变量</code>操作时，CAS 目前无法直接保证操作的原子性。但是我们可以通过以下两种办法来解决：1）使用互斥锁来保证原子性；2）将多个变量封装成对象，通过 <code>AtomicReference</code> 来保证原子性。</p>\n</li>\n<li>\n<p><strong>ABA问题</strong>：CAS 的使用流程通常如下：1）首先从地址 V 读取值 A；2）根据 A 计算目标值 B；3）通过 CAS 以原子的方式将地址 V 中的值从 A 修改为 B。</p>\n<p>但是在第1步中读取的值是A，并且在第3步修改成功了，我们就能说它的值在第1步和第3步之间没有被其他线程改变过了吗?</p>\n<p><strong>如果在这段期间它的值曾经被改成了B，后来又被改回为A</strong>，那CAS操作就会误认为它从来没有被改变过。这个漏洞称为CAS操作的“ABA”问题。Java并发包为了解决这个问题，提供了一个带有标记的原子引用类“<code>AtomicStampedReference</code>”，它可以通过控制<code>变量值的版本</code>来保证CAS的正确性。</p>\n<p>因此，在使用CAS前要考虑清楚“ABA”问题是否会影响<code>程序并发的正确性</code>，如果需要解决ABA问题，改用<code>传统的互斥同步</code>可能会比原子类更高效。</p>\n</li>\n</ol>\n</div>\n<h3 id=\"cas在jdk中的应用\"> CAS在JDK中的应用</h3>\n<p>在原子类变量中，如<code>java.util.concurrent.atomic</code>中的<code>AtomicXXX</code>，都使用了这些底层的JVM支持为数字类型的引用类型提供一种高效的CAS操作，而在<code>java.util.concurrent</code>中的大多数类在实现时都直接或间接的使用了这些原子变量类。</p>\n<p>Java 1.8中<code>AtomicInteger.incrementAndGet()</code>的实现源码为：</p>\n<div><pre><code>    <span>public</span> <span>final</span> <span>int</span> <span>incrementAndGet</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> unsafe<span>.</span><span>getAndAddInt</span><span>(</span><span>this</span><span>,</span> valueOffset<span>,</span> <span>1</span><span>)</span> <span>+</span> <span>1</span><span>;</span>\n    <span>}</span>\n\n\n    <span>public</span> <span>final</span> <span>int</span> <span>getAndAddInt</span><span>(</span><span>Object</span> var1<span>,</span> <span>long</span> var2<span>,</span> <span>int</span> var4<span>)</span> <span>{</span>\n        <span>int</span> var5<span>;</span>\n        <span>do</span> <span>{</span>\n            var5 <span>=</span> <span>this</span><span>.</span><span>getIntVolatile</span><span>(</span>var1<span>,</span> var2<span>)</span><span>;</span>\n        <span>}</span> <span>while</span><span>(</span><span>!</span><span>this</span><span>.</span><span>compareAndSwapInt</span><span>(</span>var1<span>,</span> var2<span>,</span> var5<span>,</span> var5 <span>+</span> var4<span>)</span><span>)</span><span>;</span>\n\n        <span>return</span> var5<span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>由此可见，<code>AtomicInteger.incrementAndGet</code>的实现用了<code>乐观锁</code>技术，调用了类<code>sun.misc.Unsafe</code>库里面的 <code>CAS</code>算法，用<code>CPU指令</code>来实现<code>无锁自增</code>。所以，<code>AtomicInteger.incrementAndGet</code>的自增比用<code>synchronized</code>的锁效率倍增。</p>\n<h2 id=\"原子变量-atomic\"> 原子变量（Atomic）</h2>\n<p>原子变量类( Atomics)是基于CAS实现的能够保障对共享变量进行read- modify- write 更新操作的原子性和可见性的一组工具类。这里所谓的read- modify- write更新操作,是指 对共享变量的更新不是一个简单的赋值操作,而是变量的新值依赖于变量的旧值,例如自 增操作“ count-+”。由于 volatile无法保障自增操作的原子性,而原子变量类的内部实现通 常借助一个 volatile变量并保障对该变量的read- modify-wite更新操作的原子性,因此它可以 被看作<code>增强型的 volatile变量</code>。原子变量类一共有12个,可以被分为4组。</p>\n<p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/Java-MultiThread-2/原子变量类.png\" alt=\"image-20211113154800436\" /></p>\n<ul>\n<li>字段更新器：解决ABA问题，<a href=\"https://www.cnblogs.com/54chensongxia/p/12167772.html\" target=\"_blank\" rel=\"noopener noreferrer\">参考</a></li>\n<li>引用型：主要针对引用的对象是否是原来的</li>\n</ul>\n<h3 id=\"atomiclong常用方法\"> AtomicLong常用方法</h3>\n<p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/Java-MultiThread-2/AtomicLong常用方法.png\" alt=\"image-20211113155240337\" /></p>\n<h3 id=\"字段更新器\"> 字段更新器</h3>\n<p>原子类型字段更新器在内部通过Unsafe类的native方法保证操作的原子性。</p>\n<p>关于原子类型字段更新器的使用需要注意以下几个方面：</p>\n<ul>\n<li>字段必须是volatile类型的，用于保证可见性。</li>\n<li>字段和字段更新器的访问类型(public/protected/private)必须一致。</li>\n<li>字段只能是实例变量，不能是类变量(static)。</li>\n<li>字段不能是final的变量，这样的字段不可修改。</li>\n<li>如果要处理Integer和Long类型，则需要使用AtomicReferenceFieldUpdater</li>\n</ul>\n<h3 id=\"set和lazyset\"> set和lazySet</h3>\n<p>参考</p>\n<ul>\n<li><a href=\"https://blog.csdn.net/szhlcy/article/details/102561224?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1.no_search_link&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1.no_search_link\" target=\"_blank\" rel=\"noopener noreferrer\">lazySet</a></li>\n</ul>\n<p>普通Atomic下的set保证了原子性和可见性，而lazySet只保证了原子性不保证可见性，目的是在有些情况下减少内存屏障所需要优化性能，底层只是简单地对变量普通写。</p>\n<p>set方法的设置操作在写操作的前后都加了内存屏障，因为AtomicInteger中的value是volatile修饰的，具体可以看前面的一篇博文Java并发volatile关键字的作用和汇编原理。而lazySet方法并不是直接的操作value字段，而是通过Unsafe类的putOrderedInt方法先通过初始化时候计算出的vlaue字段的偏移变量找到字段地址，然后调用本地方法进行操作的，在本地方法中只在写操作前面加了一个屏障，而后面没有加。</p>\n<h2 id=\"对象的发布和逸出\"> 对象的发布和逸出</h2>\n<h2 id=\"java线程同步机制总结\"> Java线程同步机制总结</h2>\n<p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/Java-MultiThread-2/java线程同步机制总结.png\" alt=\"image-20211113202234366\" /></p>\n<h2 id=\"线程池\"> 线程池</h2>\n<h3 id=\"线程池复用原理\"> 线程池复用原理</h3>\n<p>在线程池中，线程会从 workQueue 中读取任务来执行，最小的执行单位就是 Worker，Worker 实现了 Runnable 接口，重写了 run 方法，这个 run 方法是让每个线程去执行一个循环，在这个循环代码中，去判断是否有任务待执行，若有则直接去执行这个任务，因此线程数不会增加。</p>\n",
      "image": "https://blog-1300186248.cos.ap-shanghai.myqcloud.com/Java-MultiThread-2/%E4%BA%92%E6%96%A5%E9%94%81%E7%A4%BA%E6%84%8F%E5%9B%BE.png",
      "date_published": "2021-08-04T21:18:29.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": []
    },
    {
      "title": "Java多线程-JUC使用",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/java/java-MultiThread/Java-MultiThread-JUC/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/java/java-MultiThread/Java-MultiThread-JUC/",
      "content_html": "<p>TODO</p>\n<p>https://www.bilibili.com/video/BV1Kw411Z7dF</p>\n",
      "date_published": "2021-08-06T21:18:29.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": []
    },
    {
      "title": "Java多线程-关键字&锁",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/java/java-MultiThread/Java-MultiThread-keyword/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/java/java-MultiThread/Java-MultiThread-keyword/",
      "content_html": "<h2 id=\"sychronized-内部锁\"> Sychronized(内部锁)</h2>\n<p><a href=\"https://www.pdai.tech/md/java/thread/java-thread-x-key-synchronized.html\" target=\"_blank\" rel=\"noopener noreferrer\">关键字: synchronized详解</a></p>\n<h3 id=\"底层原理-objectmonitor\"> 底层原理：ObjectMonitor</h3>\n<p><a href=\"https://blog.csdn.net/zwjyyy1203/article/details/106217887\" target=\"_blank\" rel=\"noopener noreferrer\">jvm：ObjectMonitor源码</a></p>\n<h2 id=\"volatile\"> Volatile</h2>\n<h2 id=\"lock\"> Lock</h2>\n<p>方法</p>\n",
      "date_published": "2021-08-05T21:18:29.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": []
    },
    {
      "title": "Java-多线程并发",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/java/java-MultiThread/Java-MultiThread/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/java/java-MultiThread/Java-MultiThread/",
      "content_html": "<h2 id=\"_1-线程、程序、进程的基本概念\"> 1. 线程、程序、进程的基本概念</h2>\n<p><img src=\"./images/Java-MultiThread-1/Thread_program_process.png\" alt=\"线程、程序、进程\" /></p>\n<h2 id=\"_2-使用多线程可能带来什么问题\"> 2. 使用多线程可能带来什么问题?</h2>\n<p>并发编程的⽬的就是为了能提⾼程序的执⾏效率提⾼程序运⾏速度，但是并发编程并不总是能提⾼程序 运⾏速度的，⽽且并发编程可能会遇到很多问题，⽐如：<strong>内存泄漏、上下⽂切换、死锁还有受限于硬件 和软件的资源闲置问题</strong>。</p>\n<h2 id=\"_3-java多线程的四种实现方式-启动原理\"> 3. Java多线程的四种实现方式&amp;启动原理</h2>\n<p>参考</p>\n<blockquote>\n<ul>\n<li>https://www.cnblogs.com/felixzh/p/6036074.html</li>\n<li>https://www.jianshu.com/p/7950ea349dbb</li>\n</ul>\n</blockquote>\n<p><img src=\"./images/Java-MultiThread-1/Thread_Class_diagram.jpg\" alt=\"线程类图\" /></p>\n<p><strong>无返回值</strong>，run()返回为void</p>\n<ul>\n<li>继承Thread类：<strong>重写run()方法</strong></li>\n<li>实现Runnable接口：如果自己的类已经extends另一个类，就无法直接<strong>extends Thread</strong>，此时，可以实现一个Runnable接口，<strong>重写run方法</strong>，实现Runnable接口的实现类的实例对象作为Thread构造函数的target</li>\n</ul>\n<p><strong>有返回值</strong>，通过Callable接口，就要实现call方法，这个方法的返回值是Object</p>\n<ul>\n<li>实现<strong>Callable</strong>接口通过<strong>FutureTask</strong>包装器来创建Thread线程，调用Thread为</li>\n<li>线程池，使用<strong>ExecutorService</strong>、Callable、Future实现有返回结果的多线程</li>\n</ul>\n<h3 id=\"_3-1-线程启动原理\"> 3.1 线程启动原理</h3>\n<p>参考</p>\n<blockquote>\n<ul>\n<li>https://www.jianshu.com/p/8c16aeea7e1a</li>\n<li>https://www.cnblogs.com/xuyuanpeng/p/11050394.html</li>\n</ul>\n</blockquote>\n<p>Java多线程，皆始于Thread。Thread是多线程的根，每一个线程的开启都始于Thread的<code>start()</code>方法</p>\n<h4 id=\"_3-1-1-start-方法源码\"> 3.1.1 start()方法源码</h4>\n<div><pre><code> <span>/**\n     * Causes this thread to begin execution; the Java Virtual Machine\n     * calls the &lt;code>run&lt;/code> method of this thread.\n     * \n     * 1、start方法将导致this thread开始执行。由JVM调用this thread的run方法。\n     * \n     * The result is that two threads are running concurrently: the\n     * current thread (which returns from the call to the\n     * &lt;code>start&lt;/code> method) and the other thread (which executes its\n     * &lt;code>run&lt;/code> method).\n     * \n     * 2、结果是 调用start方法的当前线程 和 执行run方法的另一个线程 同时运行。\n     * \n     * It is never legal to start a thread more than once.\n     * In particular, a thread may not be restarted once it has completed\n     * execution.\n     *\n     * 3、多次启动线程永远不合法。 特别是，线程一旦完成执行就不会重新启动。\n     * \n     * @exception  IllegalThreadStateException  if the thread was already started.\n     * 如果线程已启动，则抛出异常。\n     * @see        #run()\n     * @see        #stop()\n     */</span>\n    <span>public</span> <span>synchronized</span> <span>void</span> <span>start</span><span>(</span><span>)</span> <span>{</span>\n        <span>/**\n         * This method is not invoked for the main method thread or \"system\"\n         * group threads created/set up by the VM. Any new functionality added\n         * to this method in the future may have to also be added to the VM.\n         * \n         * 4、对于由VM创建/设置的main方法线程或“system”组线程，不会调用此方法。 \n         *    未来添加到此方法的任何新功能可能也必须添加到VM中。\n         * \n         * A zero status value corresponds to state \"NEW\".\n         * 5、status=0 代表是 status 是 \"NEW\"。\n         */</span>\n        <span>if</span> <span>(</span>threadStatus <span>!=</span> <span>0</span><span>)</span>\n            <span>throw</span> <span>new</span> <span>IllegalThreadStateException</span><span>(</span><span>)</span><span>;</span>\n\n        <span>/* Notify the group that this thread is about to be started\n         * so that it can be added to the group's list of threads\n         * and the group's unstarted count can be decremented. \n         * \n         * 6、通知组该线程即将启动，以便将其添加到线程组的列表中，\n         *    并且减少线程组的未启动线程数递减。\n         * \n         * */</span>\n        group<span>.</span><span>add</span><span>(</span><span>this</span><span>)</span><span>;</span>\n\n        <span>boolean</span> started <span>=</span> <span>false</span><span>;</span>\n        <span>try</span> <span>{</span>\n            <span>//7、调用native方法，底层开启异步线程，并调用run方法。</span>\n            <span>start0</span><span>(</span><span>)</span><span>;</span>\n            started <span>=</span> <span>true</span><span>;</span>\n        <span>}</span> <span>finally</span> <span>{</span>\n            <span>try</span> <span>{</span>\n                <span>if</span> <span>(</span><span>!</span>started<span>)</span> <span>{</span>\n                    group<span>.</span><span>threadStartFailed</span><span>(</span><span>this</span><span>)</span><span>;</span>\n                <span>}</span>\n            <span>}</span> <span>catch</span> <span>(</span><span>Throwable</span> ignore<span>)</span> <span>{</span>\n                <span>/* do nothing. If start0 threw a Throwable then it will be passed up the call stack \n                 * 8、忽略异常。 如果start0抛出一个Throwable，它将被传递给调用堆栈。\n                 */</span>\n            <span>}</span>\n        <span>}</span>\n    <span>}</span>\n\n <span>//native方法，JVM创建并启动线程，并调用run方法</span>\n <span>private</span> <span>native</span> <span>void</span> <span>start0</span><span>(</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br></div></div><blockquote>\n<ul>\n<li><code>start</code>方法用<code>synchronized</code>修饰，为<code>同步方法</code>；</li>\n<li>虽然为同步方法，但不能避免多次调用问题，用<code>threadStatus</code>来记录线程状态，如果线程被多次start会抛出异常；threadStatus的状态由JVM控制。</li>\n<li>使用<code>Runnable</code>时，主线程无法捕获子线程中的异常状态。线程的异常，应在线程内部解决。</li>\n</ul>\n</blockquote>\n<h4 id=\"_3-1-2-run-方法源码\"> 3.1.2 run()方法源码</h4>\n<div><pre><code><span>/**\n     * If this thread was constructed using a separate\n     * &lt;code>Runnable&lt;/code> run object, then that\n     * &lt;code>Runnable&lt;/code> object's &lt;code>run&lt;/code> method is called;\n     * otherwise, this method does nothing and returns.\n     * &lt;p>\n     * Subclasses of &lt;code>Thread&lt;/code> should override this method.\n     *\n     * @see     #start()\n     * @see     #stop()\n     * @see     #Thread(ThreadGroup, Runnable, String)\n     */</span>\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>target <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n            target<span>.</span><span>run</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>run方法就很简单了，就是回调了Runable的run()接口。导致Thread写的@Overwrite void run() 方法直接是在主线程执行，导致阻塞了主线程。</p>\n<p>到此我们就知道了，start会使重写的run方法被虚拟机调用，是在子线程中执行的run方法。而直接调用线程的run方法，他是内部回调了run接口，导致直接执行了Runable.run的重写内容。相当于直接在主线程中执行。</p>\n<h3 id=\"_3-2-为什么我们调用-start-方法时会执行-run-方法-为什么我们不能直接调用-run-方法\"> 3.2 为什么我们调⽤ start() ⽅法时会执⾏ run() ⽅法，为什么我们不能直接调⽤ run() ⽅法？</h3>\n<p>new ⼀个 Thread，线程进⼊了新建状态;调⽤ start() ⽅法，会启动⼀个线程并使线程进⼊了就绪状 态，当分配到时间⽚后就可以开始运⾏了。 start() 会执⾏线程的相应准备⼯作，然后⾃动执⾏ run() ⽅法的内容，这是真正的多线程⼯作。 ⽽直接执⾏ run() ⽅法，会把 run ⽅法当成⼀个 main 主线程下的普通⽅法去执⾏，并不会在某个线程中执⾏它，所以这并不是多线程⼯作。 总结： 调⽤ start ⽅法⽅可启动线程并使线程进⼊就绪状态，⽽ run ⽅法只是 thread 的⼀个普通 ⽅法调⽤，还是在主线程⾥执⾏。</p>\n<h3 id=\"_3-3-继承thread类创建线程\"> 3.3 继承Thread类创建线程</h3>\n<p>Thread类本质上是实现了Runnable接口的一个实例，代表一个线程的实例。启动线程的唯一方法就是通过Thread类的start()实例方法。start()方法是一个native方法，它将启动一个新线程，并执行run()方法。这种方式实现多线程很简单，通过自己的类直接extend Thread，并复写run()方法，就可以启动新线程并执行自己定义的run()方法。例如：</p>\n<div><pre><code><span>public</span> <span>class</span> <span>MyThread</span> <span>extends</span> <span>Thread</span> <span>{</span>  \n　　<span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>  \n　　 <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"MyThread.run()\"</span><span>)</span><span>;</span>  \n　　<span>}</span>  \n<span>}</span>  \n \n<span>MyThread</span> myThread1 <span>=</span> <span>new</span> <span>MyThread</span><span>(</span><span>)</span><span>;</span>  \n<span>MyThread</span> myThread2 <span>=</span> <span>new</span> <span>MyThread</span><span>(</span><span>)</span><span>;</span>  \nmyThread1<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>  \nmyThread2<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>这种实现方式是显示的继承了Thread，但从类图中我们可以看到，Thread类本身就继承自Runnable，所以继承Thread的本质依然是实现Runnable接口定义的run方法。</p>\n<p>需要注意的是继承Thread方式，target对象为null，重写了run方法，导致方式1中的Thread原生的run方法失效，因此并不会调用到target.run()的逻辑，而是直接调用子类重写的run方法。</p>\n<p>因为java是单根继承，此方式一般不常用。</p>\n<h3 id=\"_3-4-实现runnable接口\"> 3.4 实现Runnable接口</h3>\n<p>实现run方法，接口的实现类的实例作为<strong>Thread</strong>的<strong>target</strong>作为参数传入带参的<strong>Thread</strong>构造函数，通过调用**start()**方法启动线程。适用于已经有继承的父类无法继承Thread类的时候</p>\n<div><pre><code><span>public</span> <span>class</span> <span>ThreadDemo02</span> <span>{</span>\n \n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span><span>{</span> \n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>Thread</span> t1 <span>=</span> <span>new</span> <span>Thread</span><span>(</span><span>new</span> <span>MyThread</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        t1<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span> \n    <span>}</span>\n<span>}</span>\n \n<span>class</span> <span>MyThread</span> <span>implements</span> <span>Runnable</span><span>{</span>\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>\n        <span>// TODO Auto-generated method stub</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span><span>+</span><span>\"-->我是通过实现接口的线程实现方式！\"</span><span>)</span><span>;</span>\n    <span>}</span>   \n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h3 id=\"_3-5-实现callable接口通过futuretask包装器来创建thread线程\"> 3.5 实现Callable接口通过FutureTask包装器来创建Thread线程</h3>\n<ul>\n<li>创建Callable接口的实现类 ，并实现Call方法</li>\n<li>创建Callable实现类的实现，使用FutureTask类包装Callable对象，该FutureTask对象封装了Callable对象的Call方法的返回值</li>\n<li>使用FutureTask对象作为Thread对象的target创建并启动线程</li>\n<li>调用FutureTask对象的get()来获取子线程执行结束的返回值</li>\n</ul>\n<div><pre><code><span>public</span> <span>class</span> <span>DemoCallable</span> <span>implements</span> <span>Callable</span><span><span>&lt;</span><span>String</span><span>></span></span><span>{</span>\n    <span>@Override</span>\n    <span>public</span> <span>String</span> <span>call</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>// TODO Auto-generated method stub</span>\n        <span>return</span> <span>null</span><span>;</span>\n    <span>}</span>\n    \n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>DemoCallable</span> c <span>=</span> <span>new</span> <span>DemoCallable</span><span>(</span><span>)</span><span>;</span>\n        <span>FutureTask</span><span><span>&lt;</span><span>String</span><span>></span></span> future <span>=</span> <span>new</span> <span>FutureTask</span><span><span>&lt;</span><span>></span></span><span>(</span>c<span>)</span><span>;</span> \n        <span>Thread</span> t <span>=</span> <span>new</span> <span>Thread</span><span>(</span>future<span>)</span><span>;</span>\n        t<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n        <span>.</span><span>.</span><span>.</span>\n        <span>String</span> result <span>=</span> future<span>.</span><span>get</span><span>(</span><span>)</span><span>;</span> <span>//同步获取返回结果</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>result<span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>这个方法里，明明没有看到run方法，没有看到Runnable，为什么说本质也是实现Runnable接口呢？</p>\n<p>回看开篇的类图，<code>FutureTask</code>实现了<code>RunnableFuture</code>，<code>RunnableFuture</code>则实现了<code>Runnable</code>和<code>Future</code>两个接口。因此构造Thread时，<code>FutureTask</code>还是被转型为<code>Runnable</code>使用。<strong>因此其本质还是实现Runnable接口。</strong></p>\n<h3 id=\"_3-6-通过线程池创建线程\"> 3.6 通过线程池创建线程</h3>\n<p>ExecutorService、Callable都是属于Executor框架。返回结果的线程是在JDK1.5中引入的新特征，还有Future接口也是属于这个框架，有了这种特征得到返回值就很方便了。\n通过分析可以知道，他同样也是实现了Callable接口，实现了Call方法，所以有返回值。这也就是正好符合了前面所说的两种分类</p>\n<p>执行Callable任务后，可以获取一个Future的对象，在该对象上调用get就可以获取到Callable任务返回的Object了。get方法是阻塞的，即：线程无返回结果，get方法会一直等待。</p>\n<div><pre><code><span>public</span> <span>class</span> <span>ThreadDemo05</span><span>{</span>\n \n    <span>private</span> <span>static</span> <span>int</span> POOL_NUM <span>=</span> <span>10</span><span>;</span>     <span>//线程池数量</span>\n \n    <span>/**\n     * @param args\n     * @throws InterruptedException \n     */</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>InterruptedException</span> <span>{</span>\n        <span>// TODO Auto-generated method stub</span>\n        <span>ExecutorService</span> executorService <span>=</span> <span>Executors</span><span>.</span><span>newFixedThreadPool</span><span>(</span><span>5</span><span>)</span><span>;</span>  \n        <span>for</span><span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i<span>&lt;</span>POOL_NUM<span>;</span> i<span>++</span><span>)</span>  \n        <span>{</span>  \n            <span>RunnableThread</span> thread <span>=</span> <span>new</span> <span>RunnableThread</span><span>(</span><span>)</span><span>;</span>\n \n            <span>//Thread.sleep(1000);</span>\n            executorService<span>.</span><span>execute</span><span>(</span>thread<span>)</span><span>;</span>  \n        <span>}</span>\n        <span>//关闭线程池</span>\n        executorService<span>.</span><span>shutdown</span><span>(</span><span>)</span><span>;</span> \n    <span>}</span>   \n \n<span>}</span>\n \n<span>class</span> <span>RunnableThread</span> <span>implements</span> <span>Runnable</span>  \n<span>{</span>     \n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span>  \n    <span>{</span>  \n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"通过线程池方式创建的线程：\"</span> <span>+</span> <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>\" \"</span><span>)</span><span>;</span>  \n \n    <span>}</span>  \n<span>}</span>  \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div><h2 id=\"_4-线程的生命周期和状态\"> 4. 线程的⽣命周期和状态?</h2>\n<p>Java 线程在运⾏的⽣命周期中的指定时刻只可能处于下⾯ 6 种不同状态的其中⼀个状态（图源《Java 并发编程艺术》4.1.4 节）。</p>\n<p><img src=\"./images/Java-MultiThread-1/Thread_life_cycle_state1.jpg\" alt=\"线程生命周期状态\" /></p>\n<p>线程在⽣命周期中并不是固定处于某⼀个状态⽽是随着代码的执⾏在不同状态之间切换。Java 线程状 态变迁如下图所示（图源《Java 并发编程艺术》4.1.4 节）：</p>\n<p><img src=\"./images/Java-MultiThread-1/Thread_life_cycle_state2.jpg\" alt=\"线程生命周期状态2\" /></p>\n<p>由上图可以看出：线程创建之后它将处于 <strong>NEW（新建） 状态</strong>，<strong>调⽤ start() ⽅法后开始运⾏</strong>，线程 这时候处于 <strong>READY（可运⾏） 状态</strong>。可运⾏状态的线程获得了 **CPU 时间⽚（timeslice）**后就处于 <strong>RUNNING（运⾏）</strong> 状态。</p>\n<p>当线程执⾏ wait() ⽅法之后，线程进⼊ WAITING（等待） 状态。进⼊等待状态的线程需要依靠其他 线程的通知才能够返回到运⾏状态，⽽ TIME_WAITING(超时等待) 状态相当于在等待状态的基础上增加 了超时限制，⽐如通过 sleep（long millis） ⽅法或 wait（long millis） ⽅法可以将 Java 线程置于 TIMED WAITING 状态。当超时时间到达后 Java 线程将会返回到 RUNNABLE 状态。当线程调 ⽤同步⽅法时，在没有获取到锁的情况下，线程将会进⼊到 BLOCKED（阻塞） 状态。线程在执⾏ Runnable 的 run() ⽅法之后将会进⼊到 TERMINATED（终⽌） 状态。</p>\n<h2 id=\"_5-什么是上下文切换\"> 5. 什么是上下文切换?</h2>\n<ul>\n<li>多线程编程中⼀般线程的个数都⼤于 CPU 核⼼的个数，⽽⼀个 CPU 核⼼在任意时刻只能被⼀个线程使 ⽤，为了让这些线程都能得到有效执⾏，CPU 采取的策略是为每个线程分配时间⽚并轮转的形式。当⼀ 个线程的时间⽚⽤完的时候就会重新处于就绪状态让给其他线程使⽤，这个过程就属于⼀次上下⽂切 换。</li>\n<li>概括来说就是：当前任务在执⾏完 CPU 时间⽚切换到另⼀个任务之前会先保存⾃⼰的状态，以便下次 再切换回这个任务时，可以再加载这个任务的状态。<strong>任务从保存到再加载的过程就是⼀次上下⽂切换</strong>。</li>\n<li>上下⽂切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒⼏⼗上百次的切换 中，每次切换都需要纳秒量级的时间。所以，上下⽂切换对系统来说意味着消耗⼤量的 CPU 时间，事 实上，可能是操作系统中时间消耗最⼤的操作。</li>\n<li>Linux 相⽐与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有⼀项就是，其上下⽂切换 和模式切换的时间消耗⾮常少。</li>\n</ul>\n<h2 id=\"_6-什么是线程死锁-如何避免死锁\"> 6. 什么是线程死锁?如何避免死锁?</h2>\n<p>线程死锁描述的是这样⼀种情况：多个线程同时被阻塞，它们中的⼀个或者全部都在等待某个资源被释 放。由于线程被⽆限期地阻塞，因此程序不可能正常终⽌。 如下图所示，线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对⽅的资源，所以这两个线 程就会互相等待⽽进⼊死锁状态。</p>\n<h3 id=\"_6-1-产生死锁必须具备以下四个条件\"> 6.1 产⽣死锁必须具备以下四个条件</h3>\n<ul>\n<li>**互斥条件：**该资源任意⼀个时刻只由⼀个线程占⽤。</li>\n<li>**请求与保持条件：**⼀个进程因请求资源⽽阻塞时，对已获得的资源保持不放。</li>\n<li>**不剥夺条件：**线程已获得的资源在末使⽤完之前不能被其他线程强⾏剥夺，只有⾃⼰使⽤完毕后 才释放资源。</li>\n<li>**循环等待条件：**若⼲进程之间形成⼀种头尾相接的循环等待资源关系。</li>\n</ul>\n<h3 id=\"_6-2-如何避免线程死锁\"> 6.2 如何避免线程死锁?</h3>\n<p>只要破坏产⽣死锁的四个条件中的其中⼀个就可以了</p>\n<ol>\n<li>**破坏互斥条件 ：**这个条件我们没有办法破坏，因为我们⽤锁本来就是想让他们互斥的（临界资 源需要互斥访问）。</li>\n<li>**破坏请求与保持条件 ：**⼀次性申请所有的资源。</li>\n<li>**破坏不剥夺条件 ：**占⽤部分资源的线程进⼀步申请其他资源时，如果申请不到，可以主动释放 它占有的资源。</li>\n<li>**破坏循环等待条件 ：**靠按序申请资源来预防。按某⼀顺序申请资源，释放资源则反序释放。破 坏循环等待条件。</li>\n</ol>\n<h2 id=\"_7-说说-sleep-方法和-wait-方法区别和共同点\"> 7. 说说 sleep() ⽅法和 wait() ⽅法区别和共同点?</h2>\n<ul>\n<li>两者最主要的区别在于：<strong>sleep ⽅法没有释放锁，⽽ wait ⽅法释放了锁 。</strong></li>\n<li>两者都可以暂停线程的执⾏。 Wait 通常被⽤于线程间交互/通信，sleep 通常被⽤于暂停执⾏。</li>\n<li>wait() ⽅法被调⽤后，线程不会⾃动苏醒，需要别的线程调⽤同⼀个对象上的 notify() 或者 notifyAll() ⽅法。sleep() ⽅法执⾏完成后，线程会⾃动苏醒。或者可以使⽤ wait(long timeout)超时后线程会⾃动苏醒。</li>\n</ul>\n<h3 id=\"_7-1-详细\"> 7.1 详细</h3>\n<ol>\n<li>原理不同，<strong>sleep（）方法是Thread类的静态方法</strong>，是线程用来控制自身流程的，它会使此线程暂停执行一段时间，而把执行机会让给其他线程，等到计时时间一到，此线程会自动“苏醒”。例如，当线程执行报时功能时，每一秒钟打印一个时间，那么此时就需要在打印方法前面加上一个Sleep()方法，以便让自己每隔1s执行一次，该过程如同闹钟一样，<strong>而wait（）方法是object类的方法，用于线程间的通信</strong>，这个方法会使当前拥有该对象锁的进程等待，直到其它线程调用notify()方法（或notifyALL方法）时才“醒过来”，不过，开发人员也可以给它指定一个时间，自动“醒”过来。与wait()方法配套的方法还有notify（）方法和notifyALL()方法。</li>\n<li>对锁的处理机制不同，由于sleep（）方法的主要作用是让线程暂停执行一段时间，时间一到则自动恢复，不涉及线程间的通信，因此，调用sleep（）方法并不会释放锁， 而wait()方法则不同，当调用wan()方法后，线程会释放掉它所占用的锁，从而使线程所在对象中的其他synchronized数据可被别的线程使用。举个简单的例子，如果小明拿遥控器的期间，可以用自己的sleep()方法每隔10min调一次频道，而在这10min里，遥控器还在他的手里。</li>\n<li>使用的区域不同。由于wait()方法的特殊意义，因此，它必须放在同步控制方法或同步语句块中使用，而 sleep（）方法则可以放在任何地方使用。\nsleep（）方法必须捕获异常，而wait（）、notify（）以及notifyALL()不需要捕获异常，在sleep()的过程中，有可能被其他对象调用它的interrupt（），产生interruptException异常。\n由于sleep不会释放“锁标志”，容易导致死锁问题的发生，因此，一般情况下，不推荐使用sleep（）方法，而推荐使用wait（）方法。</li>\n</ol>\n<p>new ⼀个 Thread，线程进⼊了新建状态;调⽤ start() ⽅法，会启动⼀个线程并使线程进⼊了就绪状 态，当分配到时间⽚后就可以开始运⾏了。 start() 会执⾏线程的相应准备⼯作，然后⾃动执⾏ run() ⽅法的内容，这是真正的多线程⼯作。 ⽽直接执⾏ run() ⽅法，会把 run ⽅法当成⼀个 main 线程下的普通⽅法去执⾏，并不会在某个线程中执⾏它，所以这并不是多线程⼯作。 总结： 调⽤ start ⽅法⽅可启动线程并使线程进⼊就绪状态，⽽ run ⽅法只是 thread 的⼀个普通 ⽅法调⽤，还是在主线程⾥执⾏。</p>\n<h2 id=\"_9-synchronized-关键字\"> 9. synchronized 关键字</h2>\n<p>synchronized关键字解决的是多个线程之间访问资源的同步性，synchronized关键字可以保证被它修饰 的⽅法或者代码块在任意时刻只能有⼀个线程执⾏。另外，在 Java 早期版本中，synchronized属于重量级锁，效率低下，<strong>因为监视器锁（monitor）是依 赖于底层的操作系统的 Mutex Lock 来实现的，Java 的线程是映射到操作系统的原⽣线程之上的</strong>。如 果要挂起或者唤醒⼀个线程，都需要操作系统帮忙完成，⽽操作系统实现线程之间的切换时需要从⽤户 态转换到内核态，这个状态之间的转换需要相对⽐较⻓的时间，时间成本相对较⾼，这也是为什么早期 的 synchronized 效率低的原因。庆幸的是在 Java 6 之后 Java 官⽅对从 JVM 层⾯对synchronized 较⼤优化，所以现在的 synchronized 锁效率也优化得很不错了。JDK1.6对锁的实现引⼊了⼤量的优化，如<strong>⾃旋锁、适应性⾃旋锁、锁消除、锁粗化、偏向锁、轻量级锁</strong>等技术来减少锁操作的开销。</p>\n<h3 id=\"_9-1-三种使用方式\"> 9.1 三种使用方式</h3>\n<ul>\n<li>**修饰实例方法，**作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁</li>\n<li>**修饰静态方法，**作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁 。也就是给当前类加锁，会作\n用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是类成员（ static 表明这是该类的一个静态\n资源，不管new了多少个对象，只有一份，所以对该类的所有对象都加了锁）。所以如果一个线程A调用一个实\n例对象的非静态 synchronized 方法，而线程B需要调用这个实例对象所属类的静态 synchronized 方法，是允\n许的，不会发生互斥现象，因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态\nsynchronized 方法占用的锁是当前实例对象锁。</li>\n<li>**修饰代码块，**指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。 和 synchronized 方\n法一样，synchronized(this)代码块也是锁定当前对象的。synchronized 关键字加到 static 静态方法和\nsynchronized(class)代码块上都是是给 Class 类上锁。这里再提一下：synchronized关键字加到非 static 静态\n方法上是给对象实例上锁。</li>\n</ul>\n<h3 id=\"_9-2-synchronized底层实现\"> 9.2 synchronized底层实现</h3>\n<h4 id=\"_9-2-1-synchronized-同步语句块的情况\"> 9.2.1 synchronized 同步语句块的情况</h4>\n<div><pre><code><span>public</span> <span>class</span> <span>SynchronizedDemo</span> <span>{</span>\n <span>public</span> <span>void</span> <span>method</span><span>(</span><span>)</span> <span>{</span>\n <span>synchronized</span> <span>(</span><span>this</span><span>)</span> <span>{</span>\n <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"synchronized 代码块\"</span><span>)</span><span>;</span>\n <span>}</span>\n <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p><img src=\"./images/Java-MultiThread-1/synchronized_decompilation.jpg\" alt=\"synchronized反编译\" /></p>\n<p>synchronized 同步语句块的实现使⽤的是 <strong>monitorenter</strong> 和 <strong>monitorexit</strong> 指令，其中 <strong>monitorenter</strong> 指令指向同步代码块的开始位置，<strong>monitorexit</strong> 指令则指明同步代码块的结束位置。 当执⾏ monitorenter 指令时，线程试图获取锁也就是获取 monitor(<strong>monitor对象存在于每个Java对象的对象 头中，synchronized 锁便是通过这种⽅式获取锁的，也是为什么Java中任意对象可以作为锁的原因</strong>) 的持有权。当计数器为0则可以成功获取，获取后将锁计数器设为1也就是加1。相应的在执⾏ monitorexit 指令后，将锁计数器设为0，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞 等待，直到锁被另外⼀个线程释放为⽌。</p>\n<h4 id=\"_9-2-2-synchronized-修饰方法的的情况\"> 9.2.2 synchronized 修饰⽅法的的情况</h4>\n<div><pre><code><span>public</span> <span>class</span> <span>SynchronizedDemo2</span> <span>{</span>\n <span>public</span> <span>synchronized</span> <span>void</span> <span>method</span><span>(</span><span>)</span> <span>{</span>\n <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"synchronized ⽅法\"</span><span>)</span><span>;</span>\n <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><img src=\"./images/Java-MultiThread-1/synchronized_method_decompilation.jpg\" alt=\"synchronized方法反编译\" /></p>\n<p>synchronized 修饰的⽅法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是 ACC_SYNCHRONIZED 标识，该标识指明了该⽅法是⼀个同步⽅法，<strong>JVM 通过该 ACC_SYNCHRONIZED 访问 标志来辨别⼀个⽅法是否声明为同步⽅法</strong>，从⽽执⾏相应的同步调⽤。</p>\n<h3 id=\"_9-3-说说-jdk1-6-之后的synchronized-关键字底层做了哪些优化-可以详细介绍一下这些优化吗\"> 9.3 说说 JDK1.6 之后的synchronized 关键字底层做了哪些优化，可以详细介绍⼀下这些优化吗</h3>\n<p>参考</p>\n<blockquote>\n<ul>\n<li>https://gitee.com/SnailClimb/JavaGuide/blob/master/docs/java/Multithread/synchronized.md</li>\n</ul>\n</blockquote>\n<p>JDK1.6 对锁的实现引入了大量的优化，如<strong>偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化</strong>等技术来减少锁操作的开销。</p>\n<p>锁主要存在四中状态，依次是：</p>\n<ul>\n<li><strong>无锁状态</strong></li>\n<li><strong>偏向锁状态</strong></li>\n<li><strong>轻量级锁状态</strong></li>\n<li><strong>重量级锁状态</strong></li>\n</ul>\n<p>他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。</p>\n<h4 id=\"_1-偏向锁\"> ① 偏向锁</h4>\n<p><strong>引入偏向锁的目的和引入轻量级锁的目的很像，他们都是为了没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。但是不同是：轻量级锁在无竞争的情况下使用 CAS 操作去代替使用互斥量。而偏向锁在无竞争的情况下会把整个同步都消除掉</strong>。</p>\n<p>偏向锁的“偏”就是偏心的偏，它的意思是会偏向于第一个获得它的线程，如果在接下来的执行中，该锁没有被其他线程获取，那么持有偏向锁的线程就不需要进行同步！关于偏向锁的原理可以查看《深入理解Java虚拟机：JVM高级特性与最佳实践》第二版的13章第三节锁优化。</p>\n<p>但是对于锁竞争比较激烈的场合，偏向锁就失效了，因为这样场合极有可能每次申请锁的线程都是不相同的，因此这种场合下不应该使用偏向锁，否则会得不偿失，需要注意的是，偏向锁失败后，并不会立即膨胀为重量级锁，而是先升级为轻量级锁。</p>\n<h4 id=\"_2-轻量级锁\"> ② 轻量级锁</h4>\n<p>倘若偏向锁失败，虚拟机并不会立即升级为重量级锁，它还会尝试使用一种称为轻量级锁的优化手段(1.6之后加入的)。<strong>轻量级锁不是为了代替重量级锁，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗，因为使用轻量级锁时，不需要申请互斥量。另外，轻量级锁的加锁和解锁都用到了CAS操作。</strong> 关于轻量级锁的加锁和解锁的原理可以查看《深入理解Java虚拟机：JVM高级特性与最佳实践》第二版的13章第三节锁优化。</p>\n<p><strong>轻量级锁能够提升程序同步性能的依据是“对于绝大部分锁，在整个同步周期内都是不存在竞争的”，这是一个经验数据。如果没有竞争，轻量级锁使用 CAS 操作避免了使用互斥操作的开销。但如果存在锁竞争，除了互斥量开销外，还会额外发生CAS操作，因此在有锁竞争的情况下，轻量级锁比传统的重量级锁更慢！如果锁竞争激烈，那么轻量级将很快膨胀为重量级锁！</strong></p>\n<h4 id=\"_3-自旋锁和自适应自旋\"> ③ 自旋锁和自适应自旋</h4>\n<p>轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的优化手段。</p>\n<p>互斥同步对性能最大的影响就是阻塞的实现，因为挂起线程/恢复线程的操作都需要转入内核态中完成（用户态转换到内核态会耗费时间）。</p>\n<p><strong>一般线程持有锁的时间都不是太长，所以仅仅为了这一点时间去挂起线程/恢复线程是得不偿失的。</strong> 所以，虚拟机的开发团队就这样去考虑：“我们能不能让后面来的请求获取锁的线程等待一会而不被挂起呢？看看持有锁的线程是否很快就会释放锁”。<strong>为了让一个线程等待，我们只需要让线程执行一个忙循环（自旋），这项技术就叫做自旋</strong>。</p>\n<p>百度百科对自旋锁的解释：</p>\n<blockquote>\n<p>何谓自旋锁？它是为实现保护共享资源而提出一种锁机制。其实，自旋锁与互斥锁比较类似，它们都是为了解决对某项资源的互斥使用。无论是互斥锁，还是自旋锁，在任何时刻，最多只能有一个保持者，也就说，在任何时刻最多只能有一个执行单元获得锁。但是两者在调度机制上略有不同。对于互斥锁，如果资源已经被占用，资源申请者只能进入睡眠状态。但是自旋锁不会引起调用者睡眠，如果自旋锁已经被别的执行单元保持，调用者就一直循环在那里看是否该自旋锁的保持者已经释放了锁，&quot;自旋&quot;一词就是因此而得名。</p>\n</blockquote>\n<p>自旋锁在 JDK1.6 之前其实就已经引入了，不过是默认关闭的，需要通过<code>--XX:+UseSpinning</code>参数来开启。JDK1.6及1.6之后，就改为默认开启的了。需要注意的是：自旋等待不能完全替代阻塞，因为它还是要占用处理器时间。如果锁被占用的时间短，那么效果当然就很好了！反之，相反！自旋等待的时间必须要有限度。如果自旋超过了限定次数任然没有获得锁，就应该挂起线程。<strong>自旋次数的默认值是10次，用户可以修改<code>--XX:PreBlockSpin</code>来更改</strong>。</p>\n<p>另外,<strong>在 JDK1.6 中引入了自适应的自旋锁。自适应的自旋锁带来的改进就是：自旋的时间不在固定了，而是和前一次同一个锁上的自旋时间以及锁的拥有者的状态来决定，虚拟机变得越来越“聪明”了</strong>。</p>\n<h4 id=\"_4-锁消除\"> ④ 锁消除</h4>\n<p>锁消除理解起来很简单，它指的就是虚拟机即使编译器在运行时，如果检测到那些共享数据不可能存在竞争，那么就执行锁消除。锁消除可以节省毫无意义的请求锁的时间。</p>\n<h4 id=\"_5-锁粗化\"> ⑤ 锁粗化</h4>\n<p>原则上，我们在编写代码的时候，总是推荐将同步块的作用范围限制得尽量小，——直在共享数据的实际作用域才进行同步，这样是为了使得需要同步的操作数量尽可能变小，如果存在锁竞争，那等待线程也能尽快拿到锁。</p>\n<p>大部分情况下，上面的原则都是没有问题的，但是如果一系列的连续操作都对同一个对象反复加锁和解锁，那么会带来很多不必要的性能消耗。</p>\n<h3 id=\"_9-4-synchronized-和-reentrantlock-的对比\"> 9.4 Synchronized 和 ReenTrantLock 的对比</h3>\n<h4 id=\"_1-两者都是可重入锁\"> ① 两者都是可重入锁</h4>\n<p>两者都是可重入锁。“可重入锁”概念是：自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。</p>\n<h4 id=\"_2-synchronized-依赖于-jvm-而-reentrantlock-依赖于-api\"> ② synchronized 依赖于 JVM 而 ReenTrantLock 依赖于 API</h4>\n<p>synchronized 是依赖于 JVM 实现的，前面我们也讲到了 虚拟机团队在 JDK1.6 为 synchronized 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。ReenTrantLock 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock 方法配合 try/finally 语句块来完成），所以我们可以通过查看它的源代码，来看它是如何实现的。</p>\n<h4 id=\"_3-reentrantlock-比-synchronized-增加了一些高级功能\"> ③ ReenTrantLock 比 synchronized 增加了一些高级功能</h4>\n<p>相比synchronized，ReenTrantLock增加了一些高级功能。主要来说主要有三点：</p>\n<blockquote>\n<ol>\n<li>等待可中断</li>\n<li>可指定公平和非公平锁</li>\n<li>可实现选择性通知（锁可以绑定多个条件）</li>\n</ol>\n</blockquote>\n<div><p>ReenTrantLock 比 synchronized 增加了一些高级功能</p>\n<ul>\n<li><strong>ReenTrantLock提供了一种能够中断等待锁的线程的机制</strong>，通过**lock.lockInterruptibly()**来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。</li>\n<li><strong>ReenTrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。</strong> ReenTrantLock默认情况是非公平的，可以通过 ReenTrantLock类的<code>ReentrantLock(boolean fair)</code>构造方法来制定是否是公平的。</li>\n<li><strong>synchronized关键字与wait()和notify/notifyAll()方法相结合可以实现等待/通知机制</strong>，ReentrantLock类当然也可以实现，但是需要借助于Condition接口与newCondition() 方法。Condition是JDK1.5之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个Lock对象中可以创建多个Condition实例（即对象监视器），<strong>线程对象可以注册在指定的Condition中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用notify/notifyAll()方法进行通知时，被通知的线程是由 JVM 选择的，用ReentrantLock类结合Condition实例可以实现“选择性通知”</strong> ，这个功能非常重要，而且是Condition接口默认提供的。而synchronized关键字就相当于整个Lock对象中只有一个Condition实例，所有的线程都注册在它一个身上。如果执行notifyAll()方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，而Condition实例的signalAll()方法 只会唤醒注册在该Condition实例中的所有等待线程。</li>\n</ul>\n<p>如果你想使用上述功能，那么选择ReenTrantLock是一个不错的选择。</p>\n<p><strong>synchronized 异常就会释放锁，而 ReenTrantLock 异常需要在 finally 里 unlock</strong></p>\n</div>\n<h4 id=\"_4-性能已不是选择标准\"> ④ 性能已不是选择标准</h4>\n<p>在JDK1.6之前，synchronized 的性能是比 ReenTrantLock 差很多。<strong>具体表示为：synchronized 关键字吞吐量随线程数的增加，下降得非常严重。而ReenTrantLock 基本保持一个比较稳定的水平</strong>。我觉得这也侧面反映了， synchronized 关键字还有非常大的优化余地。后续的技术发展也证明了这一点，我们上面也讲了在 JDK1.6 之后 JVM 团队对 synchronized 关键字做了很多优化。<strong>JDK1.6 之后，synchronized 和 ReenTrantLock 的性能基本是持平了。所以网上那些说因为性能才选择 ReenTrantLock 的文章都是错的！JDK1.6之后，性能已经不是选择synchronized和ReenTrantLock的影响因素了！而且虚拟机在未来的性能改进中会更偏向于原生的synchronized，所以还是提倡在synchronized能满足你的需求的情况下，优先考虑使用synchronized关键字来进行同步！优化后的synchronized和ReenTrantLock一样，在很多地方都是用到了CAS操作</strong>。</p>\n<h2 id=\"_10-volatile关键字\"> 10. volatile关键字</h2>\n<p>参考</p>\n<blockquote>\n<ul>\n<li><a href=\"https://www.cnblogs.com/dolphin0520/p/3920373.html\" target=\"_blank\" rel=\"noopener noreferrer\">Java并发编程：volatile关键字解析</a></li>\n<li><a href=\"https://www.cnblogs.com/java1024/p/9031560.html\" target=\"_blank\" rel=\"noopener noreferrer\">Java面试官最常问的volatile关键字</a></li>\n</ul>\n</blockquote>\n<h3 id=\"_10-1-两大特性\"> 10.1 两大特性</h3>\n<ul>\n<li>保证了不同线程对该变量操作的<strong>内存可见性</strong></li>\n<li>禁止指令重排序</li>\n</ul>\n<h3 id=\"_10-2-java内存模型与volatile\"> 10.2 Java内存模型与volatile</h3>\n<p>在 <strong>JDK1.2</strong> 之前，Java的内存模型实现总是从主存（即共享内存）读取变量，是不需要进⾏特别的注意 的。⽽在当前的 Java 内存模型下，线程可以把变量保存本地内存（⽐如机器的寄存器）中，⽽不是直 接在主存中进⾏读写。<strong>这就可能造成⼀个线程在主存中修改了⼀个变量的值，⽽另外⼀个线程还继续使 ⽤它在寄存器中的变量值的拷⻉，造成数据的不⼀致</strong>。</p>\n<p><img src=\"./images/Java-MultiThread-1/Java_memory_model_and_volatile_1.jpg\" alt=\"Java内存模型和volatile1\" /></p>\n<p>要解决这个问题，就需要把变量声明为<strong>volatile</strong>，这就指示 JVM，这个变量是不稳定的，每次使⽤它都 到主存中进⾏读取。 说⽩了， <strong>volatile 关键字的主要作⽤就是保证变量的可⻅性然后还有⼀个作⽤是防⽌指令重排序。</strong></p>\n<p><img src=\"./images/Java-MultiThread-1/Java_memory_model_and_volatile_2.jpg\" alt=\"Java内存模型和volatile2\" /></p>\n<h3 id=\"_10-3-并发编程的三个重要特性\"> 10.3 并发编程的三个重要特性</h3>\n<ol>\n<li><strong>原⼦性 :</strong> ⼀个的操作或者多次操作，要么所有的操作全部都得到执⾏并且不会收到任何因素的 ⼲扰⽽中断，要么所有的操作都执⾏，要么都不执⾏。 <strong>synchronized 可以保证代码⽚段的原⼦性。</strong></li>\n<li>**可⻅性 ：**当⼀个变量对共享变量进⾏了修改，那么另外的线程都是⽴即可以看到修改后的最新 值。 <strong>volatile 关键字可以保证共享变量的可⻅性。</strong></li>\n<li>**有序性 ：**代码在执⾏的过程中的先后顺序，Java 在编译器以及运⾏期间的优化，代码的执⾏顺序未必就是编写代码时候的顺序。 <strong>volatile 关键字可以禁⽌指令进⾏重排序优化。</strong></li>\n</ol>\n<h3 id=\"_10-4-内存可见性\"> 10.4 内存可见性</h3>\n<p><img src=\"./images/Java-MultiThread-1/Memory_visibility.jpg\" alt=\"内存可见性\" /></p>\n<h2 id=\"_11-synchronized-volatile-关键字的区别\"> 11. synchronized | volatile 关键字的区别</h2>\n<ul>\n<li>volatile关键字是线程同步的轻量级实现，所以volatile性能肯定⽐synchronized关键字要好。 <strong>但是volatile关键字只能⽤于变量⽽synchronized关键字可以修饰⽅法以及代码块。</strong> synchronized关键字在JavaSE1.6之后进⾏了主要包括为了减少获得锁和释放锁带来的性能消耗 ⽽引⼊的偏向锁和轻量级锁以及其它各种优化之后执⾏效率有了显著提升，实际开发中使⽤ synchronized 关键字的场景还是更多⼀些。</li>\n<li><strong>多线程访问volatile关键字不会发⽣阻塞，⽽synchronized关键字可能会发⽣阻塞</strong></li>\n<li><strong>volatile关键字能保证数据的可⻅性，但不能保证数据的原⼦性。synchronized关键字两者都能 保证。</strong></li>\n<li><strong>volatile关键字主要⽤于解决变量在多个线程之间的可⻅性，⽽ synchronized关键字解决的是 多个线程之间访问资源的同步性。</strong></li>\n</ul>\n<h2 id=\"_12-java线程池\"> 12. Java线程池</h2>\n<h3 id=\"_12-1-好处\"> 12.1 好处</h3>\n<ul>\n<li>降低资源消耗。通过重复利⽤已创建的线程降低线程创建和销毁造成的消耗。</li>\n<li>提⾼响应速度。当任务到达时，任务可以不需要的等到线程创建就能⽴即执⾏。</li>\n<li>提⾼线程的可管理性。线程是稀缺资源，如果⽆限制的创建，不仅会消耗系统资源，还会降低系 统的稳定性，使⽤线程池可以进⾏统⼀的分配，调优和监控。</li>\n</ul>\n<h3 id=\"_12-2-创建线程池\"> 12.2 创建线程池</h3>\n<p>参考</p>\n<blockquote>\n<ul>\n<li>https://www.cnblogs.com/teach/p/10903164.html</li>\n</ul>\n</blockquote>\n<p>《阿⾥巴巴Java开发⼿册》中强制<strong>线程池不允许使⽤ Executors 去创建</strong>，⽽是通过 <strong>ThreadPoolExecutor</strong> 的⽅式，这样的处理⽅式让写的同学更加明确线程池的运⾏规则，规避资源耗尽的⻛险</p>\n<h4 id=\"_12-2-1-executors创建线程池弊端\"> 12.2.1 Executors创建线程池弊端</h4>\n<ul>\n<li><strong>FixedThreadPool</strong> 和 <strong>SingleThreadExecutor</strong> ： 允许请求的队列⻓度为 <strong>Integer.MAX_VALUE</strong> ，可能堆积⼤量的请求，从⽽导致OOM。</li>\n<li><strong>CachedThreadPool</strong> 和 <strong>ScheduledThreadPool</strong> ： 允许创建的线程数量为 <strong>Integer.MAX_VALUE</strong> ，可能会创建⼤量线程，从⽽导致OOM。</li>\n</ul>\n<h4 id=\"_12-2-2-第一种方式-threadpoolexecutor的方式\"> 12.2.2 第一种方式：ThreadPoolExecutor的方式</h4>\n<p><img src=\"./images/Java-MultiThread-1/ThreadPoolExecutor_construction.jpg\" alt=\"ThreadPoolExecutor构造方法\" /></p>\n<div><pre><code><span>public</span> <span>ThreadPoolExecutor</span><span>(</span><span>int</span> corePoolSize<span>,</span>\n                              <span>int</span> maximumPoolSize<span>,</span>\n                              <span>long</span> keepAliveTime<span>,</span>\n                              <span>TimeUnit</span> unit<span>,</span>\n                              <span>BlockingQueue</span><span><span>&lt;</span><span>Runnable</span><span>></span></span> workQueue<span>)</span> <span>{</span>\n        <span>this</span><span>(</span>corePoolSize<span>,</span> maximumPoolSize<span>,</span> keepAliveTime<span>,</span> unit<span>,</span> workQueue<span>,</span>\n             <span>Executors</span><span>.</span><span>defaultThreadFactory</span><span>(</span><span>)</span><span>,</span> defaultHandler<span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>在这个方法中调用了另外的一个构造方法，即上图中四个构造方法中的第四个，从源码中得知，一个线程池包含的属性共有corePoolSize、maximumPoolSize、keepAliveTime、unit、workQueue、threadFactory、handler七个</p>\n<p>需要传入的参数说明</p>\n<table>\n<thead>\n<tr>\n<th>序号</th>\n<th>名称</th>\n<th>类型</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>corePoolSize</td>\n<td>int</td>\n<td>线程池的核心线程数</td>\n</tr>\n<tr>\n<td>2</td>\n<td>maximumPoolSize</td>\n<td>int</td>\n<td>线程池的最大线程数</td>\n</tr>\n<tr>\n<td>3</td>\n<td>keepAliveTime</td>\n<td>long</td>\n<td>线程池空闲时线程的存活时长</td>\n</tr>\n<tr>\n<td>4</td>\n<td>unit</td>\n<td>TimeUnit</td>\n<td>线程存活时长时间单位</td>\n</tr>\n<tr>\n<td>5</td>\n<td>workQueue</td>\n<td>BlockingQueue&lt;Runnable&gt;</td>\n<td>线程等待队列</td>\n</tr>\n<tr>\n<td>6</td>\n<td>threadFactory</td>\n<td>ThreadFactory</td>\n<td>线程池创建线程的工厂</td>\n</tr>\n<tr>\n<td>7</td>\n<td>handler</td>\n<td>RejectedExecutionHandler</td>\n<td>拒绝策略</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><strong>handler</strong>：在队列（workQueue）和线程池达到最大线程数（maximumPoolSize）均满时仍有任务的情况下的处理方式；</li>\n</ul>\n<div><p>规则</p>\n<ul>\n<li>线程池的线程数量长期维持在 <code>corePoolSize</code> 个（核心线程数量）</li>\n<li>线程池的线程数量最大可以扩展到 <code>maximumPoolSize</code> 个</li>\n<li>在 <code>corePoolSize</code> ~ <code>maximumPoolSize</code> 这个区间的线程，一旦空闲超过<code>keepAliveTime</code>时间，就会被杀掉（时间单位）</li>\n<li>送来工作的线程数量超过最大数以后，送到 <code>workQueue</code> 里面待业</li>\n<li>待业队伍也满了，就按照事先约定的策略 <code>RejectedExecutionHandler</code> 给拒绝掉</li>\n</ul>\n</div>\n<p>我们再来看中间的两个构造方法，和第一个的区别在于，<strong>第二个和第三个指定了创建线程的工厂和线程池满时的处理策略。</strong></p>\n<h4 id=\"_12-2-3-第二种方式-通过executor-框架的工具类executors来实现\"> 12.2.3 第二种方式：通过Executor 框架的⼯具类Executors来实现</h4>\n<blockquote>\n<ul>\n<li>\n<p><strong>FixedThreadPool</strong> ： 该⽅法返回⼀个固定线程数量的线程池。该线程池中的线程数量始终不 变。当有⼀个新的任务提交时，线程池中若有空闲线程，则⽴即执⾏。若没有，则新的任务会被 暂存在⼀个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</p>\n</li>\n<li>\n<p><strong>SingleThreadExecutor</strong>： ⽅法返回⼀个只有⼀个线程的线程池。若多余⼀个任务被提交到该线 程池，任务会被保存在⼀个任务队列中，待线程空闲，按先⼊先出的顺序执⾏队列中的任务。</p>\n</li>\n<li>\n<p><strong>CachedThreadPool</strong>： 该⽅法返回⼀个可根据实际情况调整线程数量的线程池。线程池的线程数 量不确定，但若有空闲线程可以复⽤，则会优先使⽤可复⽤的线程。若所有线程均在⼯作，⼜有 新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执⾏完毕后，将返回线程池进 ⾏复⽤。</p>\n</li>\n</ul>\n</blockquote>\n<p><img src=\"./images/Java-MultiThread-1/Executos_tool_class_method.jpg\" alt=\"Executos工具类的方法\" /></p>\n<p><img src=\"./images/Java-MultiThread-1/Through_construction_of_ThraPoolExecutor_class.jpg\" alt=\"通过ThreaPoolExecutor类的构造方法\" /></p>\n<div><pre><code><span>public</span> <span>static</span> <span>ExecutorService</span> <span>newFixedThreadPool</span><span>(</span><span>int</span> nThreads<span>)</span> <span>{</span>\n        <span>return</span> <span>new</span> <span>ThreadPoolExecutor</span><span>(</span>nThreads<span>,</span> nThreads<span>,</span>\n                                      <span>0L</span><span>,</span> <span>TimeUnit</span><span>.</span>MILLISECONDS<span>,</span>\n                                      <span>new</span> <span>LinkedBlockingQueue</span><span><span>&lt;</span><span>Runnable</span><span>></span></span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>从上面的代码中可以看出，其返回的是<strong>ThreaPoolExecutor</strong>对象，调用的是ThreaPoolExecutor类四个构造方法中的第一个。</p>\n<p>总结，上面两种创建线程池的方式，其本质都是通过<strong>ThreaPoolExecutor</strong>类的构造方法的方式，所以<strong>ThreaPoolExecutor</strong>是重点。</p>\n<h3 id=\"_12-3-threadpoolexecutor-类分析\"> 12.3 ThreadPoolExecutor 类分析</h3>\n<p>参考</p>\n<blockquote>\n<ul>\n<li>https://www.jianshu.com/p/c41e942bcd64</li>\n</ul>\n</blockquote>\n<p><img src=\"./images/Java-MultiThread-1/Class_diagram_of_ThreadPoolExecutor.jpg\" alt=\"ThreadPoolExecutor的类图\" /></p>\n<p>当在execute(Runnable)方法中提交新任务并且少于corePoolSize线程正在运行时，即使其他工作线程处于空闲状态，也会创建一个新线程来处理该请求。 如果有多于corePoolSize但小于maximumPoolSize线程正在运行，则仅当队列已满时才会创建新线程。 通过设置corePoolSize和maximumPoolSize相同，您可以创建一个固定大小的线程池。 通过将maximumPoolSize设置为基本上无界的值，例如Integer.MAX_VALUE，您可以允许池容纳任意数量的并发任务。 通常，核心和最大池大小仅在构建时设置，但也可以使用<code>setCorePoolSize</code>和<code>setMaximumPoolSize</code>进行动态更改。</p>\n<h3 id=\"_12-4-拒绝策略\"> 12.4 拒绝策略</h3>\n<div><p>参考</p>\n<ul>\n<li>https://www.jianshu.com/p/f0506e098c5b</li>\n</ul>\n</div>\n<p>所有拒绝策略都实现了接口<code>RejectedExecutionHandler</code></p>\n<div><pre><code><span>public</span> <span>interface</span> <span>RejectedExecutionHandler</span> <span>{</span>\n\n    <span>/**\n     * @param r the runnable task requested to be executed\n     * @param executor the executor attempting to execute this task\n     * @throws RejectedExecutionException if there is no remedy\n     */</span>\n    <span>void</span> <span>rejectedExecution</span><span>(</span><span>Runnable</span> r<span>,</span> <span>ThreadPoolExecutor</span> executor<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><blockquote>\n<p>这个接口只有一个 rejectedExecution 方法。</p>\n<p>r 为待执行任务；executor 为线程池；方法可能会抛出拒绝异常。</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>拒绝策略</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>AbortPolicy</td>\n<td>直接抛出拒绝异常（默认策略）</td>\n</tr>\n<tr>\n<td>CallerRunsPolicy</td>\n<td>在调用者线程中，运行当前被丢弃的任务。</td>\n</tr>\n<tr>\n<td>DiscardOledestPolicy</td>\n<td>丢弃队列中最老的，然后再次尝试提交新任务。</td>\n</tr>\n<tr>\n<td>DiscardPolicy</td>\n<td>默默丢弃无法加载的任务。</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"_12-4-1-abortpolicy-默认策略\"> 12.4.1 AbortPolicy（默认策略）</h4>\n<p>直接抛出拒绝异常（继承自RuntimeException），会中断调用者的处理过程，所以除非有明确需求，一般不推荐</p>\n<div><pre><code><span>public</span> <span>static</span> <span>class</span> <span>AbortPolicy</span> <span>implements</span> <span>RejectedExecutionHandler</span> <span>{</span>\n    <span>public</span> <span>void</span> <span>rejectedExecution</span><span>(</span><span>Runnable</span> r<span>,</span> <span>ThreadPoolExecutor</span> e<span>)</span> <span>{</span>\n        <span>throw</span> <span>new</span> <span>RejectedExecutionException</span><span>(</span><span>\"Task \"</span> <span>+</span> r<span>.</span><span>toString</span><span>(</span><span>)</span> <span>+</span>\n                                             <span>\" rejected from \"</span> <span>+</span>\n                                             e<span>.</span><span>toString</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h4 id=\"_12-4-2-callerrunspolicy\"> 12.4.2 CallerRunsPolicy</h4>\n<p>在调用者线程中（也就是说谁把 r 这个任务甩来的），运行当前被丢弃的任务。</p>\n<p>只会用调用者所在线程来运行任务，也就是说任务不会进入线程池。</p>\n<p>如果线程池已经被关闭，则直接丢弃该任务。</p>\n<div><pre><code><span>public</span> <span>static</span> <span>class</span> <span>CallerRunsPolicy</span> <span>implements</span> <span>RejectedExecutionHandler</span> <span>{</span>\n    <span>public</span> <span>void</span> <span>rejectedExecution</span><span>(</span><span>Runnable</span> r<span>,</span> <span>ThreadPoolExecutor</span> e<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span><span>!</span>e<span>.</span><span>isShutdown</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n            r<span>.</span><span>run</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h4 id=\"_12-4-3-discardoledestpolicy\"> 12.4.3 DiscardOledestPolicy</h4>\n<p>丢弃队列中最老的，然后再次尝试提交新任务。</p>\n<div><pre><code><span>public</span> <span>static</span> <span>class</span> <span>DiscardOldestPolicy</span> <span>implements</span> <span>RejectedExecutionHandler</span> <span>{</span>\n    <span>public</span> <span>void</span> <span>rejectedExecution</span><span>(</span><span>Runnable</span> r<span>,</span> <span>ThreadPoolExecutor</span> e<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span><span>!</span>e<span>.</span><span>isShutdown</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n            e<span>.</span><span>getQueue</span><span>(</span><span>)</span><span>.</span><span>poll</span><span>(</span><span>)</span><span>;</span>\n            e<span>.</span><span>execute</span><span>(</span>r<span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>这里 e.getQueue() 是获得待执行的任务队列，也就是前面提到的待业队列。</p>\n<p>因为是队列，所以先进先出，一个poll()方法就能直接把队列中最老的抛弃掉，再次尝试执行execute(r)。</p>\n<p>这个队列在线程池定义的时候就能看到，是一个阻塞队列</p>\n<div><pre><code>    <span>/**\n     * The queue used for holding tasks and handing off to worker\n     * threads.  We do not require that workQueue.\n     */</span>     \n    <span>private</span> <span>final</span> <span>BlockingQueue</span><span><span>&lt;</span><span>Runnable</span><span>></span></span> workQueue<span>;</span>\n\n    <span>public</span> <span>BlockingQueue</span><span><span>&lt;</span><span>Runnable</span><span>></span></span> <span>getQueue</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> workQueue<span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h4 id=\"_12-4-4-discardpolicy\"> 12.4.4 DiscardPolicy</h4>\n<p>默默丢弃无法加载的任务。</p>\n<p>这个代码就很简单了，真的是啥也没做</p>\n<div><pre><code><span>public</span> <span>static</span> <span>class</span> <span>DiscardPolicy</span> <span>implements</span> <span>RejectedExecutionHandler</span> <span>{</span>\n    <span>public</span> <span>void</span> <span>rejectedExecution</span><span>(</span><span>Runnable</span> r<span>,</span> <span>ThreadPoolExecutor</span> e<span>)</span> <span>{</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h4 id=\"_12-4-5-自定义\"> 12.4.5 自定义</h4>\n<p>通过实现 <code>RejectedExecutionHandler</code> 接口扩展</p>\n<p>jdk内置的四种拒绝策略（都在ThreadPoolExecutor.java里面）代码都很简洁易懂。</p>\n<p>我们只要继承接口都可以根据自己需要自定义拒绝策略。下面看两个例子。</p>\n<p>一是netty自己实现的线程池里面私有的一个拒绝策略。单独启动一个新的临时线程来执行任务。</p>\n<div><pre><code><span>private</span> <span>static</span> <span>final</span> <span>class</span> <span>NewThreadRunsPolicy</span> <span>implements</span> <span>RejectedExecutionHandler</span> <span>{</span>\n    <span>public</span> <span>void</span> <span>rejectedExecution</span><span>(</span><span>Runnable</span> r<span>,</span> <span>ThreadPoolExecutor</span> executor<span>)</span> <span>{</span>\n        <span>try</span> <span>{</span>\n            <span>final</span> <span>Thread</span> t <span>=</span> <span>new</span> <span>Thread</span><span>(</span>r<span>,</span> <span>\"Temporary task executor\"</span><span>)</span><span>;</span>\n            t<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>Throwable</span> e<span>)</span> <span>{</span>\n            <span>throw</span> <span>new</span> <span>RejectedExecutionException</span><span>(</span>\n                <span>\"Failed to start a new thread\"</span><span>,</span> e<span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>另外一个是dubbo的一个例子，它直接继承的 AbortPolicy ，加强了日志输出，并且输出dump文件</p>\n<div><pre><code><span>public</span> <span>class</span> <span>AbortPolicyWithReport</span> <span>extends</span> <span>ThreadPoolExecutor<span>.</span>AbortPolicy</span> <span>{</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>rejectedExecution</span><span>(</span><span>Runnable</span> r<span>,</span> <span>ThreadPoolExecutor</span> e<span>)</span> <span>{</span>\n        <span>String</span> msg <span>=</span> <span>String</span><span>.</span><span>format</span><span>(</span><span>\"Thread pool is EXHAUSTED!\"</span> <span>+</span>\n                        <span>\" Thread Name: %s, Pool Size: %d (active: %d, core: %d, max: %d, largest: %d), Task: %d (completed: %d),\"</span> <span>+</span>\n                        <span>\" Executor status:(isShutdown:%s, isTerminated:%s, isTerminating:%s), in %s://%s:%d!\"</span><span>,</span>\n                threadName<span>,</span> e<span>.</span><span>getPoolSize</span><span>(</span><span>)</span><span>,</span> e<span>.</span><span>getActiveCount</span><span>(</span><span>)</span><span>,</span> e<span>.</span><span>getCorePoolSize</span><span>(</span><span>)</span><span>,</span> e<span>.</span><span>getMaximumPoolSize</span><span>(</span><span>)</span><span>,</span> e<span>.</span><span>getLargestPoolSize</span><span>(</span><span>)</span><span>,</span>\n                e<span>.</span><span>getTaskCount</span><span>(</span><span>)</span><span>,</span> e<span>.</span><span>getCompletedTaskCount</span><span>(</span><span>)</span><span>,</span> e<span>.</span><span>isShutdown</span><span>(</span><span>)</span><span>,</span> e<span>.</span><span>isTerminated</span><span>(</span><span>)</span><span>,</span> e<span>.</span><span>isTerminating</span><span>(</span><span>)</span><span>,</span>\n                url<span>.</span><span>getProtocol</span><span>(</span><span>)</span><span>,</span> url<span>.</span><span>getIp</span><span>(</span><span>)</span><span>,</span> url<span>.</span><span>getPort</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        logger<span>.</span><span>warn</span><span>(</span>msg<span>)</span><span>;</span>\n        <span>dumpJStack</span><span>(</span><span>)</span><span>;</span>\n        <span>throw</span> <span>new</span> <span>RejectedExecutionException</span><span>(</span>msg<span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h3 id=\"_12-5-线程池执行流程\"> 12.5 线程池执行流程</h3>\n<h2 id=\"_13-java-util-concurrent\"> 13. java.util.concurrent</h2>\n<p>参考</p>\n<blockquote>\n<ul>\n<li>https://blog.csdn.net/starbxx/article/details/95333992</li>\n<li><a href=\"http://tutorials.jenkov.com/java-util-concurrent/index.html\" target=\"_blank\" rel=\"noopener noreferrer\">Jakob Jenkov博客</a></li>\n<li><a href=\"https://blog.csdn.net/defonds/article/details/44021605\" target=\"_blank\" rel=\"noopener noreferrer\">Jakob Jenkov博客中文翻译</a></li>\n<li><a href=\"https://blog.csdn.net/dichengyan0013/article/details/102347395?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param\" target=\"_blank\" rel=\"noopener noreferrer\">java并发包java.util.concurrent详解博客导航</a></li>\n</ul>\n</blockquote>\n<p><code>java.util.concurrent</code> 是在<code>并发编程</code>中很常用的实用工具类，称为<code>JUC</code>，在<code>JDK5</code>中开始发布</p>\n<p>在java.util下的集合都是发生<code>fail-fast</code>，而在java.util.concurrent下的发生的都是<code>fail-safe</code></p>\n<h3 id=\"线程池相关类\"> 线程池相关类</h3>\n<p><img src=\"./images/Java-MultiThread-1/Thread_pool_related_classes.png\" alt=\"线程池相关类\" /></p>\n<h3 id=\"阻塞队列相关类\"> 阻塞队列相关类</h3>\n<p><img src=\"./images/Java-MultiThread-1/Blocking_queue_related_classes.png\" alt=\"阻塞队列相关类\" /></p>\n<h3 id=\"concurrentmap类\"> ConcurrentMap类</h3>\n<p><img src=\"./images/Java-MultiThread-1/ConcurrentMap_class.png\" alt=\"ConcurrentMap_class\" /></p>\n<h3 id=\"多线程其他类\"> 多线程其他类</h3>\n<p><img src=\"./images/Java-MultiThread-1/Multithreading_other_classes.png\" alt=\"多线程其他类\" /></p>\n<h3 id=\"cas\"> CAS</h3>\n<p>参考</p>\n<blockquote>\n<ul>\n<li>https://blog.csdn.net/v123411739/article/details/79561458</li>\n<li>https://www.jianshu.com/p/ab2c8fce878b</li>\n</ul>\n</blockquote>\n<h4 id=\"概述\"> 概述</h4>\n<p><code>CAS（Compare-and-Swap）</code>，即比较并替换，是一种实现并发算法时常用到的技术，Java并发包中的很多类都使用了<code>CAS</code>技术。CAS是一种<code>无锁算法</code>，CAS有3个操作数</p>\n<blockquote>\n<ul>\n<li>内存值V</li>\n<li>旧的预期值A</li>\n<li>要修改的新值B。</li>\n</ul>\n</blockquote>\n<p>当且仅当<code>预期值A</code>和<code>内存值V</code>相同时(说明此时内存中的值没有被其他线程改变)，将<code>内存值V</code>修改为<code>B</code>，否则什么都不做。</p>\n<p>CAS比较与交换的伪代码可以表示为：</p>\n<blockquote>\n<p>do{</p>\n<p>备份旧数据；</p>\n<p>基于旧数据构造新数据；</p>\n<p>}while(!CAS( 内存地址，备份的旧数据，新数据 ))</p>\n</blockquote>\n<hr>\n<p><img src=\"./images/Java-MultiThread-1/CAS_algorithm.jpg\" alt=\"CAS算法理解\" /></p>\n<p>参考<code>getAndAddInt</code>方法源码</p>\n<div><pre><code>    <span>public</span> <span>final</span> <span>int</span> <span>getAndAddInt</span><span>(</span><span>Object</span> var1<span>,</span> <span>long</span> var2<span>,</span> <span>int</span> var4<span>)</span> <span>{</span>\n        <span>int</span> var5<span>;</span>\n        <span>do</span> <span>{</span>\n            var5 <span>=</span> <span>this</span><span>.</span><span>getIntVolatile</span><span>(</span>var1<span>,</span> var2<span>)</span><span>;</span>\n        <span>}</span> <span>while</span><span>(</span><span>!</span><span>this</span><span>.</span><span>compareAndSwapInt</span><span>(</span>var1<span>,</span> var2<span>,</span> var5<span>,</span> var5 <span>+</span> var4<span>)</span><span>)</span><span>;</span>\n\n        <span>return</span> var5<span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>注：t1，t2线程是同时更新<code>同一变量56的值</code></p>\n<p>因为t1和t2线程都同时去访问<code>同一变量56</code>，所以他们会把<strong>主内存的值完全拷贝一份到自己的工作内存空间</strong>，所以t1和t2线程的预期值都为<code>56</code>。</p>\n<p>假设t1在与t2线程竞争中线程t1能去更新变量的值，而其他线程都失败。（失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次发起尝试）。t1线程去更新变量值改为57，然后写到内存中。此时对于t2来说，内存值变为了57，与预期值56不一致，就操作失败了（想改的值不再是原来的值）。</p>\n<p>（上图通俗的解释是：CPU去更新一个值，但如果想改的值不再是原来的值，操作就失败，因为很明显，有其它操作先改变了这个值。）</p>\n<p>就是指当两者进行比较时</p>\n<blockquote>\n<ul>\n<li>如果相等，则证明共享数据没有被修改，替换成新值，然后继续往下运行；</li>\n<li>如果不相等，说明共享数据已经被修改，放弃已经所做的操作，然后重新执行刚才的操作。</li>\n</ul>\n</blockquote>\n<p>容易看出 CAS 操作是基于共享数据不会被修改的假设，采用了类似于数据库的<code>commit-retry</code> 的模式。当同步冲突出现的机会很少时，这种假设能带来较大的性能提升。</p>\n<h4 id=\"使用例子-源码\"> 使用例子/源码</h4>\n<p>创建一个<code>AtomicInteger</code>类型来测试多线程多同一个变量的自增操作</p>\n<div><pre><code>    <span>public</span> <span>static</span> <span>AtomicInteger</span> race <span>=</span> <span>new</span> <span>AtomicInteger</span><span>(</span><span>0</span><span>)</span><span>;</span>\n\n    <span>public</span> <span>static</span> <span>void</span> <span>increase</span><span>(</span><span>)</span> <span>{</span>\n        <span>/*race++;并非原子操作，经过下面三个步骤，取值，+1，写值*/</span>\n        race<span>.</span><span>getAndIncrement</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>getAndIncrement()源码</p>\n<div><pre><code>    <span>public</span> <span>final</span> <span>int</span> <span>getAndIncrement</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> unsafe<span>.</span><span>getAndAddInt</span><span>(</span><span>this</span><span>,</span> valueOffset<span>,</span> <span>1</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>getAndAddInt源码</p>\n<div><pre><code>    <span>public</span> <span>final</span> <span>int</span> <span>getAndAddInt</span><span>(</span><span>Object</span> var1<span>,</span> <span>long</span> var2<span>,</span> <span>int</span> var4<span>)</span> <span>{</span>\n        <span>int</span> var5<span>;</span>\n        <span>do</span> <span>{</span>\n            var5 <span>=</span> <span>this</span><span>.</span><span>getIntVolatile</span><span>(</span>var1<span>,</span> var2<span>)</span><span>;</span>\n        <span>}</span> <span>while</span><span>(</span><span>!</span><span>this</span><span>.</span><span>compareAndSwapInt</span><span>(</span>var1<span>,</span> var2<span>,</span> var5<span>,</span> var5 <span>+</span> var4<span>)</span><span>)</span><span>;</span>\n\n        <span>return</span> var5<span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>可以看到最后底层调用的是<code>compareAndSwapInt()</code>，如果 CAS 失败，会一直进行尝试</p>\n<h4 id=\"cas缺点\"> CAS缺点</h4>\n<p>CAS虽然很高效的解决了原子操作问题，但是CAS仍然存在三大问题。</p>\n<div><p>CAS缺点</p>\n<ol>\n<li>\n<p><strong>循环时间长开销很大</strong>：CAS 通常是配合无限循环一起使用的，我们可以看到 <code>getAndAddInt</code> 方法执行时，如果 CAS 失败，会一直进行尝试。如果 CAS 长时间一直不成功，可能会给 CPU 带来很大的开销。</p>\n</li>\n<li>\n<p><strong>只能保证一个变量的原子操作</strong>：当对一个变量执行操作时，我们可以使用<code>循环 CAS</code> 的方式来保证原子操作，但是对<code>多个变量</code>操作时，CAS 目前无法直接保证操作的原子性。但是我们可以通过以下两种办法来解决：1）使用互斥锁来保证原子性；2）将多个变量封装成对象，通过 <code>AtomicReference</code> 来保证原子性。</p>\n</li>\n<li>\n<p><strong>ABA问题</strong>：CAS 的使用流程通常如下：1）首先从地址 V 读取值 A；2）根据 A 计算目标值 B；3）通过 CAS 以原子的方式将地址 V 中的值从 A 修改为 B。</p>\n<p>但是在第1步中读取的值是A，并且在第3步修改成功了，我们就能说它的值在第1步和第3步之间没有被其他线程改变过了吗?</p>\n<p><strong>如果在这段期间它的值曾经被改成了B，后来又被改回为A</strong>，那CAS操作就会误认为它从来没有被改变过。这个漏洞称为CAS操作的“ABA”问题。Java并发包为了解决这个问题，提供了一个带有标记的原子引用类“<code>AtomicStampedReference</code>”，它可以通过控制<code>变量值的版本</code>来保证CAS的正确性。</p>\n<p>因此，在使用CAS前要考虑清楚“ABA”问题是否会影响<code>程序并发的正确性</code>，如果需要解决ABA问题，改用<code>传统的互斥同步</code>可能会比原子类更高效。</p>\n</li>\n</ol>\n</div>\n<h4 id=\"cas开销\"> CAS开销</h4>\n<h4 id=\"cas在jdk中的应用\"> CAS在JDK中的应用</h4>\n<p>在原子类变量中，如<code>java.util.concurrent.atomic</code>中的<code>AtomicXXX</code>，都使用了这些底层的JVM支持为数字类型的引用类型提供一种高效的CAS操作，而在<code>java.util.concurrent</code>中的大多数类在实现时都直接或间接的使用了这些原子变量类。</p>\n<p>Java 1.8中<code>AtomicInteger.incrementAndGet()</code>的实现源码为：</p>\n<div><pre><code>    <span>public</span> <span>final</span> <span>int</span> <span>incrementAndGet</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> unsafe<span>.</span><span>getAndAddInt</span><span>(</span><span>this</span><span>,</span> valueOffset<span>,</span> <span>1</span><span>)</span> <span>+</span> <span>1</span><span>;</span>\n    <span>}</span>\n\n\n    <span>public</span> <span>final</span> <span>int</span> <span>getAndAddInt</span><span>(</span><span>Object</span> var1<span>,</span> <span>long</span> var2<span>,</span> <span>int</span> var4<span>)</span> <span>{</span>\n        <span>int</span> var5<span>;</span>\n        <span>do</span> <span>{</span>\n            var5 <span>=</span> <span>this</span><span>.</span><span>getIntVolatile</span><span>(</span>var1<span>,</span> var2<span>)</span><span>;</span>\n        <span>}</span> <span>while</span><span>(</span><span>!</span><span>this</span><span>.</span><span>compareAndSwapInt</span><span>(</span>var1<span>,</span> var2<span>,</span> var5<span>,</span> var5 <span>+</span> var4<span>)</span><span>)</span><span>;</span>\n\n        <span>return</span> var5<span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>由此可见，<code>AtomicInteger.incrementAndGet</code>的实现用了<code>乐观锁</code>技术，调用了类<code>sun.misc.Unsafe</code>库里面的 <code>CAS</code>算法，用<code>CPU指令</code>来实现<code>无锁自增</code>。所以，<code>AtomicInteger.incrementAndGet</code>的自增比用<code>synchronized</code>的锁效率倍增。</p>\n<h2 id=\"_14-threadlocal\"> 14. ThreadLocal</h2>\n<p>参考</p>\n<blockquote>\n<ul>\n<li>https://www.cnblogs.com/fsmly/p/11020641.html</li>\n<li>https://www.jianshu.com/p/3c5d7f09dfbd</li>\n</ul>\n</blockquote>\n<h3 id=\"_14-1-简介\"> 14.1 简介</h3>\n<p>多线程访问同一个共享变量的时候容易出现并发问题，特别是多个线程对一个变量进行写入的时候，为了保证线程安全，一般使用者在访问共享变量的时候需要进行额外的同步措施才能保证线程安全性。ThreadLocal是除了加锁这种同步方式之外的一种保证一种规避多线程访问出现线程不安全的方法，当我们在创建一个变量后，如果每个线程对其进行访问的时候访问的都是线程自己的变量这样就不会存在线程不安全问题。</p>\n<p><code>ThreadLocal</code>是JDK包提供的，它提供线程本地变量，如果创建一个<code>ThreadLocal变量</code>，那么访问这个变量的每个线程都会有这个变量的一个<code>副本</code>，在实际多线程操作的时候，操作的是<code>自己本地内存中的变量</code>，从而规避了线程安全问题，如下图所示</p>\n<p>其实，<code>ThreadLocal</code>并不是一个<code>Thread</code>，而是<code>Thread</code>的<code>局部变量</code>，也许把它命名为<code>ThreadLocalVariable</code>更容易让人理解一些。</p>\n<p>当使用<code>ThreadLocal</code>维护变量时，ThreadLocal为每个使用该变量的线程提供<code>独立的变量副本</code>，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。</p>\n<p><img src=\"./images/Java-MultiThread-1/Introduction_to_ThreadLocal.png\" alt=\"ThreadLocal简介\" /></p>\n<p>除此之外，threadlocal还可避免很深的方法调用时的参数传递，当一个线程调用很深的方法需要从头吧参数传到底部处理时，可以用threadlocal保存当前线程的这个值，然后再取出就行</p>\n<h3 id=\"哈希冲突\"> 哈希冲突</h3>\n<p><code>ThreadLocalMap</code>解决<code>哈希冲突</code>的方式是<code>线性探测法</code>，如果当前数组位有值，则判断下一个数组位是否有值，如果有值继续向下寻找，直到一个为空的数组位，这样保证在所有线程的Map中存放的同一个ThreadLocal的位置都是相同的</p>\n<h3 id=\"_14-2-如何使用-原理\"> 14.2 如何使用/原理</h3>\n<p><img src=\"./images/Java-MultiThread-1/ThreadLocal_Thread_ThreadLocalMap.jpg\" alt=\"ThreadLocal和Thread以及ThreadLocalMap三者的关系\" /></p>\n<p>threadlocal使用方法很简单</p>\n<div><pre><code><span>static</span> <span>final</span> <span>ThreadLocal</span><span><span>&lt;</span><span>T</span><span>></span></span> sThreadLocal <span>=</span> <span>new</span> <span>ThreadLocal</span><span><span>&lt;</span><span>T</span><span>></span></span><span>(</span><span>)</span><span>;</span>\nsThreadLocal<span>.</span><span>set</span><span>(</span><span>)</span>\nsThreadLocal<span>.</span><span>get</span><span>(</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><code>threadlocal</code>而是一个线程内部的存储类，可以在<code>指定线程内存储数据</code>，数据存储以后，只有指定线程可以得到存储数据，官方解释如下。</p>\n<div><pre><code><span>/**\n * This class provides thread-local variables.  These variables differ from\n * their normal counterparts in that each thread that accesses one (via its\n * {@code get} or {@code set} method) has its own, independently initialized\n * copy of the variable.  {@code ThreadLocal} instances are typically private\n * static fields in classes that wish to associate state with a thread (e.g.,\n * a user ID or Transaction ID).\n */</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>大致意思就是<code>ThreadLocal</code>提供了<code>线程内存储变量</code>的能力，这些变量不同之处在于<code>每一个线程读取的变量是对应的互相独立的</code>。通过<code>get</code>和<code>set</code>方法就可以得到<code>当前线程对应的值</code>。</p>\n<p>做个不恰当的比喻，从表面上看<code>ThreadLocal</code>相当于维护了一个<code>map</code>，<code>key</code>就是当前的线程，<code>value</code>就是需要存储的对象。</p>\n<p>这里的这个比喻是不恰当的，实际上是<code>ThreadLocal</code>的<code>静态内部类ThreadLocalMap</code>为每个<code>Thread</code>都维护了<code>一个数组table</code>，<code>ThreadLocal</code>确定了一个数组下标，而这个下标就是<code>value</code>存储的对应位置。。</p>\n<p>作为一个存储数据的类，关键点就在<code>get</code>和<code>set</code>方法。</p>\n<h3 id=\"_14-3-set-方法\"> 14.3 set()方法</h3>\n<div><pre><code><span>//set 方法</span>\n<span>public</span> <span>void</span> <span>set</span><span>(</span><span>T</span> value<span>)</span> <span>{</span>\n      <span>//获取当前线程</span>\n      <span>Thread</span> t <span>=</span> <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>;</span>\n      <span>//实际存储的数据结构类型</span>\n      <span>ThreadLocalMap</span> map <span>=</span> <span>getMap</span><span>(</span>t<span>)</span><span>;</span>\n      <span>//如果存在map就直接set，没有则创建map并set</span>\n      <span>if</span> <span>(</span>map <span>!=</span> <span>null</span><span>)</span>\n          map<span>.</span><span>set</span><span>(</span><span>this</span><span>,</span> value<span>)</span><span>;</span>\n      <span>else</span>\n          <span>createMap</span><span>(</span>t<span>,</span> value<span>)</span><span>;</span>\n  <span>}</span>\n  \n<span>//getMap方法</span>\n<span>ThreadLocalMap</span> <span>getMap</span><span>(</span><span>Thread</span> t<span>)</span> <span>{</span>\n      <span>//thred中维护了一个ThreadLocalMap</span>\n      <span>return</span> t<span>.</span>threadLocals<span>;</span>\n <span>}</span>\n \n<span>//createMap</span>\n<span>void</span> <span>createMap</span><span>(</span><span>Thread</span> t<span>,</span> <span>T</span> firstValue<span>)</span> <span>{</span>\n      <span>//实例化一个新的ThreadLocalMap，并赋值给线程的成员变量threadLocals</span>\n      t<span>.</span>threadLocals <span>=</span> <span>new</span> <span>ThreadLocalMap</span><span>(</span><span>this</span><span>,</span> firstValue<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><p>从上面代码可以看出每个线程持有一个<code>ThreadLocalMap</code>对象。每一个新的线程<code>Thread</code>都会实例化一个<code>ThreadLocalMap</code>并赋值给<code>成员变量threadLocals</code>，使用时若已经存在<code>threadLocals</code>则直接使用已经存在的对象。</p>\n<h3 id=\"_14-4-threadlocalmap\"> 14.4 ThreadLocalMap</h3>\n<div><pre><code><span>//Entry为ThreadLocalMap静态内部类，对ThreadLocal的弱引用</span>\n<span>//同时让ThreadLocal和储值形成key-value的关系</span>\n<span>static</span> <span>class</span> <span>Entry</span> <span>extends</span> <span>WeakReference</span><span><span>&lt;</span><span>ThreadLocal</span><span>&lt;</span><span>?</span><span>></span><span>></span></span> <span>{</span>\n    <span>/** The value associated with this ThreadLocal. */</span>\n    <span>Object</span> value<span>;</span>\n\n    <span>Entry</span><span>(</span><span>ThreadLocal</span><span><span>&lt;</span><span>?</span><span>></span></span> k<span>,</span> <span>Object</span> v<span>)</span> <span>{</span>\n           <span>super</span><span>(</span>k<span>)</span><span>;</span>\n            value <span>=</span> v<span>;</span>\n    <span>}</span>\n<span>}</span>\n\n<span>//ThreadLocalMap构造方法</span>\n<span>ThreadLocalMap</span><span>(</span><span>ThreadLocal</span><span><span>&lt;</span><span>?</span><span>></span></span> firstKey<span>,</span> <span>Object</span> firstValue<span>)</span> <span>{</span>\n        <span>//内部成员数组，INITIAL_CAPACITY值为16的常量</span>\n        table <span>=</span> <span>new</span> <span>Entry</span><span>[</span>INITIAL_CAPACITY<span>]</span><span>;</span>\n        <span>//位运算，结果与取模相同，计算出需要存放的位置</span>\n        <span>//threadLocalHashCode比较有趣，这里计算出索引值</span>\n        <span>int</span> i <span>=</span> firstKey<span>.</span>threadLocalHashCode <span>&amp;</span> <span>(</span>INITIAL_CAPACITY <span>-</span> <span>1</span><span>)</span><span>;</span>\n        <span>//new一个新的Entry并赋值table数组中计算出来的索引值</span>\n        table<span>[</span>i<span>]</span> <span>=</span> <span>new</span> <span>Entry</span><span>(</span>firstKey<span>,</span> firstValue<span>)</span><span>;</span>\n        size <span>=</span> <span>1</span><span>;</span>\n        <span>setThreshold</span><span>(</span>INITIAL_CAPACITY<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><p>通过上面的代码不难看出在实例化<code>ThreadLocalMap</code>时创建了一个<code>长度为16的Entry数组</code>。通过<code>hashCode</code>与<code>length</code>位运算确定出一个<code>索引值i</code>，这个i就是<code>被存储在table数组中的位置</code>。</p>\n<p>前面讲过每个线程<code>Thread</code>持有一个<code>ThreadLocalMap</code>类型的实例<code>threadLocals</code>，结合此处的构造方法可以理解成每个线程Thread都持有一个Entry型的数组table，而一切的读取过程都是通过操作这个数组table完成的。</p>\n<p><em>显然table是set和get的焦点，在看具体的set和get方法前，先看下面这段代码。</em></p>\n<div><pre><code><span>//在某一线程声明了ABC三种类型的ThreadLocal</span>\n<span>ThreadLocal</span><span><span>&lt;</span><span>A</span><span>></span></span> sThreadLocalA <span>=</span> <span>new</span> <span>ThreadLocal</span><span><span>&lt;</span><span>A</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n<span>ThreadLocal</span><span><span>&lt;</span><span>B</span><span>></span></span> sThreadLocalB <span>=</span> <span>new</span> <span>ThreadLocal</span><span><span>&lt;</span><span>B</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n<span>ThreadLocal</span><span><span>&lt;</span><span>C</span><span>></span></span> sThreadLocalC <span>=</span> <span>new</span> <span>ThreadLocal</span><span><span>&lt;</span><span>C</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>由前面我们知道对于一个<code>Thread</code>来说只有持有一个<code>ThreadLocalMap</code>，所以<code>ABC</code>对应同一个<code>ThreadLocalMap对象</code>。为了管理<code>ABC</code>，于是将他们存储在<code>一个数组的不同位置</code>，而这个数组就是上面提到的<code>Entry型的数组table</code>。</p>\n<p>那么问题来了，<code>ABC</code>在<code>table</code>中的位置是如何确定的？为了能正常够正常的访问对应的值，肯定存在一种方法计算出确定的<code>索引值i</code>，show me code。</p>\n<div><pre><code>  <span>//ThreadLocalMap中set方法。</span>\n  <span>private</span> <span>void</span> <span>set</span><span>(</span><span>ThreadLocal</span><span><span>&lt;</span><span>?</span><span>></span></span> key<span>,</span> <span>Object</span> value<span>)</span> <span>{</span>\n\n            <span>// We don't use a fast path as with get() because it is at</span>\n            <span>// least as common to use set() to create new entries as</span>\n            <span>// it is to replace existing ones, in which case, a fast</span>\n            <span>// path would fail more often than not.</span>\n\n            <span>Entry</span><span>[</span><span>]</span> tab <span>=</span> table<span>;</span>\n            <span>int</span> len <span>=</span> tab<span>.</span>length<span>;</span>\n            <span>//获取索引值，这个地方是比较特别的地方</span>\n            <span>int</span> i <span>=</span> key<span>.</span>threadLocalHashCode <span>&amp;</span> <span>(</span>len<span>-</span><span>1</span><span>)</span><span>;</span>\n\n            <span>//遍历tab如果已经存在则更新值</span>\n            <span>for</span> <span>(</span><span>Entry</span> e <span>=</span> tab<span>[</span>i<span>]</span><span>;</span>\n                 e <span>!=</span> <span>null</span><span>;</span>\n                 e <span>=</span> tab<span>[</span>i <span>=</span> <span>nextIndex</span><span>(</span>i<span>,</span> len<span>)</span><span>]</span><span>)</span> <span>{</span>\n                <span>ThreadLocal</span><span><span>&lt;</span><span>?</span><span>></span></span> k <span>=</span> e<span>.</span><span>get</span><span>(</span><span>)</span><span>;</span>\n\n                <span>if</span> <span>(</span>k <span>==</span> key<span>)</span> <span>{</span>\n                    e<span>.</span>value <span>=</span> value<span>;</span>\n                    <span>return</span><span>;</span>\n                <span>}</span>\n\n                <span>if</span> <span>(</span>k <span>==</span> <span>null</span><span>)</span> <span>{</span>\n                    <span>replaceStaleEntry</span><span>(</span>key<span>,</span> value<span>,</span> i<span>)</span><span>;</span>\n                    <span>return</span><span>;</span>\n                <span>}</span>\n            <span>}</span>\n            \n            <span>//如果上面没有遍历成功则创建新值</span>\n            tab<span>[</span>i<span>]</span> <span>=</span> <span>new</span> <span>Entry</span><span>(</span>key<span>,</span> value<span>)</span><span>;</span>\n            <span>int</span> sz <span>=</span> <span>++</span>size<span>;</span>\n            <span>//满足条件数组扩容x2</span>\n            <span>if</span> <span>(</span><span>!</span><span>cleanSomeSlots</span><span>(</span>i<span>,</span> sz<span>)</span> <span>&amp;&amp;</span> sz <span>>=</span> threshold<span>)</span>\n                <span>rehash</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br></div></div><p>在<code>ThreadLocalMap</code>中的<code>set</code>方法与构造方法能看到以下代码片段。</p>\n<div><pre><code><span>int</span> i <span>=</span> key<span>.</span>threadLocalHashCode <span>&amp;</span> <span>(</span>len<span>-</span><span>1</span><span>)</span>\n<span>int</span> i <span>=</span> firstKey<span>.</span>threadLocalHashCode <span>&amp;</span> <span>(</span>INITIAL_CAPACITY <span>-</span> <span>1</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>简而言之就是将<code>threadLocalHashCode</code>进行一个位运算（取模）得到索引i，</p>\n<p><code>threadLocalHashCode</code>代码如下：</p>\n<div><pre><code>    <span>//ThreadLocal中threadLocalHashCode相关代码.</span>\n    \n    <span>private</span> <span>final</span> <span>int</span> threadLocalHashCode <span>=</span> <span>nextHashCode</span><span>(</span><span>)</span><span>;</span>\n\n    <span>/**\n     * The next hash code to be given out. Updated atomically. Starts at\n     * zero.\n     */</span>\n    <span>private</span> <span>static</span> <span>AtomicInteger</span> nextHashCode <span>=</span>\n        <span>new</span> <span>AtomicInteger</span><span>(</span><span>)</span><span>;</span>\n\n    <span>/**\n     * The difference between successively generated hash codes - turns\n     * implicit sequential thread-local IDs into near-optimally spread\n     * multiplicative hash values for power-of-two-sized tables.\n     */</span>\n    <span>private</span> <span>static</span> <span>final</span> <span>int</span> HASH_INCREMENT <span>=</span> <span>0x61c88647</span><span>;</span>\n\n    <span>/**\n     * Returns the next hash code.\n     */</span>\n    <span>private</span> <span>static</span> <span>int</span> <span>nextHashCode</span><span>(</span><span>)</span> <span>{</span>\n        <span>//自增</span>\n        <span>return</span> nextHashCode<span>.</span><span>getAndAdd</span><span>(</span>HASH_INCREMENT<span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><p>因为static的原因，在每次<code>new ThreadLocal</code>时因为<code>threadLocalHashCode</code>的初始化，会使<code>threadLocalHashCode</code>值自增一次，增量为<code>0x61c88647</code>。</p>\n<p><code>0x61c88647</code>是斐波那契散列乘数,它的优点是通过它<code>散列(hash)</code>出来的结果分布会比较均匀，可以很大程度上避免<code>hash冲突</code>，</p>\n<p>以很大程度上避免<code>hash冲突</code>，已初始<code>容量16</code>为例，hash并与15位运算计算数组下标结果如下：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">hashCode</th>\n<th style=\"text-align:center\">数组下标</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">0x61c88647</td>\n<td style=\"text-align:center\">7</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">0xc3910c8e</td>\n<td style=\"text-align:center\">14</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">0x255992d5</td>\n<td style=\"text-align:center\">5</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">0x8722191c</td>\n<td style=\"text-align:center\">12</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">0xe8ea9f63</td>\n<td style=\"text-align:center\">3</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">0x4ab325aa</td>\n<td style=\"text-align:center\">10</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">0xac7babf1</td>\n<td style=\"text-align:center\">1</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">0xe443238</td>\n<td style=\"text-align:center\">8</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">0x700cb87f</td>\n<td style=\"text-align:center\">15</td>\n</tr>\n</tbody>\n</table>\n<p>总结如下：</p>\n<div><p>总结如下</p>\n<ol>\n<li>对于某一<code>ThreadLocal</code>来讲，他的<code>索引值i</code>是确定的，在不同线程之间访问时访问的是不同的table数组的同一位置即都为table[i]，只不过这个不同线程之间的table是独立的。</li>\n<li>对于同一线程的不同<code>ThreadLocal</code>来讲，这些<code>ThreadLocal</code>实例共享一个<code>table</code>数组，然后每个<code>ThreadLocal</code>实例在<code>table</code>中的<code>索引i</code>是不同的。</li>\n</ol>\n</div>\n<h3 id=\"_14-5-get-方法\"> 14.5 get()方法</h3>\n<div><pre><code><span>//ThreadLocal中get方法</span>\n<span>public</span> <span>T</span> <span>get</span><span>(</span><span>)</span> <span>{</span>\n    <span>Thread</span> t <span>=</span> <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>;</span>\n    <span>ThreadLocalMap</span> map <span>=</span> <span>getMap</span><span>(</span>t<span>)</span><span>;</span>\n    <span>if</span> <span>(</span>map <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n        <span>ThreadLocalMap<span>.</span>Entry</span> e <span>=</span> map<span>.</span><span>getEntry</span><span>(</span><span>this</span><span>)</span><span>;</span>\n        <span>if</span> <span>(</span>e <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n            <span>@SuppressWarnings</span><span>(</span><span>\"unchecked\"</span><span>)</span>\n            <span>T</span> result <span>=</span> <span>(</span><span>T</span><span>)</span>e<span>.</span>value<span>;</span>\n            <span>return</span> result<span>;</span>\n        <span>}</span>\n    <span>}</span>\n    <span>return</span> <span>setInitialValue</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n    \n<span>//ThreadLocalMap中getEntry方法</span>\n<span>private</span> <span>Entry</span> <span>getEntry</span><span>(</span><span>ThreadLocal</span><span><span>&lt;</span><span>?</span><span>></span></span> key<span>)</span> <span>{</span>\n       <span>int</span> i <span>=</span> key<span>.</span>threadLocalHashCode <span>&amp;</span> <span>(</span>table<span>.</span>length <span>-</span> <span>1</span><span>)</span><span>;</span>\n       <span>Entry</span> e <span>=</span> table<span>[</span>i<span>]</span><span>;</span>\n       <span>if</span> <span>(</span>e <span>!=</span> <span>null</span> <span>&amp;&amp;</span> e<span>.</span><span>get</span><span>(</span><span>)</span> <span>==</span> key<span>)</span>\n            <span>return</span> e<span>;</span>\n       <span>else</span>\n            <span>return</span> <span>getEntryAfterMiss</span><span>(</span>key<span>,</span> i<span>,</span> e<span>)</span><span>;</span>\n   <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><p>理解了<code>set</code>方法，<code>get</code>方法也就清楚明了，无非是通过计算出索引直接从数组对应位置读取即可。</p>\n<p>在进行<code>get</code>之前，必须先<code>set</code>，否则会报<code>空指针异常</code>，当然也可以初始化一个，但是必须重写<code>initialValue()</code>方法。</p>\n<h3 id=\"_14-6-内存泄漏问题\"> 14.6 内存泄漏问题</h3>\n<p><img src=\"./images/Java-MultiThread-1/ThreadLocal_Thread_ThreadLocalMap.jpg\" alt=\"\" /></p>\n<p>上面这张图详细的揭示了<code>ThreadLocal</code>和<code>Thread</code>以及<code>ThreadLocalMap</code>三者的关系。</p>\n<div><p>关系</p>\n<ul>\n<li>Thread中有一个map，就是ThreadLocalMap</li>\n<li>ThreadLocalMap的key是ThreadLocal，值是我们自己设定的。</li>\n<li>ThreadLocal是一个弱引用，当为null时，会被当成垃圾回收</li>\n</ul>\n</div>\n<h4 id=\"那为什么使用弱引用而不是强引用\"> 那为什么使用弱引用而不是强引用？？</h4>\n<p>我们看看Key使用的</p>\n<ul>\n<li>key 使用强引用：当hreadLocalMap的key为强引用回收ThreadLocal时，因为ThreadLocalMap还持有ThreadLocal的强引用，如果没有手动删除，ThreadLocal不会被回收，导致Entry内存泄漏。这种情况发生在例如ThreadLocal设为null不再使用且线程池处理完线程在复用时依然还持有强引用到ThreadLocal导致一直无法回收。</li>\n<li>key 使用弱引用：当ThreadLocalMap的key为弱引用回收ThreadLocal时，由于ThreadLocalMap持有ThreadLocal的弱引用，即使没有手动删除，ThreadLocal也会被回收。当key为null，在下一次ThreadLocalMap调用set(),get()，remove()方法的时候会被清除value值。</li>\n</ul>\n<p>重点来了，突然我们<code>ThreadLocal</code>是<code>null</code>了，也就是要被<code>垃圾回收器</code>回收了，但是此时我们的<code>ThreadLocalMap</code>生命周期和<code>Thread</code>的一样，它不会回收，这时候就出现了一个现象。那就是<code>ThreadLocalMap</code>的<code>key</code>没了，但是<code>value</code>还在，这就造成了<code>内存泄漏</code>。</p>\n<h4 id=\"为什么value不设为弱引用\"> 为什么value不设为弱引用</h4>\n<p>不设置为弱引用，是因为不清楚这个<code>Value</code>除了<code>map</code>的引用还是否还存在其他引用，如果不存在其他引用，当<code>GC</code>的时候就会直接将这个Value干掉了，而此时我们的<code>ThreadLocal</code>还处于使用期间，就会造成Value为null的错误，所以将其设置为强引用。</p>\n<h4 id=\"为什么要remove\"> 为什么要remove</h4>\n<p>Java为了最小化减少内存泄露的可能性和影响，在ThreadLocal的get,set的时候都会清除线程Map里所有key为null的value。</p>\n<p>threadLocal对象设null了，开始发生“内存泄露”，然后使用线程池，这个线程结束，线程放回线程池中不销毁，这个线程一直不被使用，或者分配使用了又不再调用get,set方法，那么这个期间就会发生真正的内存泄露。</p>\n<h4 id=\"正确食用方法\"> 正确食用方法</h4>\n<ul>\n<li>每次使用完ThreadLocal都调用它的remove()方法清除数据</li>\n<li>将ThreadLocal变量定义成private static，这样就一直存在ThreadLocal的强引用，也就能保证任何时候都能通过ThreadLocal的弱引用访问到Entry的value值，进而清除掉 。</li>\n</ul>\n<h3 id=\"_14-7-特性\"> 14.7 特性</h3>\n<p><code>ThreadLocal</code>和<code>Synchronized</code>都是为了解决<code>多线程中相同变量的访问冲突</code>问题，不同的点是</p>\n<div><p>不同点</p>\n<ul>\n<li><code>Synchronized</code>是通过线程等待，<code>牺牲时间</code>来解决访问冲突</li>\n<li>ThreadLocal是通过每个线程单独一份存储空间，牺牲空间来解决冲突，并且相比于<code>Synchronized</code>，<code>ThreadLocal</code>具有<code>线程隔离</code>的效果，只有在线程内才能获取到对应的值，线程外则不能访问到想要的值。</li>\n</ul>\n</div>\n<p>正因为ThreadLocal的线程隔离特性，使他的应用场景相对来说更为特殊一些。在android中Looper、ActivityThread以及AMS中都用到了<code>ThreadLocal</code>。当某些数据是以线程为作用域并且不同线程具有不同的数据副本的时候或者说只有在同一个线程共享数据时，就可以考虑采用<code>ThreadLocal</code>。</p>\n<h2 id=\"其他面试题\"> 其他面试题</h2>\n<h3 id=\"i-线程安全吗\"> i++线程安全吗</h3>\n<p>参考</p>\n<blockquote>\n<ul>\n<li>https://blog.csdn.net/weixin_39446980/article/details/90597576</li>\n<li>https://blog.csdn.net/zbw18297786698/article/details/53420780?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param</li>\n</ul>\n</blockquote>\n",
      "date_published": "2020-08-23T20:36:25.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": []
    },
    {
      "title": "概述/参考",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/java/java-MultiThread/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/java/java-MultiThread/",
      "content_html": "<h2 id=\"参考\"> 参考</h2>\n<blockquote>\n<ul>\n<li><a href=\"http://tutorials.jenkov.com/java-concurrency/index.html\" target=\"_blank\" rel=\"noopener noreferrer\">Java 并发和多线程教程-雅各布博客</a></li>\n<li><a href=\"https://blog.csdn.net/qq_25827845/article/details/76422930\" target=\"_blank\" rel=\"noopener noreferrer\">Java多线程编程实战指南（核心篇）读书笔记（一）</a></li>\n</ul>\n</blockquote>\n<h2 id=\"调优工具\"> 调优工具</h2>\n<ul>\n<li>jvisuallvm</li>\n<li>JMC（Java Mission Control）：拥有JMX，JFR（飞行记录器）</li>\n</ul>\n",
      "date_published": "2021-05-11T19:41:12.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": []
    },
    {
      "title": "Java学习目录",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/java/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/java/",
      "content_html": "<ul>\n<li>\n<p><a href=\"./Java-BasicNotes.html\">Java-基础知识笔记</a></p>\n</li>\n<li>\n<p><a href=\"./Java-Collections.html\">Java-集合容器</a></p>\n</li>\n<li>\n<p><a href=\"./Java-Interview.html\">Java-基础面试题</a></p>\n</li>\n<li>\n<p><a href=\"./Java-JVM.html\">Java-JVM</a></p>\n</li>\n<li>\n<p><a href=\"./Java-Multithreading.html\">Java-多线程</a></p>\n</li>\n<li>\n<p><a href=\"./Java-DesignPatterns.html\">Java-设计模式</a></p>\n</li>\n<li>\n<p><a href=\"./Java-reflection.html\">Java-反射</a></p>\n</li>\n<li>\n<p><a href=\"./Java-String.html\">Java-String</a></p>\n</li>\n<li>\n<p><a href=\"./Java-JDK8.html\">Java-JDK8新特性</a></p>\n</li>\n<li>\n<p><a href=\"./Java-IO.html\">Java-IO</a></p>\n</li>\n<li>\n<p><a href=\"./Java-Date.html\">Java-时间处理</a></p>\n</li>\n<li>\n<p><a href=\"./Java-UML-ClassDiagram.html\">Java-时间处理</a></p>\n</li>\n</ul>\n<h2 id=\"方法汇总\"> 方法汇总</h2>\n<ul>\n<li><a href=\"./Java-Methods.html\">Java-方法汇总</a></li>\n</ul>\n<p>参考</p>\n<ul>\n<li><a href=\"https://www.pdai.tech/\" target=\"_blank\" rel=\"noopener noreferrer\">Java 全栈知识体系</a></li>\n</ul>\n",
      "date_published": "2020-11-24T22:10:27.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": []
    },
    {
      "title": "Linux常用命令",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/linux/Linux-commands/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/linux/Linux-commands/",
      "summary": "Linux常用命令",
      "content_html": "<h1 id=\"菜鸟教程linux命令大全\"> 菜鸟教程Linux命令大全</h1>\n<blockquote>\n<p>https://www.runoob.com/linux/linux-command-manual.html</p>\n</blockquote>\n<h2 id=\"系统管理\"> 系统管理</h2>\n<h3 id=\"uname-显示系统相关信息\"> uname：显示系统相关信息</h3>\n<blockquote>\n<p>Linux uname命令用于显示系统信息。</p>\n<p>uname可显示电脑以及操作系统的相关信息。</p>\n</blockquote>\n<div><pre><code><span>uname</span> <span>[</span>-amnrsv<span>]</span><span>[</span>--help<span>]</span><span>[</span>--version<span>]</span>\n\n-a或--all 　显示全部的信息。\n-m或--machine 　显示电脑类型。\n-n或-nodename 　显示在网络上的主机名称。\n-r或--release 　显示操作系统的发行编号。\n-s或--sysname 　显示操作系统名称。\n-v 　显示操作系统的版本。\n--help 　显示帮助。\n--version 　显示版本信息。\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div>",
      "date_published": "2020-08-14T16:45:16.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": []
    },
    {
      "title": "Linux技巧",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/linux/Linux-skill/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/linux/Linux-skill/",
      "summary": "Linux技巧",
      "content_html": "<h2 id=\"环境\"> 环境</h2>\n<p><code>Centos7</code></p>\n<h2 id=\"使用树形结构展示文件\"> 使用树形结构展示文件</h2>\n<p>下载<code>tree</code></p>\n<div><pre><code>yum <span>install</span> tree\n</code></pre>\n<div><span>1</span><br></div></div><p>使用</p>\n<div><pre><code><span>[</span>root@izuf6f489inattnq5zpfcxz ~<span>]</span><span># tree --help</span>\nusage: tree <span>[</span>-acdfghilnpqrstuvxACDFQNSUX<span>]</span> <span>[</span>-H baseHREF<span>]</span> <span>[</span>-T title <span>]</span> <span>[</span>-L level <span>[</span>-R<span>]</span><span>]</span>\n        <span>[</span>-P pattern<span>]</span> <span>[</span>-I pattern<span>]</span> <span>[</span>-o filename<span>]</span> <span>[</span>--version<span>]</span> <span>[</span>--help<span>]</span> <span>[</span>--inodes<span>]</span>\n        <span>[</span>--device<span>]</span> <span>[</span>--noreport<span>]</span> <span>[</span>--nolinks<span>]</span> <span>[</span>--dirsfirst<span>]</span> <span>[</span>--charset charset<span>]</span>\n        <span>[</span>--filelimit<span>[</span><span>=</span><span>]</span><span>#] [--si] [--timefmt[=]&lt;f>] [&lt;directory list>]</span>\n  ------- Listing options -------\n  -a            All files are listed.\n  -d            List directories only.\n  -l            Follow symbolic links like directories.\n  -f            Print the full path prefix <span>for</span> each file.\n  -x            Stay on current filesystem only.\n  -L level      Descend only level directories deep.\n  -R            Rerun tree when max <span>dir</span> level reached.\n  -P pattern    List only those files that match the pattern given.\n  -I pattern    Do not list files that match the given pattern.\n  --noreport    Turn off file/directory count at end of tree listing.\n  --charset X   Use charset X <span>for</span> terminal/HTML and indentation line output.\n  --filelimit <span># Do not descend dirs with more than # files in them.</span>\n  --timefmt <span>&lt;</span>f<span>></span> Print and <span>format</span> <span>time</span> according to the <span>format</span> <span>&lt;</span>f<span>></span>.\n  -o filename   Output to <span>file</span> instead of stdout.\n  --du          Print directory sizes.\n  --prune       Prune empty directories from the output.\n  -------- File options ---------\n  -q            Print non-printable characters as <span>'?'</span><span>.</span>\n  -N            Print non-printable characters as is.\n  -Q            Quote filenames with double quotes.\n  -p            Print the protections <span>for</span> each file.\n  -u            Displays <span>file</span> owner or <span>UID</span> number.\n  -g            Displays <span>file</span> group owner or GID number.\n  -s            Print the size <span>in</span> bytes of each file.\n  -h            Print the size <span>in</span> a <span>more</span> human readable way.\n  --si          Like -h, but use <span>in</span> SI <span>units</span> <span>(</span>powers of <span>1000</span><span>)</span>.\n  -D            Print the <span>date</span> of last modification or <span>(</span>-c<span>)</span> status change.\n  -F            Appends <span>'/'</span>, <span>'='</span>, <span>'*'</span>, <span>'@'</span>, <span>'|'</span> or <span>'>'</span> as per <span>ls</span> -F.\n  --inodes      Print inode number of each file.\n  --device      Print device ID number to <span>which</span> each <span>file</span> belongs.\n  ------- Sorting options -------\n  -v            Sort files alphanumerically by version.\n  -r            Sort files <span>in</span> reverse alphanumeric order.\n  -t            Sort files by last modification time.\n  -c            Sort files by last status change time.\n  -U            Leave files unsorted.\n  --dirsfirst   List directories before files <span>(</span>-U disables<span>)</span>.\n  ------- Graphics options ------\n  -i            Don't print indentation lines.\n  -A            Print ANSI lines graphic indentation lines.\n  -S            Print with ASCII graphics indentation lines.\n  -n            Turn colorization off always <span>(</span>-C overrides<span>)</span>.\n  -C            Turn colorization on always.\n  ------- XML/HTML options -------\n  -X            Prints out an XML representation of the tree.\n  -H baseHREF   Prints out HTML <span>format</span> with baseHREF as <span>top</span> directory.\n  -T string     Replace the default HTML title and H1 header with string.\n  --nolinks     Turn off hyperlinks <span>in</span> HTML output.\n  ---- Miscellaneous options ----\n  --version     Print version and exit.\n  --help        Print usage and this <span>help</span> message and exit.\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br></div></div><p>一般使用</p>\n<div><pre><code><span>#显示第一层文件</span>\ntree -L <span>1</span> /var/lib/docker/\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>显示第一层</p>\n",
      "date_published": "2020-08-15T16:45:16.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": []
    },
    {
      "title": "SSH",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/linux/SSH/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/linux/SSH/",
      "summary": "SSH",
      "content_html": "<h2 id=\"环境\"> 环境</h2>\n<p><code>Centos7</code></p>\n<h2 id=\"使用树形结构展示文件\"> 使用树形结构展示文件</h2>\n<p>下载<code>tree</code></p>\n<div><pre><code>yum <span>install</span> tree\n</code></pre>\n<div><span>1</span><br></div></div><p>使用</p>\n<div><pre><code><span>[</span>root@izuf6f489inattnq5zpfcxz ~<span>]</span><span># tree --help</span>\nusage: tree <span>[</span>-acdfghilnpqrstuvxACDFQNSUX<span>]</span> <span>[</span>-H baseHREF<span>]</span> <span>[</span>-T title <span>]</span> <span>[</span>-L level <span>[</span>-R<span>]</span><span>]</span>\n        <span>[</span>-P pattern<span>]</span> <span>[</span>-I pattern<span>]</span> <span>[</span>-o filename<span>]</span> <span>[</span>--version<span>]</span> <span>[</span>--help<span>]</span> <span>[</span>--inodes<span>]</span>\n        <span>[</span>--device<span>]</span> <span>[</span>--noreport<span>]</span> <span>[</span>--nolinks<span>]</span> <span>[</span>--dirsfirst<span>]</span> <span>[</span>--charset charset<span>]</span>\n        <span>[</span>--filelimit<span>[</span><span>=</span><span>]</span><span>#] [--si] [--timefmt[=]&lt;f>] [&lt;directory list>]</span>\n  ------- Listing options -------\n  -a            All files are listed.\n  -d            List directories only.\n  -l            Follow symbolic links like directories.\n  -f            Print the full path prefix <span>for</span> each file.\n  -x            Stay on current filesystem only.\n  -L level      Descend only level directories deep.\n  -R            Rerun tree when max <span>dir</span> level reached.\n  -P pattern    List only those files that match the pattern given.\n  -I pattern    Do not list files that match the given pattern.\n  --noreport    Turn off file/directory count at end of tree listing.\n  --charset X   Use charset X <span>for</span> terminal/HTML and indentation line output.\n  --filelimit <span># Do not descend dirs with more than # files in them.</span>\n  --timefmt <span>&lt;</span>f<span>></span> Print and <span>format</span> <span>time</span> according to the <span>format</span> <span>&lt;</span>f<span>></span>.\n  -o filename   Output to <span>file</span> instead of stdout.\n  --du          Print directory sizes.\n  --prune       Prune empty directories from the output.\n  -------- File options ---------\n  -q            Print non-printable characters as <span>'?'</span><span>.</span>\n  -N            Print non-printable characters as is.\n  -Q            Quote filenames with double quotes.\n  -p            Print the protections <span>for</span> each file.\n  -u            Displays <span>file</span> owner or <span>UID</span> number.\n  -g            Displays <span>file</span> group owner or GID number.\n  -s            Print the size <span>in</span> bytes of each file.\n  -h            Print the size <span>in</span> a <span>more</span> human readable way.\n  --si          Like -h, but use <span>in</span> SI <span>units</span> <span>(</span>powers of <span>1000</span><span>)</span>.\n  -D            Print the <span>date</span> of last modification or <span>(</span>-c<span>)</span> status change.\n  -F            Appends <span>'/'</span>, <span>'='</span>, <span>'*'</span>, <span>'@'</span>, <span>'|'</span> or <span>'>'</span> as per <span>ls</span> -F.\n  --inodes      Print inode number of each file.\n  --device      Print device ID number to <span>which</span> each <span>file</span> belongs.\n  ------- Sorting options -------\n  -v            Sort files alphanumerically by version.\n  -r            Sort files <span>in</span> reverse alphanumeric order.\n  -t            Sort files by last modification time.\n  -c            Sort files by last status change time.\n  -U            Leave files unsorted.\n  --dirsfirst   List directories before files <span>(</span>-U disables<span>)</span>.\n  ------- Graphics options ------\n  -i            Don't print indentation lines.\n  -A            Print ANSI lines graphic indentation lines.\n  -S            Print with ASCII graphics indentation lines.\n  -n            Turn colorization off always <span>(</span>-C overrides<span>)</span>.\n  -C            Turn colorization on always.\n  ------- XML/HTML options -------\n  -X            Prints out an XML representation of the tree.\n  -H baseHREF   Prints out HTML <span>format</span> with baseHREF as <span>top</span> directory.\n  -T string     Replace the default HTML title and H1 header with string.\n  --nolinks     Turn off hyperlinks <span>in</span> HTML output.\n  ---- Miscellaneous options ----\n  --version     Print version and exit.\n  --help        Print usage and this <span>help</span> message and exit.\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br></div></div><p>一般使用</p>\n<div><pre><code><span>#显示第一层文件</span>\ntree -L <span>1</span> /var/lib/docker/\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>显示第一层</p>\n",
      "date_published": "2022-01-18T14:45:16.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": []
    },
    {
      "title": "RabbitMQ面试题",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/mq/rabbitmq/RabbitMQ-Interview/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/mq/rabbitmq/RabbitMQ-Interview/",
      "content_html": "<p>面试</p>\n",
      "date_published": "2022-01-03T00:04:05.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": []
    },
    {
      "title": "RabbitMQ",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/mq/rabbitmq/RabbitMQ/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/mq/rabbitmq/RabbitMQ/",
      "content_html": "<h2 id=\"大纲\"> 大纲</h2>\n<p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/RabbitMQ/RabbitMQ.png\" alt=\"RabbitMQ大纲\" /></p>\n<h2 id=\"参考\"> 参考</h2>\n<ul>\n<li>\n<p><a href=\"https://www.rabbitmq.com/\" target=\"_blank\" rel=\"noopener noreferrer\">RabbitMQ官方文档</a></p>\n</li>\n<li>\n<p><a href=\"https://www.rabbitmq.com/rabbitmqctl.8.html\" target=\"_blank\" rel=\"noopener noreferrer\">rabbitmqctl文档</a></p>\n</li>\n<li>\n<p>尚硅谷RabbitMQ</p>\n</li>\n<li>\n<p><a href=\"https://zhangc233.github.io/2021/07/23/RabbitMQ/\" target=\"_blank\" rel=\"noopener noreferrer\">尚硅谷笔记</a></p>\n</li>\n<li>\n<p>《RabbitMQ实战指南》</p>\n</li>\n</ul>\n<h2 id=\"什么是消息中间件\"> 什么是消息中间件</h2>\n<p>消息、（Message）是指在应用间传送的数据。消息可以非常简单，比如只包含文本字符串、JSON等，也可以很复杂，比如内嵌对象。</p>\n<p>消息队列中间件（Message Queue Middleware，简称为MQ）是指利用高效可靠的消息传递机制进行与平台无关的数据交流，并基于数据通信来进行分布式系统的集成。通过提供消息传递和消息排队模型，它可以在分布式环境下扩展进程间的通信。</p>\n<p>消息队列中间件，也可以称为消息队列或者消息中间件。它一般有两种传递模式：点对点（PP，Point-to-Point）模式和发布/订阅（Pub/Sub）模式。</p>\n<ul>\n<li>点对点模式是基于队列的，消息生产者发送消息到队列，消息消费者从队列中接收消息，队列的存在使得消息的异步传输成为可能。</li>\n<li>发布订阅模式定义了如何向一个内容节点发布和订阅消息，这个内容节点称为主题（topic），主题可以认为是消息传递的中介，消息发布者将消息发布到某个主题，而消息订阅者则从主题中订阅消息。主题使得消息的订阅者与消息的发布者互相保持独立，不需要进行接触即可保证消息的传递，发布/订阅模式在消息的一对多广播时采用。</li>\n</ul>\n<h2 id=\"消息中间件作用\"> 消息中间件作用</h2>\n<ul>\n<li>解耦：在项目启动之初来预测将来会碰到什么需求是极其困难的。消息中间件在处理过程中间插入了一个隐含的、基于数据的接口层，两边的处理过程都要实现这一接口，这允许你独立地扩展或修改两边的处理过程，只要确保它们遵守同样的接口约束即可。</li>\n<li>冗余（存储）：有些情况下，处理数据的过程会失败。消息中间件可以把数据进行持久化直到它们已经被完全处理，通过这一方式规避了数据丢失风险。在把一个消息从消息中间件中删除之前，需要你的处理系统明确地指出该消息已经被处理完成，从而确保你的数据被安全地保存直到你使用完毕。</li>\n<li>扩展性：因为消息中间件解耦了应用的处理过程，所以提高消息入队和处理的效率是很容易的，只要另外增加处理过程即可，不需要改变代码，也不需要调节参数。</li>\n<li>削峰：在访问量剧增的情况下，应用仍然需要继续发挥作用，但是这样的突发流量并不常见。如果以能处理这类峰值为标准而投入资源，无疑是巨大的浪费。使用消息中间件能够使关键组件支撑突发访问压力，不会因为突发的超负荷请求而完全崩溃。</li>\n<li>可恢复性：当系统一部分组件失效时，不会影响到整个系统。消息中间件降低了进程间的耦合度，所以即使一个处理消息的进程挂掉，加入消息中间件中的消息仍然可以在系统恢复后进行处理。\n顺序保证：在大多数使用场景下，数据处理的顺序很重要，大部分消息中间件支持一定程度上的顺序性。</li>\n<li>缓冲：在任何重要的系统中，都会存在需要不同处理时间的元素。消息中间件通过一个缓冲层来帮助任务最高效率地执行，写入消息中间件的处理会尽可能快速。该缓冲层有助于控制和优化数据流经过系统的速度。</li>\n<li>异步通信：在很多时候应用不想也不需要立即处理消息。消息中间件提供了异步处理机制，允许应用把一些消息放入消息中间件中，但并不立即处理它，在之后需要的时候再慢慢处理。</li>\n</ul>\n<h2 id=\"rabbitmq特点\"> RabbitMQ特点</h2>\n<ul>\n<li>可靠性：RabbitMQ使用一些机制来保证可靠性，如持久化、传输确认及发布确认等。</li>\n<li>灵活的路由：在消息进入队列之前，通过交换器来路由消息。对于典型的路由功能，RabbitMQ已经提供了一些内置的交换器来实现。针对更复杂的路由功能，可以将多个交换器绑定在一起，也可以通过插件机制来实现自己的交换器。</li>\n</ul>\n<h2 id=\"常用消息中间件\"> 常用消息中间件</h2>\n<ul>\n<li>\n<p>ActiveMQ\n优点：单机吞吐量万级，时效性 ms 级，可用性高，基于主从架构实现高可用性，较低的概率丢失数据。</p>\n<p>缺点：官方社区现在对 ActiveMQ 5.x 维护越来越少，高吞吐量场景较少使用。</p>\n</li>\n<li>\n<p>Kafka\n大数据的杀手锏，谈到大数据领域内的消息传输，则绕不开 Kafka，这款为大数据而生的消息中间件，以其百万级 TPS 的吞吐量名声大噪，迅速成为大数据领域的宠儿，在数据采集、传输、存储的过程中发挥着举足轻重的作用。目前已经被 LinkedIn，Uber, Twitter, Netflix 等大公司所采纳。</p>\n<p>优点：性能卓越，单机写入 TPS 约在百万条 / 秒，最大的优点，就是吞吐量高。时效性 ms 级，可用性非常高，kafka 是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用，消费者采用 Pull 方式获取消息，消息有序，通过控制能够保证所有消息被消费且仅被消费一次；有优秀的第三方 Kafka Web 管理界面 Kafka-Manager；在日志领域比较成熟，被多家公司和多个开源项目使用；功能支持：功能较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用。</p>\n<p>缺点：Kafka 单机超过 64 个队列 / 分区，Load 会发生明显的飙高现象，队列越多，load 越高，发送消息响应时间变长，使用短轮询方式，实时性取决于轮询间隔时间，消费失败不支持重试；支持消息顺序，但是一台代理宕机后，就会产生消息乱序，社区更新较慢。</p>\n</li>\n<li>\n<p>RocketMQ\nRocketMQ 出自阿里巴巴的开源产品，用 Java 语言实现，在设计时参考了 Kafka，并做出了自己的一 些改进。被阿里巴巴广泛应用在订单，交易，充值，流计算，消息推送，日志流式处理，binglog 分发等场景。</p>\n<p>优点：单机吞吐量十万级，可用性非常高，分布式架构，消息可以做到 0 丢失，MQ 功能较为完善，还是分布式的，扩展性好，支持 10 亿级别的消息堆积，不会因为堆积导致性能下降。</p>\n<p>缺点：支持的客户端语言不多，目前是 java 及 c++，其中 c++ 不成熟；社区活跃度一般，没有在 MQ 核心中去实现 JMS 等接口，有些系统要迁移需要修改大量代码。</p>\n</li>\n<li>\n<p>RabbitMQ\n2007 年发布，是一个在 AMQP (高级消息队列协议) 基础上完成的，可复用的企业消息系统，是当前最主流的消息中间件之一。</p>\n<p>优点：由于 erlang 语言的高并发特性，性能较好；吞吐量到万级，MQ 功能比较完备，健壮、稳定、易用、跨平台、支持多种语言。如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP 等，AJAX 文档齐全；开源提供的管理界面非常棒，用起来很好用，社区活跃度高；更新频率相当高。</p>\n<p>缺点：商业版需要收费，学习成本较高。</p>\n</li>\n</ul>\n<p>作者: zhangc233\n链接: https://zhangc233.github.io/2021/07/23/RabbitMQ/#MQ-%E7%9A%84%E5%88%86%E7%B1%BB\n来源: ZC的学习录</p>\n<h2 id=\"rabbitmq入门\"> RabbitMQ入门</h2>\n<h3 id=\"介绍\"> 介绍</h3>\n<p>RabbitMO整体上是一个生产者与消费者模型，主要负责接收、存储和转发消息。可以把消息传递的过程想象成：当你将一个包裹送到邮局，邮局会暂存并最终将邮件通过邮递员送到收件人的手上，RabbitMQ就好比由邮局、邮箱和邮递员组成的一个系统。从计算机术语层面来说，RabbitMQ模型更像是一种交换机模型。</p>\n<p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/RabbitMQ/RabbitMQ模型架构.png\" alt=\"\" /></p>\n<p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/RabbitMQ/RabbitMQ工作原理png\" alt=\"RabbitMQ-00000007\" /></p>\n<h3 id=\"核心概念\"> 核心概念</h3>\n<ul>\n<li>Producer：生产者创建消息，然后发布到RabbitMO中。消息一般可以包含2个部分：<strong>消息体和标签（Label）</strong>。消息体也可以称之为<strong>payload</strong>，在实际应用中，消息体一般是一个带有业务逻辑结构的数据，比如一个JON字符串。当然可以进一步对这个消息体进行序列化操作。消息的标签用来表述这条消息，比如一个交换器的名称和一个路由键。生产者把消息交由RabbitMQ，RabbitMQ之后会根据标签把消息发送给感兴趣的消费者（Consumer）。</li>\n<li>Consumer：消费者，就是接收消息的一方。消费者连接到RabbitMQ服务器，并订阅到队列上。当消费者消费一条消息时，只是消费消息的消息体（payload）。在消息路由的过程中，<strong>消息的标签会丢弃</strong>，存入到队列中的消息只有消息体，<strong>消费者也只会消费到消息体，也就不知道消息的生产者是谁</strong>，当然消费者也不需要知道。</li>\n<li>Broker：消息中间件的服务节点。对于RabbitMQ来说，一个RabbitMQ Broker可以简单地看作一个RabbitMQ服务节点，或者RabbitMQ服务实例。大多数情况下也可以将一个RabbitMQ Broker看作一台RabbitMQ服务器。</li>\n</ul>\n<p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/RabbitMQ/消息队列生产消费流程.png\" alt=\"image-20220101153843047\" /></p>\n<ul>\n<li>\n<p>Connection：publisher／consumer 和 broker 之间的 TCP 连接。</p>\n</li>\n<li>\n<p>Channel：如果每一次访问 RabbitMQ 都建立一个 Connection，在消息量大的时候建立 TCP Connection 的开销将是巨大的，效率也较低。Channel 是在 connection 内部建立的逻辑连接，如果应用程序支持多线程，通常每个 thread 创建单独的 channel 进行通讯，AMQP method 包含了 channel id 帮助客户端和 message broker 识别 channel，所以 channel 之间是完全隔离的。Channel 作为轻量级的 Connection 极大减少了操作系统建立 TCP connection 的开销。</p>\n</li>\n</ul>\n<p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/RabbitMQ/连接和信道.png\" alt=\"image-20220101212952076\" /></p>\n<ul>\n<li>\n<p>Queue：用于存储消息用于存储消息</p>\n</li>\n<li>\n<p>Exchange：交换器。在图2-中我们暂时可以理解成生产者将消息投递到队列中，实际上这个在RabbitMQ中不会发生。真实情况是，生产者将消息发送到Exchange（交换器，通常也可以用大写的“Ⅹ”来表示），由交换器将消息路由到一个或者多个队列中。如果路由不到，或许会返回给生产者，或许直接丢弃。有四种交换器</p>\n</li>\n<li>\n<p>RoutingKey：路由键。生产者将消息发给交换器的时候，一般会指定一个RoutingKey，用来指定这个消息的路由规则，而这个Routing Key需要与交换器类型和绑定键（BindingKey）联合使用才能最终生效。在交换器类型和绑定键（BindingKey）固定的情况下，生产者可以在发送消息给交换器时，通过指定RoutingKey来决定消息流向哪里。</p>\n</li>\n<li>\n<p>Binding：绑定。RabbitMQ中通过绑定将交换器与队列关联起来，在绑定的时候一般会指定一个绑定键BindingKey</p>\n</li>\n</ul>\n<p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/RabbitMQ/绑定.png\" alt=\"image-20220101155411425\" /></p>\n<p>生产者将消息发送给交换器时，需要一个RoutingKey，<strong>当BindingKey和RoutingKey相匹配时，消息会被路由到对应的队列中</strong>。在绑定多个队列到同一个交换器的时候，这些绑定允许使用相同的BindingKey。BindingKey并不是在所有的情况下都生效，它依赖于交换器类型，比如fanout类型的交换器就会无视BindingKey，而是将消息路由到所有绑定到该交换器的队列中。</p>\n<p>路由键和绑定</p>\n<ul>\n<li>在使用绑定的时候，其中需要的路由键是BindingKey。涉及的客户端方法如：channel.exchangeBind、channel.queueBind，对应的AMQP命令（详情参见\n2.2节）为Exchange.Bind、Queue.Bind。</li>\n<li>在发送消息的时候，其中需要的路由键是RoutingKey。涉及的客户端方法如\nchannel.basicPublish，对应的AMQ命令为Basic.Publish。</li>\n</ul>\n<h3 id=\"交换器类型-路由规则\"> 交换器类型（路由规则）</h3>\n<ul>\n<li>fanout：它会把所有发送到该交换器的消息路由到所有与该交换器绑定的队列中。</li>\n<li>direct：它会把消息路由到那些BindingKey和RoutingKey完全匹配的队列中。</li>\n<li>topic：也是消息路由到绑定和路由相匹配的队列，但不同的是\n<ul>\n<li>RoutingKey为一个点号“.”分隔的字符串（被点号“.”分隔开的每一段独立的字符串称为一个单词），如“com.rabbitmq.client'”、“java.util.concurrent”、“com.hidden.client”；</li>\n<li>BindingKey和RoutingKey一样也是点号“.”分隔的字符串；</li>\n<li>BindingKey中可以存在两种特殊字符串a星号和“#”，用于做模糊匹配，其中星号用于匹配一个单词，”#“用于匹配多个</li>\n</ul>\n</li>\n<li>headers：headers类型的交换器不依赖于路由键的匹配规则来路由消息，而是根据发送的消息内容中的headers属性进行匹配。在绑定队列和交换器时制定一组键值对，当发送消息到交换器时，RabbitMQ会获取到该消息的headers（也是一个键值对的形式），对比其中的键值对是否完全匹配队列和交换器绑定时指定的键值对，如果完全匹配则消息会路由到该队列，否则不会路由到该队列。headers类型的交换器性能会很差，而且也不实用，基本上不会看到它的存在。</li>\n</ul>\n<p>topic举例</p>\n<ul>\n<li>路由键为“com.rabbitmg.client”的消息会同时路由到Queuel和Queue2；</li>\n<li>路由键为“com.hidden.client”的消息只会路由到Queue2中；</li>\n<li>路由键为“com.hidden.demo”的消息只会路由到Queue2中；</li>\n<li>路由键为“java.rabbitmg.demo”的消息只会路由到Queuel中；</li>\n<li>路由键为“java.util.concurrent”的消息将会被丢弃或者返回给生产者（需要设置mandatory参数），因为它没有匹配任何路由键。</li>\n</ul>\n<p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/RabbitMQ/topic路由交换器.png\" alt=\"\" /></p>\n<h2 id=\"客户端开发向导\"> 客户端开发向导</h2>\n<h3 id=\"连接\"> 连接</h3>\n<p>指定</p>\n<ul>\n<li>IP</li>\n<li>HOST</li>\n<li>USERNAME</li>\n<li>PASSWORD</li>\n</ul>\n<p>创建<strong>Connection</strong>，并创建<strong>Channel</strong>实例，Channel不能在线程间共享会有线程安全问题</p>\n<p>通过isOpen判断是否处于开启状态</p>\n<h3 id=\"使用交换器和队列\"> 使用交换器和队列</h3>\n<div><pre><code><span>//创建一个type=\"direct\"非排它非自动删除的交换器</span>\nchannel<span>.</span><span>exchangeDeclare</span><span>(</span>EXCHANGE_NAME<span>,</span> <span>\"direct\"</span><span>,</span> <span>true</span><span>,</span> <span>false</span><span>,</span> <span>null</span><span>)</span><span>;</span>\n<span>//创建一个持久化非排它非自动删除的交队列</span>\nchannel<span>.</span><span>queueDeclare</span><span>(</span>QUEUE_NAME<span>,</span> <span>true</span><span>,</span> <span>false</span><span>,</span> <span>false</span><span>,</span> <span>null</span><span>)</span><span>;</span>\n<span>//将交换器与队列通过路由键进行绑定</span>\nchannel<span>.</span><span>queueBind</span><span>(</span>QUEUE_NAME<span>,</span> EXCHANGE_NAME<span>,</span> ROUTING_KEY<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><ul>\n<li>上面的代码也展示了如何使用路由键将队列和交换器绑定起来。</li>\n<li>上面声明的队列具备如下特性：只对当前应用中同一个Connection层面<code>可用</code>，同一个Connection的不同Channel可共用，并且也会在应用连接断开时自动删除。</li>\n<li>如果其他生产消费者声明一样的交换器或队列名字相同时只要属性相同就什么都不做，否则抛出异常</li>\n</ul>\n<h3 id=\"交换器声明方法属性\"> 交换器声明方法属性</h3>\n<p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/RabbitMQ/交换机方法属性_1.png\" alt=\"image-20220101231901431\" /></p>\n<blockquote>\n<p>autoDelete指的是当交换器至少有一个绑定的队列或交换器，且与之解绑时且autoDelete为true时自动删除，而不是与客户端断开连接就删除</p>\n</blockquote>\n<h3 id=\"队列申明方法属性\"> 队列申明方法属性</h3>\n<p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/RabbitMQ/队列声明属性.png\" alt=\"image-20220102001031566\" /></p>\n<blockquote>\n<p>生产者和消费者都能够使用queueDeclare来声明一个队列，但是如果消费者在同一个信道上订阅了另一个队列，就无法再声明队列了。必须先取消订阅，然后将信道置为“传输”，才能声明队列</p>\n</blockquote>\n<h3 id=\"交换器队列绑定方法属性\"> 交换器队列绑定方法属性</h3>\n<p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/RabbitMQ/交换器队列绑定方法属性.png\" alt=\"image-20220102002534960\" /></p>\n<h3 id=\"交换器与交换器绑定\"> 交换器与交换器绑定</h3>\n<div><pre><code>channel<span>.</span><span>exchangeDeclare</span><span>(</span><span>\"source\"</span><span>,</span> <span>BuiltinExchangeType</span><span>.</span>DIRECT<span>)</span><span>;</span>\nchannel<span>.</span><span>exchangeDeclare</span><span>(</span><span>\"destination\"</span><span>,</span> <span>BuiltinExchangeType</span><span>.</span>FANOUT<span>)</span><span>;</span>\nchannel<span>.</span><span>exchangeBind</span><span>(</span><span>\"destination\"</span><span>,</span> <span>\"source\"</span><span>,</span> <span>\"exKey\"</span><span>)</span><span>;</span>\nchannel<span>.</span><span>queueBind</span><span>(</span>channel<span>.</span><span>queueDeclare</span><span>(</span><span>)</span><span>.</span><span>getQueue</span><span>(</span><span>)</span><span>,</span> <span>\"destination\"</span><span>,</span> <span>\"\"</span><span>)</span><span>;</span>\nchannel<span>.</span><span>basicPublish</span><span>(</span><span>\"source\"</span><span>,</span> <span>\"exKey\"</span><span>,</span> <span>null</span><span>,</span> <span>\"exToExDemo\"</span><span>.</span><span>getBytes</span><span>(</span><span>)</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>生产者发送消息至交换器source中，交换器source根据路由键找到与其匹配的另一个交换器destination，并把消息转发到destination中，进而存储在destination绑定的队列queue中，可参考图3-1。</p>\n<p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/RabbitMQ/i交换器与交换器绑定.png\" alt=\"image-20220102003824898\" /></p>\n<h3 id=\"发送消息方法属性\"> 发送消息方法属性</h3>\n<div><pre><code><span>//发送属性示例</span>\nchannel<span>.</span><span>basicPublish</span><span>(</span>EXCHANGE_NAME<span>,</span> ROUTING_NAME<span>,</span> <span>true</span><span>,</span> <span>new</span> <span>AMQP<span>.</span>BasicProperties</span><span>(</span><span>)</span><span>.</span><span>builder</span><span>(</span><span>)</span>\n                     <span>.</span><span>headers</span><span>(</span><span>Maps</span><span>.</span><span>newHashMap</span><span>(</span><span>)</span><span>)</span>\n                     <span>.</span><span>contentType</span><span>(</span><span>\"text/plain\"</span><span>)</span>\n                     <span>.</span><span>deliveryMode</span><span>(</span><span>2</span><span>)</span>\n                     <span>.</span><span>priority</span><span>(</span><span>1</span><span>)</span>\n                     <span>.</span><span>userId</span><span>(</span><span>\"hidden\"</span><span>)</span>\n                     <span>.</span><span>expiration</span><span>(</span><span>\"6000\"</span><span>)</span>\n                     <span>.</span><span>build</span><span>(</span><span>)</span><span>,</span> <span>\"message_demo\"</span><span>.</span><span>getBytes</span><span>(</span><span>)</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/RabbitMQ/发送消息方法属性.png\" alt=\"image-20220102183618810\" /></p>\n<h3 id=\"消费消息\"> 消费消息</h3>\n<p>RabbitMQ的消费模式分两种：</p>\n<ul>\n<li>推（Push）模式：推模式采用Basic.Consume进行消费</li>\n<li>和拉（Pull）模式：拉模式则是调用Basic.Get进行消费</li>\n</ul>\n<p>常用一个Channel对应一个消费者</p>\n<h4 id=\"推模式-订阅模式\"> 推模式（订阅模式）</h4>\n<p>推模式可以通过持续订阅的方式等待消息队列推送消息并消费信息，相关类：</p>\n<div><pre><code><span>import</span> <span>com<span>.</span>rabbitmq<span>.</span>client<span>.</span></span><span>Consumer</span><span>;</span>\n<span>import</span> <span>com<span>.</span>rabbitmg<span>.</span>client<span>.</span></span><span>DefaultConsumer</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>接收消息一般通过实现Consumer接口或者继承DefaultConsumer类来实现。当调用与Consumer相关的API方法时，不同的订阅采用不同的消费者标签（consumerTag）来区分彼此，在同一个Channel中的消费者也需要通过唯一的消费者标签以作区分，关键消费代码如代码清单3-9所示。</p>\n<p>Channel类中的basicConsume方法有如下形式</p>\n<p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/RabbitMQ/消费消息推模式方法属性.png\" alt=\"image-20220102200123744\" /></p>\n<h4 id=\"拉模式-主动消费\"> 拉模式（主动消费）</h4>\n<p>这里讲一下拉模式的消费方式。通过channel.basicGet方法可以单条地获取消息，其返回值是GetRespone。Channel类的basicGet方法没有其他重载方法，只有：\nGetResponse basicGet (String queue,boolean autoAck)throws IOException;其中queue代表队列的名称，如果设置autoAck为false，那么同样需要调用channel.basicAck来确认消息已被成功接收。拉模式的关键代码如代码清单3-10所示。</p>\n<div><pre><code><span>Channel</span> channel <span>=</span> <span>RabbitMqUtils</span><span>.</span><span>getChannel</span><span>(</span><span>)</span><span>;</span>\n<span>GetResponse</span> response <span>=</span> channel<span>.</span><span>basicGet</span><span>(</span>QUEUE<span>,</span> <span>false</span><span>)</span><span>;</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>new</span> <span>String</span><span>(</span>response<span>.</span><span>getBody</span><span>(</span><span>)</span><span>)</span><span>)</span><span>;</span>\n<span>//设置autoAck为false需要basicAck来确认消息接收成功</span>\nchannel<span>.</span><span>basicAck</span><span>(</span>response<span>.</span><span>getEnvelope</span><span>(</span><span>)</span><span>.</span><span>getDeliveryTag</span><span>(</span><span>)</span><span>,</span> <span>false</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><blockquote>\n<p>Basic.Consume将信道（Channel）置为接收模式即推模式，直到取消队列的订阅为止。在接收模式期间，RabbitMQ会不断地推送消息给消费者，当然推送消息的个数还是会受到Basic.Qos的限制。如果只想从队列获得单条消息而不是持续订阅，建议还是使用Basic.Get进行消费。但是不能将Basic.Get放在一个循环里来代替Basic.Consume，这样做会严重影响RabbitMQ的性能。如果要实现高吞吐量，消费者理应使用Basic.Consume方法。</p>\n</blockquote>\n<h3 id=\"消费者端确认与拒绝autoack\"> 消费者端确认与拒绝autoAck</h3>\n<p>为了保证消息从队列可靠地达到消费者，RabbitMQ提供了消息确认机制（messageacknowledgement）。消费者在订阅队列时，可以指定autoAck参数，</p>\n<ul>\n<li>当autoAck等于false时，RabbitMQ会等待消费者显式地回复确认信号后才从内存（或者磁盘）中移去消息、（实质上是先打上删除标记，之后再删除）。</li>\n<li>当autoAck等于true时，RabbitMQ会自动把发送出去的消息置为确认，然后从内存（或者磁盘）中删除，而不管消费者是否真正地消费到了这些消息。</li>\n</ul>\n<p>采用消息确认机制后，只要设置autoAck参数为false，消费者就有足够的时间处理消息（任务），不用担心处理消息过程中消费者进程挂掉后消息丢失的问题，因为RabbitMQ会一直等待持有消息直到消费者显式调用Basic.Ack命令为止。</p>\n<p>当autoAck参数置为false，对于RabbitMQ服务端而言，队列中的消息分成了两个部分：</p>\n<ul>\n<li>\n<p>一部分是等待投递给消费者的消息</p>\n</li>\n<li>\n<p>一部分是已经投递给消费者</p>\n</li>\n</ul>\n<p>但是还没有收到消费者确认信号的消息。如果RabbitMQ一直没有收到消费者的确认信号，并且消费此消息的消费者已经断开连接，则RabbitMQ会安排该消息重新进入队列，等待投递给下一个消费者，当然也有可能还是原来的那个消费者。且RabbitMQ不会为其设置过期时间</p>\n<p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/RabbitMQ/查看ready.png\" alt=\"image-20220102212838391\" /></p>\n<h4 id=\"消息拒绝\"> 消息拒绝</h4>\n<p>RabbitMQ在2.O.0版本开始引入了Basic.Reject这个命令，消费者客户端可以调用与其对应的channel.basicReject方法来告诉RabbitMQ拒绝这个消息。</p>\n<p>Channel类中的basicReject方法定义如下：void basicReject (long deliveryTag,boolean requeue)throws IOException;</p>\n<p>其中deliveryTag可以看作消息的编号，它是一个64位的长整型值，最大值是9223372036854775807。</p>\n<ul>\n<li>如果requeue参数设置true，则RabbitMQ会重新将这条消息存入队列，以便可以发送给下一个订阅的消费者；</li>\n<li>如果requeue参数设置为false，则RabbitMQ立即会把消息从队列中移除，而不会把它发送给新的消费者。</li>\n</ul>\n<p>Basic.Reject命令一次只能拒绝一条消息，如果想要批量拒绝消息，则可以使用</p>\n<p>Basic.Nack这个命令。消费者客户端可以调用channel.basicNack方法来实现，方法定义如下：</p>\n<div><pre><code><span>void</span> basicNack <span>(</span><span>long</span> deliveryTag<span>,</span><span>boolean</span> multiple<span>,</span><span>boolean</span> requeue<span>)</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>其中 deliverytag和 requeue的含义可以参考 basicreject方法。</p>\n<ul>\n<li>multiple参数设置为 false则表示拒绝编号为 deliverytag的这一条消息，这时候 basicnack和basicreject方法一样；</li>\n<li>multiple参数设置为tue则表示拒绝 deliverytag编号之前所有未被当前消费者确认的消息。</li>\n</ul>\n<h4 id=\"消息恢复\"> 消息恢复</h4>\n<p>这个 channel. basicrecover方法用来请求 Rabbitmq重新发送还未被确认的消息。如果 requeue参数设置为true，则未被确认的消息会被重新加入到队列中，这样对于同一条消息来说，可能会被分配给与之前不同的消费者。如果 requeue参数设置为 false，那么同一条消息会被分配给与之前相同的消费者。默认情况下，如果不设置 requeue这个参数，相当于channe. basicrecover（true），即 requeue默认为tue</p>\n<h3 id=\"关闭连接\"> 关闭连接</h3>\n<div><pre><code>channel<span>.</span><span>close</span><span>(</span><span>)</span>\n<span>//conn关闭channel也会关闭</span>\nconn<span>.</span><span>close</span><span>(</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>连接和信道状态</p>\n<ul>\n<li>Open：开启状态，代表当前对象可以使用。</li>\n<li>Closing：正在关闭状态。当前对象被显式地通知调用关闭方法（ shutdown），这样就产生了一个关闭请求让其内部对象进行相应的操作，并等待这些关闭操作的完成。</li>\n<li>Closed：已经关闭状态。当前对象已经接收到所有的内部对象已完成关闭动作的通知，并且其也关闭了自身。</li>\n</ul>\n<p>同时还有对应的其他方法</p>\n<h2 id=\"消息何去何从-未路由消息处理\"> 消息何去何从（未路由消息处理）</h2>\n<h3 id=\"mandatory-immediate\"> mandatory&amp;immediate</h3>\n<p>mandatory和 immediate是 <code>channel.basicpublish</code>方法中的两个参数，它们都有当消息传递过程中不可达目的地时将消息返回给生产者的功能。</p>\n<p>概括来说：</p>\n<ul>\n<li>mandatory：参数告诉服务器至少将该消息路由到一个队列中，否则将消息返回给生产者。</li>\n<li>immediate：参数告诉服务器，如果该消息关联的队列上有消费者，则立刻投递如果所有匹配的队列上都没有消费者，则直接将消息返还给生产者，不用将消息存入队列而等待消费者了。</li>\n</ul>\n<p>Rabbitmq提供的备份交换器（ Alternate Exchange）可以将未能被交换器路由的消息（没有绑定队列或者没有匹配的绑定）存储起来，而不用返回给客户端</p>\n<h3 id=\"mandatory\"> mandatory</h3>\n<ul>\n<li>true：交换器无法根据自身类型和路由键找到符合的队列，那么 Rabbitmq会调用 Basic.Return命令将消息返回给生产者</li>\n<li>false：当 mandatory参数设置为 false时，出现上述情形，则消息直接被丢弃。</li>\n</ul>\n<p>拿回返回来的消息可以用<code>channel.addReturnListener</code>添加<code>ReturnListener</code>监听器来实现</p>\n<div><pre><code><span>@Test</span>\n<span>public</span> <span>void</span> <span>mandatory</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n  <span>Channel</span> channel <span>=</span> <span>RabbitMqUtils</span><span>.</span><span>getChannel</span><span>(</span><span>)</span><span>;</span>\n  <span>//- true：交换器无法根据自身类型和路由键找到符合的队列，那么 Rabbitmq会调用 Basic.Return命令将消息返回给生产者</span>\n  <span>//- false：当 mandatory参数设置为 false时，出现上述情形，则消息直接被丢弃。</span>\n  channel<span>.</span><span>basicPublish</span><span>(</span>EXCHANGE_NAME<span>,</span> <span>\"54343\"</span><span>,</span> <span>true</span><span>,</span> <span>MessageProperties</span><span>.</span>PERSISTENT_TEXT_PLAIN<span>,</span> <span>\"mandatory_msg\"</span><span>.</span><span>getBytes</span><span>(</span><span>)</span><span>)</span><span>;</span>\n  channel<span>.</span><span>addReturnListener</span><span>(</span><span>(</span>replyCode<span>,</span> replyText<span>,</span> exchange<span>,</span> routingKey<span>,</span> properties<span>,</span> body<span>)</span> <span>-></span> <span>{</span>\n    <span>String</span> message <span>=</span> <span>new</span> <span>String</span><span>(</span>body<span>)</span><span>;</span>\n    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"Basic.Return返回的结果是 ：\"</span> <span>+</span> message<span>)</span><span>;</span>\n  <span>}</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/RabbitMQ/mandatory参数.png\" alt=\"image-20220103131152641\" /></p>\n<h3 id=\"immediate\"> immediate</h3>\n<p>已不支持，影响镜像队列性能，建议采用TTL和DLX方法替代</p>\n<h3 id=\"备份交换机\"> 备份交换机</h3>\n<p>生产者在发送消息的时候如果不设置 mandatory参数，那么消息在未被路由的情况下将会丢失；如果设置了 mandatory参数，那么需要添加 Returnlistener的编程逻辑，生产者的代码将变得复杂。</p>\n<p>如果既不想复杂化生产者的编程逻辑，又不想消息丢失，那么可以使用备份交换器，这样可以将未被路由的消息存储在 Rabbitmq中，再在需要的时候去处理这些消息。</p>\n<div><pre><code><span>@Test</span>\n<span>public</span> <span>void</span> <span>alternateExchange</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n  <span>Channel</span> channel <span>=</span> <span>RabbitMqUtils</span><span>.</span><span>getChannel</span><span>(</span><span>)</span><span>;</span>\n  <span>HashMap</span><span><span>&lt;</span><span>String</span><span>,</span> <span>Object</span><span>></span></span> args <span>=</span> <span>Maps</span><span>.</span><span>newHashMap</span><span>(</span><span>)</span><span>;</span>\n  args<span>.</span><span>put</span><span>(</span><span>\"alternate-exchange\"</span><span>,</span> <span>\"alternate_exchange\"</span><span>)</span><span>;</span>\n  channel<span>.</span><span>exchangeDeclare</span><span>(</span><span>\"normal_exchange\"</span><span>,</span> <span>BuiltinExchangeType</span><span>.</span>DIRECT<span>,</span> <span>true</span><span>,</span> <span>false</span><span>,</span> args<span>)</span><span>;</span>\n  channel<span>.</span><span>exchangeDeclare</span><span>(</span><span>\"alternate_exchange\"</span><span>,</span> <span>BuiltinExchangeType</span><span>.</span>FANOUT<span>,</span> <span>true</span><span>,</span> <span>false</span><span>,</span> <span>null</span><span>)</span><span>;</span>\n  channel<span>.</span><span>queueDeclare</span><span>(</span><span>\"normal_queue\"</span><span>,</span> <span>true</span><span>,</span> <span>false</span><span>,</span> <span>false</span><span>,</span> <span>null</span><span>)</span><span>;</span>\n  channel<span>.</span><span>queueBind</span><span>(</span><span>\"normal_queue\"</span><span>,</span> <span>\"normal_exchange\"</span><span>,</span> <span>\"normal_key\"</span><span>)</span><span>;</span>\n  channel<span>.</span><span>queueDeclare</span><span>(</span><span>\"unRoute_queue\"</span><span>,</span> <span>true</span><span>,</span> <span>false</span><span>,</span> <span>false</span><span>,</span> <span>null</span><span>)</span><span>;</span>\n  channel<span>.</span><span>queueBind</span><span>(</span><span>\"unRoute_queue\"</span><span>,</span> <span>\"alternate_exchange\"</span><span>,</span> <span>\"\"</span><span>)</span><span>;</span>\n\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>声明了两个交换机normal和alternate，分别绑定队列normal和unroute，同时将alternate设置为normal的备份交换机。如果发送消息到Normal上未路由到正确队列，则会发送给备用交换机的队列。为了方便使用备份交换机设置为<code>fanout</code>类型</p>\n<blockquote>\n<p>消息被重新您发送到备份时的<code>路由键</code>和从生产者发出的路由键一样，如果设置备份交换机为direct且没有路由到队列消息也会丢失</p>\n</blockquote>\n<p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/RabbitMQ/备份交换机.png\" alt=\"image-20220103141226407\" /></p>\n<p>可能的情况</p>\n<ul>\n<li>\n<p>如果设置的备份交换器不存在，客户端和 Rabbitmq服务端都不会有异常出现，此时消息会丢失。</p>\n</li>\n<li>\n<p>如果备份交换器没有绑定任何队列，客户端和 Rabbitmq服务端都不会有异常出现，此时消息会丢失。</p>\n</li>\n<li>\n<p>如果备份交换器没有任何匹配的队列，客户端和 Rabbitmq服务端都不会有异常出现，此时消息会丢失。</p>\n</li>\n<li>\n<p>如果备份交换器和<code>mandatory</code>参数一起使用，那么mandatory参数<code>无效</code>。</p>\n</li>\n</ul>\n<h2 id=\"过期时间-ttl\"> 过期时间(TTL)</h2>\n<p>RabbitMQ可以对消息和队列设置TTL。</p>\n<ul>\n<li>消息的过期：指限定时间内没有被消费</li>\n<li>队列的过期：指删除前除于未使用状态的时间</li>\n</ul>\n<h3 id=\"设置消息ttl\"> 设置消息TTL</h3>\n<p>目前有两种方法可以设置消息的TTL。</p>\n<ul>\n<li>第一种方法是通过队列属性设置，队列中所有消息都有相同的过期时间。</li>\n<li>第二种方法是对消息本身进行单独设置，每条消息的TTL可以不同。</li>\n</ul>\n<p>如果两种方法一起使用，则消息的TTL以<code>两者之间较小的那个数值为准</code>。消息在队列中的生存时间一旦超过设置的TTL值时，就会变成<code>死信（ Dead Message）</code>，消费者将无法再收到该消息（这点不是绝对的，可以参考4.3节）。</p>\n<p>设置方法一：</p>\n<div><pre><code><span>@Test</span>\n<span>public</span> <span>void</span> <span>timeToLive</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n  <span>Channel</span> channel <span>=</span> <span>RabbitMqUtils</span><span>.</span><span>getChannel</span><span>(</span><span>)</span><span>;</span>\n  <span>HashMap</span><span><span>&lt;</span><span>String</span><span>,</span> <span>Object</span><span>></span></span> args <span>=</span> <span>Maps</span><span>.</span><span>newHashMap</span><span>(</span><span>)</span><span>;</span>\n  args<span>.</span><span>put</span><span>(</span><span>\"x-message-ttl\"</span><span>,</span> <span>6000</span><span>)</span><span>;</span>\n  <span>//1.声明队列过期</span>\n  channel<span>.</span><span>queueDeclare</span><span>(</span>QUEUE_NAME<span>,</span> <span>true</span><span>,</span> <span>false</span><span>,</span> <span>false</span><span>,</span> args<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>还可以通过Policy和HTTP API接口设置。</p>\n<ul>\n<li>如果不设置TTL，则表示此消息不会过期；</li>\n<li>如果将TTL设置为0，则表示除非此时可以直接将消息投递到消费者，否则该消息会被立即丢弃，这个特性可以部分替代 Rabbitmq3.0版本之前的 immediate参数，之所以部分代替，是因为 immediate参数在投递失败时会用Basic. Return将消息返回（这个功能可以用死信队列来实现，详细参考4.3节）。</li>\n</ul>\n<p>设置方法二：</p>\n<p>针对每条消息设置TTL的方法是在 channel. basicpublish方法中加入 expiration的属性参数，单位为毫秒。</p>\n<div><pre><code>channel<span>.</span><span>basicPublish</span><span>(</span><span>\"\"</span><span>,</span> <span>\"ttl_queue\"</span><span>,</span> <span>new</span> <span>AMQP<span>.</span>BasicProperties</span><span>(</span><span>)</span><span>.</span><span>builder</span><span>(</span><span>)</span>\n                     <span>.</span><span>deliveryMode</span><span>(</span><span>2</span><span>)</span>\n                     <span>.</span><span>expiration</span><span>(</span><span>\"6000\"</span><span>)</span>\n                     <span>.</span><span>build</span><span>(</span><span>)</span><span>,</span> MSG<span>.</span><span>getBytes</span><span>(</span><span>)</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>判定时机的区别：</p>\n<ul>\n<li>对于第一种设置队列TL属性的方法，一旦消息过期，就会从队列中抹去</li>\n<li>而在第二种方法中，即使消息过期，也不会马上从队列中抹去，因为考虑到可能各个消息TTL不同需要扫描整个队列，所以在即将投递到消费者之前判定是否过期然后抹掉</li>\n</ul>\n<p>区别原因：</p>\n<ul>\n<li>因为第一种方法里，队列中己过期的消息肯定在队列头部， Rabbitmq只要定期从队头开始扫描是否有过期的消息即可。</li>\n<li>而第二种方法里，每条消息的过期时间不同，如果要删除所有过期消息势必要扫描整个队列，所以不如等到此消息即将被消费时再判定是否过期，如果过期再进行删除即可即懒加载</li>\n</ul>\n<h3 id=\"设置队列ttl\"> 设置队列TTL</h3>\n<p>通过声明队列时的参数<code>x-expires</code>参数可以控制队列被自动删除前处于<code>未使用状态</code>的时间。未使用的意思是：</p>\n<ul>\n<li>队列上没有任何的消费者</li>\n<li>队列也没有被重新声明</li>\n<li>在过期时间段内也未调用过 Basic.Get命令</li>\n</ul>\n<p>设置队列里的TTL可以应用于类似RPC方式的回复队列，在RPC中，许多队列会被创建出来，但是却是未被使用的。</p>\n<p>Rabbitmq会确保在过期时间到达后将队列删除，但是不保障删除的动作有多及时。在Rabbitmq重启后，持久化的队列的过期时间会被重新计算。</p>\n<p>用于表示过期时间的x- expires参数以毫秒为单位，并且服从和x- message-ttl一样的约束条件，不过不能设置为0。比如该参数设置为1000，则表示该队列如果在1秒钟之内未使用则会被删除</p>\n<h2 id=\"死信队列\"> 死信队列</h2>\n<p>DLX，全称为 Dead-letter-Exchange，可以称之为死信交换器，也有人称之为死信邮箱。当消息在一个队列中变成死信（ dead message）之后，它能被重新被发送到另一个交换器中，这个交换器就是DLX，绑定DLX的队列就称之为死信队列。</p>\n<h3 id=\"消息成为死信的情况\"> 消息成为死信的情况</h3>\n<ul>\n<li>消息被拒绝（ Basic.Reject/ Basic.Nack）并且设置 requeue参数为 false</li>\n<li>消息过期</li>\n<li>队列达到最大长度。</li>\n</ul>\n<p>DLX也是一个正常的交换器，和一般的交换器没有区别，它能在任何的队列上被指定，实际上就是设置某个队列的属性。当这个队列中存在死信时， Rabbitmq就会自动地将这个消息重新发布到设置的DLX上去，进而被路由到另一个队列，即死信队列。</p>\n<p>可以监听这个队列中的消息以进行相应的处理，这个特性与将消息的TTL设置为0配合使用可以弥补 <code>immediate</code>参数的功能。</p>\n<p>通过在 <code>channe.queuedeclare</code>方法中设置<code>x-dead-letter-exchange</code>参数来为这个队列添加DLX（代码清单4-7中的d1_exchange）</p>\n<div><pre><code><span>@Test</span>\n<span>public</span> <span>void</span> <span>dlx</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n  <span>Channel</span> channel <span>=</span> <span>RabbitMqUtils</span><span>.</span><span>getChannel</span><span>(</span><span>)</span><span>;</span>\n  <span>//声明死信交换器</span>\n  channel<span>.</span><span>exchangeDeclare</span><span>(</span><span>\"dlx_exchange\"</span><span>,</span> <span>BuiltinExchangeType</span><span>.</span>DIRECT<span>)</span><span>;</span>\n  <span>HashMap</span><span><span>&lt;</span><span>String</span><span>,</span> <span>Object</span><span>></span></span> args <span>=</span> <span>Maps</span><span>.</span><span>newHashMap</span><span>(</span><span>)</span><span>;</span>\n  args<span>.</span><span>put</span><span>(</span><span>\"x-dead-letter-exchange\"</span><span>,</span> <span>\"dlx_exchange\"</span><span>)</span><span>;</span>\n  <span>//死信交换器的路由，不指定则用生产者发送消息是的路由</span>\n  args<span>.</span><span>put</span><span>(</span><span>\"x-dead-letter-routing-key\"</span><span>,</span> <span>\"dlx_routing_key\"</span><span>)</span><span>;</span>\n  <span>//给队列添加DLX</span>\n  channel<span>.</span><span>queueDeclare</span><span>(</span><span>\"dlx_queue\"</span><span>,</span> <span>true</span><span>,</span> <span>false</span><span>,</span> <span>false</span><span>,</span> args<span>)</span><span>;</span>\n\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h3 id=\"示例\"> 示例</h3>\n<div><pre><code><span>/**\n     * @description: ttl和dlx示例,消息过期后会被发送到死信交换器绑定的死信队列\n     **/</span>\n<span>@Test</span>\n<span>public</span> <span>void</span> <span>ttlAndDlx</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n  <span>Channel</span> channel <span>=</span> <span>RabbitMqUtils</span><span>.</span><span>getChannel</span><span>(</span><span>)</span><span>;</span>\n  <span>//声明死信交换器</span>\n  channel<span>.</span><span>exchangeDeclare</span><span>(</span><span>\"exchange.dlx\"</span><span>,</span> <span>BuiltinExchangeType</span><span>.</span>DIRECT<span>,</span> <span>true</span><span>)</span><span>;</span>\n  <span>//声明普通交换机</span>\n  channel<span>.</span><span>exchangeDeclare</span><span>(</span><span>\"exchange.normal\"</span><span>,</span> <span>BuiltinExchangeType</span><span>.</span>FANOUT<span>,</span> <span>true</span><span>)</span><span>;</span>\n  <span>HashMap</span><span><span>&lt;</span><span>String</span><span>,</span> <span>Object</span><span>></span></span> args <span>=</span> <span>Maps</span><span>.</span><span>newHashMap</span><span>(</span><span>)</span><span>;</span>\n  args<span>.</span><span>put</span><span>(</span><span>\"x-message-ttl\"</span><span>,</span> <span>10000</span><span>)</span><span>;</span>\n  args<span>.</span><span>put</span><span>(</span><span>\"x-dead-letter-exchange\"</span><span>,</span> <span>\"exchange.dlx\"</span><span>)</span><span>;</span>\n  args<span>.</span><span>put</span><span>(</span><span>\"x-dead-letter-routing-key\"</span><span>,</span> <span>\"routingKey\"</span><span>)</span><span>;</span>\n  channel<span>.</span><span>queueDeclare</span><span>(</span><span>\"queue.normal\"</span><span>,</span> <span>true</span><span>,</span> <span>false</span><span>,</span> <span>false</span><span>,</span> args<span>)</span><span>;</span>\n  channel<span>.</span><span>queueBind</span><span>(</span><span>\"queue.normal\"</span><span>,</span> <span>\"exchange.normal\"</span><span>,</span> <span>\"\"</span><span>)</span><span>;</span>\n  channel<span>.</span><span>queueDeclare</span><span>(</span><span>\"queue.dlx\"</span><span>,</span> <span>true</span><span>,</span> <span>false</span><span>,</span> <span>false</span><span>,</span> <span>null</span><span>)</span><span>;</span>\n  channel<span>.</span><span>queueBind</span><span>(</span><span>\"queue.dlx\"</span><span>,</span> <span>\"exchange.dlx\"</span><span>,</span> <span>\"routingKey\"</span><span>)</span><span>;</span>\n  channel<span>.</span><span>basicPublish</span><span>(</span><span>\"exchange.normal\"</span><span>,</span> <span>\"\"</span><span>,</span> <span>MessageProperties</span><span>.</span>PERSISTENT_TEXT_PLAIN<span>,</span> <span>\"dlx_1\"</span><span>.</span><span>getBytes</span><span>(</span><span>)</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/RabbitMQ/死信队列.png\" alt=\"image-20220103211442199\" /></p>\n<p>对于 Rabbitmq来说，DLX是一个非常有用的特性。它可以处理异常情况下，消息不能够被消费者正确消费（消费者调用了 Basic.Nack或者 Basic. Reject）而被置入死信队列中的情况，后续分析程序可以通过消费这个死信队列中的内容来分析当时所遇到的异常情况，进而可以改善和优化系统。DLX配合TTL使用还可以实现延迟队列的功能，详细请看下一节。</p>\n<h2 id=\"延迟队列\"> 延迟队列</h2>\n<p>延迟队列存储的对象是对应的延迟消息，所谓“延迟消息”是指当消息被发送以后，并不想让消费者立刻拿到消息，而是等待特定时间后，消费者才能拿到这个消息进行消费。延迟队列的使用场景有很多，比如：</p>\n<ul>\n<li>在订单系统中，一个用户下单之后通常有30分钟的时间进行支付，如果30分钟之内没有支付成功，那么这个订单将进行异常处理，这时就可以使用延迟队列来处理这些订单了。</li>\n<li>用户希望通过手机远程遥控家里的智能设备在指定的时间进行工作。这时候就可以将用户指令发送到延迟队列，当指令设定的时间到了再将指令推送到智能设备。</li>\n</ul>\n<p>在AMQP中本身不支持延迟队列，但是可以通过DLX和TTL模拟延迟队列，即消费者订阅死信队列，然后生产者发送消息指定TTL到TTL后消息就能进入死信队列，消费者刚好能消费这个延迟了TTL的消息</p>\n<p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/RabbitMQ/image-20220108184812049.png\" alt=\"image-20220108184812049\" /></p>\n<h2 id=\"优先级队列\"> 优先级队列</h2>\n<p>指队列和消息的优先级，优先级高的消息具备优先被消费的特权</p>\n<ul>\n<li>消息队列优先级：可以通过<code>x-max-priority</code>设置</li>\n<li>消息优先级：通过prop参数设置，默认最低优先级0，最高位队列设置的最大优先级，优先级高可以被优先消费，这里的优先级比较是队列中的值而不包括准备发送的消息</li>\n</ul>\n<div><pre><code><span>/**\n     * @description: 优先级队列\n     **/</span>\n<span>@Test</span>\n<span>public</span> <span>void</span> <span>priorityQueue</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n  <span>Channel</span> channel <span>=</span> <span>RabbitMqUtils</span><span>.</span><span>getChannel</span><span>(</span><span>)</span><span>;</span>\n  <span>Map</span><span><span>&lt;</span><span>String</span><span>,</span> <span>Object</span><span>></span></span> args <span>=</span> <span>Maps</span><span>.</span><span>newHashMap</span><span>(</span><span>)</span><span>;</span>\n  <span>//声明优先级</span>\n  args<span>.</span><span>put</span><span>(</span><span>\"x-max-priority\"</span><span>,</span> <span>10</span><span>)</span><span>;</span>\n  channel<span>.</span><span>queueDeclare</span><span>(</span><span>\"queue.priority\"</span><span>,</span> <span>true</span><span>,</span> <span>false</span><span>,</span> <span>false</span><span>,</span> args<span>)</span><span>;</span>\n  <span>//设置消息优先级</span>\n  channel<span>.</span><span>basicPublish</span><span>(</span><span>\"\"</span><span>,</span> <span>\"\"</span><span>,</span>\n                       <span>new</span> <span>AMQP<span>.</span>BasicProperties</span><span>(</span><span>)</span><span>.</span><span>builder</span><span>(</span><span>)</span>\n                       <span>//默认最小是0</span>\n                       <span>.</span><span>priority</span><span>(</span><span>5</span><span>)</span>\n                       <span>.</span><span>build</span><span>(</span><span>)</span><span>,</span> <span>\"message\"</span><span>.</span><span>getBytes</span><span>(</span><span>)</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/RabbitMQ/优先级队列.png\" alt=\"image-20220108233051589\" /></p>\n<h2 id=\"rpc实现\"> RPC实现</h2>\n<p>一般在RabbitMQ中进行RPC是很简单。客户端发送请求消息，服务端回复响应的消息。</p>\n<p>为了接收响应的消息，我们需要在请求消息中发送一个回调队列（参考下面代码中的<code>replyTo</code>）。可以使用默认的队列，具体示例代码如代码清单4-11所示。</p>\n<div><pre><code><span>/**\n     * @description: rpc调用且回调\n     **/</span>\n<span>@Test</span>\n<span>public</span> <span>void</span> <span>rpc</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n  <span>Channel</span> channel <span>=</span> <span>RabbitMqUtils</span><span>.</span><span>getChannel</span><span>(</span><span>)</span><span>;</span>\n  <span>String</span> callbackQueueName <span>=</span> channel<span>.</span><span>queueDeclare</span><span>(</span><span>)</span><span>.</span><span>getQueue</span><span>(</span><span>)</span><span>;</span>\n  channel<span>.</span><span>basicPublish</span><span>(</span><span>\"\"</span><span>,</span> <span>\"rpc_queue\"</span><span>,</span> <span>new</span> <span>AMQP<span>.</span>BasicProperties<span>.</span>Builder</span><span>(</span><span>)</span>\n                       <span>//回调队列接收响应的消息</span>\n                       <span>.</span><span>replyTo</span><span>(</span>callbackQueueName<span>)</span>\n                       <span>.</span><span>build</span><span>(</span><span>)</span><span>,</span>\n                       <span>\"message\"</span><span>.</span><span>getBytes</span><span>(</span><span>)</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>对于代码中涉及的BasicProperties这个类，这里就用到两个属性。</p>\n<ul>\n<li>replyTo：通常用来设置一个回调队列。</li>\n<li>correlationId：用来关联请求（request）和其调用RPC之后的回复（response）。</li>\n</ul>\n<p>如果像上面的代码中一样，为每个RPC请求创建一个回调队列，则是非常低效的。但是幸运的是这里有一个通用的解决方案——<strong>可以为每个客户端创建一个单一的回调队列</strong>。这样就产生了一个新的问题，对于回调队列而言，在其接收到一条回复的消息之后，它并不知道这条消息应该和哪一个请求匹配。</p>\n<p>这里就用到<code>correlationId</code>这个属性了，我们应该为每一个请求设置一个唯一的<code>correlationId</code>。之后在回调队列接收到回复的消息时，可以根据这个属性匹配到相应的请求。如果回调队列接收到一条未知<code>correlationId</code>的回复消息，可以简单地将其丢弃。</p>\n<p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/RabbitMQ/rabbitmq-rpc.png\" alt=\"image-20220109180122979\" /></p>\n<p>RPC处理流程如下：</p>\n<ul>\n<li>当客户端启动时，创建一个匿名的回调队列（名称由RabbitMQ自动创建）。</li>\n<li>客户端为RPC请求设置2个属性：replyTo用来告知RPC服务端回复请求时的目的队列，即回调队列；correlationId用来标记一个请求。</li>\n<li>请求被发送到rpc queue队列中。</li>\n<li>RPC服务端监听rpc_queue队列中的请求，当请求到来时，服务端会处理并且把带有结果的消息发送给客户端。接收的队列就是replyTo设定的回调队列。</li>\n<li>客户端监听回调队列，当有消息时，检查correlationId属性，如果与请求匹配，那就是结果了。</li>\n</ul>\n<h2 id=\"持久化\"> 持久化</h2>\n<ul>\n<li>交换机持久化：声明时设置<code>durable</code>参数为true，不设置持久化重启关闭时消息不会丢失，但是相关的交换器元数据会丢失，不能将消息发送到这个交换器了</li>\n<li>队列持久化：声明时设置<code>durable</code>参数为true，不设置持久化重启关闭时消息会丢失</li>\n<li>消息持久化：投递时将消息的<code>deliveryMode</code>属性设置为2即可持久化，如果只是队列持久化当重启后消息会丢失，如果消息持久化但是队列没持久化name消息也会丢失</li>\n</ul>\n<blockquote>\n<p>可以将所有的消息都设置为持久化，但是这样会严重影响RabbitMO的<code>性能</code>（随机）。写入磁盘的速度比写入内存的速度慢得不只一点点。对于可靠性不是那么高的消息可以不采用持久化处理以提高整体的吞吐量。在选择是否要将消息持久化时，需要在可靠性和吐吞量之间做一个权衡</p>\n</blockquote>\n<p>如果都设置持久化并不意味着数据不会丢失，当订阅消息队列时设置<code>autoAck</code>为true时消费者这边没及时消费那么就会丢失消息</p>\n<h3 id=\"镜像队列\"> 镜像队列</h3>\n<p>其次，在持久化的消息正确存入RabbitMQ之后，还需要有一段时间（虽然很短，但是不可忽视）才能存入磁盘之中。RabbitMQ并不会为每条消息都进行同步存盘（调用内核的fsync方法）的处理，可能仅仅保存到<code>操作系统缓存</code>之中而不是物理磁盘之中。如果在这段时间内RabbitMQ服务节点发生了宕机、重启等异常情况，消息保存还没来得及落盘，那么这些消息将丢失。</p>\n<p>RabbitMQ的镜像队列机制相当于配置了副本主节点和从节点，实际生产环境的关键业务业务队列也会设置镜像队列，还可以在发送端引入<code>事务机制</code>或者<code>发送方确认机制</code>来保证消息已经正确地发送并存储至RabbitMQ中，前提还要保证在调用<code>channel.basicPublish</code>方法的时候交换器能够将消息正确路由到相应的队列之中。</p>\n<h2 id=\"生产者确认\"> 生产者确认</h2>\n<p>除了消费者确认应答机制，还要确保生产者这边到底有没有正确把消息发送到<code>消息队列的交换器</code>中去，默认情况生产者发送消息服务器不会返回任何消息给生产者，有以下方式</p>\n<ul>\n<li>通过事务机制</li>\n<li>通过发送方确认机制</li>\n</ul>\n<blockquote>\n<ul>\n<li>两者不能共存</li>\n<li>这里的确认消息发送到RabbitMQ是指消息被正确的发往RabbitMQ的交换器，如果交换器没有匹配的队列消息也可能会丢失，配合mandory参数或备份交换器使用</li>\n</ul>\n</blockquote>\n<h3 id=\"事务机制\"> 事务机制</h3>\n<p>相关的方法有三个</p>\n<ul>\n<li>channel.txSelect：将当前信道设置成事务模式</li>\n<li>channel.txCommit：用于提交事务</li>\n<li>channel.txRollback：用于事务回滚</li>\n</ul>\n<p>在通过channel.txSelect方法开启事务之后，我们便可以发布消息给RabbitMQ了：</p>\n<ul>\n<li>如果事务提交成功，则消息一定到达了RabbitMQ中</li>\n<li>如果在事务提交执行之前由于RabbitMQ异常崩溃或者其他原因抛出异常，这个时候我们便可以将其捕获，进而通过执行channel.txRollback方法来实现事务回滚。</li>\n</ul>\n<blockquote>\n<p>注意这里的RabbitMQ中的事务机制与大多数数据库中的事务概念并不相同，需要注意区分。</p>\n<p>事务机制在一条消息发送后会使发送端阻塞，以等待Rabbitmq回应，之后才能发送下一条消息</p>\n</blockquote>\n<div><pre><code><span>/**\n     * @description: 事务\n     **/</span>\n<span>@Test</span>\n<span>public</span> <span>void</span> <span>transaction</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n  <span>Channel</span> channel <span>=</span> <span>RabbitMqUtils</span><span>.</span><span>getChannel</span><span>(</span><span>)</span><span>;</span>\n  <span>//将信道设置为事务模式</span>\n  channel<span>.</span><span>txSelect</span><span>(</span><span>)</span><span>;</span>\n  channel<span>.</span><span>basicPublish</span><span>(</span>EXCHANGE_NAME<span>,</span> ROUTING_KEY<span>,</span> <span>MessageProperties</span><span>.</span>PERSISTENT_TEXT_PLAIN<span>,</span> <span>\"transaction\"</span><span>.</span><span>getBytes</span><span>(</span><span>)</span><span>)</span><span>;</span>\n  <span>//提交事务</span>\n  channel<span>.</span><span>txCommit</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>流程如下</p>\n<p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/RabbitMQ/rabbitmq事务.png\" alt=\"image-20220110154800172\" /></p>\n<ul>\n<li>客户端发送Tx.Select，将信道置为事务模式：</li>\n<li>Broker回复Tx.Select-Ok，确认已将信道置为事务模式；</li>\n<li>在发送完消息之后，客户端发送Tx.Commit提交事务；</li>\n<li>Broker回复Tx.Commit-Ok，确认事务提交。</li>\n</ul>\n<h4 id=\"事务回滚\"> 事务回滚</h4>\n<div><pre><code><span>/**\n     * @description: 事务\n     **/</span>\n<span>@Test</span>\n<span>public</span> <span>void</span> <span>transaction</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n  <span>Channel</span> channel <span>=</span> <span>RabbitMqUtils</span><span>.</span><span>getChannel</span><span>(</span><span>)</span><span>;</span>\n  <span>//将信道设置为事务模式</span>\n  channel<span>.</span><span>txSelect</span><span>(</span><span>)</span><span>;</span>\n  <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>10</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>\n    <span>try</span> <span>{</span>\n      channel<span>.</span><span>basicPublish</span><span>(</span>EXCHANGE_NAME<span>,</span> ROUTING_KEY<span>,</span> <span>MessageProperties</span><span>.</span>PERSISTENT_TEXT_PLAIN<span>,</span> <span>\"transaction\"</span><span>.</span><span>getBytes</span><span>(</span><span>)</span><span>)</span><span>;</span>\n      <span>//异常</span>\n      <span>int</span> result <span>=</span> <span>1</span> <span>/</span> <span>0</span><span>;</span>\n      <span>//提交事务</span>\n      channel<span>.</span><span>txCommit</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span> <span>catch</span> <span>(</span><span>Exception</span> e<span>)</span> <span>{</span>\n      e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n      <span>//在事务提交之前铺捉到异常并回滚</span>\n      channel<span>.</span><span>txRollback</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n  <span>}</span>\n\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/RabbitMQ/事务回滚.png\" alt=\"image-20220110160010989\" /></p>\n<h3 id=\"发送确认机制\"> 发送确认机制</h3>\n<p>使用事务机制会使RabbitMQ性能有损失造成吞吐量下降，所以有发送确认机制。</p>\n<p>生产者将信道设置成<code>confirm（确认）模式</code>，一旦信道进入confirm模式，所有在该信道上面发布的消息都会被指派一个唯一的ID（从1开始），一旦消息被投递到所有匹配的队列之后，RabbitMQ就会发送一个确认（Basic.Ack）给生产者（包含消息的唯一ID），这就使得生产者知晓消息已经正确到达了目的地了。</p>\n<blockquote>\n<p>如果消息和队列是可持久化的，那么确认消息会在消息写入磁盘之后发出。</p>\n</blockquote>\n<p>RabbitMQ回传给生产者的确认消息中的<code>deliveryTag</code>包含了确认消息，此外RabbitMQ也可以设置channel.basicAck方法中的<code>multiple</code>参数，表示到这个序号之前的所有消息都已经得到了处理，可以参考图4-10。注意辨别这里的确认和消费时候的确认之间的异同。</p>\n<p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/RabbitMQ/发送方确认机制.png\" alt=\"image-20220110171845530\" /></p>\n<p>事务机制在一条消息发送之后会使发送端阻塞，以等待RabbitMQ的回应，之后才能继续发送下一条消息。</p>\n<p>相比之下，发送方确认机制最大的好处在于它是<code>异步</code>的，一旦发布一条消息，生产者应用程序就可以在等信道返回确认的同时继续发送下一条消息，当消息最终得到确认之后，生产者应用程序便可以通过<code>回调方法</code>来处理该确认消息，如果RabbitMQ因为自身内部错误导致消息丢失，就会发送一条<code>nack（Basic.Nack）</code>命令，生产者应用程序同样可以在回调方法中处理该nack命令。</p>\n<h4 id=\"使用\"> 使用</h4>\n<ul>\n<li>生产者通过调用<code>channel.confirmSelect</code>方法（即Confirm.Select命令）将信道设置为<code>confirm</code>模式</li>\n<li>之后RabbitMQ会返回Confirm.Select-Ok命令表示同意生产者将当前信道设置为confirm模式。</li>\n<li>所有被发送的后续消息都被ack或者nack一次，不会出现一条消息既被ack又被nack的情况，并且RabbitMQ也并没有对消息被confirm的快慢做任何保证。</li>\n</ul>\n<p>确认方式</p>\n<ul>\n<li>单个同步确认：每发送一个消息就调用<code>channel.waitForConfirms</code>，这时候是同步串行化的</li>\n<li>批量确认：每发送一批消息后，再调用<code>channel.waitForConfirms</code>方法，等待服务器确认返回。当出现Nack或超时情况，客户端需要将这一批次消息重发，带来明显的重复消息数量，且经常消息丢失时，批量confirm性能不升反降</li>\n<li>异步确认：提供回调方法，服务端确认了一条或者多条消息后客户端会回调方法处理</li>\n</ul>\n<p>单个同步确认&amp;批量确认：</p>\n<div><pre><code><span>/**\n     * @description: 发送者确认：发送确认机制(单个同步确认，批量确认)\n     **/</span>\n<span>@Test</span>\n<span>public</span> <span>void</span> <span>confirm</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n  <span>Channel</span> channel <span>=</span> <span>RabbitMqUtils</span><span>.</span><span>getChannel</span><span>(</span><span>)</span><span>;</span>\n  <span>//设置为确认模式</span>\n  channel<span>.</span><span>confirmSelect</span><span>(</span><span>)</span><span>;</span>\n\n  <span>//单个同步确认</span>\n  <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>5</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>\n    <span>String</span> message <span>=</span> i <span>+</span> <span>\"producer confirm\"</span><span>;</span>\n    channel<span>.</span><span>basicPublish</span><span>(</span>EXCHANGE_NAME<span>,</span> ROUTING_KEY<span>,</span> <span>null</span><span>,</span> message<span>.</span><span>getBytes</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>//服务端返回 false 或超时时间内未返回，生产者可以消息重发</span>\n    <span>if</span> <span>(</span>channel<span>.</span><span>waitForConfirms</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n      <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"消息发送成功\"</span><span>)</span><span>;</span>\n    <span>}</span> <span>else</span> <span>{</span>\n      <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"消息发送失败\"</span><span>)</span><span>;</span>\n    <span>}</span>\n  <span>}</span>\n\n  <span>//批量确认</span>\n  <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>5</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>\n    <span>String</span> message <span>=</span> i <span>+</span> <span>\"producer confirm\"</span><span>;</span>\n    channel<span>.</span><span>basicPublish</span><span>(</span>EXCHANGE_NAME<span>,</span> ROUTING_KEY<span>,</span> <span>null</span><span>,</span> message<span>.</span><span>getBytes</span><span>(</span><span>)</span><span>)</span><span>;</span>\n  <span>}</span>\n  <span>if</span> <span>(</span>channel<span>.</span><span>waitForConfirms</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"消息批量发送成功\"</span><span>)</span><span>;</span>\n  <span>}</span> <span>else</span> <span>{</span>\n    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"消息批量发送失败\"</span><span>)</span><span>;</span>\n    <span>//重新批量发送消息</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div><p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/RabbitMQ/发送多条消息发送确认模式.png\" alt=\"image-20220110181136940\" /></p>\n<p>异步确认：</p>\n<p>异步confirm方法的编程实现最为复杂。在客户端Channel接口中提供的<code>addConfirmListener</code>方法可以添加<code>ConfirmListener</code>这个回调接口，这个ConfirmListener接口包含两个方法：<code>handleAck</code>和<code>handleNack</code>，分别用来处理\nRabbitMQ回传的<code>Basic.Ack</code>和<code>Basic.Nack</code>。在这两个方法中都包含有一个参数<code>deliveryTag</code>（在publisher confirm模式下用来标记消息的唯一有序序号）。我们需要为每一个信道维护一个已发送未确认的消息序号集合，</p>\n<ul>\n<li>在发送时根据channel.getNextPublishSeqNo()获取发送消息时的<code>deliveryTag</code>并插入</li>\n<li>在回调方法中根据返回的<code>deliveryTag</code>去移除集合中的消息或标记其已确认</li>\n</ul>\n<p>集合最好采用<code>SortedSet</code>维护消息序号，<code>waitForConfirms</code>也是通过<code>Sortedset</code>来维护消息序号</p>\n<div><pre><code><span>/**\n     * @description: 发送者确认：发送确认机制(异步确认)\n     **/</span>\n<span>@Test</span>\n<span>public</span> <span>void</span> <span>confirmAsync</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n  <span>Channel</span> channel <span>=</span> <span>RabbitMqUtils</span><span>.</span><span>getChannel</span><span>(</span><span>)</span><span>;</span>\n  channel<span>.</span><span>queuePurge</span><span>(</span>QUEUE_NAME<span>)</span><span>;</span>\n  channel<span>.</span><span>confirmSelect</span><span>(</span><span>)</span><span>;</span>\n  <span>/*\n         * 线程安全跳跃表\n         * 1.map能将序号与消息进行关联\n         * 2.轻松批量删除条目根据序号\n         * 3.线程安全并发\n         * */</span>\n  <span>//已发送未确认的消息</span>\n  <span>ConcurrentSkipListMap</span><span><span>&lt;</span><span>Long</span><span>,</span> <span>String</span><span>></span></span> outstandingConfirm <span>=</span> <span>new</span> <span>ConcurrentSkipListMap</span><span><span>&lt;</span><span>Long</span><span>,</span> <span>String</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n\n  <span>// 消息确认成功，回调函数</span>\n  <span>ConfirmCallback</span> ackCallback <span>=</span> <span>(</span>deliverTag<span>,</span> multiple<span>)</span> <span>-></span> <span>{</span>\n    <span>// 如果是批量的,就批量清除</span>\n    <span>if</span> <span>(</span>multiple<span>)</span> <span>{</span>\n      outstandingConfirm<span>.</span><span>headMap</span><span>(</span>deliverTag<span>,</span> <span>true</span><span>)</span><span>.</span><span>clear</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span> <span>else</span> <span>{</span>\n      outstandingConfirm<span>.</span><span>remove</span><span>(</span>deliverTag<span>)</span><span>;</span>\n    <span>}</span>\n    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"消息确认成功：\"</span> <span>+</span> deliverTag<span>)</span><span>;</span>\n  <span>}</span><span>;</span>\n  <span>/*\n         * 1. 消息的标记\n         * 2. 是否为批量确认\n         * */</span>\n  <span>ConfirmCallback</span> nackCallback <span>=</span> <span>(</span>deliverTag<span>,</span> multiple<span>)</span> <span>-></span> <span>{</span>\n    <span>String</span> message <span>=</span> outstandingConfirm<span>.</span><span>get</span><span>(</span>deliverTag<span>)</span><span>;</span>\n    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"未确认的消息：\"</span> <span>+</span> deliverTag<span>)</span><span>;</span>\n  <span>}</span><span>;</span>\n\n  <span>/*\n         * 消息监听器\n         * 1. 监听那些成功了\n         * 2. 监听那些失败了\n         * */</span>\n  channel<span>.</span><span>addConfirmListener</span><span>(</span>ackCallback<span>,</span> nackCallback<span>)</span><span>;</span>\n  <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>10</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>\n    <span>String</span> message <span>=</span> <span>String</span><span>.</span><span>valueOf</span><span>(</span>i<span>)</span><span>;</span>\n    outstandingConfirm<span>.</span><span>put</span><span>(</span>channel<span>.</span><span>getNextPublishSeqNo</span><span>(</span><span>)</span><span>,</span> message<span>)</span><span>;</span>\n    channel<span>.</span><span>basicPublish</span><span>(</span>EXCHANGE_NAME<span>,</span> ROUTING_KEY<span>,</span> <span>null</span><span>,</span> message<span>.</span><span>getBytes</span><span>(</span><span>)</span><span>)</span><span>;</span>\n  <span>}</span>\n  <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"发布\"</span> <span>+</span> <span>10</span> <span>+</span> <span>\"个异步确认消息\"</span><span>)</span><span>;</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br></div></div><h4 id=\"watiforconfirm\"> watiForConfirm</h4>\n<p>如果没有开启confirm模式调用任何watiForConfirm都会报错。</p>\n<div><pre><code><span>/**\n * Wait until all messages published since the last call have been\n * either ack'd or nack'd by the broker.  Note, when called on a\n * non-Confirm channel, waitForConfirms throws an IllegalStateException.\n * @return whether all the messages were ack'd (and none were nack'd)\n * @throws java.lang.IllegalStateException\n */</span>\n<span>boolean</span> <span>waitForConfirms</span><span>(</span><span>)</span> <span>throws</span> <span>InterruptedException</span><span>;</span>\n\n<span>/**\n * Wait until all messages published since the last call have been\n * either ack'd or nack'd by the broker; or until timeout elapses.\n * If the timeout expires a TimeoutException is thrown.  When\n * called on a non-Confirm channel, waitForConfirms throws an\n * IllegalStateException.\n * @return whether all the messages were ack'd (and none were nack'd)\n * @throws java.lang.IllegalStateException\n */</span>\n<span>boolean</span> <span>waitForConfirms</span><span>(</span><span>long</span> timeout<span>)</span> <span>throws</span> <span>InterruptedException</span><span>,</span> <span>TimeoutException</span><span>;</span>\n\n<span>/** Wait until all messages published since the last call have\n * been either ack'd or nack'd by the broker.  If any of the\n * messages were nack'd, waitForConfirmsOrDie will throw an\n * IOException.  When called on a non-Confirm channel, it will\n * throw an IllegalStateException.\n * @throws java.lang.IllegalStateException\n */</span>\n <span>void</span> <span>waitForConfirmsOrDie</span><span>(</span><span>)</span> <span>throws</span> <span>IOException</span><span>,</span> <span>InterruptedException</span><span>;</span>\n\n<span>/** Wait until all messages published since the last call have\n * been either ack'd or nack'd by the broker; or until timeout elapses.\n * If the timeout expires a TimeoutException is thrown.  If any of the\n * messages were nack'd, waitForConfirmsOrDie will throw an\n * IOException.  When called on a non-Confirm channel, it will\n * throw an IllegalStateException.\n * @throws java.lang.IllegalStateException\n */</span>\n<span>void</span> <span>waitForConfirmsOrDie</span><span>(</span><span>long</span> timeout<span>)</span> <span>throws</span> <span>IOException</span><span>,</span> <span>InterruptedException</span><span>,</span> <span>TimeoutException</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br></div></div><p><code>waitForConfirmsOrDie</code>在接收到RabbitMQ返回的Basic.Nack之后会抛出<code>IoException</code>异常</p>\n<h3 id=\"比较\"> 比较</h3>\n<p>四种方式比较</p>\n<p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/RabbitMQ/生产者确认四种方式QPS比较.png\" alt=\"image-20220110223704926\" /></p>\n<p>可以看到批量confirm和异步confirm这两种方式所呈现的性能要比其余两种好得多。</p>\n<p>事务机制和普通confirm的方式吐吞量很低，但是编程方式简单，不需要在客户端维护状态（这里指的是维护deliveryTag及缓存未确认的消息）</p>\n<p>批量confirm方式的问题在于遇到RabbitMQ服务端返回Basic.Nack需要重发批量消息而导致的性能降低。异步confirm方式编程模型最为复杂，而且和批量confirm方式一样需要在客户端维护状态。</p>\n<p>在实际生产环境中采用何种方式，这里就仁者见仁智者见智了，不过<strong>强烈建议读者使用异步confirm的方式</strong>。</p>\n<h2 id=\"消费端要点\"> 消费端要点</h2>\n<p>对于消费者有几点要注意</p>\n<ul>\n<li>消息分发</li>\n<li>消息顺序性</li>\n<li>弃用QueueingConsumer</li>\n</ul>\n<h3 id=\"消息分发\"> 消息分发</h3>\n<p>当RabbitMQ队列拥有多个消费者时，队列收到的消息将以<code>轮询（round-robin）</code>的分发方式发送给消费者。每条消息只会发送给订阅列表里的一个消费者。这种方式非常适合扩展，而且它是专门为并发程序设计的。如果现在负载加重，那么只需要创建更多的消费者来消费处理消息即可。</p>\n<p>轮询的方式在消费者处理性能方面不能做到好的均衡，有些消费者处理慢有些处理快造成整体吞吐量下降，可以用到<code>channel.basicQos(int prefetchCount)</code>这个方法，<strong>允许限制信道上的消费者所能保持的最大未确认消息数量</strong>。</p>\n<p>举例说明，在订阅消费队列之前，消费端程序调用了<code>channel.basicQos(5)</code>，之后订阅了某个队列进行消费。RabbitMO会保存一个消费者的列表，每发送一条消息都会为对应的消费者计数，如果达到了所设定的上限，那么RabbitMQ就不会向这个消费者再发送任何消息。直到消费者确认了某条消息之后，RabbitMQ将相应的计数减l，之后消费者可以继续接收消息，直到再次到达计数上限。这种机制可以类比于TCP/IP中的“滑动窗口”。</p>\n<blockquote>\n<p>basicQos对于拉模式无效</p>\n<p>basicQos设置为0则无上限</p>\n</blockquote>\n<p>channel.basicQos方法</p>\n<p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/RabbitMQ/basicQos.png\" alt=\"image-20220114140010010\" /></p>\n<p>参数</p>\n<ul>\n<li>\n<p>prefetchCount：允许限制信道上的消费者所能保持的最大未确认消息数量，设置为0无上限</p>\n</li>\n<li>\n<p>prefetchCount：消息本身大小限制，设置为0无上限</p>\n</li>\n<li>\n<p>grobal：</p>\n<p>对于一个信道来说，它可以同时消费多个队列，当设置了<code>prefetchCount</code>大于0时，这个信道需要和各个队列协调以确保发送的消息都没有超过所限定的prefetchCount的值，这样会使RabbitMQ的性能降低，尤其是这些队列分散在集群中的多个Broker节点之中。RabbitMQ为了提升相关的性能，在AMQP0-9-1协议之上重新定义了global这个参数，对比如表4-1所示。</p>\n<p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/RabbitMQ/grobal参数对比.png\" alt=\"image-20220114141718769\" /></p>\n</li>\n</ul>\n<blockquote>\n<p>global为true时是对整个信道的未确认数量总和做限制和共享</p>\n</blockquote>\n<p>示例</p>\n<p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/RabbitMQ/多个global.png\" alt=\"image-20220114150921343\" /></p>\n<p>那么这里每个消费者最多只能收到<code>3个</code>未确认的消息，两个消费者能收到的未确认的消息个数之和的上限为<code>5个</code>。在未确认消息的情况下，如果consumerl接收到了消息、1、2和3，那么consumer2至多只能收到11和12.如果像这样同时使用两种global的模式，则会增加RabbitMQ的负载，因为RabbitMQ需要更多的资源来协调完成这些限制。</p>\n<p>如无特殊需要，最好只使用global为false的设置，这也是默认的设置。</p>\n<h3 id=\"消息顺序性\"> 消息顺序性</h3>\n<p>指消费者消费到的消息和发送者发布的消息顺序一致。</p>\n<p>理想情况下消息是顺序性的，下面一些情况RabbitMQ的顺序性会被打破：</p>\n<ul>\n<li>生产者使用<code>事务机制</code>或<code>确认模式</code>，发送消息后遇到异常进行消息补偿发送，此时需要重新补偿发送消息，补偿消息是另一个线程实现此时顺序就会打乱</li>\n<li>生产者设置不同的消息TTL且设置死信队列，此时消费者消息死信队列的消费顺序和生产者发送消息的顺序不一致</li>\n<li>生产者设置不同的消息优先级</li>\n<li>多个消费者消费时，有消费者拒绝且设置requeue为true，此时其他消费者会消费这个被拒绝重新入队的消息</li>\n</ul>\n<p>解决办法</p>\n<p>需要业务方使用RabbitMQ做进一步处理，比如在消息体内添加全局有序标识符(类似Sequence ID)</p>\n<h3 id=\"弃用queueingconsumer\"> 弃用QueueingConsumer</h3>\n<p>内存溢出问题，底层使用的是<code>LinkedBlockingQueue</code>，通过设置BasicQos来解决，除此之外还有其他缺陷：</p>\n<ul>\n<li>QueueingConsumer会拖累同一个Connection下的所有信道，使其性能降低；</li>\n<li>同步递归调用QueueingConsumer会产生死锁；</li>\n<li>RabbitMQ的自动连接恢复机制（automatic connection recovery）不支持QueueingConsumer的这种形式；</li>\n<li>QueueingConsumer不是事件驱动的。</li>\n</ul>\n<p>为了避免不必要的麻烦，建议在消费的时候尽量使用继承DefaultConsumer的方式，</p>\n<h2 id=\"消息传输保障\"> 消息传输保障</h2>\n<p>消息传输保障分为三个层级</p>\n<ul>\n<li>At most once：最多一次。消息可能会丢失，但绝不会重复传输。</li>\n<li>At least once：最少一次。消息绝不会丢失，但可能会重复传输。</li>\n<li>Exactly once：恰好一次。每条消息肯定会被传输一次且仅传输一次。</li>\n</ul>\n<p>RabbitMQ支持最多一次和最少一次，投递要考虑以下几个方面内容去保障消息</p>\n<ul>\n<li>生产者要开启事务机制或者生产者确认机制，确保消息可靠地传输到RabbitMQ中</li>\n<li>生产者需要配合使用mandatory参数或者备份交换器来确保消息能够从交换器路由到队列中，进而保存下来不被丢弃</li>\n<li>消息和队列都要持久化处理，以确保RabbitMQ服务器在遇到异常情况时不会消息丢失</li>\n<li>消费者在消费消息的同时需要将<code>autoAck</code>设置为<code>false</code>，然后通过手动确认的方式去确认已经正确消费的消息，避免在消费端消息丢失</li>\n</ul>\n<h3 id=\"恰好一次\"> 恰好一次</h3>\n<p>RabbitMQ无法保障恰好一次，有两种情况重复消费情况</p>\n<ul>\n<li>消费者这边发送Basic.Ack的这时候网络断开，此时RabbitMQ没有收到命令且断开后就会重新将消息入队，此时这条消息就会被<code>重复消费</code></li>\n<li>生产者使用生产者确认机制时，此时网络断开，生产者做异常处理重新发送消息，此时RabbitMQ就会有两个一样的消息，造成<code>重复消费</code></li>\n</ul>\n<p>目前主流消息中间件没有去重机制，去重处理一般在客户端实现，比如<code>GUID</code>，可能需要借助集中式缓存去存储然后去重</p>\n<h2 id=\"rabbitmq管理\"> RabbitMQ管理</h2>\n<h3 id=\"多用户和权限\"> 多用户和权限</h3>\n<p>每一个RabbitMO服务器都能创建虚拟的消息服务器，我们称之为虚拟主机（virtual host），简称为vhost.</p>\n<p>每一个vhost本质上是一个独立的小型RabbitMQ服务器，拥有自己独立的队列、交换器及绑定关系等，并且它拥有自己独立的权限。vhost就像是虚拟机与物理服务器一样，它们在各个实例间提供逻辑上的分离，为不同程序安全保密地运行数据，它既能将同一个RabbitMQ中的众多客户区分开，又可以避免队列和交换器等命名冲突。</p>\n<p>vhost之间是<code>绝对隔离</code>的，无法将vhostl1中的交换器与vhost2中的队列进行绑定，这样既保证了安全性，又可以确保可移植性</p>\n<p>如果在使用RabbitMQ达到一定规模的时候，建议用户对业务功能、场景进行归类区分，并为之分配独立的vhost。</p>\n<p>vhost是AMQP概念的基础，客户端在连接的时候必须制定一个vhost。RabbitMQ默认创建的vhost为<code>“/”</code>，如果不需要多个vhost或者对vhost的概念不是很理解，那么用这个默认的vhost也是非常合理的，使用默认的用户名guest和密码guest就可以访问它。但是为了安全和方便，建议重新建立一个新的用户来访问它。</p>\n<p>vhost有关命令</p>\n<p>创建vhost</p>\n<div><pre><code>//创建vhost\nrabbitmqctl add_vhost vhost1\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>查询vhost</p>\n<div><pre><code>//tracing是否使用了trace功能\nrabbitmqctl list_vhost <span>[</span>name<span>]</span> <span>[</span>tracing<span>]</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>删除vhost</p>\n<div><pre><code>rabbitmqctl delete_bhost <span>[</span>name<span>]</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>vhost权限</p>\n<p>AMQP协议中并没有指定权限在vhost级别还是在服务器级别实现，由具体的应用自定义。在RabbitMQ中，权限控制则是<code>以vhost为单位</code>的。当创建一个用户时，用户通常会被指派给至少一个vhost，并且只能访问被指派的vhost内的队列、交换器和绑定关系等。因此，RabbitMQ中的授予权限是指在vhost级别对用户而言的权限授予。</p>\n<p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/RabbitMQ/rabbitmq授予权限命令.png\" alt=\"image-20220114213316862\" /></p>\n<blockquote>\n<ul>\n<li>可配置：指的是队列和交换器的创建及删除之类的操作；</li>\n<li>可写：指的是发布消息；</li>\n<li>可读：指与消息有关的操作，包括读取消息及清空整个队列等。</li>\n</ul>\n</blockquote>\n<p>AMQP命令与权限的映射关系</p>\n<p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/RabbitMQ/AMQP命令与权限的映射关系.png\" alt=\"image-20220114213500746\" /></p>\n<p>vhost权限分配示例</p>\n<div><pre><code>//授予root用户可访问虚拟主机vhostl，并在所有资源上都具备可配置、可写及可读的权限\nrabbitmqctl set_permissions -p vhost1 root <span>\".*\"</span> <span>\".*\"</span> <span>\".*\"</span>\n\n//授予root用户可访问虚拟主机vhost2，在以“queue”开头的资源上具备可配置权限，并在所有资源上拥有可写、可读的权限\nrabbitmqctl set_permissions -p vhost2 root <span>\"^queue.*\"</span> <span>\".*\"</span> <span>\".*\"</span>\n\n//清除权限\nrabbitmqctl clear_permissions -p vhost2 root\n\n//列举vhost的相关用户权限\nrabbitmqctl list_permissions -p vhost1\n  Listing permissions <span>for</span> vhost <span>\"vhost1\"</span> <span>..</span>.\n  user\tconfigure\t<span>write</span>\t<span>read</span>\n  root\t.*\t.*\t.*\n\n//列举用户的权限\nrabbitmqctl list_user_permissions root\n  Listing permissions <span>for</span> user <span>\"root\"</span> <span>..</span>.\n  vhost\tconfigure\t<span>write</span>\t<span>read</span>\n  /\t.*\t.*\t.*\n  vhost1\t.*\t.*\t.*\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><h3 id=\"用户管理\"> 用户管理</h3>\n<p>罗列用户</p>\n<div><pre><code>rabbitmqctl list_users\n  Listing <span>users</span> <span>..</span>.\n  user\ttags\n  guest\t<span>[</span>administrator<span>]</span>\n  root\t<span>[</span>administrator<span>]</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>创建用户</p>\n<div><pre><code>rabbitmqctl add_user <span>{</span>username<span>}</span> <span>{</span>password<span>}</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>设置角色</p>\n<ul>\n<li>none：无任何角色，默认角色</li>\n<li>management：可以访问web管理界面</li>\n<li>policymaker：包含management权限，并且可管理策略policy和参数</li>\n<li>monitoring：包含management权限，并且可以看到所有连接，信道以及节点</li>\n<li>administrator：包含management权限，并且可以管理用户，虚拟主机，权限，策略，参数等，最高权限</li>\n</ul>\n<div><pre><code>rabbitmqctl set_user_tags {username} {tag...}\n</code></pre>\n<div><span>1</span><br></div></div><p>改密码</p>\n<div><pre><code>rabbitmqctl change_password <span>{</span>username<span>}</span> <span>{</span>password<span>}</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>用户验证</p>\n<div><pre><code>rabbitmqctl authenticate_user <span>{</span>username<span>}</span> <span>{</span>password<span>}</span>\n  Authenticating user <span>\"root1\"</span> <span>..</span>.\n  Success\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>删除用户</p>\n<div><pre><code>rabbitmqctl delete_user\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"web端管理\"> Web端管理</h3>\n<h2 id=\"应用与集群\"> 应用与集群</h2>\n<h3 id=\"应用\"> 应用</h3>\n<div><pre><code>//停止运行rabbitMQ的Erlang虚拟机和RabbitMQ服务应用,如果指定pid文件还需要等待指定进程结束\nrabbitmqctl stop <span>{</span>pid.file<span>}</span>\n\n//停止运行rabbitMQ的Erlang虚拟机和RabbitMQ服务应用\nrabbitmqctl <span>shutdown</span>\n\n//停止RabbitMQ应用但是Erlang虚拟机还是运行状态。一般用于管理操作前停止RabbitMQ\nrabbitmqctl stop_app\n\n//启动RabbitMQ应用\nrabbitmqctl start_app\n\n//等待RabbitMQ应用启动，会等到pid_file创建且pid_file中的进程启动\nrabbitmqctl <span>wait</span> <span>{</span>pid_file<span>}</span>\n\n//将RabbitMQ节点重置还原到最初状态，包括用户，vhost，所有数据等\nrabbitmqctl reset/force_reset\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h3 id=\"集群\"> 集群</h3>\n<div><pre><code>//将节点加入到指定集群\nrabbitmqctl join_cluster <span>{</span>cluster_node<span>}</span>\n\n//集群状态\nrabbitmqctl cluster_status\n\n//修改集群节点类型,这个命令前需要停止RabbitMQ应用\nrabbitmqctl change_cluster_node_type <span>{</span>disc<span>|</span>ram<span>}</span>\n\n//将节点从集群中删除,允许离线执行\nrabbitmqctl forget_cluster_node <span>[</span>--offline<span>]</span>\n\n//在集群的节点应用启动前咨询clusternode节点的最新消息，并更新相应的集群消息\nrabbitmqctl update_cluster_nodes <span>{</span>clusternode<span>}</span>\n\n//确保节点可以启动，通常集群关闭时再启动的第一个节点是最后关闭的节点\n//在特殊情况下所有节点都认为自己是最后一个节点，使用该命令告诉节点可以无条件启动节点\nrabbitmqctl force_boot\n\n//指示未同步队列queue的slave镜像可以同步master镜像行的内容，前提是queue配置了镜像\n//未同步队列中的消息被耗尽后，也会变成同步，主要用于为耗尽队列\nrabbitmqctl sync_queue <span>[</span>-p vhost<span>]</span> <span>{</span>queue<span>}</span>\n\n//取消队列同步镜像\nrabbitmqctl cancel_sync_queue <span>[</span>-p vhost<span>]</span> <span>{</span>queue<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><h3 id=\"服务端状态\"> 服务端状态</h3>\n<h4 id=\"队列查询\"> 队列查询</h4>\n<div><pre><code>//没指定vhost则默认为/，queueInfoItem显示的属性\nrabbitmqctl list_queues [-p vhost] [queueInfoItem]\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>显示属性示例</p>\n<p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/RabbitMQ/queue显示属性1.png\" alt=\"image-20220115214336053\" /></p>\n<h4 id=\"交换器\"> 交换器</h4>\n<div><pre><code>rabbitmqctl list_exchanges [-p vhost] [exchangeInfoItem]\n</code></pre>\n<div><span>1</span><br></div></div><p>可选显示参数</p>\n<p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/RabbitMQ/交换器可显示参数.png\" alt=\"image-20220115214725834\" /></p>\n<h4 id=\"绑定\"> 绑定</h4>\n<div><pre><code>rabbitmqctl list_bindings [-p vhost] [bindingInfoItem]\n</code></pre>\n<div><span>1</span><br></div></div><p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/RabbitMQ/绑定可选显示参数.png\" alt=\"image-20220115215014713\" /></p>\n<h4 id=\"连接-2\"> 连接</h4>\n<p>获取TCP/IP连接信息</p>\n<div><pre><code>rabbitmqctl list_connections [-p vhost] [connectionInfoItem]\n</code></pre>\n<div><span>1</span><br></div></div><p>其他更多参考官方文档</p>\n<h3 id=\"httpapi管理\"> HTTPAPI管理</h3>\n<p>接口列表可以在web管理界面的左下角的HTTP API</p>\n<p><a href=\"http://localhost:15672/api/index.html\" target=\"_blank\" rel=\"noopener noreferrer\">http://localhost:15672/api/index.html</a></p>\n<p>如果单纯使用curl方式可以用<code>rabbitmqadmin</code>工具来调用，是一个python脚本，该工具只是一种用于访问 rabbitmq-server api 便捷方式</p>\n<ul>\n<li><a href=\"https://www.rabbitmq.com/management-cli.html\" target=\"_blank\" rel=\"noopener noreferrer\">官方文档参考</a></li>\n<li><a href=\"http://soft.dog/2016/04/20/RabbitMQ-cli-rabbitmqadmin/\" target=\"_blank\" rel=\"noopener noreferrer\">rabbitmqadmin使用</a></li>\n</ul>\n<p>工具下载方式：</p>\n<div><pre><code><span>curl</span> http://localhost:15672/cli/rabbitmqadmin\n</code></pre>\n<div><span>1</span><br></div></div><h2 id=\"rabbitmq配置\"> RabbitMQ配置</h2>\n<p>大多数情况不用修改配置，提供了三种方式定制化：</p>\n<ul>\n<li>环境变量（Enviroment Variables）。RabbitMQ服务端参数可以通过环境变量进行配置，例如，节点名称、RabbitMQ配置文件的地址、节点内部通信端口等。</li>\n<li>配置文件（Configuration File）。可以定义RabbitMQ服务和插件设置，例如，TCP监听端口，以及其他网络相关的设置、内存限制、磁盘限制等。</li>\n<li>运行时参数和策略（Runtime Parameters and Policies）。可以在运行时定义集群层面的服务设置。</li>\n</ul>\n<h3 id=\"环境变量\"> 环境变量</h3>\n<p>在Shell环境中配置，环境变量都是以<code>RABBITMQ_</code>开头，也可以在<code>rabbitmq-env.conf</code>中配置</p>\n<p>非Shell环境中配置，则需要去除<code>RABBITMQ_</code>前缀</p>\n<p>优先级：Shell环境 &gt; 配置文件 &gt; 默认配置</p>\n<p>当采用rabbitmq-server-detached启动RabbitMQ服务的时候，此服务节点默认以“rabbit@”加上当前的Shell环境的hostname（主机名）来命名，即rabbit@$HOSTNAME。如果要自定义名称可以在<code>rabbitmq-server</code>命令前添加<code>RABBITMQ_NODENAME</code></p>\n",
      "image": "https://blog-1300186248.cos.ap-shanghai.myqcloud.com/RabbitMQ/RabbitMQ.png",
      "date_published": "2021-08-13T00:04:05.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": []
    },
    {
      "title": "音频批量识别平台",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/my-project/Music-Recognition/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/my-project/Music-Recognition/",
      "summary": "音频批量识别平台",
      "content_html": "<h2 id=\"需求评审-拆分\"> 需求评审/拆分</h2>\n<p>入职后了解到招我是因为目前有许多其他部门需要批量调用我们的<code>识曲服务SDK</code>，有着采用脚本或者临时调用的方式繁琐，不可控，沟通成本高，无法持久化日志等等痛点，所以一直想做一个开放平台中台，通过中台去调用服务。对于需求方来说，可视化，方便，实时查看批量识曲结果，可增量；而对于我们服务提供者兼管理者而言，可以动态查看各个识曲任务调用的SDK的QPS可视化并做到随时动态控制和预警，还能根据需求方那边具体的业务分配QPS并提前扩容(申请机器)等等，最重要的是让我们和需求方的对接规范化，流程化，可监控是最重要的。甚至以后还有可能开放出去面向<code>toB</code>，将听歌识曲开放平台推广(可参考其他开放平台<a href=\"https://www.acrcloud.com/music-recognition/\" target=\"_blank\" rel=\"noopener noreferrer\">ACRCloud</a>)</p>\n<p><img src=\"./images/Music-Recognition/acrcloud.jpg\" alt=\"acrcloud\" /></p>\n<p>并要求拥有基础的用户角色体系，管理员能随时查看和控制每个用户的每个任务调用<code>识曲服务SDK</code>的QPS，并能可视化监控和预警。<code>识曲服务SDK</code>采用的是http协议，即调用接口API的方式，所以会考虑到并发等问题所以要从我们这边控制好调用的QPS。过了两个月开发功能快完成时，与大部分需求方开了个关于数据源的形式的需求讨论会，发现大部分部门还是希望能简化调用，于是我们提出可以从原来的识曲任务绑定资源库的方式改为识曲任务绑定数据库的形式，需求方提供数据库地址端口号密码等，每次增量数据库就通知识曲任务增量。但在讨论过后发现不同部门一般不会暴露数据库，要做隔离，最后敲定说我们开放API接口的方式供他们调用，进行推送任务，查询结果等，还供给我们回调接口，即每识别一批增量数据后将结果推送到他们的接口。</p>\n<h2 id=\"技术栈总览\"> 技术栈总览</h2>\n<div><p>技术栈总览</p>\n<ul>\n<li>【前端】：Vue.js+ElementUi</li>\n<li>【后端】：Springboot，SpringSecurity，Swagger，JWT(Java Web Token)，Mybatis Plus，Druid数据库连接池，EasyExcel</li>\n<li>【数据库】：Mysql，Redis</li>\n<li>【服务器】：Docker，Docker-compose，Nginx</li>\n<li>【监控】：Grafana+Prometheus</li>\n</ul>\n</div>\n<h2 id=\"前端\"> 前端</h2>\n<div><p>技术栈</p>\n<p>Vue.js+组件ElementUi</p>\n</div>\n<p>为了快速开发前端，使用Vue.js搭配组件ElementUi，后面将项目打包build后放到Docker部署的Nginx中，进行反向代理。开发难度基本不高。</p>\n<h2 id=\"后端\"> 后端</h2>\n<div><p>技术栈</p>\n<ul>\n<li>Springboot</li>\n<li>SpringSecurity</li>\n<li>Swagger</li>\n<li>JWT(Java Web Token)</li>\n<li>Mybatis Plus</li>\n<li>Druid数据库连接池</li>\n<li>EasyExcel</li>\n</ul>\n</div>\n<p>后端为了快速搭建好整体业务框架采用了<code>Springboot+MybatisPlus</code>，在设计好初步的数据库后，利用<code>MybatisPlus</code>的逆向工程快速生成代码，包括entity，dao，service，controller层等，然后开始基本的业务开发。</p>\n<h3 id=\"使用springsecurity做登录验证和动态权限过滤\"> 使用SpringSecurity做登录验证和动态权限过滤</h3>\n<p>spring security 的核心功能主要包括：</p>\n<div><p>Info</p>\n<ul>\n<li>认证 （你是谁）</li>\n<li>授权 （你能干什么）</li>\n<li>攻击防护 （防止伪造身份）</li>\n</ul>\n</div>\n<p>一开始做登录验证和动态权限的时候，就想到使用SpringSecurity。对于密码加密和验证，使用里面自带的<code>Bcrypt</code>进行加密和验证，后面使用内网登录的时候就没使用。而关于权限验证过滤的问题，需要做到对用户的每个API请求都判断是否有权限，下面是SpringSecurity的整体流程活动图：</p>\n<p><img src=\"./images/Music-Recognition/SpringSecurity.jpg\" alt=\"SpringSecurity活动流程图\" /></p>\n<p>通过<code>getAuthorities</code>来获取该用户的角色集合需要用户实体类实现<code>SpringSecurity</code>自带的<code>UserDetails</code>，重写<code>Collection&lt;? extends GrantedAuthority&gt; getAuthorities()</code>方法，自己写根据用户获取角色的方法，然后将角色名提取出来生成集合。</p>\n<p>而与之对应的是数据库设计，围绕着<code>RBAC</code>设计，设计了用户，角色，菜单以及中间表用户角色，角色菜单中间表。</p>\n<p>而关于token采用的不是session等实现方式，由于http协议是无状态的，每一次请求都无状态。当一个用户通过用户名和密码登录了之后，他的下一个请求不会携带任何状态，应用程序无法知道他的身份，那就必须重新认证。因此我们希望用户登录成功之后的每一次http请求，都能够保存他的登录状态。所以使用了符合无状态stateless的JWT来做token，好处是在服务服务均衡的时候无需服务保存一份对应的token，一旦用户注销，令牌将在客户端被销毁，且在负载均衡应用程序分布式部署的情况下，session需要做多机数据共享，通常可以存在数据库或者redis里面。而jwt不需要。</p>\n<h3 id=\"使用swagger做技术文档\"> 使用Swagger做技术文档</h3>\n<p>在于前端对接时，一份动态的swagger接口API文档能帮助我们调试接口，接口说明等以此降低对接的沟通成本和准确率</p>\n<h3 id=\"使用mybatisplus\"> 使用MybatisPlus</h3>\n<p>通过MybatisPlus的逆向工程和自定义代码模板快速生成entity，dao，service，controller等，且自带封装好的方法已经能满足大部分的场景的CRUD需求</p>\n<h3 id=\"使用druid做数据库连接池\"> 使用Druid做数据库连接池</h3>\n<p>使用Alibaba的Druid做连接池，并监控执行SQL语句次数，时间等</p>\n<h2 id=\"数据库\"> 数据库</h2>\n<div><p>技术栈</p>\n<ul>\n<li>Mysql</li>\n<li>Redis</li>\n</ul>\n</div>\n<h3 id=\"mysql\"> Mysql</h3>\n<p>Mysql主要难点还是表的设计，且了解到到时候将会吧数据在公司维护的Mysql数据库中，所以没有过于考虑其他。</p>\n<h3 id=\"redis\"> Redis</h3>\n<p>redis作为一个支持多种数据类型，读写性能高地key-value数据库，在项目许多地方使用的都很多，而且不用太过于考虑内存(公司服务器内存一般比较充足)。</p>\n<p>具体在项目使用用途有</p>\n<h4 id=\"将系统相关的配置改动较少但读比较多的放在redis中\"> 将系统相关的配置改动较少但读比较多的放在redis中</h4>\n<div><p>Info</p>\n<p>将系统相关的配置改动较少但读比较多的放在redis中，例如角色对应菜单，前端表单下拉框，返回体等放在redis中，每次获取时先从redis中获取，如果没有就从数据库获取，然后再写入redis中，同样改动这些的时候，改动数据库和redis即可。存入的都是序列化后的对象</p>\n</div>\n<h4 id=\"单点登录\"> 单点登录</h4>\n<div><p>Info</p>\n<p>用户在第一次登录后不仅返回token，还会将当时登录的时间戳存入到redis中，而前端则将时间戳放到请求头中，用户的每次请求都会比较请求头中的时间戳和redis的时间戳，此时就有三种情况</p>\n<ul>\n<li>请求头中的时间戳<code>小于</code>redis中的时间戳：说明用户在其他地方登录了并更新了redis中的时间戳，那么当前用户便会被挤下去重新回到登录界面</li>\n<li>请求头中的时间戳<code>等于</code>redis中的时间戳：说明时间戳没变，则允许访请求</li>\n</ul>\n<p>得益于redis的高性能读写的特性，每次请求都去做验证的耗时很快，唯一阻碍的就是网络阻塞等</p>\n</div>\n<h4 id=\"实时反馈任务状态和任务队列\"> 实时反馈任务状态和任务队列</h4>\n<p>项目功能中，用户在创建任务并开始识曲任务后，前端能实时反馈识曲进度，剩余时间等，于是在创建任务后便使用redis的<code>hash</code>数据结构来存储，field有总数total，已完成finish，状态state，调用频率qps，total一般不会变，而当每识曲完一条，finish字段就自增1，对于前端来说，定时调度查询这些字段的接口实时返回进度。如果将这些字段放在普通数据库中，去轮询调用，且不说操作的是磁盘IO速度相对较慢，频繁的修改finish这个字段也会产生事务一致性同步等问题。</p>\n<p>另外，将redis的<code>list</code>改造成队列，每当任务下有新的小任务，我就会<code>RPUSH</code>到redis的<code>list</code>，然后后台的识曲任务则循环从里面<code>LPOP</code>去取，为了批量取一定的数据这里我用到了redis的<code>事务</code>，也叫管道操作，因为每次都去取受网络等因素影响最后累积也会造成性能下降，所以用<code>pipeline</code>去完成两个命令，即</p>\n<div><pre><code>pipe <span>=</span> r.pipeline<span>(</span><span>)</span>\npipe.lrange<span>(</span>my_key, <span>0</span>, <span>3</span><span>)</span>\npipe.ltrim<span>(</span>my_key, <span>4</span>, -1<span>)</span>\npipe.execute<span>(</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>这样操作能保证一致性，当然新版本的redis中pop已经有参数count可以直接取多个。</p>\n<p>这样子在redis list中一个生产者消费者队列，既可以避免了频繁从数据库磁盘IO获取引起阻塞性能下降，也避免了一次性取出大量数据堆积在JVM中当任务一多时造成<code>OOM(out of memory)</code>，且一边生产，一边消费，后期增量任务时也方便容易。做好redis的持久化后，也不用担心任务队列丢失，在后台做好异常捕捉，如果中途发生错误，就暂停任务，且将消费取出的任务重新塞回redis list队列中。</p>\n<h2 id=\"服务器\"> 服务器</h2>\n<div><p>技术栈</p>\n<ul>\n<li>Docker</li>\n<li>Nginx</li>\n</ul>\n</div>\n<h3 id=\"docker\"> Docker</h3>\n<p>整个项目的所有使用到的都通过Docker容器部署在服务器上，好处是通过Dockerfile能随时做镜像版本的迭代，且将镜像打包push到hub上，也能随时做好项目服务的迁移。使用Docker，能很容易开启多个Springboot后台容器从而使用Nginx的负载均衡到各个服务上，且使用数据卷挂载，在持久化redis，mysql数据，随时修改Nginx配置等都非常方便。</p>\n<h3 id=\"nginx\"> Nginx</h3>\n<p>Nginx主要是做反向代理，直接将域名指向打包好的Vue项目。在搭配负载均衡轮询多个Springboot后台，顺便解决了跨域的问题。除此之外，在对接内网登录的时候用到了链路，当用户访问域名时会转发到智能网关，用户在智能网关登录后，返回的用户信息是写在响应头中，但是在前端的响应头中看不到，需要在<code>Nginx</code>中奖响应头的中的内容写到返回给前端的响应头即<code>add_header</code>写到响应头中去，链路图如下</p>\n<p><img src=\"./images/Music-Recognition/ioa.jpg\" alt=\"ioa链路活动图\" /></p>\n<h2 id=\"监控\"> 监控</h2>\n<div><p>技术栈</p>\n<ul>\n<li>Grafana</li>\n<li>Prometheus</li>\n</ul>\n</div>\n<p><code>Grafana</code>是一个开源的度量分析与可视化套件，他可以以<code>Prometheus</code>作为数据源，而<code>Prometheus</code>则是开源的服务监控系统和时间序列数据库。两者都通过Docker部署。</p>\n<p>首先是数据源<code>Prometheus</code>，通过配置从而监听各个项目暴露在某个端口的时序数据，比如SpringBoot，Mysql，Redis，Linux等等</p>\n<p>图来源自己服务器</p>\n<p><img src=\"./images/Music-Recognition/prometheus.png\" alt=\"prometheus\" /></p>\n<p>然后使用Grafana选择prometheus为数据源后，再选择响应的模板就可以监控到以时间为横坐标的数据大表图，例如监控Springboot</p>\n<p><img src=\"./images/Music-Recognition/grafana_springboot.png\" alt=\"Springboot\" /></p>\n<p>还可以通过配置，当某个指标的值超过多少则预警，通过控制识曲QPS防止任务量多时堆积内存</p>\n<h2 id=\"其他难点-方案\"> 其他难点&amp;方案</h2>\n<h3 id=\"识曲任务如何在后台运行和暂停\"> 识曲任务如何在后台运行和暂停</h3>\n<p>用户在后台开始任务请求接口时，异步调用开始任务方法，在开始后即返回开始成功消息，而后台则开启一个线程去调用真正的识曲方法，识曲方法会不断的循环消费redis中任务队列直到为空，线程结束。而想要获取实时进度等信息，我是放到redis中，适合频繁的修改，且由于redis是网络多线程，但是处理确实单线程，所以基本不会发生同步问题在高并发不高的情况下。这样子，前端轮询调用查看进度接口，对用户而言，就相当于后台有个正在进行中的任务。</p>\n<p>而对于暂停任务，由于没有使用获取那个线程的操作，所以识曲任务在每次循环识曲都会去判断redis中的任务状态，当发现任务状态不是<code>进行中</code>就退出循环结束识曲，所以我们只需要修改redis中任务状态即可。</p>\n<h3 id=\"如何在springboot后台控制调用识曲接口的qps\"> 如何在Springboot后台控制调用识曲接口的QPS</h3>\n<p>如果真正要做到QPS，每秒调用多少次，就需要用到多线程异步调用，Springboot有一个注解<code>@Async</code>，使用该注解可以异步调用该方法，无需等待该方法返回再去执行下一步。而该方法难以获取到返回值，需要用到<code>Future</code>去获取返回值，但在本项目没用到。接下来就是根据QPS一次性调用多少个该异步方法，然后让线程sleep后，再去异步调用。这样就不用等待每个识曲小任务返回结果后再去调用下一个。</p>\n<h3 id=\"全局异常处理\"> 全局异常处理</h3>\n<p>新建全局异常处理类，通过<code>@ExceptionHandler</code>注解去捕获异常，让系统返回我们自定义的返回体。首先捕获最大的异常类<code>Exception.class</code>，然后其余的根据业务需求去获取即可。</p>\n",
      "date_published": "2021-03-14T12:29:45.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": []
    },
    {
      "title": "实验室出入管理小程序",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/my-project/MyProject-AttendanceMiniprogram/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/my-project/MyProject-AttendanceMiniprogram/",
      "summary": "实验室出入管理小程序",
      "content_html": "<div align=center><img src=\"https://cdn.jsdelivr.net/gh/lifealsoisgg/MyProject-AttendanceMiniprogram-2.0/images/readme/logo.png\"/></div>\n<p>原文链接</p>\n<blockquote>\n<p>https://wiki.lifeisgg.online/archives/MyProject-AttendanceMiniprogram/</p>\n</blockquote>\n<p>Github</p>\n<blockquote>\n<p>https://github.com/LifeAlsoIsGG/MyProject-AttendanceMiniprogram-2.0</p>\n</blockquote>\n<h2 id=\"_1-小程序二维码\"> 1. 小程序二维码</h2>\n<div align=center><img width=\"70%\" src=\"https://cdn.jsdelivr.net/gh/lifealsoisgg/MyProject-AttendanceMiniprogram-2.0/images/readme/实验室出入管理小程序二维码.jpg\"/></div>\n<p>此小程序获得了<a href=\"https://developers.weixin.qq.com/community/competition\" target=\"_blank\" rel=\"noopener noreferrer\">2020中国微信官方小程序大赛</a>华南赛区二等奖🎉</p>\n<div align=center><img width=\"70%\"src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/2020微信小程序应用开发赛华南赛区二等奖.png\"/></div>\n<p>赛区奖项比例</p>\n<blockquote>\n<ul>\n<li>一等奖：5%</li>\n<li>二等奖：10%</li>\n<li>三等奖：15</li>\n</ul>\n</blockquote>\n<div align=center><img src=\"https://cdn.jsdelivr.net/gh/lifealsoisgg/MyProject-AttendanceMiniprogram-2.0/images/readme/华南赛区.png\"/></div>\n<h2 id=\"_2-在开发之前\"> 2. 在开发之前</h2>\n<p>​\t这个项目原本是结合物联网硬件指纹和人脸识别的一款实验室出入管理的项目，主要也是为诸如<strong>中国大学生计算机设计大赛，挑战杯，互联网+<strong>等比赛准备的。我在三人团队中担任的职责是</strong>小程序前后端开发</strong>，之后恰巧看到这个微信小程序比赛的时候就想着拿来参赛了，当然线下的硬件只能用模拟的方式去进行。</p>\n<h2 id=\"_3-关于小程序-需求分析\"> 3. 关于小程序&amp;需求分析</h2>\n<p>​\t实验室作为安全性较高的重要封闭场所，对于其它诸如公共封闭场所教室，办公室等场所，实验室的安全性，人员限制性，人员出入管理更为重要。某些实验室还是用着<strong>古老的人员登记表和进入前提前报备管理员</strong>，所以为了使实验室的管理，透明化，智能化，方便化，我们将管理系统放在移动端小程序上，无论是发布公告，管理人员，控制实验室开关，查看实验室人员情况等都能快速掌握。</p>\n<p>​\t对于普通用户来说，查看实验室开放状态，申请进入实验室，查看在某间实验室的时长和实验室公告，查看自己的日志，以及时长排行榜等。</p>\n<p>​\t在安全性方面，实验室出入采用指纹和人脸识别，生物识别中的人脸识别及指纹识别，利用其唯一性，可采集性和稳定性。唯一性指的是特征是独一无二的，每个人所有属于自己的唯一属性；可采集性指的是易于被采集；稳定性指的是不会轻易地被外在或内在因素改变。其特征更具有安全性、可靠性和有效性。</p>\n<p>​\t在国内已有类似的通过指纹及人脸等技术，对开发性活动室或实验室实现智能化的管理，类似的研究已趋近成熟，但是做成H5端和APP不够方便，且大材小用，相对小程序这种轻量级的还是不足。</p>\n<h2 id=\"_4-技术方案\"> 4. 技术方案</h2>\n<h3 id=\"_4-1-前端-小程序端\"> 4.1 前端(小程序端)</h3>\n<blockquote>\n<ul>\n<li>使用了第三方组件库ColorUi,uView组件作为前端设计的组件库</li>\n<li>IDE：微信开发者工具，HbuilderX</li>\n<li>框架：<a href=\"https://uniapp.dcloud.io/\" target=\"_blank\" rel=\"noopener noreferrer\">uniapp</a>(一款能发布到多端的Vue框架)，并没有用开发者工具去写，因为开发者工具的语法微信自定义太多了，按照<a href=\"https://ask.dcloud.net.cn/article/35947\" target=\"_blank\" rel=\"noopener noreferrer\">uniapp官方原话</a>来说，就是不伦不类的语法，两个我都有试过，自己的确更喜欢接近Vue原生的语法。在HbuilderX写好后能自动编译在开发者工具。</li>\n</ul>\n</blockquote>\n<h3 id=\"_4-2-后端\"> 4.2 后端</h3>\n<blockquote>\n<ul>\n<li>服务器：阿里云，腾讯云</li>\n<li>框架：SpringBoot，SpringCloud简单部署，Mybatis</li>\n<li>云函数：腾讯云云开发(获取openid，发送腾讯云短信，发送订阅消息等)</li>\n<li>数据库：Mysql5.7</li>\n<li>环境：java1.8</li>\n<li>IDE：IDEA</li>\n</ul>\n</blockquote>\n<p>​\t后端采用的SSM框架和spring的微服务使业务模块化。而使用云函数是为了方便地获取用户openid以及发送订阅消息</p>\n<p><code>获取openid</code></p>\n<div align=center><img src=\"https://cdn.jsdelivr.net/gh/lifealsoisgg/MyProject-AttendanceMiniprogram-2.0/images/readme/获取openid.jpg\"/></div>\n<p><code>订阅消息</code></p>\n<div align=center><img width=\"50%\" src=\"https://cdn.jsdelivr.net/gh/lifealsoisgg/MyProject-AttendanceMiniprogram-2.0/images/readme/订阅消息.jpg\"/></div>\n<h3 id=\"_4-3-硬件\"> 4.3 硬件</h3>\n<blockquote>\n<ul>\n<li>树莓派，Arduino平台，指纹器，摄像头</li>\n<li>腾讯云物联网开发平台</li>\n</ul>\n</blockquote>\n<h2 id=\"_5-页面功能展示说明\"> 5. 页面功能展示说明</h2>\n<p>​\t共有5个页面，与底部dock栏一一对应</p>\n<div align=center><img src=\"https://cdn.jsdelivr.net/gh/lifealsoisgg/MyProject-AttendanceMiniprogram-2.0/images/readme/dock栏.jpg\"/></div>\n<blockquote>\n<ol>\n<li>首页</li>\n<li>日志</li>\n<li>仪表盘</li>\n<li>排行榜</li>\n<li>我的</li>\n</ol>\n</blockquote>\n<h3 id=\"架构图\"> 架构图</h3>\n<div align=center> <img src=\"https://cdn.jsdelivr.net/gh/lifealsoisgg/MyProject-AttendanceMiniprogram-2.0/images/readme/实验室出入管理小程序架构图.png\"/></div>\n<h3 id=\"_5-1-首页home\"> 5.1 首页Home</h3>\n<p>当进入页面时会判断你当前在哪个实验室，如果不在则可以<strong>模拟选择教室进入</strong>，模拟进入后会发送打卡通知</p>\n<div align=center>  <table><tr>    <img width=\"50%\" src=\"https://cdn.jsdelivr.net/gh/lifealsoisgg/MyProject-AttendanceMiniprogram-2.0/images/readme/home7.jpg\"/>    <img width=\"50%\" src=\"https://cdn.jsdelivr.net/gh/lifealsoisgg/MyProject-AttendanceMiniprogram-2.0/images/readme/订阅消息.jpg\"/>    </tr></table></div>\t\n<p>如果你在进入实验室后点击打开通知，则展示目前所在实验室的状态，可以查看如下</p>\n<ul>\n<li><strong>顶部可以查看在线时长</strong></li>\n<li><strong>这间教室的出入日志，公告，文件，概览等</strong></li>\n<li><strong>实验室成员(已进入人员，已离开成员，管理员)</strong></li>\n<li><strong>还有提醒在实验室时长超过六小时</strong></li>\n</ul>\n<div align=center>  <table><tr>    <img width=\"50%\" src=\"https://cdn.jsdelivr.net/gh/lifealsoisgg/MyProject-AttendanceMiniprogram-2.0/images/readme/home1.jpg\"/>    <img width=\"50%\" src=\"https://cdn.jsdelivr.net/gh/lifealsoisgg/MyProject-AttendanceMiniprogram-2.0/images/readme/home2.jpg\"/>   </tr></table></div>\n<div align=center>  <table><tr>   <img width=\"50%\" src=\"https://cdn.jsdelivr.net/gh/lifealsoisgg/MyProject-AttendanceMiniprogram-2.0/images/readme/home3.jpg\"/> <img width=\"50%\" src=\"https://cdn.jsdelivr.net/gh/lifealsoisgg/MyProject-AttendanceMiniprogram-2.0/images/readme/home4.jpg\"/>    </tr></table></div>\n<div align=center>  <table><tr>     <img width=\"50%\" src=\"https://cdn.jsdelivr.net/gh/lifealsoisgg/MyProject-AttendanceMiniprogram-2.0/images/readme/home5.jpg\"/>  <img width=\"50%\" src=\"https://cdn.jsdelivr.net/gh/lifealsoisgg/MyProject-AttendanceMiniprogram-2.0/images/readme/home6.jpg\"/>  </tr></table></div>\n<p>之后点击右下角的按钮则可以<strong>模拟退出实验室</strong>，成功后也会发送打卡通知</p>\n<div align=center>  <table><tr>    <img width=\"50%\" src=\"https://cdn.jsdelivr.net/gh/lifealsoisgg/MyProject-AttendanceMiniprogram-2.0/images/readme/home6.jpg\"/>    <img width=\"50%\" src=\"https://cdn.jsdelivr.net/gh/lifealsoisgg/MyProject-AttendanceMiniprogram-2.0/images/readme/订阅消息.jpg\"/>    </tr></table></div>\n<h3 id=\"_5-2-日志log\"> 5.2 日志Log</h3>\n<p>在这里可以查看自己进出实验室的日志记录，日志记录采用逆序显示，还可以根据时间选择区段查看</p>\n<div align=center>  <table><tr>    <img width=\"50%\" src=\"https://cdn.jsdelivr.net/gh/lifealsoisgg/MyProject-AttendanceMiniprogram-2.0/images/readme/log1.jpg\"/>    <img width=\"50%\" src=\"https://cdn.jsdelivr.net/gh/lifealsoisgg/MyProject-AttendanceMiniprogram-2.0/images/readme/log2.jpg\"/>    </tr></table></div>\n<p>点击Tab栏中<strong>我的实验室</strong>可以查看我去过的实验室，点击实验室卡片可以看到<strong>我在这间实验室的日志</strong></p>\n<div align=center>  <table><tr>    <img width=\"50%\" src=\"https://cdn.jsdelivr.net/gh/lifealsoisgg/MyProject-AttendanceMiniprogram-2.0/images/readme/log3.jpg\"/>    <img width=\"50%\" src=\"https://cdn.jsdelivr.net/gh/lifealsoisgg/MyProject-AttendanceMiniprogram-2.0/images/readme/log4.jpg\"/>    </tr></table></div>\n<h3 id=\"_5-3-控制台dashboard\"> 5.3 控制台Dashboard</h3>\n<p>控制台涉及比较多的CURD事务，也是小程序的核心功能，为了将复杂笨重的管理系统移植到小程序上，做了许多页面简化处理和友好的用户交互体验(但貌似还是过于笨重🏃)</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">权限/身份</th>\n<th style=\"text-align:center\">超管</th>\n<th style=\"text-align:center\">普通用户</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">查看实验室详细</td>\n<td style=\"text-align:center\">所有实验室</td>\n<td style=\"text-align:center\">自己管理的</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">关闭/开放实验室</td>\n<td style=\"text-align:center\">所有实验室</td>\n<td style=\"text-align:center\">自己管理的</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">添加实验室</td>\n<td style=\"text-align:center\">✔️</td>\n<td style=\"text-align:center\">❌</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">添加/删除实验室管理员</td>\n<td style=\"text-align:center\">✔️</td>\n<td style=\"text-align:center\">❌</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">添加/删除实验室公告</td>\n<td style=\"text-align:center\">所有实验室</td>\n<td style=\"text-align:center\">自己管理的</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">查看用户/用户详细</td>\n<td style=\"text-align:center\">✔️</td>\n<td style=\"text-align:center\">❌</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">查看所有用户日志</td>\n<td style=\"text-align:center\">✔️</td>\n<td style=\"text-align:center\">❌</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<ul>\n<li>超级管理员：可以查看所有实验室，用户，日志，增加关闭教室，赋予用户为某个实验室的管理员，撤销某个实验室的管理员等等</li>\n<li>管理员：能查看自己管理的实验室日志用户等，能发布公告在自己管理的实验室，总之基于自己管理的实验室。</li>\n<li>普通用户：其实就理解为没有管理实验室的用户，可以查看自己的日志，自己所在教室的动态以及活跃时长排行榜</li>\n</ul>\n</blockquote>\n<ul>\n<li>控制台查看实验室，<strong>点击卡片可以查看实验室详情</strong>，超管可以查看所有实验室详情，普通用户只能查看自己管理的</li>\n</ul>\n<div align=center>  <table><tr>    <img width=\"30%\" src=\"https://cdn.jsdelivr.net/gh/lifealsoisgg/MyProject-AttendanceMiniprogram-2.0/images/readme/admin1.jpg\"/>    <img width=\"30%\" src=\"https://cdn.jsdelivr.net/gh/lifealsoisgg/MyProject-AttendanceMiniprogram-2.0/images/readme/room1.jpg\"/>  <img width=\"30%\" src=\"https://cdn.jsdelivr.net/gh/lifealsoisgg/MyProject-AttendanceMiniprogram-2.0/images/readme/room2.jpg\"/>  </tr></table></div>\n<p>在<strong>概览</strong>页面</p>\n<ul>\n<li>超管：<strong>查看监控(TODO)</strong>，<strong>关闭开放实验室(如果实验室有人会提醒)</strong>，<strong>添加删除此房间管理员</strong>，超管默认为管理员，没分配时不会显示，分配后会头像会显示<strong>超管</strong></li>\n<li>管理员：<strong>查看监控(TODO)</strong>，<strong>关闭开放实验室(如果实验室有人会提醒)</strong></li>\n</ul>\n<div align=center>  <table><tr>    <img width=\"30%\" src=\"https://cdn.jsdelivr.net/gh/lifealsoisgg/MyProject-AttendanceMiniprogram-2.0/images/readme/room3.jpg\"/>    <img width=\"30%\" src=\"https://cdn.jsdelivr.net/gh/lifealsoisgg/MyProject-AttendanceMiniprogram-2.0/images/readme/room4.jpg\"/>  <img width=\"30%\" src=\"https://cdn.jsdelivr.net/gh/lifealsoisgg/MyProject-AttendanceMiniprogram-2.0/images/readme/room5.jpg\"/>  </tr></table></div>\n<h3 id=\"_5-4-排行榜rank\"> 5.4 排行榜Rank</h3>\n<p>排行榜类似<code>微信运动</code>，可以查看目前谁的活跃时长最高，可以查看<strong>当前周和当前月的活跃度排行榜</strong>💯</p>\n<blockquote>\n<p>TODO：图表显示，历史周和历史月排名</p>\n</blockquote>\n<div align=center>  <table><tr>    <img width=\"50%\" src=\"https://cdn.jsdelivr.net/gh/lifealsoisgg/MyProject-AttendanceMiniprogram-2.0/images/readme/rank1.jpg\"/>    <img width=\"50%\" src=\"https://cdn.jsdelivr.net/gh/lifealsoisgg/MyProject-AttendanceMiniprogram-2.0/images/readme/rank2.jpg\"/>    </tr></table></div>\n<h3 id=\"_5-5-我的profile\"> 5.5 我的Profile</h3>\n<p>我的界面，需要在这里实名手机绑定，在学校用基本调用接口输入学号密码，但这里为了方便只能模拟用手机绑定。在这里也可以主动申请服务消息的打卡通知，滑动接收消息的Switch即可。</p>\n<div align=center>  <table><tr>    <img width=\"30%\" src=\"https://cdn.jsdelivr.net/gh/lifealsoisgg/MyProject-AttendanceMiniprogram-2.0/images/readme/profile1.jpg\"/>    <img width=\"30%\" src=\"https://cdn.jsdelivr.net/gh/lifealsoisgg/MyProject-AttendanceMiniprogram-2.0/images/readme/profile2.jpg\"/>  <img width=\"30%\" src=\"https://cdn.jsdelivr.net/gh/lifealsoisgg/MyProject-AttendanceMiniprogram-2.0/images/readme/profile3.jpg\"/>  </tr></table></div>\n<p>点击最下方的<strong>介绍&amp;使用手册</strong>可以帮助您更快地了解并使用小程序。</p>\n<div align=center>  <table><tr>    <img width=\"50%\" src=\"https://cdn.jsdelivr.net/gh/lifealsoisgg/MyProject-AttendanceMiniprogram-2.0/images/readme/refe.jpg\"/>   </tr></table></div>\n<h1 id=\"_6-后记\"> 6. 后记</h1>\n<p>​\t由于小程序比较复杂，这也造成了评委体验时对我的小程序有点懵的状况，在大家在群里都开始评审的时候我的小程序老师只是来踩了踩点便没了动静，得亏我反馈并说明后才有老师使用，后来在群里也看到有几个人说小程序没有被评审。主办方那边也算挺负责，及时组织评委去使用只是踩了踩点的小程序。除了评委老师可能疏漏的原因(作品数还是比较多的)，我也吸取了教训，就是一开始的用户体验和引导非常重要，能做到手把手教那种更好，避免一上来就要登录或者填写一大推表单的情况（真的会让人瞬间感到烦躁）。还有就是要符合小程序轻量，方便的特点，有些地方做做减法反而效果更好(我也参考了那些入围全国比赛的小程序)。但这些属于前端的灵魂的东西，包括独特的UI设计那些，对于作为后端狗的我来说貌似不太感冒。我在想，或许那些优雅的用户体验前端设计的背后一定是一个温柔细致体贴的人吧😇。</p>\n<p>​\t最后还是想说，这个比赛有一定的水分，自己也看了看获奖的小程序，有些真的是过于简单，比如调用第三方接口识图，还有那些综合科普信息展示答题类，更多的是纯静态信息显示，并没有多少难度，比赛结果后也没有分数。再者，有些小程序背靠团队企业资源，名校倾向啥的我也不谈。在答辩过程中准备的PPT那些商业计划啥的准备的很完整，而比赛规定中有一条是没有参加过其他省级以上比赛的项目，而这些却很难去求证了。再者还有条规定，核心功能在19年9月份前开发的小程序算违规，这些也很难去求证了。但是比赛过程中，比赛方的态度都很好，也都有耐心回答我们的问题，群里面也有人展示小程序然后一起讨论，也算不错的比赛体验了。最后拿了个华南赛区二等奖也算是对我那几个星期熬夜的慰问了吧(也不知道对找工作有没有用😂)。</p>\n",
      "date_published": "2020-08-07T00:24:30.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": []
    },
    {
      "title": "Javaweb大学活动管理系统",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/my-project/MyProject-JavaWeb-ActivitySystem/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/my-project/MyProject-JavaWeb-ActivitySystem/",
      "summary": "Javaweb大学活动管理系统",
      "content_html": "<p><a href=\"./MyProject-JavaWeb-ActivitySystem.html\"><img src=\"./images/My-Project/activity_system.png\" alt=\"\" /></a></p>\n<blockquote>\n<ul>\n<li>介绍：Javaweb应用，大学活动管理系统，管理大学活动申请，查看，更改状态，管理员审核，超级管理员添加删除管理员等</li>\n<li>类型：Javaweb</li>\n<li>预览链接：<a href=\"https://activitysystem.lifeisgg.online/\" target=\"_blank\" rel=\"noopener noreferrer\">Activity System</a></li>\n<li>Github地址：https://github.com/LifeAlsoIsGG/MyProject-JavaWeb-ActivitySystem</li>\n</ul>\n</blockquote>\n",
      "date_published": "2020-07-12T01:34:30.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": []
    },
    {
      "title": "JavaSwing-超市系统",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/my-project/MyProject-SupermarketSystem/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/my-project/MyProject-SupermarketSystem/",
      "summary": "JavaSwing-超市系统",
      "content_html": "<div align=center><img src=\"https://cdn.jsdelivr.net/gh/lifealsoisgg/MyProject-SupermarketSystem/images/logo.png\"/></div>\n<h2 id=\"_1-链接\"> 1. 链接</h2>\n<p>Github：https://github.com/LifeAlsoIsGG/MyProject-SupermarketSystem</p>\n<h2 id=\"_2-写在前面\"> 2. 写在前面</h2>\n<p>初次引入可能会报错，所以食用前请重新引入好三个jar包，都在lib目录下</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/lifealsoisgg/MyProject-SupermarketSystem/images/build.jpg\" alt=\"\" /></p>\n<p>其它修改</p>\n<blockquote>\n<ol>\n<li>\n<p>修改config/jdbc.properties里面连接mysql数据库的属性值为自己的。</p>\n</li>\n<li>\n<p>进货功能的邮件发送方面，调用的类为<strong>com.lingnan.supermarket.util/SendQQMailUtil.java</strong>，在<strong>com.lingnan.supermarket.view/InView.java</strong>下调用，如图，照着SendQQMailUtil.java的属性修改即可，前提要开通QQEmail的SMTP服务(自行百度),调用位置如图。<strong>请务必使用自己的SMTP服务方便邮件的发送与接收，如果你实在要用我的请务必将收件人邮箱改为自己的，否则你这边是看不到邮件是否发送成功(修改下面第三个参数的邮箱为自己的即可)！！！</strong></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/lifealsoisgg/MyProject-SupermarketSystem/images/sendEmail.jpg\" alt=\"\" /></p>\n</li>\n</ol>\n</blockquote>\n<p>整个项目的运行入口在<strong>com.lingnan.supermarket.view/LoginView.java</strong>下即main函数放的地方</p>\n<h2 id=\"_3-工具-环境tools\"> 3. 工具&amp;环境tools</h2>\n<blockquote>\n<ul>\n<li>数据库：Mysql5.7</li>\n<li>java环境：Java1.8</li>\n<li>编辑器：Eclipse</li>\n<li>服务器：Tomcat8</li>\n</ul>\n</blockquote>\n<h2 id=\"_4-首页home\"> 4. 首页home</h2>\n<div align=center><img src=\"https://cdn.jsdelivr.net/gh/lifealsoisgg/MyProject-SupermarketSystem/images/首页.jpg\" /></div>\n<h2 id=\"_5-人员管理manage\"> 5. 人员管理manage</h2>\n<p>权限0为超管，1为收货员，2为进货员</p>\n<div align=center><img src=\"https://cdn.jsdelivr.net/gh/lifealsoisgg/MyProject-SupermarketSystem/images/人员管理.jpg\"/></div>\n<h2 id=\"_6-进货系统import\"> 6. 进货系统import</h2>\n<p>这里在添加要进货物时偷了懒只有选择编号加入。右上角添加按钮即可添加要进的货，右下角第一个按钮就是确认进货，点击后会发送邮件给相应的仓库，公司等，这里只是模拟。</p>\n<p><code>进货流程就是</code>(理想情况，实际还需看需求)</p>\n<blockquote>\n<ol>\n<li>进货员添加进货商品</li>\n<li>确认进货订单后会发送邮件</li>\n<li>供货方收到邮件后准备进货</li>\n<li>商场收到货，进货员线下清点好后更改订单状态为已入库</li>\n<li>系统库存自动增加</li>\n</ol>\n</blockquote>\n<h3 id=\"_6-1-添加进货\"> 6.1 添加进货</h3>\n<div align=center><img src=\"https://cdn.jsdelivr.net/gh/lifealsoisgg/MyProject-SupermarketSystem/images/进货添加进货.jpg\"/></div>\n### 6.2 更改进货数量\n<div align=center><img src=\"https://cdn.jsdelivr.net/gh/lifealsoisgg/MyProject-SupermarketSystem/images/进货修改数量.jpg\"/></div>\n### 6.3 确认进货订单&发送进货邮件\n<div align=center>\n  <table>\n    <tr>\n  <img width=\"50%\" src=\"https://cdn.jsdelivr.net/gh/lifealsoisgg/MyProject-SupermarketSystem/images/进货确认订单.jpg\"/>\n\t<img width=\"50%\" src=\"https://cdn.jsdelivr.net/gh/lifealsoisgg/MyProject-SupermarketSystem/images/进货发送邮件.jpg\"/>\n    </tr></table>\n</div>\n<h3 id=\"_6-4-供货方查看邮件内容\"> 6.4 供货方查看邮件内容</h3>\n<p>没有用到表格或html，只是简单的字符串排版</p>\n<div align=center><img src=\"https://cdn.jsdelivr.net/gh/lifealsoisgg/MyProject-SupermarketSystem/images/进货邮件内容.jpg\"/></div>\n### 6.5 更改进货订单状态\n<p>模拟当进货成功后，==修改订单状态==为已入库或者已取消，如果已入库后库存数量会自动增加</p>\n<div align=center>\n  <table>\n    <tr>\n  <img width=\"50%\" src=\"https://cdn.jsdelivr.net/gh/lifealsoisgg/MyProject-SupermarketSystem/images/进货更改订单状态.jpg\"/>\n\t<img width=\"50%\" src=\"https://cdn.jsdelivr.net/gh/lifealsoisgg/MyProject-SupermarketSystem/images/进货库存更新成功.jpg\"/>\n    </tr></table>\n</div>\n<h2 id=\"_7-收银系统cashier\"> 7. 收银系统cashier</h2>\n<p>也是没扫描机器，所以只能模拟。</p>\n<p><code>收银流程如下</code></p>\n<blockquote>\n<ol>\n<li>添加商品，如果库存不够会提示</li>\n<li>(手动)确认结账</li>\n<li>支付成功后库存减少</li>\n</ol>\n</blockquote>\n<h3 id=\"_7-1-添加商品\"> 7.1 添加商品</h3>\n<div align=center><img src=\"https://cdn.jsdelivr.net/gh/lifealsoisgg/MyProject-SupermarketSystem/images/收银添加商品.jpg\"/></div>\n### 7.2 库存不够提示\n<div align=center><img src=\"https://cdn.jsdelivr.net/gh/lifealsoisgg/MyProject-SupermarketSystem/images/收银库存不够.jpg\"/></div>\n### 7.3 收银结账&支付成功\n<div align=center>\n  <table>\n    <tr>\n  <img width=\"50%\" src=\"https://cdn.jsdelivr.net/gh/lifealsoisgg/MyProject-SupermarketSystem/images/收银结账.jpg\"/>\n\t<img width=\"50%\" src=\"https://cdn.jsdelivr.net/gh/lifealsoisgg/MyProject-SupermarketSystem/images/收银支付成功.jpg\"/>\n    </tr></table>\n</div>\n<h3 id=\"_7-4-首页更新\"> 7.4 首页更新</h3>\n<div align=center><img src=\"https://cdn.jsdelivr.net/gh/lifealsoisgg/MyProject-SupermarketSystem/images/收银成功首页.jpg\"/></div>\n<h2 id=\"_8-商品库存storage\"> 8. 商品库存storage</h2>\n<h3 id=\"_8-1-总览\"> 8.1 总览</h3>\n<div align=center><img src=\"https://cdn.jsdelivr.net/gh/lifealsoisgg/MyProject-SupermarketSystem/images/商品库存.jpg\"/></div>\n<h3 id=\"_8-2-库存日志\"> 8.2 库存日志</h3>\n<h4 id=\"进货库存日志\"> 进货库存日志</h4>\n<div align=center>\n  <table>\n    <tr>\n  <img width=\"50%\" src=\"https://cdn.jsdelivr.net/gh/lifealsoisgg/MyProject-SupermarketSystem/images/库存进货记录.jpg\"/>\n\t<img width=\"50%\" src=\"https://cdn.jsdelivr.net/gh/lifealsoisgg/MyProject-SupermarketSystem/images/进货订单详情.jpg\"/>\n    </tr></table>\n</div>\n<h4 id=\"收银库存日志\"> 收银库存日志</h4>\n<div align=center>\n  <table>\n    <tr>\n  <img width=\"50%\" src=\"https://cdn.jsdelivr.net/gh/lifealsoisgg/MyProject-SupermarketSystem/images/库存收银记录.jpg\"/>\n\t<img width=\"50%\" src=\"https://cdn.jsdelivr.net/gh/lifealsoisgg/MyProject-SupermarketSystem/images/收银订单详情.jpg\"/>\n    </tr></table>\n</div>\n<h2 id=\"_9-供应商supplier\"> 9. 供应商supplier</h2>\n<div align=center><img src=\"https://cdn.jsdelivr.net/gh/lifealsoisgg/MyProject-SupermarketSystem/images/供应商.jpg\"/></div>\n<h2 id=\"_10-商品目录catalog\"> 10. 商品目录catalog</h2>\n<div align=center><img src=\"https://cdn.jsdelivr.net/gh/lifealsoisgg/MyProject-SupermarketSystem/images/商品目录.jpg\"/></div>\n<h2 id=\"_11-联系contact\"> 11. 联系contact</h2>\n<p>email：1138312802@qq.com</p>\n<p>wechat：a1138312802</p>\n<h2 id=\"_12-写在最后last\"> 12. 写在最后last</h2>\n<p>这个项目是几个人一组做的。前端用的是java本身的窗口那些类JModel,JTable,JPanel等，首先难看，其次也不好写。当时想着先把核心功能实现再说，然后到后面时间有限和肝不动了遂只能这样。结束后想优化前端和后台逻辑的时候却发现里面很乱遂不了了之。每次看到这个作品都在警示着我要加强大局观和撸代码的素养(又或许是开发经验不足吧)。</p>\n<p>话说要是能折腾下这套系统所对应的线下的设备，比如扫货机，收银台啥的等，我还是很愿意再折腾的，虽然只是超市系统而非高大上创新的项目。但在这之前，这个作品起码是我第二个比较完整地Java应用，算是交代了我大二的学习成果吧，反正水没水学业拉出来溜溜就知道了。</p>\n",
      "image": "https://cdn.jsdelivr.net/gh/lifealsoisgg/MyProject-SupermarketSystem/images/build.jpg",
      "date_published": "2020-07-12T01:27:13.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": []
    },
    {
      "title": "My Project",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/my-project/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/my-project/",
      "content_html": "<h2 id=\"attendance-miniprogram\"> Attendance Miniprogram <MyBadge text=\"2020中国微信官方小程序大赛华南赛区二等奖\" type=\"tip\"  vertical=\"top\"/></h2>\n<p><a href=\"./MyProject-AttendanceMiniprogram.html\"><img src=\"./images/My-Project/attendance_miniprogram.png\" alt=\"\" /></a></p>\n<div><p>Attendance Miniprogram</p>\n<ul>\n<li>介绍：一个与线下人脸识别等硬件结合的实验室管理小程序，可以查看出入日志，所在实验室的人员公告等，管理员可以管理实验室开关发布公告，超级管理员添加删除实验室管理员等等</li>\n<li>类型：微信小程序，uniapp</li>\n<li>介绍文档：<a href=\"./MyProject-AttendanceMiniprogram.html\">Attendance Miniprogram</a></li>\n<li>Github地址：https://github.com/LifeAlsoIsGG/MyProject-AttendanceMiniprogram-2.0</li>\n</ul>\n</div>\n<h2 id=\"智慧社区疫情防控系统\"> 智慧社区疫情防控系统<MyBadge text=\"2020中国大学生计算机设计大赛三等奖\" type=\"tip\"  vertical=\"top\"/></h2>\n<p><a href=\"./MyProject-AttendanceMiniprogram.html\"><img src=\"./images/My-Project/Smart_community_epidemic_prevention_and_control_system.png\" alt=\"\" /></a></p>\n<div><p>智慧社区疫情防控系统</p>\n<ul>\n<li>介绍：当前气候多变，季节性、流行性、传染疾病越来越多，社区作为人们最常生活的区域，同时居民素质能力普遍提高，对健康生活要求越来越高。但是目前社区防控能力较弱，管理效率较低，居民呼声较大，项目结合新技术着力提高居民健康生活水平。 为有效解决当前传统模式下的健康卫生防控系统的不足，设计了一套基于物联网、移动开发、微信小程序和公众号等新技术手段，面向社区的疫情防控系统。重点实现被检测对象的持续监测方案；防止医务人员感染远程采集数据；权威疫情数据信息公布和社区防控医疗物资的调配；居民健康教育科普和咨询医生等问题。</li>\n<li>类型：物联网应用-医药卫生</li>\n<li>介绍文档：<a href=\"http://2020.jsjds.com.cn/chaxun/?keys=76004\" target=\"_blank\" rel=\"noopener noreferrer\">中国大学生计算机设计大赛作品简介-智慧社区疫情防控系统</a></li>\n</ul>\n</div>\n<h2 id=\"supermarket-system\"> Supermarket System</h2>\n<p><a href=\"./MyProject-SupermarketSystem.html\"><img src=\"./images/My-Project/supermarket_system.png\" alt=\"\" /></a></p>\n<div><p>Supermarket System</p>\n<ul>\n<li>介绍：模拟超市里面收银进货系统，人员管理系统，仓库管理的Java应用</li>\n<li>类型：Java应用</li>\n<li>介绍文档：<a href=\"./MyProject-SupermarketSystem.html\">Supermarket System</a></li>\n<li>Github地址：https://github.com/LifeAlsoIsGG/MyProject-SupermarketSystem</li>\n</ul>\n</div>\n<h2 id=\"activity-system\"> Activity System</h2>\n<p><a href=\"./MyProject-JavaWeb-ActivitySystem.html\"><img src=\"./images/My-Project/activity_system.png\" alt=\"\" /></a></p>\n<div><p>Activity System</p>\n<ul>\n<li>介绍：Javaweb应用，大学活动管理系统，管理大学活动申请，查看，更改状态，管理员审核，超级管理员添加删除管理员等</li>\n<li>类型：Javaweb</li>\n<li>介绍文档：<a href=\"./MyProject-JavaWeb-ActivitySystem.html\">Activity System</a></li>\n<li>预览链接：<a href=\"https://activitysystem.lifeisgg.online/\" target=\"_blank\" rel=\"noopener noreferrer\">Activity System</a></li>\n<li>Github地址：https://github.com/LifeAlsoIsGG/MyProject-JavaWeb-ActivitySystem</li>\n</ul>\n</div>\n<h2 id=\"the-expanse\"> The Expanse</h2>\n<p><a href=\"https://expanse.lifeisgg.online/\" target=\"_blank\" rel=\"noopener noreferrer\"><img src=\"./images/My-Project/the_expanse.png\" alt=\"\" /></a></p>\n<div><p>The Expanse</p>\n<ul>\n<li>介绍：大二下学期网页设计作品，HTML+CSS+JAVASCRIPT大杂烩，以未来星际航空交谈为主题的飞船租赁，星旅，新闻资讯，星际通行证，星际军事等信息综合类网站</li>\n<li>类型：网页设计</li>\n<li>介绍文档：无</li>\n<li>预览链接：<a href=\"https://lifealsoisgg.github.io/MyProject-TheExpanse/index.html\" target=\"_blank\" rel=\"noopener noreferrer\">The Expanse</a></li>\n<li>Github地址：<a href=\"https://github.com/LifeAlsoIsGG/MyProject-TheExpanse\" target=\"_blank\" rel=\"noopener noreferrer\">https://github.com/LifeAlsoIsGG/MyProject-WebDesign</a></li>\n</ul>\n</div>\n",
      "date_published": "2020-08-07T22:10:27.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": []
    },
    {
      "title": "Mybatis基础笔记",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/mybatis/Mybatis-basic-notes/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/mybatis/Mybatis-basic-notes/",
      "content_html": "<p>基础面试</p>\n",
      "date_published": "2020-10-10T15:05:06.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": []
    },
    {
      "title": "Mybatis语法笔记",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/mybatis/Mybatis-grammar-notes/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/mybatis/Mybatis-grammar-notes/",
      "content_html": "<h2 id=\"select\"> SELECT</h2>\n<h2 id=\"insert\"> INSERT</h2>\n<p>插入后获取主键，<a href=\"https://blog.csdn.net/qq_36614559/article/details/80257228?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param\" target=\"_blank\" rel=\"noopener noreferrer\">参考</a></p>\n<h2 id=\"update\"> UPDATE</h2>\n<h2 id=\"delete\"> DELETE</h2>\n",
      "date_published": "2020-10-10T15:05:07.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": []
    },
    {
      "title": "Mybatis逆向工程&Example类使用",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/mybatis/Mybatis-reverse-project&Example-use/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/mybatis/Mybatis-reverse-project&Example-use/",
      "content_html": "<h2 id=\"_1-参考\"> 1. 参考</h2>\n<blockquote>\n<ul>\n<li>http://mybatis.org/generator/index.html</li>\n<li>https://blog.csdn.net/for_my_life/article/details/51228098?utm_medium=distribute.pc_relevant.none-task-blog-title-1&amp;spm=1001.2101.3001.4242</li>\n<li>视频：https://www.bilibili.com/video/av78230600/</li>\n</ul>\n</blockquote>\n<h2 id=\"_2-demo\"> 2. Demo</h2>\n<p>通过已经搭建好的项目创建，连接数据库并修改<code>mybatisGenerator.xml</code>后Run即可</p>\n<blockquote>\n<ul>\n<li>Github：https://github.com/LifeAlsoIsGG/MybatisGenerator-Demo</li>\n</ul>\n</blockquote>\n<h2 id=\"_3-配置pom-xml\"> 3. 配置<code>pom.xml</code></h2>\n<div><pre><code>        <span><span><span>&lt;</span>dependency</span><span>></span></span>\n            <span><span><span>&lt;</span>groupId</span><span>></span></span>org.mybatis.generator<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n            <span><span><span>&lt;</span>artifactId</span><span>></span></span>mybatis-generator-core<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n            <span><span><span>&lt;</span>version</span><span>></span></span>1.3.2<span><span><span>&lt;/</span>version</span><span>></span></span>\n        <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n\n<span><span><span>&lt;</span>build</span><span>></span></span>\n        <span><span><span>&lt;</span>plugins</span><span>></span></span>\n            <span><span><span>&lt;</span>plugin</span><span>></span></span>\n                <span><span><span>&lt;</span>groupId</span><span>></span></span>org.mybatis.generator<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n                <span><span><span>&lt;</span>artifactId</span><span>></span></span>mybatis-generator-maven-plugin<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n                <span><span><span>&lt;</span>version</span><span>></span></span>1.3.2<span><span><span>&lt;/</span>version</span><span>></span></span>\n                <span><span><span>&lt;</span>configuration</span><span>></span></span>\n                    <span><span><span>&lt;</span>configurationFile</span><span>></span></span>src/main/resources/mybatisGenerator.xml<span><span><span>&lt;/</span>configurationFile</span><span>></span></span>\n                    <span><span><span>&lt;</span>verbose</span><span>></span></span>true<span><span><span>&lt;/</span>verbose</span><span>></span></span>\n                    <span><span><span>&lt;</span>overwrite</span><span>></span></span>true<span><span><span>&lt;/</span>overwrite</span><span>></span></span>\n                <span><span><span>&lt;/</span>configuration</span><span>></span></span>\n                <span><span><span>&lt;</span>executions</span><span>></span></span>\n                    <span><span><span>&lt;</span>execution</span><span>></span></span>\n                        <span><span><span>&lt;</span>id</span><span>></span></span>Generate MyBatis Artifacts<span><span><span>&lt;/</span>id</span><span>></span></span>\n                        <span><span><span>&lt;</span>goals</span><span>></span></span>\n                            <span><span><span>&lt;</span>goal</span><span>></span></span>generate<span><span><span>&lt;/</span>goal</span><span>></span></span>\n                        <span><span><span>&lt;/</span>goals</span><span>></span></span>\n                    <span><span><span>&lt;/</span>execution</span><span>></span></span>\n                <span><span><span>&lt;/</span>executions</span><span>></span></span>\n                <span><span><span>&lt;</span>dependencies</span><span>></span></span>\n                    <span><span><span>&lt;</span>dependency</span><span>></span></span>\n                        <span><span><span>&lt;</span>groupId</span><span>></span></span>org.mybatis.generator<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n                        <span><span><span>&lt;</span>artifactId</span><span>></span></span>mybatis-generator-core<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n                        <span><span><span>&lt;</span>version</span><span>></span></span>1.3.2<span><span><span>&lt;/</span>version</span><span>></span></span>\n                    <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n                    <span><span><span>&lt;</span>dependency</span><span>></span></span>\n                        <span><span><span>&lt;</span>groupId</span><span>></span></span>mysql<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n                        <span><span><span>&lt;</span>artifactId</span><span>></span></span>mysql-connector-java<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n                        <span><span><span>&lt;</span>scope</span><span>></span></span>runtime<span><span><span>&lt;/</span>scope</span><span>></span></span>\n                        <span><span><span>&lt;</span>version</span><span>></span></span>5.1.47<span><span><span>&lt;/</span>version</span><span>></span></span>\n                    <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n                <span><span><span>&lt;/</span>dependencies</span><span>></span></span>\n            <span><span><span>&lt;/</span>plugin</span><span>></span></span>\n        <span><span><span>&lt;/</span>plugins</span><span>></span></span>\n    <span><span><span>&lt;/</span>build</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br></div></div><h2 id=\"_4-配置mybatisgenerator-xml\"> 4. 配置<code>mybatisGenerator.xml</code></h2>\n<p>参考</p>\n<blockquote>\n<ul>\n<li>https://blog.csdn.net/for_my_life/article/details/51228098?utm_medium=distribute.pc_relevant.none-task-blog-title-1&amp;spm=1001.2101.3001.4242</li>\n<li>视频：https://www.bilibili.com/video/av78230600/</li>\n</ul>\n</blockquote>\n<p>通过已经搭建好的项目创建，连接数据库并修改<code>mybatisGenerator.xml</code>后Run即可</p>\n<blockquote>\n<ul>\n<li>Github：https://github.com/LifeAlsoIsGG/MybatisGenerator-Demo</li>\n</ul>\n</blockquote>\n<p>在resources下创建<code>mybatisGenerator.xml</code></p>\n<div><pre><code><span>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?></span>\n<span><span>&lt;!</span><span>DOCTYPE</span> <span>generatorConfiguration</span>\n        <span>PUBLIC</span> <span>\"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\"</span>\n        <span>\"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\"</span><span>></span></span>\n\n<span><span><span>&lt;</span>generatorConfiguration</span><span>></span></span>\n    <span><span><span>&lt;</span>context</span> <span>id</span><span><span>=</span><span>\"</span>DB2Tables<span>\"</span></span> <span>targetRuntime</span><span><span>=</span><span>\"</span>MyBatis3<span>\"</span></span><span>></span></span>\n\n        <span>&lt;!-- optional，旨在创建class时，对注释进行控制 --></span>\n        <span><span><span>&lt;</span>commentGenerator</span><span>></span></span>\n                <span><span><span>&lt;</span>property</span> <span>name</span><span><span>=</span><span>\"</span>suppressDate<span>\"</span></span> <span>value</span><span><span>=</span><span>\"</span>true<span>\"</span></span><span>/></span></span>\n                <span>&lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --></span>\n                <span><span><span>&lt;</span>property</span> <span>name</span><span><span>=</span><span>\"</span>suppressAllComments<span>\"</span></span> <span>value</span><span><span>=</span><span>\"</span>true<span>\"</span></span><span>/></span></span>\n        <span><span><span>&lt;/</span>commentGenerator</span><span>></span></span>\n\n        <span>&lt;!--jdbc数据库连接 --></span>\n        <span><span><span>&lt;</span>jdbcConnection</span> <span>driverClass</span><span><span>=</span><span>\"</span>com.mysql.jdbc.Driver<span>\"</span></span>\n                        <span>connectionURL</span><span><span>=</span><span>\"</span>jdbc:mysql://localhost:3306/database<span>\"</span></span>\n                        <span>userId</span><span><span>=</span><span>\"</span>root<span>\"</span></span>\n                        <span>password</span><span><span>=</span><span>\"</span>root<span>\"</span></span><span>></span></span>\n        <span><span><span>&lt;/</span>jdbcConnection</span><span>></span></span>\n\n        <span>&lt;!-- 默认false，把JDBC DECIMAL 和 NUMERIC 类型解析为 Integer，\n        为true时把JDBC DECIMAL和NUMERIC类型解析为java.math.BigDecimal --></span>\n        <span><span><span>&lt;</span>javaTypeResolver</span> <span>></span></span>\n            <span><span><span>&lt;</span>property</span> <span>name</span><span><span>=</span><span>\"</span>forceBigDecimals<span>\"</span></span> <span>value</span><span><span>=</span><span>\"</span>false<span>\"</span></span> <span>/></span></span>\n        <span><span><span>&lt;/</span>javaTypeResolver</span><span>></span></span>\n\n        <span>&lt;!-- Model模型生成器,用来生成含有主键key的类，记录类 以及查询Example类\n            targetPackage     指定生成的model生成所在的包名\n            targetProject     指定在该项目下所在的路径\n        --></span>\n        <span><span><span>&lt;</span>javaModelGenerator</span> <span>targetPackage</span><span><span>=</span><span>\"</span>com.lifeisgg.springboot_demo.entity<span>\"</span></span> <span>targetProject</span><span><span>=</span><span>\"</span>src/main/java<span>\"</span></span><span>></span></span>\n            <span>&lt;!-- 是否允许子包，即targetPackage.schemaName.tableName --></span>\n            <span><span><span>&lt;</span>property</span> <span>name</span><span><span>=</span><span>\"</span>enableSubPackages<span>\"</span></span> <span>value</span><span><span>=</span><span>\"</span>true<span>\"</span></span> <span>/></span></span>\n            <span>&lt;!-- 是否对model添加 构造函数 --></span>\n            <span><span><span>&lt;</span>property</span> <span>name</span><span><span>=</span><span>\"</span>constructorBased<span>\"</span></span> <span>value</span><span><span>=</span><span>\"</span>false<span>\"</span></span><span>/></span></span>\n            <span>&lt;!-- 是否对类CHAR类型的列的数据进行trim操作 --></span>\n            <span><span><span>&lt;</span>property</span> <span>name</span><span><span>=</span><span>\"</span>trimStrings<span>\"</span></span> <span>value</span><span><span>=</span><span>\"</span>true<span>\"</span></span> <span>/></span></span>\n        <span><span><span>&lt;/</span>javaModelGenerator</span><span>></span></span>\n\n        <span>&lt;!--Mapper映射文件生成所在的目录 为每一个数据库的表生成对应的SqlMap文件 --></span>\n        <span><span><span>&lt;</span>sqlMapGenerator</span> <span>targetPackage</span><span><span>=</span><span>\"</span>mapper<span>\"</span></span>  <span>targetProject</span><span><span>=</span><span>\"</span>src/main/resources<span>\"</span></span><span>></span></span>\n            <span><span><span>&lt;</span>property</span> <span>name</span><span><span>=</span><span>\"</span>enableSubPackages<span>\"</span></span> <span>value</span><span><span>=</span><span>\"</span>true<span>\"</span></span> <span>/></span></span>\n        <span><span><span>&lt;/</span>sqlMapGenerator</span><span>></span></span>\n\n        <span>&lt;!-- 客户端代码，生成易于使用的针对Model对象和XML配置文件 的代码\n                type=\"ANNOTATEDMAPPER\",生成Java Model 和基于注解的Mapper对象\n                type=\"MIXEDMAPPER\",生成基于注解的Java Model 和相应的Mapper对象\n                type=\"XMLMAPPER\",生成SQLMap XML文件和独立的Mapper接口\n        --></span>\n        <span><span><span>&lt;</span>javaClientGenerator</span> <span>type</span><span><span>=</span><span>\"</span>XMLMAPPER<span>\"</span></span> <span>targetPackage</span><span><span>=</span><span>\"</span>com.lifeisgg.springboot_demo.mapper<span>\"</span></span>  <span>targetProject</span><span><span>=</span><span>\"</span>src/main/java<span>\"</span></span><span>></span></span>\n            <span><span><span>&lt;</span>property</span> <span>name</span><span><span>=</span><span>\"</span>enableSubPackages<span>\"</span></span> <span>value</span><span><span>=</span><span>\"</span>true<span>\"</span></span> <span>/></span></span>\n        <span><span><span>&lt;/</span>javaClientGenerator</span><span>></span></span>\n\n        <span><span><span>&lt;</span>table</span> <span>schema</span><span><span>=</span><span>\"</span>labManagement_demo<span>\"</span></span> <span>tableName</span><span><span>=</span><span>\"</span>user<span>\"</span></span> <span>domainObjectName</span><span><span>=</span><span>\"</span>User<span>\"</span></span> <span>/></span></span>\n\n    <span><span><span>&lt;/</span>context</span><span>></span></span>\n<span><span><span>&lt;/</span>generatorConfiguration</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br></div></div><h2 id=\"_5-配置run-mybatis-generator\"> 5. 配置Run mybatis-generator</h2>\n<p>点击右上角<code>Edit Configuration</code></p>\n<p><img src=\"./images/Mybatis-reverse-project&Example-use/deploy_Run-mybatis-generator.jpg\" alt=\"配置Run-mybatis-generator\" /></p>\n<div><pre><code>mybatis-generator:generate\n</code></pre>\n<div><span>1</span><br></div></div><p>点击Run后会生成三个文件夹，以表User为例子</p>\n<blockquote>\n<ul>\n<li>\n<p>entity</p>\n<blockquote>\n<ul>\n<li>User.java</li>\n<li>UserExample.java</li>\n</ul>\n</blockquote>\n</li>\n<li>\n<p>mapper</p>\n<blockquote>\n<ul>\n<li>UserMapper.java</li>\n</ul>\n</blockquote>\n</li>\n<li>\n<p>resources/mapper</p>\n<blockquote>\n<ul>\n<li>UserMapper.xml</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n</blockquote>\n<p>之后自己创建<code>Service</code>，<code>ServiceImpl</code>，<code>Controller</code>即可，也可以用<code>EasyCode</code>插件创建</p>\n<h2 id=\"_6-example类的使用\"> 6. Example类的使用</h2>\n<p>参考</p>\n<blockquote>\n<ul>\n<li>https://www.cnblogs.com/wxywxy/p/10697173.html</li>\n</ul>\n</blockquote>\n<h3 id=\"_6-1-mapper接口中方法\"> 6.1 mapper接口中方法</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">方法</th>\n<th style=\"text-align:left\">功能说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">int countByExample(UserExample example) thorws SQLException</td>\n<td style=\"text-align:left\">按条件计数</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">int deleteByPrimaryKey(Integer id) thorws SQLException</td>\n<td style=\"text-align:left\">按主键删除</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">int deleteByExample(UserExample example) thorws SQLException</td>\n<td style=\"text-align:left\">按条件查询</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">String/Integer insert(User record) thorws SQLException</td>\n<td style=\"text-align:left\">插入数据（返回值为ID）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">User selectByPrimaryKey(Integer id) thorws SQLException</td>\n<td style=\"text-align:left\">按主键查询</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">List&lt;T&gt; selectByExample(UserExample example) thorws SQLException</td>\n<td style=\"text-align:left\">按条件查询</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">List&lt;T&gt; selectByExampleWithBLOGs(UserExample example) thorws SQLException</td>\n<td style=\"text-align:left\">按条件查询（包括BLOB字段）。只有当数据表中的字段类型有为二进制的才会产生。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">int updateByPrimaryKey(User record) thorws SQLException</td>\n<td style=\"text-align:left\">按主键更新</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">int updateByPrimaryKeySelective(User record) thorws SQLException</td>\n<td style=\"text-align:left\">按主键更新值不为null的字段</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">int updateByExample(User record, UserExample example) thorws SQLException</td>\n<td style=\"text-align:left\">按条件更新</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">int updateByExampleSelective(User record, UserExample example) thorws SQLException</td>\n<td style=\"text-align:left\">按条件更新值不为null的字段</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"_6-2-example实例解析\"> 6.2 example实例解析</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">方法</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">example.setOrderByClause(“字段名 ASC”);</td>\n<td style=\"text-align:left\">添加升序排列条件，DESC为降序</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">example.setDistinct(false)</td>\n<td style=\"text-align:left\">去除重复，boolean型，true为选择不重复的记录。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">criteria.andXxxIsNull</td>\n<td style=\"text-align:left\">添加字段xxx为null的条件</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">criteria.andXxxIsNotNull</td>\n<td style=\"text-align:left\">添加字段xxx不为null的条件</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">criteria.andXxxEqualTo(value)</td>\n<td style=\"text-align:left\">添加xxx字段等于value条件</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">criteria.andXxxNotEqualTo(value)</td>\n<td style=\"text-align:left\">添加xxx字段不等于value条件</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">criteria.andXxxGreaterThan(value)</td>\n<td style=\"text-align:left\">添加xxx字段大于value条件</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">criteria.andXxxGreaterThanOrEqualTo(value)</td>\n<td style=\"text-align:left\">添加xxx字段大于等于value条件</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">criteria.andXxxLessThan(value)</td>\n<td style=\"text-align:left\">添加xxx字段小于value条件</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">criteria.andXxxLessThanOrEqualTo(value)</td>\n<td style=\"text-align:left\">添加xxx字段小于等于value条件</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">criteria.andXxxIn(List&lt;？&gt;)</td>\n<td style=\"text-align:left\">添加xxx字段值在List&lt;？&gt;条件</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">criteria.andXxxNotIn(List&lt;？&gt;)</td>\n<td style=\"text-align:left\">添加xxx字段值不在List&lt;？&gt;条件</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">criteria.andXxxLike(“%”+value+”%”)</td>\n<td style=\"text-align:left\">添加xxx字段值为value的模糊查询条件</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">criteria.andXxxNotLike(“%”+value+”%”)</td>\n<td style=\"text-align:left\">添加xxx字段值不为value的模糊查询条件</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">criteria.andXxxBetween(value1,value2)</td>\n<td style=\"text-align:left\">添加xxx字段值在value1和value2之间条件</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">criteria.andXxxNotBetween(value1,value2)</td>\n<td style=\"text-align:left\">添加xxx字段值不在value1和value2之间条件</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"注意\"> 注意</h2>\n<p><code>updateByExample</code>需要将表的条件全部给出，比如一个一个表有三个字段，就必须给三个字段给他，不给会设为null。</p>\n<p><code>updateByExampleSelective</code>不同，当某一实体类的属性为null时，mybatis会使用动态sql过滤掉，不更新该字段</p>\n",
      "date_published": "2022-03-06T10:17:18.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": []
    },
    {
      "title": "Mybatis-Plus基础笔记",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/mybatis/MybatisPlus-notes/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/mybatis/MybatisPlus-notes/",
      "content_html": "<h2 id=\"参考\"> 参考</h2>\n<div><p>参考</p>\n<ul>\n<li><a href=\"https://mybatis.plus/\" target=\"_blank\" rel=\"noopener noreferrer\">Mybatis-Plus官网</a></li>\n<li><a href=\"https://www.bilibili.com/video/BV1yA411t782\" target=\"_blank\" rel=\"noopener noreferrer\">视频：【最新版】4小时学会MyBatis Plus通俗易懂，从入门到部署上线</a></li>\n</ul>\n</div>\n<h2 id=\"_1-快速上手\"> 1. 快速上手</h2>\n<h3 id=\"_1-1-创建表\"> 1.1 创建表</h3>\n<div><pre><code><span>DROP</span> <span>TABLE</span> <span>IF</span> <span>EXISTS</span> <span>user</span><span>;</span>\n\n<span>CREATE</span> <span>TABLE</span> <span>user</span>\n<span>(</span>\n\tid <span>BIGINT</span><span>(</span><span>20</span><span>)</span> <span>NOT</span> <span>NULL</span> <span>COMMENT</span> <span>'主键ID'</span><span>,</span>\n\tname <span>VARCHAR</span><span>(</span><span>30</span><span>)</span> <span>NULL</span> <span>DEFAULT</span> <span>NULL</span> <span>COMMENT</span> <span>'姓名'</span><span>,</span>\n\tage <span>INT</span><span>(</span><span>11</span><span>)</span> <span>NULL</span> <span>DEFAULT</span> <span>NULL</span> <span>COMMENT</span> <span>'年龄'</span><span>,</span>\n\temail <span>VARCHAR</span><span>(</span><span>50</span><span>)</span> <span>NULL</span> <span>DEFAULT</span> <span>NULL</span> <span>COMMENT</span> <span>'邮箱'</span><span>,</span>\n\t<span>PRIMARY</span> <span>KEY</span> <span>(</span>id<span>)</span>\n<span>)</span><span>;</span>\n\n<span>DELETE</span> <span>FROM</span> <span>user</span><span>;</span>\n\n<span>INSERT</span> <span>INTO</span> <span>user</span> <span>(</span>id<span>,</span> name<span>,</span> age<span>,</span> email<span>)</span> <span>VALUES</span>\n<span>(</span><span>1</span><span>,</span> <span>'Jone'</span><span>,</span> <span>18</span><span>,</span> <span>'test1@baomidou.com'</span><span>)</span><span>,</span>\n<span>(</span><span>2</span><span>,</span> <span>'Jack'</span><span>,</span> <span>20</span><span>,</span> <span>'test2@baomidou.com'</span><span>)</span><span>,</span>\n<span>(</span><span>3</span><span>,</span> <span>'Tom'</span><span>,</span> <span>28</span><span>,</span> <span>'test3@baomidou.com'</span><span>)</span><span>,</span>\n<span>(</span><span>4</span><span>,</span> <span>'Sandy'</span><span>,</span> <span>21</span><span>,</span> <span>'test4@baomidou.com'</span><span>)</span><span>,</span>\n<span>(</span><span>5</span><span>,</span> <span>'Billie'</span><span>,</span> <span>24</span><span>,</span> <span>'test5@baomidou.com'</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><table>\n<thead>\n<tr>\n<th>id</th>\n<th>name</th>\n<th>age</th>\n<th>email</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>Jone</td>\n<td>18</td>\n<td>test1@baomidou.com</td>\n</tr>\n<tr>\n<td>2</td>\n<td>Jack</td>\n<td>20</td>\n<td>test2@baomidou.com</td>\n</tr>\n<tr>\n<td>3</td>\n<td>Tom</td>\n<td>28</td>\n<td>test3@baomidou.com</td>\n</tr>\n<tr>\n<td>4</td>\n<td>Sandy</td>\n<td>21</td>\n<td>test4@baomidou.com</td>\n</tr>\n<tr>\n<td>5</td>\n<td>Billie</td>\n<td>24</td>\n<td>test5@baomidou.com</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"_1-2-创建springboot项目\"> 1.2 创建Springboot项目</h3>\n<h3 id=\"_1-3-引入依赖\"> 1.3 引入依赖</h3>\n<div><pre><code><span>&lt;!-- https://mvnrepository.com/artifact/com.baomidou/mybatis-plus-boot-starter --></span>\n<span><span><span>&lt;</span>dependency</span><span>></span></span>\n  <span><span><span>&lt;</span>groupId</span><span>></span></span>com.baomidou<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n  <span><span><span>&lt;</span>artifactId</span><span>></span></span>mybatis-plus-boot-starter<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n  <span><span><span>&lt;</span>version</span><span>></span></span>3.4.1<span><span><span>&lt;/</span>version</span><span>></span></span>\n<span><span><span>&lt;/</span>dependency</span><span>></span></span>\n\n<span>&lt;!-- 其他基本的springboot依赖 --></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><div><p>小坑注意</p>\n<p>配合分页插件<code>page helper</code>时比较老的版本会导致无法注入等问题，可以使用最新的</p>\n<div><pre><code><span>&lt;!-- page helper --></span>\n<span><span><span>&lt;</span>dependency</span><span>></span></span>\n  <span><span><span>&lt;</span>groupId</span><span>></span></span>com.github.pagehelper<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n  <span><span><span>&lt;</span>artifactId</span><span>></span></span>pagehelper-spring-boot-starter<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n  <span><span><span>&lt;</span>version</span><span>></span></span>1.3.0<span><span><span>&lt;/</span>version</span><span>></span></span>\n<span><span><span>&lt;/</span>dependency</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div></div>\n<h3 id=\"_1-4-配置数据源datasource\"> 1.4 配置数据源dataSource</h3>\n<div><pre><code><span>spring</span><span>:</span>\n  <span>application</span><span>:</span>\n    <span>name</span><span>:</span> dao\n  <span>datasource</span><span>:</span>\n     <span># 特别注意：java 9以后需要将com.mysql.jdbc.Driver  改为  com.mysql.cj.jdbc.Driver即可</span>\n     <span># 否则报错：Loading class `com.mysql.jdbc.Driver'. This is deprecated.</span>\n     <span>driver-class-name</span><span>:</span> com.mysql.cj.jdbc.Driver\n     <span>#基本属性</span>\n     <span>url</span><span>:</span> jdbc<span>:</span>mysql<span>:</span>//localhost<span>:</span>3306/music_recognition<span>?</span>\n     <span>username</span><span>:</span> root\n     <span>password</span><span>:</span> root\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h3 id=\"_1-5-创建实体\"> 1.5 创建实体</h3>\n<div><pre><code><span>@Data</span>\n<span>public</span> <span>class</span> <span>UserDemo</span> <span>{</span>\n    <span>private</span> <span>Integer</span> id<span>;</span>\n    <span>private</span> <span>String</span> username<span>;</span>\n    <span>private</span> <span>String</span> password<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id=\"_1-6-创建mapper\"> 1.6 创建mapper</h3>\n<div><pre><code><span>//继承BaseMapper，User作为泛型参数类</span>\n<span>public</span> <span>interface</span> <span>UserMapper</span> <span>extends</span> <span>BaseMapper</span><span><span>&lt;</span><span>User</span><span>></span></span> <span>{</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id=\"_1-7-启动器加扫描mapper的注解\"> 1.7 启动器加扫描mapper的注解</h3>\n<p><code>@MapperScan(&quot;com.tme.musicrecognition.dao&quot;)</code></p>\n<div><div><br><div>&nbsp;</div><br><br><br><br><br><br></div><pre><code><span>@SpringBootApplication</span>\n<span>@MapperScan</span><span>(</span><span>\"com.tme.musicrecognition.dao\"</span><span>)</span>\n<span>public</span> <span>class</span> <span>WebApplication</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>SpringApplication</span><span>.</span><span>run</span><span>(</span><span>WebApplication</span><span>.</span><span>class</span><span>,</span> args<span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id=\"_1-8-在测试类中运行\"> 1.8 在测试类中运行</h3>\n<div><pre><code><span>@SpringBootTest</span>\n<span>class</span> <span>WebApplicationTests</span> <span>{</span>\n\n    <span>@Autowired</span>\n    <span>private</span> <span>UserMapper</span> userMapper<span>;</span>\n\n    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>testSelect</span><span>(</span><span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>(</span><span>\"----- selectAll method test ------\"</span><span>)</span><span>)</span><span>;</span>\n        userMapper<span>.</span><span>selectList</span><span>(</span><span>null</span><span>)</span><span>.</span><span>forEach</span><span>(</span><span>System</span><span>.</span>out<span>::</span><span>println</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><div><p>结果</p>\n<blockquote>\n<p>----- selectAll method test ------\nCreating a new SqlSession\nSqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@47cf65f1] was not registered for synchronization because synchronization is not active\nJDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@2ad80cf6] will not be managed by Spring\n<mark>&gt;  Preparing: SELECT id,name,age,email FROM user\n<mark>&gt; Parameters:\n&lt;</mark>    Columns: id, name, age, email\n&lt;</mark>        Row: 1, Jone, 18, test1@baomidou.com\n&lt;==        Row: 2, Jack, 20, test2@baomidou.com\n&lt;==        Row: 3, Tom, 28, test3@baomidou.com\n&lt;==        Row: 4, Sandy, 21, test4@baomidou.com\n&lt;==        Row: 5, Billie, 24, test5@baomidou.com\n&lt;==      Total: 5\nClosing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@47cf65f1]\nUser(id=1, name=Jone, age=18, email=test1@baomidou.com)\nUser(id=2, name=Jack, age=20, email=test2@baomidou.com)\nUser(id=3, name=Tom, age=28, email=test3@baomidou.com)\nUser(id=4, name=Sandy, age=21, email=test4@baomidou.com)\nUser(id=5, name=Billie, age=24, email=test5@baomidou.com)</p>\n</blockquote>\n</div>\n<h3 id=\"_1-9-application-yml配置\"> 1.9 application.yml配置</h3>\n<div><p>参考</p>\n<p><a href=\"https://blog.csdn.net/u012153904/article/details/106134902\" target=\"_blank\" rel=\"noopener noreferrer\">mybatis-plus 3.X yml配置</a></p>\n</div>\n<p><code>application.yml</code></p>\n<div><pre><code><span>#mybatis-plus</span>\n<span>mybatis-plus</span><span>:</span>\n  <span>mapper-locations</span><span>:</span> classpath<span>:</span>mapper/*\n  <span>type-aliases-package</span><span>:</span> com.tme.musicrecognition.entity\n  <span># MyBatis 原生支持的配置</span>\n  <span>configuration</span><span>:</span>\n    <span># 是否开启自动驼峰命名规则（camel case）映射</span>\n    <span>mapUnderscoreToCamelCase</span><span>:</span> <span>true</span>\n    <span># 在控制台打印SQL命令并打印执行结果</span>\n    <span>log-impl</span><span>:</span> org.apache.ibatis.logging.stdout.StdOutImpl\n  <span># 全局策略配置</span>\n  <span>global-config</span><span>:</span>\n    <span>db-config</span><span>:</span>\n      <span>logic-delete-field</span><span>:</span> deleted  <span># 全局逻辑删除的实体字段名(since 3.3.0,配置后可以忽略不配置步骤2)</span>\n      <span>logic-delete-value</span><span>:</span> <span>1</span> <span># 逻辑已删除值(默认为 1)</span>\n      <span>logic-not-delete-value</span><span>:</span> <span>0</span> <span># 逻辑未删除值(默认为 0)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h2 id=\"_2-常用注解\"> 2. 常用注解</h2>\n<div><p>参考</p>\n<ul>\n<li>\n<p><a href=\"https://mybatis.plus/guide/annotation.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://mybatis.plus/guide/annotation.html</a></p>\n<p>介绍 <code>MybatisPlus</code> 注解包相关类详解(更多详细描述可点击查看源码注释)</p>\n<p>注解类包：</p>\n<p>👉 <a href=\"https://gitee.com/baomidou/mybatis-plus/tree/3.0/mybatis-plus-annotation/src/main/java/com/baomidou/mybatisplus/annotation\" target=\"_blank\" rel=\"noopener noreferrer\">mybatis-plus-annotation(opens new window)</a></p>\n</li>\n</ul>\n</div>\n<h3 id=\"_2-1-tablename\"> 2.1 @TableName</h3>\n<blockquote>\n<p>描述：表名注解</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">属性</th>\n<th style=\"text-align:center\">类型</th>\n<th style=\"text-align:center\">必须指定</th>\n<th style=\"text-align:center\">默认值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">value</td>\n<td style=\"text-align:center\">String</td>\n<td style=\"text-align:center\">否</td>\n<td style=\"text-align:center\">&quot;&quot;</td>\n<td>表名</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">schema</td>\n<td style=\"text-align:center\">String</td>\n<td style=\"text-align:center\">否</td>\n<td style=\"text-align:center\">&quot;&quot;</td>\n<td>schema</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">keepGlobalPrefix</td>\n<td style=\"text-align:center\">boolean</td>\n<td style=\"text-align:center\">否</td>\n<td style=\"text-align:center\">false</td>\n<td>是否保持使用全局的 tablePrefix 的值(如果设置了全局 tablePrefix 且自行设置了 value 的值)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">resultMap</td>\n<td style=\"text-align:center\">String</td>\n<td style=\"text-align:center\">否</td>\n<td style=\"text-align:center\">&quot;&quot;</td>\n<td>xml 中 resultMap 的 id</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">autoResultMap</td>\n<td style=\"text-align:center\">boolean</td>\n<td style=\"text-align:center\">否</td>\n<td style=\"text-align:center\">false</td>\n<td>是否自动构建 resultMap 并使用(如果设置 resultMap 则不会进行 resultMap 的自动构建并注入)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">excludeProperty</td>\n<td style=\"text-align:center\">String[]</td>\n<td style=\"text-align:center\">否</td>\n<td style=\"text-align:center\">{}</td>\n<td>需要排除的属性名(@since 3.3.1)</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"_2-2-tableid\"> 2.2 @TableId</h3>\n<blockquote>\n<p>描述：主键注解</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">属性</th>\n<th style=\"text-align:center\">类型</th>\n<th style=\"text-align:center\">必须指定</th>\n<th style=\"text-align:center\">默认值</th>\n<th style=\"text-align:center\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">value</td>\n<td style=\"text-align:center\">String</td>\n<td style=\"text-align:center\">否</td>\n<td style=\"text-align:center\">&quot;&quot;</td>\n<td style=\"text-align:center\">主键字段名</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">type</td>\n<td style=\"text-align:center\">Enum</td>\n<td style=\"text-align:center\">否</td>\n<td style=\"text-align:center\">IdType.NONE</td>\n<td style=\"text-align:center\">主键类型</td>\n</tr>\n</tbody>\n</table>\n<p>IdType</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">值</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">AUTO</td>\n<td style=\"text-align:left\">数据库ID自增。即使手动指定了Id，存入数据库还是按数据库字段最大值来自增</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">NONE</td>\n<td style=\"text-align:left\">无状态,该类型为未设置主键类型(注解里等于跟随全局,全局里约等于 INPUT)。MP set主键，使用雪花算法自动生成随机数</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">INPUT</td>\n<td style=\"text-align:left\">insert前自行set主键值。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">ASSIGN_ID</td>\n<td style=\"text-align:left\">分配ID(主键类型为Number(Long和Integer)或String)(since 3.3.0),使用接口<code>IdentifierGenerator</code>的方法<code>nextId</code>(默认实现类为<code>DefaultIdentifierGenerator</code>雪花算法)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">ASSIGN_UUID</td>\n<td style=\"text-align:left\">分配UUID,主键类型为String(since 3.3.0),使用接口<code>IdentifierGenerator</code>的方法<code>nextUUID</code>(默认default方法)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">ID_WORKER(弃用)</td>\n<td style=\"text-align:left\">分布式全局唯一ID 长整型类型(please use <code>ASSIGN_ID</code>)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">UUID(弃用)</td>\n<td style=\"text-align:left\">32位UUID字符串(please use <code>ASSIGN_UUID</code>)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">ID_WORKER_STR(弃用)</td>\n<td style=\"text-align:left\">分布式全局唯一ID 字符串类型(please use <code>ASSIGN_ID</code>)</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"_2-3-tablefield\"> 2.3 @TableField</h3>\n<blockquote>\n<p>描述：字段注解(非主键),value映射字段名</p>\n<p>exist表示是否为数据库字段false</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">属性</th>\n<th style=\"text-align:center\">类型</th>\n<th style=\"text-align:center\">必须指定</th>\n<th style=\"text-align:center\">默认值</th>\n<th style=\"text-align:center\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">value</td>\n<td style=\"text-align:center\">String</td>\n<td style=\"text-align:center\">否</td>\n<td style=\"text-align:center\">&quot;&quot;</td>\n<td style=\"text-align:center\">数据库字段名</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">el</td>\n<td style=\"text-align:center\">String</td>\n<td style=\"text-align:center\">否</td>\n<td style=\"text-align:center\">&quot;&quot;</td>\n<td style=\"text-align:center\">映射为原生 <code>#{ ... }</code> 逻辑,相当于写在 xml 里的 <code>#{ ... }</code> 部分</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">exist</td>\n<td style=\"text-align:center\">boolean</td>\n<td style=\"text-align:center\">否</td>\n<td style=\"text-align:center\">true</td>\n<td style=\"text-align:center\">是否为数据库表字段</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">condition</td>\n<td style=\"text-align:center\">String</td>\n<td style=\"text-align:center\">否</td>\n<td style=\"text-align:center\">&quot;&quot;</td>\n<td style=\"text-align:center\">字段 <code>where</code> 实体查询比较条件,有值设置则按设置的值为准,没有则为默认全局的 <code>%s=#{%s}</code>,<a href=\"https://github.com/baomidou/mybatis-plus/blob/3.0/mybatis-plus-annotation/src/main/java/com/baomidou/mybatisplus/annotation/SqlCondition.java\" target=\"_blank\" rel=\"noopener noreferrer\">参考(opens new window)</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">update</td>\n<td style=\"text-align:center\">String</td>\n<td style=\"text-align:center\">否</td>\n<td style=\"text-align:center\">&quot;&quot;</td>\n<td style=\"text-align:center\">字段 <code>update set</code> 部分注入, 例如：update=&quot;%s+1&quot;：表示更新时会set version=version+1(该属性优先级高于 <code>el</code> 属性)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">insertStrategy</td>\n<td style=\"text-align:center\">Enum</td>\n<td style=\"text-align:center\">N</td>\n<td style=\"text-align:center\">DEFAULT</td>\n<td style=\"text-align:center\">举例：NOT_NULL: <code>insert into table_a(&lt;if test=&quot;columnProperty != null&quot;&gt;column&lt;/if&gt;) values (&lt;if test=&quot;columnProperty != null&quot;&gt;#{columnProperty}&lt;/if&gt;)</code></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">updateStrategy</td>\n<td style=\"text-align:center\">Enum</td>\n<td style=\"text-align:center\">N</td>\n<td style=\"text-align:center\">DEFAULT</td>\n<td style=\"text-align:center\">举例：IGNORED: <code>update table_a set column=#{columnProperty}</code></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">whereStrategy</td>\n<td style=\"text-align:center\">Enum</td>\n<td style=\"text-align:center\">N</td>\n<td style=\"text-align:center\">DEFAULT</td>\n<td style=\"text-align:center\">举例：NOT_EMPTY: <code>where &lt;if test=&quot;columnProperty != null and columnProperty!=''&quot;&gt;column=#{columnProperty}&lt;/if&gt;</code></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">fill</td>\n<td style=\"text-align:center\">Enum</td>\n<td style=\"text-align:center\">否</td>\n<td style=\"text-align:center\">FieldFill.DEFAULT</td>\n<td style=\"text-align:center\">字段自动填充策略</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">select</td>\n<td style=\"text-align:center\">boolean</td>\n<td style=\"text-align:center\">否</td>\n<td style=\"text-align:center\">true</td>\n<td style=\"text-align:center\">是否进行 select 查询</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">keepGlobalFormat</td>\n<td style=\"text-align:center\">boolean</td>\n<td style=\"text-align:center\">否</td>\n<td style=\"text-align:center\">false</td>\n<td style=\"text-align:center\">是否保持使用全局的 format 进行处理</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">jdbcType</td>\n<td style=\"text-align:center\">JdbcType</td>\n<td style=\"text-align:center\">否</td>\n<td style=\"text-align:center\">JdbcType.UNDEFINED</td>\n<td style=\"text-align:center\">JDBC类型 (该默认值不代表会按照该值生效)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">typeHandler</td>\n<td style=\"text-align:center\">Class&lt;? extends TypeHandler&gt;</td>\n<td style=\"text-align:center\">否</td>\n<td style=\"text-align:center\">UnknownTypeHandler.class</td>\n<td style=\"text-align:center\">类型处理器 (该默认值不代表会按照该值生效)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">numericScale</td>\n<td style=\"text-align:center\">String</td>\n<td style=\"text-align:center\">否</td>\n<td style=\"text-align:center\">&quot;&quot;</td>\n<td style=\"text-align:center\">指定小数点后保留的位数</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"关于fill自动填充\"> 关于fill自动填充</h4>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">值</th>\n<th style=\"text-align:center\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">DEFAULT</td>\n<td style=\"text-align:center\">默认不处理</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">INSERT</td>\n<td style=\"text-align:center\">插入时填充字段</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">UPDATE</td>\n<td style=\"text-align:center\">更新时填充字段</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">INSERT_UPDATE</td>\n<td style=\"text-align:center\">插入和更新时填充字段</td>\n</tr>\n</tbody>\n</table>\n<p>例子(在实体类中)</p>\n<div><pre><code><span>@TableField</span><span>(</span>fill <span>=</span> <span>FieldFill</span><span>.</span>INSERT<span>)</span>\n<span>private</span> <span>Date</span> createTime<span>;</span>\n\n<span>@TableField</span><span>(</span>fill <span>=</span> <span>FieldFill</span><span>.</span>UPDATE<span>)</span>\n<span>private</span> <span>Date</span> updateTime<span>;</span>\n\n<span>@TableField</span><span>(</span>fill <span>=</span> <span>FieldFill</span><span>.</span>INSERT_UPDATE<span>)</span>\n<span>private</span> <span>Date</span> updateTime<span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>然后创建Handle方法</p>\n<p><code>MyMetaObjectHandler.java</code></p>\n<blockquote>\n<p>要加上注解<code>@Component</code></p>\n</blockquote>\n<div><pre><code><span>@Component</span>\n<span>public</span> <span>class</span> <span>MyMetaObjectHandler</span> <span>implements</span> <span>MetaObjectHandler</span> <span>{</span>\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>insertFill</span><span>(</span><span>MetaObject</span> metaObject<span>)</span> <span>{</span>\n        <span>this</span><span>.</span><span>setFieldValByName</span><span>(</span><span>\"createTime\"</span><span>,</span> <span>new</span> <span>Date</span><span>(</span><span>)</span><span>,</span> metaObject<span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>updateFill</span><span>(</span><span>MetaObject</span> metaObject<span>)</span> <span>{</span>\n\n    <span>}</span>\n\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>这样插入的时候就能自动填充当前时间</p>\n<h3 id=\"_2-4-version\"> 2.4 @Version</h3>\n<p>标记乐观锁,通过 <code>version</code>字段来保证数据的安全性,当修改数据的时候,会以<code>version</code>作为更新时的条件,当条件成立的时候才会修改成功。</p>\n<p>例如</p>\n<div><p>例如</p>\n<p>线程1: update… set version=2 where version=1</p>\n<p>线程2: update…, set version=2 where version=1</p>\n</div>\n<h4 id=\"_2-4-1-数据库添加version字段\"> 2.4.1 数据库添加version字段</h4>\n<p>设置默认为1</p>\n<h4 id=\"_2-4-2-在实体类的属性上添加-version注解\"> 2.4.2 在实体类的属性上添加@Version注解</h4>\n<div><pre><code><span>@Version</span>\n<span>private</span> <span>Integer</span> version<span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h4 id=\"_2-4-3-并发测试\"> 2.4.3 并发测试</h4>\n<div><pre><code><span>SysUser</span> sysUser <span>=</span> sysUserMapper<span>.</span><span>selectById</span><span>(</span><span>1</span><span>)</span><span>;</span>\nsysUser <span>=</span> sysUser<span>.</span><span>toBuilder</span><span>(</span><span>)</span><span>.</span><span>name</span><span>(</span><span>\"小北\"</span><span>)</span><span>.</span><span>build</span><span>(</span><span>)</span><span>;</span>\n\n<span>SysUser</span> sysUser2 <span>=</span> sysUserMapper<span>.</span><span>selectById</span><span>(</span><span>1</span><span>)</span><span>;</span>\nsysUser2 <span>=</span> sysUser2<span>.</span><span>toBuilder</span><span>(</span><span>)</span><span>.</span><span>name</span><span>(</span><span>\"小南\"</span><span>)</span><span>.</span><span>build</span><span>(</span><span>)</span><span>;</span>\n\nsysUserMapper<span>.</span><span>updateById</span><span>(</span>sysUser<span>)</span><span>;</span>\nsysUserMapper<span>.</span><span>updateById</span><span>(</span>sysUser2<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>这里先查询两次分别赋值给<code>sysSuser</code>和<code>sysUser2</code>，此时调用<code>debug</code>模式可以看到两个查询出来的<code>version</code>都为1</p>\n<p><img src=\"./images/MybatisPlus-notes/@Version_debug.png\" alt=\"@Version测试结果\" /></p>\n<p>此时这里按顺序更新，由于第一次带着的version与数据库中的匹配，更新后version会变为2，而接着sysUser2也带着version=1去更新，由于更新是带着version=1为条件更新，但是数据库的version已经变成2了所以找不到，所以也就无法更新。</p>\n<p>最后的更新结果是sysUser的更新。</p>\n<h3 id=\"_2-5-enumvalue\"> 2.5 @EnumValue</h3>\n<p>枚举类型，根据数据库的字段映射替换成自定义枚举类型的实体</p>\n<h4 id=\"_2-5-1-在数据库创建state字段\"> 2.5.1 在数据库创建state字段</h4>\n<p>1表示正常</p>\n<p>2表示禁用</p>\n<h4 id=\"_2-5-2-在实体类加上对应属性state\"> 2.5.2 在实体类加上对应属性state</h4>\n<blockquote>\n<p>类型为创建的枚举型</p>\n</blockquote>\n<div><pre><code><span>private</span> <span>SysUserState</span> state<span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"_2-5-3-创建enum类型\"> 2.5.3 创建enum类型</h4>\n<p>在字段<code>code</code>上加注解<code>@EnumValue</code>表示用code去对应映射数据库中字段<code>state</code>的值</p>\n<div><p>Info</p>\n<ul>\n<li>如果<code>state</code>的值为1那么实体类中的<code>state</code>会自动填充为<code>NORMAL(1,&quot;正常&quot;)</code></li>\n<li>如果<code>state</code>的值为2那么实体类中的<code>state</code>会自动填充为<code>DISABLED(2, &quot;禁用&quot;)</code></li>\n</ul>\n</div>\n<div><pre><code><span>public</span> <span>enum</span> <span>SysUserState</span> <span>{</span>\n    <span>NORMAL</span><span>(</span><span>1</span><span>,</span><span>\"正常\"</span><span>)</span><span>,</span>\n    <span>DISABLED</span><span>(</span><span>2</span><span>,</span> <span>\"禁用\"</span><span>)</span><span>;</span>\n\n    <span>@EnumValue</span>\n    <span>private</span> <span>Integer</span> code<span>;</span>\n    <span>private</span> <span>String</span> msg<span>;</span>\n\n    <span>SysUserState</span><span>(</span><span>Integer</span> code<span>,</span> <span>String</span> msg<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>code <span>=</span> code<span>;</span>\n        <span>this</span><span>.</span>msg <span>=</span> msg<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h4 id=\"_2-5-4-在application-yml中配置扫描枚举的包\"> 2.5.4 在application.yml中配置扫描枚举的包</h4>\n<div><div><br><br><br><br><div>&nbsp;</div><br></div><pre><code><span>#mybatis-plus</span>\n<span>mybatis-plus</span><span>:</span>\n  <span>mapper-locations</span><span>:</span> classpath<span>:</span>mapper/*\n  <span>type-aliases-package</span><span>:</span> com.tme.musicrecognition.entity\n  <span>type-enums-package</span><span>:</span> com.tme.musicrecognition.enums\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h4 id=\"_2-5-5-测试结果\"> 2.5.5 测试结果</h4>\n<p><img src=\"./images/MybatisPlus-notes/@EnumValue_test.png\" alt=\"@EnumValue测试结果\" /></p>\n<h4 id=\"_2-5-6-第二种方式-实现接口\"> 2.5.6 第二种方式：实现接口</h4>\n<div><pre><code><span>public</span> <span>enum</span> <span>SysUserStateEnum2</span> <span>implements</span> <span>IEnum</span><span><span>&lt;</span><span>Integer</span><span>></span></span> <span>{</span>\n\n    <span>NORMAL</span><span>(</span><span>1</span><span>,</span><span>\"正常\"</span><span>)</span><span>,</span>\n    <span>DISABLED</span><span>(</span><span>2</span><span>,</span> <span>\"禁用\"</span><span>)</span><span>;</span>\n\n    <span>private</span> <span>Integer</span> code<span>;</span>\n    <span>private</span> <span>String</span> msg<span>;</span>\n\n    <span>SysUserStateEnum2</span><span>(</span><span>Integer</span> code<span>,</span> <span>String</span> msg<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>code <span>=</span> code<span>;</span>\n        <span>this</span><span>.</span>msg <span>=</span> msg<span>;</span>\n    <span>}</span>\n\n  \t<span>//实现此方法，等同于在code上加注解@EnumValue</span>\n    <span>@Override</span>\n    <span>public</span> <span>Integer</span> <span>getValue</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>this</span><span>.</span>code<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><h3 id=\"_2-6-tablelogic\"> 2.6 @TableLogic</h3>\n<blockquote>\n<p>描述：表字段逻辑处理注解（逻辑删除）</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">属性</th>\n<th style=\"text-align:center\">类型</th>\n<th style=\"text-align:center\">必须指定</th>\n<th style=\"text-align:center\">默认值</th>\n<th style=\"text-align:center\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">value</td>\n<td style=\"text-align:center\">String</td>\n<td style=\"text-align:center\">否</td>\n<td style=\"text-align:center\">&quot;&quot;</td>\n<td style=\"text-align:center\">逻辑未删除值</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">delval</td>\n<td style=\"text-align:center\">String</td>\n<td style=\"text-align:center\">否</td>\n<td style=\"text-align:center\">&quot;&quot;</td>\n<td style=\"text-align:center\">逻辑删除值</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"_2-6-1-数据库增加字段deleted\"> 2.6.1 数据库增加字段deleted</h4>\n<h4 id=\"_2-6-2-application-yml配置\"> 2.6.2 application.yml配置</h4>\n<div><div><br><br><br><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br></div><pre><code><span>#mybatis-plus</span>\n<span>mybatis-plus</span><span>:</span>\n  <span>mapper-locations</span><span>:</span> classpath<span>:</span>mapper/*\n  <span>type-aliases-package</span><span>:</span> com.tme.musicrecognition.entity\n  <span>type-enums-package</span><span>:</span> com.tme.musicrecognition.enums\n  <span># MyBatis 原生支持的配置</span>\n  <span>configuration</span><span>:</span>\n    <span># 是否开启自动驼峰命名规则（camel case）映射</span>\n    <span>mapUnderscoreToCamelCase</span><span>:</span> <span>true</span>\n    <span># 在控制台打印SQL命令并打印执行结果</span>\n    <span>log-impl</span><span>:</span> org.apache.ibatis.logging.stdout.StdOutImpl\n  <span># 全局策略配置</span>\n  <span>global-config</span><span>:</span>\n    <span>db-config</span><span>:</span>\n      <span>logic-delete-field</span><span>:</span> deleted  <span># 全局逻辑删除的实体字段名(since 3.3.0,配置后可以忽略不配置步骤2)</span>\n      <span>logic-delete-value</span><span>:</span> <span>1</span> <span># 逻辑已删除值(默认为 1)</span>\n      <span>logic-not-delete-value</span><span>:</span> <span>0</span> <span># 逻辑未删除值(默认为 0)</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>如果不配置<code>logic-delete-field: deleted</code>，则可以直接在实体类中的<code>deleted</code>上加注解<code>@TableLogic</code></p>\n<div><pre><code><span>@TableLogic</span>\n<span>private</span> <span>Integer</span> deleted<span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h4 id=\"_2-6-3-测试\"> 2.6.3 测试</h4>\n<div><pre><code><span>@Test</span>\n<span>public</span> <span>void</span> <span>deleteTest</span><span>(</span><span>)</span><span>{</span>\n    sysUserMapper<span>.</span><span>deleteById</span><span>(</span><span>1</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><img src=\"./images/MybatisPlus-notes/@TableLogic_test.png\" alt=\"@TableLogic测试结果\" /></p>\n<blockquote>\n<p>可以看到这里是软删除，并不是真的删除。在后续查询中也会自动添加条件<code>deleted=0</code>来作为筛选条件</p>\n</blockquote>\n<h2 id=\"_3-crud示例\"> 3. CRUD示例</h2>\n<h3 id=\"_3-1-查询示例\"> 3.1 查询示例</h3>\n<div><pre><code>    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>testSelect</span><span>(</span><span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>(</span><span>\"----- selectAll method test ------\"</span><span>)</span><span>)</span><span>;</span>\n        <span>//分页查询</span>\n<span>//        Page&lt;SysUser> pages = null;</span>\n<span>//        PageHelper.startPage(0,3);</span>\n<span>//        pages = (Page&lt;SysUser>) sysUserMapper.selectList(null);</span>\n<span>//        pages.getResult().forEach(System.out::println);</span>\n<span>//        System.out.println(\"pages.getTotal() = \" + pages.getTotal());</span>\n\n        <span>//普通查询</span>\n<span>//        sysUserMapper.selectList(null);</span>\n        <span>//带条件查询</span>\n        <span>QueryWrapper</span> queryWrapper <span>=</span> <span>new</span> <span>QueryWrapper</span><span>(</span><span>)</span><span>;</span>\n        queryWrapper<span>.</span><span>eq</span><span>(</span><span>\"name\"</span><span>,</span> <span>\"小北\"</span><span>)</span><span>;</span>\n<span>//        sysUserMapper.selectList(queryWrapper);</span>\n        <span>//多条件查询</span>\n        queryWrapper <span>=</span> <span>new</span> <span>QueryWrapper</span><span>(</span><span>)</span><span>;</span>\n        <span>HashMap</span><span><span>&lt;</span><span>String</span><span>,</span> <span>Object</span><span>></span></span> conditionHashMap <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n        <span>/*conditionHashMap.put(\"name\", \"小北\");\n        conditionHashMap.put(\"state\", 2);\n        queryWrapper.allEq(conditionHashMap);*/</span>\n        <span>//大于等于</span>\n        queryWrapper<span>.</span><span>ge</span><span>(</span><span>\"state\"</span><span>,</span><span>1</span><span>)</span><span>;</span>\n        <span>//模糊查询</span>\n        queryWrapper<span>.</span><span>like</span><span>(</span><span>\"name\"</span><span>,</span> <span>\"小\"</span><span>)</span><span>;</span>\n        <span>//inSQL查询</span>\n        queryWrapper<span>.</span><span>inSql</span><span>(</span><span>\"state\"</span><span>,</span><span>\"select state from sys_user where state > 0\"</span><span>)</span><span>;</span>\n        queryWrapper<span>.</span><span>inSql</span><span>(</span><span>\"version\"</span><span>,</span><span>\"select version from sys_user where version > 0\"</span><span>)</span><span>;</span>\n        <span>//降序排序</span>\n        queryWrapper<span>.</span><span>orderByDesc</span><span>(</span><span>\"state\"</span><span>)</span><span>;</span>\n\n\n        sysUserMapper<span>.</span><span>selectList</span><span>(</span>queryWrapper<span>)</span><span>;</span>\n\n    <span>}</span>\n\n    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>testSelect2</span><span>(</span><span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>(</span><span>\"----- testSelect method test ------\"</span><span>)</span><span>)</span><span>;</span>\n        <span>//批量查询</span>\n<span>//        sysUserMapper.selectBatchIds(Arrays.asList(1,2,3)).forEach(System.out::println);</span>\n        <span>//Map填充条件，只能做等值判断</span>\n        <span>HashMap</span><span><span>&lt;</span><span>String</span><span>,</span> <span>Object</span><span>></span></span> conditionHashMap <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n        conditionHashMap<span>.</span><span>put</span><span>(</span><span>\"name\"</span><span>,</span> <span>\"小北\"</span><span>)</span><span>;</span>\n<span>//        sysUserMapper.selectByMap(conditionHashMap).forEach(System.out::println);</span>\n\n        <span>//将查询结果填充到Map的List中</span>\n<span>//        sysUserMapper.selectMaps(null).forEach(System.out::println);</span>\n\n        <span>//分页查询</span>\n        <span>Page</span><span><span>&lt;</span><span>SysUser</span><span>></span></span> page <span>=</span> <span>new</span> <span>Page</span><span><span>&lt;</span><span>></span></span><span>(</span><span>0</span><span>,</span><span>1</span><span>)</span><span>;</span>\n        <span>Page</span><span><span>&lt;</span><span>SysUser</span><span>></span></span> result <span>=</span> sysUserMapper<span>.</span><span>selectPage</span><span>(</span>page<span>,</span> <span>null</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"page.getSize() = \"</span> <span>+</span> result<span>.</span><span>getSize</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"page.getTotal() = \"</span> <span>+</span> result<span>.</span><span>getTotal</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        result<span>.</span><span>getRecords</span><span>(</span><span>)</span><span>.</span><span>forEach</span><span>(</span><span>System</span><span>.</span>out<span>::</span><span>println</span><span>)</span><span>;</span>\n\n        <span>//分页查询并封装在Map中</span>\n        <span>Page</span><span><span>&lt;</span><span>Map</span><span>&lt;</span><span>String</span><span>,</span> <span>Object</span><span>></span><span>></span></span> page2 <span>=</span> <span>new</span> <span>Page</span><span><span>&lt;</span><span>></span></span><span>(</span><span>1</span><span>,</span> <span>2</span><span>)</span><span>;</span>\n<span>//        sysUserMapper.selectMapsPage(page2, null).getRecords().forEach(System.out::println);</span>\n\n\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br></div></div><p>分页查询</p>\n<p>在<code>MybatisPlusConfig.java</code>中配置<code>Bean</code></p>\n<div><pre><code><span>@Bean</span>\n<span>public</span> <span>PaginationInterceptor</span> <span>paginationInterceptor</span><span>(</span><span>)</span> <span>{</span>\n    <span>PaginationInterceptor</span> paginationInterceptor <span>=</span> <span>new</span> <span>PaginationInterceptor</span><span>(</span><span>)</span><span>;</span>\n    <span>// 设置请求的页面大于最大页后操作， true调回到首页，false 继续请求  默认false</span>\n    <span>// paginationInterceptor.setOverflow(false);</span>\n    <span>// 设置最大单页限制数量，默认 500 条，-1 不受限制</span>\n    <span>// paginationInterceptor.setLimit(500);</span>\n    <span>// 开启 count 的 join 优化,只针对部分 left join</span>\n    paginationInterceptor<span>.</span><span>setCountSqlParser</span><span>(</span><span>new</span> <span>JsqlParserCountOptimize</span><span>(</span><span>true</span><span>)</span><span>)</span><span>;</span>\n    <span>return</span> paginationInterceptor<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h3 id=\"_3-2-删除示例\"> 3.2 删除示例</h3>\n<div><pre><code>sysUserMapper<span>.</span><span>deleteById</span><span>(</span><span>1</span><span>)</span><span>;</span>\n<span>//批量删除</span>\nsysUserMapper<span>.</span><span>deleteBatchIds</span><span>(</span><span>Arrays</span><span>.</span><span>asList</span><span>(</span><span>1</span><span>,</span><span>2</span><span>)</span><span>)</span><span>;</span>\n<span>//条件删除</span>\n<span>QueryWrapper</span> queryWrapper <span>=</span> <span>new</span> <span>QueryWrapper</span><span>(</span><span>)</span><span>;</span>\nqueryWrapper<span>.</span><span>eq</span><span>(</span><span>\"gender\"</span><span>,</span> <span>1</span><span>)</span><span>;</span>\nsysUserMapper<span>.</span><span>delete</span><span>(</span>queryWrapper<span>)</span><span>;</span>\n<span>//通过map删除</span>\n<span>HashMap</span><span><span>&lt;</span><span>String</span><span>,</span> <span>Object</span><span>></span></span> conditionHashMap <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\nconditionHashMap<span>.</span><span>put</span><span>(</span><span>\"gender\"</span><span>,</span> <span>1</span><span>)</span><span>;</span>\nsysUserMapper<span>.</span><span>deleteByMap</span><span>(</span>conditionHashMap<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h3 id=\"_3-3-更新示例\"> 3.3 更新示例</h3>\n<div><pre><code><span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>(</span><span>\"----- updateTest method test ------\"</span><span>)</span><span>)</span><span>;</span>\n<span>SysUser</span> sysUser <span>=</span> sysUserMapper<span>.</span><span>selectById</span><span>(</span><span>1</span><span>)</span><span>;</span>\nsysUser <span>=</span> sysUser<span>.</span><span>toBuilder</span><span>(</span><span>)</span><span>.</span><span>name</span><span>(</span><span>\"小北\"</span><span>)</span><span>.</span><span>state</span><span>(</span><span>SysUserStateEnum</span><span>.</span>DISABLED<span>)</span><span>.</span><span>build</span><span>(</span><span>)</span><span>;</span>\nsysUserMapper<span>.</span><span>updateById</span><span>(</span>sysUser<span>)</span><span>;</span>\n\n<span>//使用QueryWrapper作为更新条件更新成sysUser</span>\n<span>QueryWrapper</span> queryWrapper <span>=</span> <span>new</span> <span>QueryWrapper</span><span>(</span><span>)</span><span>;</span>\nqueryWrapper<span>.</span><span>eq</span><span>(</span><span>\"gender\"</span><span>,</span> <span>2</span><span>)</span><span>;</span>\nsysUserMapper<span>.</span><span>update</span><span>(</span><span>SysUser</span><span>.</span><span>builder</span><span>(</span><span>)</span><span>.</span><span>name</span><span>(</span><span>\"熊熊\"</span><span>)</span><span>.</span><span>build</span><span>(</span><span>)</span><span>,</span> queryWrapper<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id=\"_3-4-增加示例\"> 3.4 增加示例</h3>\n<div><pre><code><span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>(</span><span>\"----- insertTest method test ------\"</span><span>)</span><span>)</span><span>;</span>\n<span>SysUser</span> sysUser <span>=</span> <span>SysUser</span><span>.</span><span>builder</span><span>(</span><span>)</span><span>.</span><span>name</span><span>(</span><span>\"小明\"</span><span>)</span><span>.</span><span>build</span><span>(</span><span>)</span><span>;</span>\nsysUserMapper<span>.</span><span>insert</span><span>(</span>sysUser<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id=\"_3-2-自定义sql语句-多表关联查询\"> 3.2 自定义SQL语句(多表关联查询)</h3>\n<div><pre><code><span>@Select</span><span>(</span><span>\"select * from sys_user su, sys_role sr, sys_user_role sur where su.user_id = #{userId} and su.user_id = sur.user_id and sr.role_id = sur.role_id\"</span><span>)</span>\n<span>SysUserRoleVO</span> <span>selectRoleByUserId</span><span>(</span><span>Integer</span> userId<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h2 id=\"_4-mybatis-plus自动生成代码\"> 4. Mybatis-Plus自动生成代码</h2>\n<p>自动生成</p>\n<div><p>自动生成</p>\n<ul>\n<li>entity</li>\n<li>mapper</li>\n<li>service</li>\n<li>serviceImpl</li>\n<li>controller</li>\n</ul>\n</div>\n<h3 id=\"_4-1-创建一个module用来生成代码\"> 4.1 创建一个module用来生成代码</h3>\n<h3 id=\"_4-2-添加依赖\"> 4.2 添加依赖</h3>\n<div><pre><code><span>&lt;</span><span>!</span><span>--</span> https<span>:</span><span>/</span><span>/</span>mvnrepository<span>.</span>com<span>/</span>artifact<span>/</span>com<span>.</span>baomidou<span>/</span>mybatis<span>-</span>plus<span>-</span>generator <span>--</span><span>></span>\n<span><span>&lt;</span>dependency<span>></span></span>\n  <span><span>&lt;</span>groupId<span>></span></span>com<span>.</span>baomidou<span>&lt;</span><span>/</span>groupId<span>></span>\n  <span><span>&lt;</span>artifactId<span>></span></span>mybatis<span>-</span>plus<span>-</span>generator<span>&lt;</span><span>/</span>artifactId<span>></span>\n  <span><span>&lt;</span>version<span>></span></span><span>3.4</span><span>.1</span><span>&lt;</span><span>/</span>version<span>></span>\n<span>&lt;</span><span>/</span>dependency<span>></span>\n<span>//模板引擎velocity(默认)，Freemarker，Beetl</span>\n<span><span>&lt;</span>dependency<span>></span></span>\n  <span><span>&lt;</span>groupId<span>></span></span>org<span>.</span>apache<span>.</span>velocity<span>&lt;</span><span>/</span>groupId<span>></span>\n  <span><span>&lt;</span>artifactId<span>></span></span>velocity<span>-</span>engine<span>-</span>core<span>&lt;</span><span>/</span>artifactId<span>></span>\n  <span><span>&lt;</span>version<span>></span></span><span>2.2</span><span>&lt;</span><span>/</span>version<span>></span>\n<span>&lt;</span><span>/</span>dependency<span>></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h3 id=\"_4-3-创建并配置启动类\"> 4.3 创建并配置启动类</h3>\n<div><p>参考</p>\n<ul>\n<li><a href=\"https://baomidou.com/guide/generator.html\" target=\"_blank\" rel=\"noopener noreferrer\">代码生成器</a></li>\n</ul>\n</div>\n<p><code>MybatisPlusGenerator.java</code></p>\n<div><pre><code><span>package</span> <span>com<span>.</span>tme<span>.</span>musicrecognition<span>.</span>mybatisGenerator</span><span>;</span>\n\n<span>import</span> <span>com<span>.</span>baomidou<span>.</span>mybatisplus<span>.</span>annotation<span>.</span></span><span>DbType</span><span>;</span>\n<span>import</span> <span>com<span>.</span>baomidou<span>.</span>mybatisplus<span>.</span>annotation<span>.</span></span><span>IdType</span><span>;</span>\n<span>import</span> <span>com<span>.</span>baomidou<span>.</span>mybatisplus<span>.</span>core<span>.</span>exceptions<span>.</span></span><span>MybatisPlusException</span><span>;</span>\n<span>import</span> <span>com<span>.</span>baomidou<span>.</span>mybatisplus<span>.</span>core<span>.</span>toolkit<span>.</span></span><span>StringPool</span><span>;</span>\n<span>import</span> <span>com<span>.</span>baomidou<span>.</span>mybatisplus<span>.</span>core<span>.</span>toolkit<span>.</span></span><span>StringUtils</span><span>;</span>\n<span>import</span> <span>com<span>.</span>baomidou<span>.</span>mybatisplus<span>.</span>generator<span>.</span></span><span>AutoGenerator</span><span>;</span>\n<span>import</span> <span>com<span>.</span>baomidou<span>.</span>mybatisplus<span>.</span>generator<span>.</span></span><span>InjectionConfig</span><span>;</span>\n<span>import</span> <span>com<span>.</span>baomidou<span>.</span>mybatisplus<span>.</span>generator<span>.</span>config<span>.</span></span><span>*</span><span>;</span>\n<span>import</span> <span>com<span>.</span>baomidou<span>.</span>mybatisplus<span>.</span>generator<span>.</span>config<span>.</span>po<span>.</span></span><span>TableInfo</span><span>;</span>\n<span>import</span> <span>com<span>.</span>baomidou<span>.</span>mybatisplus<span>.</span>generator<span>.</span>config<span>.</span>rules<span>.</span></span><span>DateType</span><span>;</span>\n<span>import</span> <span>com<span>.</span>baomidou<span>.</span>mybatisplus<span>.</span>generator<span>.</span>config<span>.</span>rules<span>.</span></span><span>NamingStrategy</span><span>;</span>\n<span>import</span> <span>com<span>.</span>baomidou<span>.</span>mybatisplus<span>.</span>generator<span>.</span>engine<span>.</span></span><span>FreemarkerTemplateEngine</span><span>;</span>\n\n<span>import</span> <span>java<span>.</span>util<span>.</span></span><span>ArrayList</span><span>;</span>\n<span>import</span> <span>java<span>.</span>util<span>.</span></span><span>List</span><span>;</span>\n<span>import</span> <span>java<span>.</span>util<span>.</span></span><span>Scanner</span><span>;</span>\n\n<span>/**\n * @Project: music-recognition\n * @Package: com.tme.musicrecognition.mybatisGenerator\n * @ClassName: MybatisPlusGenerator\n * @Author: Chen Long\n * @Description:\n * @Datetime: 2021/1/10  13:29\n */</span>\n<span>public</span> <span>class</span> <span>MybatisPlusGenerator</span> <span>{</span>\n    <span>/**\n     * &lt;p>\n     * 读取控制台内容\n     * &lt;/p>\n     */</span>\n    <span>public</span> <span>static</span> <span>String</span> <span>scanner</span><span>(</span><span>String</span> tip<span>)</span> <span>{</span>\n        <span>Scanner</span> scanner <span>=</span> <span>new</span> <span>Scanner</span><span>(</span><span>System</span><span>.</span>in<span>)</span><span>;</span>\n        <span>StringBuilder</span> help <span>=</span> <span>new</span> <span>StringBuilder</span><span>(</span><span>)</span><span>;</span>\n        help<span>.</span><span>append</span><span>(</span><span>\"请输入\"</span> <span>+</span> tip <span>+</span> <span>\"：\"</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>help<span>.</span><span>toString</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>if</span> <span>(</span>scanner<span>.</span><span>hasNext</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n            <span>String</span> ipt <span>=</span> scanner<span>.</span><span>next</span><span>(</span><span>)</span><span>;</span>\n            <span>if</span> <span>(</span><span>StringUtils</span><span>.</span><span>isNotBlank</span><span>(</span>ipt<span>)</span><span>)</span> <span>{</span>\n                <span>return</span> ipt<span>;</span>\n            <span>}</span>\n        <span>}</span>\n        <span>throw</span> <span>new</span> <span>MybatisPlusException</span><span>(</span><span>\"请输入正确的\"</span> <span>+</span> tip <span>+</span> <span>\"！\"</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>// 代码生成器</span>\n        <span>AutoGenerator</span> mpg <span>=</span> <span>new</span> <span>AutoGenerator</span><span>(</span><span>)</span><span>;</span>\n\n        <span>// 数据源配置</span>\n        <span>DataSourceConfig</span> dsc <span>=</span> <span>new</span> <span>DataSourceConfig</span><span>(</span><span>)</span><span>;</span>\n        dsc<span>.</span><span>setUrl</span><span>(</span><span>\"jdbc:mysql://localhost:3306/music_recognition?characterEncoding=utf8&amp;useSSL=false&amp;useUnicode=true&amp;serverTimezone=CTT&amp;allowMultiQueries=true\"</span><span>)</span><span>;</span>\n        <span>// dsc.setSchemaName(\"public\");</span>\n        dsc<span>.</span><span>setDbType</span><span>(</span><span>DbType</span><span>.</span>MYSQL<span>)</span><span>;</span>\n        dsc<span>.</span><span>setDriverName</span><span>(</span><span>\"com.mysql.cj.jdbc.Driver\"</span><span>)</span><span>;</span>\n        dsc<span>.</span><span>setUsername</span><span>(</span><span>\"root\"</span><span>)</span><span>;</span>\n        dsc<span>.</span><span>setPassword</span><span>(</span><span>\"root\"</span><span>)</span><span>;</span>\n        mpg<span>.</span><span>setDataSource</span><span>(</span>dsc<span>)</span><span>;</span>\n\n        <span>// 全局配置</span>\n        <span>GlobalConfig</span> gc <span>=</span> <span>new</span> <span>GlobalConfig</span><span>(</span><span>)</span><span>;</span>\n        <span>//输出路径</span>\n        gc<span>.</span><span>setOutputDir</span><span>(</span><span>System</span><span>.</span><span>getProperty</span><span>(</span><span>\"user.dir\"</span> <span>)</span> <span>+</span><span>\"\\\\mybatisGenerator\"</span> <span>+</span> <span>\"/src/main/java\"</span><span>)</span><span>;</span>\n        <span>//      gc.setOutputDir(scanner(\"请输入项目路径\") + \"/src/main/java\");</span>\n        gc<span>.</span><span>setAuthor</span><span>(</span><span>\"v_geekrchen\"</span><span>)</span><span>;</span>\n        <span>//生成之后是否打开资源管理器</span>\n        gc<span>.</span><span>setOpen</span><span>(</span><span>false</span><span>)</span><span>;</span>\n        <span>//重新生成后是否覆盖文件</span>\n        gc<span>.</span><span>setFileOverride</span><span>(</span><span>true</span><span>)</span><span>;</span>\n        <span>//%s为占位符，mp生成Service层代码，默认接口名称第一个字母是有I</span>\n        gc<span>.</span><span>setServiceName</span><span>(</span><span>\"%sService\"</span><span>)</span><span>;</span>\n        <span>//设置主键生成策略 自动增长</span>\n        gc<span>.</span><span>setIdType</span><span>(</span><span>IdType</span><span>.</span>AUTO<span>)</span><span>;</span>\n        <span>//设置Date类型 只使用java.util.date代替</span>\n        gc<span>.</span><span>setDateType</span><span>(</span><span>DateType</span><span>.</span>ONLY_DATE<span>)</span><span>;</span>\n        <span>// 实体属性 Swagger2 注解</span>\n        gc<span>.</span><span>setSwagger2</span><span>(</span><span>true</span><span>)</span><span>;</span>\n        mpg<span>.</span><span>setGlobalConfig</span><span>(</span>gc<span>)</span><span>;</span>\n\n\n        <span>// 包配置</span>\n        <span>PackageConfig</span> pc <span>=</span> <span>new</span> <span>PackageConfig</span><span>(</span><span>)</span><span>;</span>\n        pc<span>.</span><span>setParent</span><span>(</span><span>\"com.tme.musicrecognition\"</span><span>)</span><span>;</span>\n        pc<span>.</span><span>setModuleName</span><span>(</span><span>\"generator\"</span><span>)</span><span>;</span>\n        <span>//        pc.setModuleName(scanner(\"模块名\"));</span>\n        pc<span>.</span><span>setController</span><span>(</span><span>\"controller\"</span><span>)</span><span>;</span>\n        pc<span>.</span><span>setService</span><span>(</span><span>\"service\"</span><span>)</span><span>;</span>\n        pc<span>.</span><span>setServiceImpl</span><span>(</span><span>\"service.impl\"</span><span>)</span><span>;</span>\n        pc<span>.</span><span>setMapper</span><span>(</span><span>\"mapper\"</span><span>)</span><span>;</span>\n        pc<span>.</span><span>setEntity</span><span>(</span><span>\"entity\"</span><span>)</span><span>;</span>\n        mpg<span>.</span><span>setPackageInfo</span><span>(</span>pc<span>)</span><span>;</span>\n\n\n        <span>// 策略配置</span>\n        <span>StrategyConfig</span> strategy <span>=</span> <span>new</span> <span>StrategyConfig</span><span>(</span><span>)</span><span>;</span>\n        strategy<span>.</span><span>setInclude</span><span>(</span><span>scanner</span><span>(</span><span>\"表名，多个英文逗号分割\"</span><span>)</span><span>.</span><span>split</span><span>(</span><span>\",\"</span><span>)</span><span>)</span><span>;</span>\n\n        <span>//实体类名称驼峰命名</span>\n        strategy<span>.</span><span>setNaming</span><span>(</span><span>NamingStrategy</span><span>.</span>underline_to_camel<span>)</span><span>;</span>\n        <span>//字段名称驼峰命名</span>\n        strategy<span>.</span><span>setColumnNaming</span><span>(</span><span>NamingStrategy</span><span>.</span>underline_to_camel<span>)</span><span>;</span>\n        <span>//strategy.setSuperEntityClass(\"你自己的父类实体,没有就不用设置!\");</span>\n        <span>//设置lombok</span>\n        strategy<span>.</span><span>setEntityLombokModel</span><span>(</span><span>true</span><span>)</span><span>;</span>\n        <span>//Controller使用RestController</span>\n        strategy<span>.</span><span>setRestControllerStyle</span><span>(</span><span>true</span><span>)</span><span>;</span>\n        <span>// 公共父类</span>\n        <span>//strategy.setSuperControllerClass(\"你自己的父类控制器,没有就不用设置!\");</span>\n        <span>// 写于父类中的公共字段</span>\n        <span>//strategy.setSuperEntityColumns(\"id\");</span>\n\n        <span>//驼峰转连字符</span>\n        strategy<span>.</span><span>setControllerMappingHyphenStyle</span><span>(</span><span>true</span><span>)</span><span>;</span>\n        <span>//strategy.setTablePrefix(pc.getModuleName() + \"_\");</span>\n        mpg<span>.</span><span>setStrategy</span><span>(</span>strategy<span>)</span><span>;</span>\n        mpg<span>.</span><span>execute</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br><span>111</span><br><span>112</span><br><span>113</span><br><span>114</span><br><span>115</span><br><span>116</span><br><span>117</span><br><span>118</span><br><span>119</span><br><span>120</span><br><span>121</span><br></div></div><p>然后运行即可</p>\n",
      "date_published": "2021-01-10T14:26:01.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": []
    },
    {
      "title": "Nginx-动静分离",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/nginx/Nginx-Dynamic&static/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/nginx/Nginx-Dynamic&static/",
      "content_html": "<h2 id=\"参考\"> 参考</h2>\n<h2 id=\"介绍\"> 介绍</h2>\n<p><img src=\"./images/Nginx-Dynamic&static/dynamic&static.jpg\" alt=\"什么是动静分离\" /></p>\n<p><strong>Nginx 动静分离简单来说就是把动态跟静态请求分开，不能理解成只是单纯的把动态页面和静态页面物理分离</strong>。严格意义上说应该是<code>动态请求</code>跟<code>静态请求</code>分开，可以理解成使用 <code>Nginx</code> 处理<code>静态页面</code>， <code>Tomcat</code> 处理<code>动态页面</code>。动静分离从目前实现角度来讲大致分为两种：</p>\n<div><p>Info</p>\n<ol>\n<li>一种是纯粹把静态文件独立成单独的域名，放在独立的服务器上，也是目前主流推崇的方案；</li>\n<li>另外一种方法就是动态跟静态文件混合在一起发布，通过 nginx 来分开。</li>\n</ol>\n</div>\n<p>通过 location 指定不同的后缀名实现不同的请求转发。通过 <code>expires</code> 参数设置，可以使浏览器缓存过期时间，减少与服务器之前的请求和流量。</p>\n<p>具体 <code>Expires</code> 定义</p>\n<div><p>Expires 定义</p>\n<p>是给一个资源设定一个过期时间，也就是说无需去服务端验证，直接通过浏览器自身确认是否过期即可，所以不会产生额外的流量。<strong>此种方法非常适合不经常变动的资源</strong>。（如果经常更新的文件，不建议使用 Expires 来缓存）</p>\n<p>若将其设置 3d，表示在这 3 天之内访问这个 URL，发送一个请求，比对服务器该文件最后更新时间没有变化，则不会从服务器抓取，返回状态码304，如果有修改，则直接从服务器重新下载，返回状态码 200。</p>\n</div>\n<p>Nginx的并发能力公式：</p>\n<div><p>公式</p>\n<p>worker_processes * worker_connections / 4 | 2 = Nginx最终的并发能力</p>\n</div>\n<p>动态资源需要/4（因为要访问Nginx后面的服务器），静态资源需要/2（直接通过Nginx访问静态资源）</p>\n<p>Nginx通过动静分离来提升Nginx的并发能力，更快的给用户响应</p>\n<h2 id=\"配置\"> 配置</h2>\n<h3 id=\"创建数据卷并映射到docker中\"> 创建数据卷并映射到docker中</h3>\n<p><code>docker-compose.yml</code></p>\n<p>将<code>img</code>和<code>html</code>文件映射</p>\n<div><pre><code><span>version</span><span>:</span> <span>'3.1'</span>\n<span>services</span><span>:</span>\n  <span>nginx</span><span>:</span>\n    <span>restart</span><span>:</span> always\n    <span>image</span><span>:</span> nginx\n    <span>container_name</span><span>:</span> nginx\n    <span>ports</span><span>:</span>\n      <span>-</span> <span>80:80</span>\n    <span>volumes</span><span>:</span>\n      <span>-</span> /usr/local/docker/nginx/conf.d/<span>:</span>/etc/nginx/conf.d\n      <span>-</span> /usr/local/docker/nginx/img/<span>:</span>/data/img\n      <span>-</span> /usr/local/docker/nginx/html/<span>:</span>/data/html\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>根据配置重新加载docker中的nginx</p>\n<div><pre><code><span>docker-compose</span> down\n<span>docker-compose</span> up -d\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h3 id=\"修改配置文件的location映射\"> 修改配置文件的location映射</h3>\n<p>配置如下</p>\n<div><pre><code>location / <span>{</span>\n  root 静态资源路径;\n  index 默认访问路径下的什么资源;\n  autoindex on;#代表展示静态资源的全部内容，以列表的形式展开\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>default.conf</p>\n<div><pre><code>location /html <span>{</span>\n  root /data;\n  index index.html;\n<span>}</span>\n\nlocation /img <span>{</span>\n  root /data;\n  autoindex on;\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id=\"访问\"> 访问</h3>\n<p>访问<code>http://localhost/html/</code>或<code>http://localhost/img/index.html</code>如下</p>\n<p><img src=\"./images/Nginx-Dynamic&static/static_html.jpg\" alt=\"访问\" /></p>\n<p>访问<code>http://localhost/img/</code>如下（localhost替换为自己的服务器），首先要在img文件夹中放入文件</p>\n<p><img src=\"./images/Nginx-Dynamic&static/static-img.jpg\" alt=\"访问\" /></p>\n",
      "date_published": "2021-01-03T00:04:05.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": []
    },
    {
      "title": "Nginx-负载均衡",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/nginx/Nginx-LoadBalance/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/nginx/Nginx-LoadBalance/",
      "content_html": "<h2 id=\"参考\"> 参考</h2>\n<div><p>参考</p>\n<ul>\n<li><a href=\"https://blog.51cto.com/7424593/1744111\" target=\"_blank\" rel=\"noopener noreferrer\">Nginx负载均衡的实现和调度算法</a></li>\n<li><a href=\"https://www.cnblogs.com/canflyfish/p/11580417.html\" target=\"_blank\" rel=\"noopener noreferrer\">Nginx 负载均衡算法</a></li>\n<li><a href=\"https://www.jb51.net/article/173410.htm\" target=\"_blank\" rel=\"noopener noreferrer\">简单了解Nginx七层负载均衡的几种调度算法</a></li>\n</ul>\n</div>\n<h2 id=\"算法\"> 算法</h2>\n<table>\n<thead>\n<tr>\n<th>算法</th>\n<th>介绍</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>round robin（轮询，默认）</td>\n<td>每个请求按<code>时间顺序逐一分配</code>到不同的后端服务，它均衡地对待后端的每一台服务器</td>\n</tr>\n<tr>\n<td>weight（加权值轮询）</td>\n<td>指定轮询几率，weight值(权重)和访问比例成正比，weight的值越大分配到的访问概率越高</td>\n</tr>\n<tr>\n<td>least_conn（最小连接数）</td>\n<td>最小连接数法根据后端服务器当前的连接情况，动态地选取其中当前<code>积压连接数最少</code>的一台服务器来处理当前的请求</td>\n</tr>\n<tr>\n<td>ip_hash</td>\n<td>每个请求按<code>访问IP的哈希结果</code>分配，使来自同一个IP的访客固定访问一台后端服务器，并且可以有效解决动态网页存在的session共享问题。</td>\n</tr>\n<tr>\n<td>fair</td>\n<td>比 weight、ip_hash更加智能的负载均衡算法，fair算法可以根据页面大小和加载时间长短智能地进行负载均衡，也就是根据<code>后端服务器的响应时间</code>来分配请求，<code>响应时间短</code>的优先分配。</td>\n</tr>\n<tr>\n<td>url_hash</td>\n<td>按<code>访问的URL的哈希结果</code>来分配请求，使每个URL定向到一台后端服务器，可以进一步提高后端缓存服务器的效率。</td>\n</tr>\n</tbody>\n</table>\n<div><p>Note</p>\n<p>注意，<code>upstream</code>后面的名称不能带下划线,否则可能引起关键字冲突</p>\n</div>\n<h3 id=\"round-robin-轮询-默认\"> round robin（轮询，默认）</h3>\n<div><p>轮询（默认）</p>\n<p>每个请求按<code>时间顺序逐一分配</code>到不同的后端服务，它均衡地对待后端的每一台服务器，而不关心服务器实际的连接数和当前的系统负载。如果后端某台服务器死机，自动剔除故障系统，使用户访问不受影响。</p>\n<p><strong>适用于</strong>：后端服务器硬件性能配置完全一致，业务无特殊要求时使用</p>\n</div>\n<div><pre><code>upstream backendserver <span>{</span> \n  server <span>192.168</span>.0.14：80 <span>max_fails</span><span>=</span><span>2</span> <span>fail_timeout</span><span>=</span>10s<span>;</span> \n  server <span>192.168</span>.0.15：80 <span>max_fails</span><span>=</span><span>2</span> <span>fail_timeout</span><span>=</span>10s<span>;</span> \n<span>}</span>\n\nlocation / <span>{</span>\n\tproxy_pass http://backendserver/<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id=\"weight-加权值轮询\"> weight（加权值轮询）</h3>\n<div><p>weight（轮询权值）</p>\n<p>指定轮询几率，weight值(权重)和访问比例成正比，weight的值越大分配到的访问概率越高。或者仅仅为在主从的情况下设置不同的权值，达到合理有效的地利用主机资源。</p>\n<p><strong>适用于</strong>：主要用于后端每台服务器性能不均衡的情况下</p>\n</div>\n<div><pre><code>upstream backendserver <span>{</span> \n  server <span>192.168</span>.0.14:80 <span>weight</span><span>=</span><span>5</span> <span>max_fails</span><span>=</span><span>2</span> <span>fail_timeout</span><span>=</span>10s<span>;</span> \n  server <span>192.168</span>.0.15:80 <span>weight</span><span>=</span><span>10</span> <span>max_fails</span><span>=</span><span>2</span> <span>fail_timeout</span><span>=</span>10s<span>;</span>\n<span>}</span>\n\nlocation / <span>{</span>\n\tproxy_pass http://backendserver/<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id=\"least-conn-最小连接数\"> least_conn（最小连接数）</h3>\n<div><p>least_conn</p>\n<p>least_connected 方式可以更公平的将负载分配到多个机器上面。由于后端服务器的配置不尽相同，对于请求的处理有快有慢，最小连接数法根据后端服务器当前的连接情况，动态地选取其中当前积压连接数最少的一台服务器来处理当前的请求，尽可能地提高后端服务的利用效率，将负责合理地分流到每一台服务器。</p>\n<p><strong>适用于</strong>：适用于客户端与后端服务器需要保持长连接的业务</p>\n</div>\n<div><pre><code>upstream backendserver <span>{</span> \n  least_conn<span>;</span>\n  server <span>192.168</span>.0.14:80 <span>max_fails</span><span>=</span><span>2</span> <span>fail_timeout</span><span>=</span>10s<span>;</span> \n  server <span>192.168</span>.0.15:80 <span>max_fails</span><span>=</span><span>2</span> <span>fail_timeout</span><span>=</span>10s<span>;</span> \n<span>}</span> \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id=\"ip-hash\"> ip_hash</h3>\n<div><p>ip_hash</p>\n<p>每个请求按<code>访问IP的哈希结果</code>分配，使来自同一个IP的访客固定访问一台后端服务器，并且可以有效解决动态网页存在的session共享问题。</p>\n<p><strong>适用于</strong>：适用于需要账号登录的系统，会话连接保持的业务</p>\n</div>\n<div><pre><code>upstream backendserver <span>{</span>\n  ip_hash<span>;</span> \n  server <span>192.168</span>.0.14:80 <span>max_fails</span><span>=</span><span>2</span> <span>fail_timeout</span><span>=</span>10s<span>;</span> \n  server <span>192.168</span>.0.15:80 <span>max_fails</span><span>=</span><span>2</span> <span>fail_timeout</span><span>=</span>10s<span>;</span> \n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id=\"fair\"> fair</h3>\n<div><p>fair</p>\n<blockquote>\n<p>需编译安装第三方模块 <code>ngx_http_upstream_fair_module</code></p>\n</blockquote>\n<p>比 weight、ip_hash更加智能的负载均衡算法，fair算法可以根据页面大小和加载时间长短智能地进行负载均衡，也就是根据<code>后端服务器的响应时间</code>来分配请求，响应时间短的优先分配。</p>\n<p><strong>适用于</strong>：对访问响应速度有一定要求的业务。</p>\n</div>\n<div><pre><code>upstream backendserver <span>{</span>\n  fair<span>;</span> \n  server <span>192.168</span>.0.14:80 <span>max_fails</span><span>=</span><span>2</span> <span>fail_timeout</span><span>=</span>10s<span>;</span> \n  server <span>192.168</span>.0.15:80 <span>max_fails</span><span>=</span><span>2</span> <span>fail_timeout</span><span>=</span>10s<span>;</span> \n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id=\"url-hash\"> url_hash</h3>\n<div><p>url_hash</p>\n<blockquote>\n<p>需编译安装第三方模块 <code>ngx_http_upstream_hash_module</code></p>\n</blockquote>\n<p>按<code>访问的URL的哈希结果</code>来分配请求，使每个URL定向到一台后端服务器，可以进一步提高后端缓存服务器的效率。</p>\n<p><strong>适用于</strong>：适用于后端服务器为<code>缓存服务器</code>时比较有效。</p>\n</div>\n<div><pre><code>upstream backendserver <span>{</span> \n  server <span>192.168</span>.0.14:80 <span>max_fails</span><span>=</span><span>2</span> <span>fail_timeout</span><span>=</span>10s<span>;</span>\n  server <span>192.168</span>.0.15:80 <span>max_fails</span><span>=</span><span>2</span> <span>fail_timeout</span><span>=</span>10s<span>;</span> \n  <span>hash</span> <span>$request_uri</span><span>;</span> \n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div>",
      "date_published": "2020-12-25T00:58:57.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": []
    },
    {
      "title": "Nginx-反向代理",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/nginx/Nginx-ReverseProxy/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/nginx/Nginx-ReverseProxy/",
      "content_html": "<h2 id=\"参考\"> 参考</h2>\n<div><p>参考</p>\n<ul>\n<li><a href=\"https://blog.csdn.net/m0_49558851/article/details/107786372\" target=\"_blank\" rel=\"noopener noreferrer\">Nginx学习笔记 基于docker</a></li>\n<li><a href=\"https://www.cnblogs.com/ysocean/p/9392908.html\" target=\"_blank\" rel=\"noopener noreferrer\">Nginx（三）------nginx 反向代理</a></li>\n</ul>\n</div>\n<h2 id=\"_1-介绍\"> 1. 介绍</h2>\n<h3 id=\"_1-1-正向代理\"> 1.1 正向代理</h3>\n<div><p>正向代理</p>\n<p>局域网中的电脑用户想要直接访问网络是不可行的，只能通过代理服务器来访问，这种代理服务就被称为正向代理。</p>\n</div>\n<p>正向代理</p>\n<h3 id=\"_1-2-反向代理\"> 1.2 反向代理</h3>\n<div><p>反向代理</p>\n<p>客户端无法感知代理，因为客户端访问网络不需要配置，只要把请求发送到反向代理服务器，由反向代理服务器去选择目标服务器获取数据，然后再返回到客户端，此时反向代理服务器和目标服务器对外就是一个服务器，暴露的是代理服务器地址，隐藏了真实服务器IP地址。</p>\n<p>Nginx在做反向代理时，提供性能稳定，并且能够提供配置灵活的转发功能。Nginx可以根据不同的正则匹配，采取不同的转发策略，比如图片文件结尾的走文件服务器，动态页面走web服务器，只要你正则写的没问题，又有相对应的服务器解决方案，你就可以随心所欲的玩。并且Nginx对返回结果进行错误页跳转，异常判断等。如果被分发的服务器存在异常，他可以将请求重新转发给另外一台服务器，然后自动去除异常服务器。</p>\n</div>\n<p>反向代理</p>\n<h3 id=\"_1-3-正向代理和反向代理的区别\"> 1.3 正向代理和反向代理的区别</h3>\n<p>两者的区别在于代理的对象不一样</p>\n<div><p>区别</p>\n<p><strong>正向代理是为客户端代理，反向代理是为服务端代理。</strong></p>\n</div>\n<h2 id=\"_2-简单使用\"> 2. 简单使用</h2>\n<p>在<code>location块</code>中设置</p>\n<div><pre><code>proxy_pass http<span>:</span><span>//47.100.59.153:8080/;</span>\n</code></pre>\n<div><span>1</span><br></div></div><div><pre><code>server <span>{</span>\n    listen       <span>80</span>;\n    listen  <span>[</span><span>:</span><span>:</span><span>]</span><span>:</span><span>80</span>;\n    server_name  localhost;\n    \n\t\t#基于反向代理到<span>8080</span>端口的tomcat服务器\n    location / <span>{</span>\n      proxy_pass http<span>:</span><span>//47.100.59.153:8080/;</span>\n    \n    <span>}</span>\n\n#    location / <span>{</span>\n#       root   /usr/share/nginx/html;\n#       index  index.html index.htm;\n#   <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h2 id=\"_3-关于location的路径映射\"> 3. 关于location的路径映射</h2>\n<p>优先级关系：\n(location = ) &gt; (location /xxx/yyy/zzz) &gt; (location ^~) &gt; (location <sub>,</sub>*) &gt; (location /起始路径) &gt; (location /)</p>\n<h3 id=\"_3-1-精准匹配\"> 3.1 精准匹配</h3>\n<div><p>精准匹配</p>\n<div><pre><code># <span>1</span>. = 匹配\nlocation = / <span>{</span>\n\t#精准匹配，主机名后面不能带能和字符串\n\t#例如www.baidu.com不能是www.baidu.com/id=xxx\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div></div>\n<h3 id=\"_3-2-通用匹配\"> 3.2 通用匹配</h3>\n<div><pre><code>#<span>2</span>. 通用匹配\nlocation /xxx <span>{</span>\n  #匹配所有以/xxx开头的路径\n  #例如<span>127.0</span>.<span>0.1</span><span>:</span><span>8080</span>/xxx\txxx可以为空，为空则和=匹配一样\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id=\"_3-3-匹配开头路径\"> 3.3 匹配开头路径</h3>\n<div><pre><code>#<span>4</span>. 匹配开头路径\nlocation ^~ /xxx/xx <span>{</span>\n  #匹配所有以/xxx/xx开头的路径\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id=\"_3-4-正则匹配\"> 3.4 正则匹配</h3>\n<div><pre><code>#<span>3</span>. 正则匹配\nlocation ~ /xxx <span>{</span>\n#匹配所有以/xxx开头的路径\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id=\"_3-5-匹配结尾路径\"> 3.5 匹配结尾路径</h3>\n<div><pre><code>#<span>5</span>. 匹配结尾路径\nlocation ~* \\.(gif/jpg/png)$ <span>{</span>\n  #匹配以.gif、.jpg或者.png结尾的路径\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id=\"_3-6-例子\"> 3.6 例子</h3>\n<p>使用tomcat中的examples为例</p>\n<p><code>default.conf</code></p>\n<div><pre><code>server <span>{</span>\n  listen       <span>80</span>;\n  listen  <span>[</span><span>:</span><span>:</span><span>]</span><span>:</span><span>80</span>;\n\tserver_name  localhost;\n\n\tlocation = /index <span>{</span>\n\t\tproxy_pass http<span>:</span><span>//47.100.59.153:8080/;</span>\n\t<span>}</span>\n\n\tlocation ^~ /examples/ <span>{</span>\n  \tproxy_pass http<span>:</span><span>//47.100.59.153:8080/examples/;</span>\n\t<span>}</span>\n\n\tlocation / <span>{</span>\n  \tproxy_pass http<span>:</span><span>//47.100.59.153:8080/;</span>\n\t<span>}</span>\n\n  #    location / <span>{</span>\n  #       root   /usr/share/nginx/html;\n  #       index  index.html index.htm;\n  #   <span>}</span>\n  error_page   <span>500</span> <span>502</span> <span>503</span> <span>504</span>  /50x.html;\n  location = /50x.html <span>{</span>\n  root   /usr/share/nginx/html;\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><p>在docker-compose.yml的文件下执行命令重启</p>\n<div><pre><code><span>docker-compose</span> restart\n</code></pre>\n<div><span>1</span><br></div></div><h2 id=\"_4-相关配置\"> 4. 相关配置</h2>\n<div><p>参考</p>\n<ul>\n<li><a href=\"https://www.cnblogs.com/ysocean/p/9392908.html\" target=\"_blank\" rel=\"noopener noreferrer\">Nginx（三）------nginx 反向代理</a></li>\n</ul>\n</div>\n",
      "date_published": "2020-12-25T00:57:51.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": []
    },
    {
      "title": "Nginx基础笔记和安装配置",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/nginx/Nginx-basicNote&deployment/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/nginx/Nginx-basicNote&deployment/",
      "content_html": "<h2 id=\"参考\"> 参考</h2>\n<div><p>参考</p>\n<ul>\n<li><a href=\"https://www.w3cschool.cn/nginxsysc/\" target=\"_blank\" rel=\"noopener noreferrer\">W3CSCHOOL-Nginx使用手册</a></li>\n<li><a href=\"https://blog.csdn.net/m0_49558851/article/details/107786372\" target=\"_blank\" rel=\"noopener noreferrer\">Nginx学习笔记 基于docker</a></li>\n<li><a href=\"https://www.jianshu.com/p/e90050dc89b6\" target=\"_blank\" rel=\"noopener noreferrer\">当初我要是这么学习Nginx就好了！多图详解</a></li>\n<li><a href=\"https://blog.csdn.net/yujing1314/article/details/107000737\" target=\"_blank\" rel=\"noopener noreferrer\">搞懂Nginx一篇文章就够了</a></li>\n<li><a href=\"https://www.runoob.com/w3cnote/nginx-setup-intro.html\" target=\"_blank\" rel=\"noopener noreferrer\">Nginx 配置详解</a></li>\n<li><a href=\"https://www.nginx.cn/nginx-how-to\" target=\"_blank\" rel=\"noopener noreferrer\">nginx中文手册</a></li>\n</ul>\n</div>\n<h2 id=\"介绍\"> 介绍</h2>\n<p>Nginx (engine x) 是一个高性能的 <code>Web 服务器</code>和<code>反向代理服务器</code>，也是一个 IMAP/POP3/SMTP 服务器：</p>\n<p>Nginx是一款轻量级的高性能web服务器，同时也是一款非常优秀的负载均衡器和反向代理服务器。由于支持强大的正则匹配规则、动静分离、URLrewrite功能及安装配置简单且对网络稳定性依赖非常小等优点，所以常用来做为七层负载均衡使用。在硬件不差的情况下，通常可以稳定支持几万的并发连接，在硬件性能足够好，且对系统内核参数及Nginx配置进行优化甚至可以达到10万以上的并发。</p>\n<p><img src=\"./images/Nginx-basicNote&deployment/Nginx_knowledge_diagram.png\" alt=\"学习路线图\" /></p>\n<h2 id=\"特点\"> 特点</h2>\n<div><p>特点</p>\n<ul>\n<li><strong>反向代理，负载均衡器</strong></li>\n<li><strong>高可靠性、单 Master 多 Worker 模式</strong></li>\n<li><strong>高可扩展性、高度模块化</strong></li>\n<li><strong>非阻塞</strong></li>\n<li><strong>事件驱动</strong></li>\n<li><strong>低内存消耗</strong></li>\n<li><strong>热部署</strong></li>\n</ul>\n</div>\n<h2 id=\"应用场景\"> 应用场景</h2>\n<div><p>应用场景</p>\n<ul>\n<li><strong>静态文件服务器</strong></li>\n<li><strong>反向代理，负载均衡</strong></li>\n<li><strong>安全防御</strong></li>\n<li><strong>智能路由（企业级灰度测试、地图 POI 一键切流）</strong></li>\n<li><strong>灰度发布</strong></li>\n<li><strong>静态化</strong></li>\n<li><strong>消息推送</strong></li>\n<li><strong>图片实时压缩</strong></li>\n<li><strong>防盗链</strong></li>\n</ul>\n</div>\n<h2 id=\"安装-docker安装\"> 安装（Docker安装）</h2>\n<div><p>参考</p>\n<p><a href=\"https://www.runoob.com/docker/docker-install-nginx.html\" target=\"_blank\" rel=\"noopener noreferrer\">Docker 安装 Nginx</a></p>\n</div>\n<h3 id=\"第一种-直接docker安装\"> 第一种：直接docker安装</h3>\n<h4 id=\"拉取镜像\"> 拉取镜像</h4>\n<div><p>Tips</p>\n<ul>\n<li>https://hub.docker.com/_/nginx?tab=tags</li>\n</ul>\n</div>\n<div><pre><code><span>docker</span> pull nginx:latest\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"启动容器\"> 启动容器</h4>\n<div><pre><code>docker run <span>--</span>name nginx <span>-</span>p <span>80</span><span>:</span><span>80</span> <span>-</span>d nginx\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"修改配置文件\"> 修改配置文件</h4>\n<p>配置文件存放路径：<code>/etc/nginx/nginx.conf</code></p>\n<p>修改后重启容器即可</p>\n<h3 id=\"第二种-使用docker-compose\"> 第二种：使用docker-compose</h3>\n<p>在<code>/usr/local/docker/nginx/</code>配置好<code>docker-compose.yml</code>，并将<code>/etc/nginx/conf.d</code>下的配置文件映射</p>\n<div><pre><code><span>version</span><span>:</span> <span>'3.1'</span>\n<span>services</span><span>:</span>\n  <span>nginx</span><span>:</span>\n    <span>restart</span><span>:</span> always\n    <span>image</span><span>:</span> nginx\n    <span>container_name</span><span>:</span> nginx\n    <span>ports</span><span>:</span>\n      <span>-</span> <span>80:80</span>\n    <span>volumes</span><span>:</span>\n      <span>-</span> /usr/local/docker/nginx/conf.d/<span>:</span>/etc/nginx/conf.d\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>下载<code>docker-compose</code></p>\n<div><pre><code><span>sudo</span> <span>curl</span> -L https://github.com/docker/compose/releases/download/1.16.1/docker-compose-<span><span>`</span><span>uname</span> -s<span>`</span></span>-<span><span>`</span><span>uname</span> -m<span>`</span></span> -o /usr/local/bin/docker-compose\n<span>#或</span>\n<span>sudo</span> <span>curl</span> -L https://get.daocloud.io/docker/compose/releases/download/1.25.1/docker-compose-<span><span>`</span><span>uname</span> -s<span>`</span></span>-<span><span>`</span><span>uname</span> -m<span>`</span></span> -o /usr/local/bin/docker-compose\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>添加可执行权限</p>\n<div><pre><code><span>sudo</span> <span>chmod</span> +x /usr/local/bin/docker-compose\n</code></pre>\n<div><span>1</span><br></div></div><p>在<code>/usr/local/docker/nginx/conf.d/</code>下创建<code>default.conf</code>并配置</p>\n<div><pre><code>server <span>{</span>\n    listen       <span>80</span><span>;</span>\n    listen  <span>[</span>::<span>]</span>:80<span>;</span>\n    server_name  localhost<span>;</span>\n\n    location / <span>{</span>\n        root   /usr/share/nginx/html<span>;</span>\n        index  index.html index.htm<span>;</span>\n    <span>}</span>\n    error_page   <span>500</span> <span>502</span> <span>503</span> <span>504</span>  /50x.html<span>;</span>\n    location <span>=</span> /50x.html <span>{</span>\n        root   /usr/share/nginx/html<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>运行<code>docker-compose.yml</code></p>\n<div><pre><code><span>docker-compose</span> up -d\n</code></pre>\n<div><span>1</span><br></div></div><h2 id=\"nginx配置文件\"> Nginx配置文件</h2>\n<div><p>参考</p>\n<ul>\n<li><a href=\"https://www.nginx.cn/76.html\" target=\"_blank\" rel=\"noopener noreferrer\">nginx基本配置与参数说明</a></li>\n<li>https://www.cnblogs.com/panchanggui/p/12067953.html</li>\n</ul>\n</div>\n<p><img src=\"./images/Nginx-basicNote&deployment/The_overall_structure_of_the_nginx_configuration_file.jpg\" alt=\"nginx配置文件的整体结构\" /></p>\n<table>\n<thead>\n<tr>\n<th>文件块</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>全局块</td>\n<td>配置影响nginx全局的指令。一般有运行nginx服务器的用户组，nginx进程pid存放路径，日志存放路径，配置文件引入，允许生成<code>worker process</code>数等。</td>\n</tr>\n<tr>\n<td>events</td>\n<td>配置影响nginx<code>服务器或与用户的网络连接</code>。<code>每个进程的最大连接数</code>，<code>选取哪种事件驱动模型处理连接请求</code>，<code>是否允许同时接受多个网路连接</code>，<code>开启多个网络连接序列化</code>等</td>\n</tr>\n<tr>\n<td>http</td>\n<td>可以嵌套多个server，配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置。如文件引入，mime-type定义，日志自定义，是否使用sendfile传输文件，连接超时时间，单连接请求数等。</td>\n</tr>\n<tr>\n<td>server</td>\n<td>配置<code>虚拟主机的相关参数</code>，一个http中可以有多个server。</td>\n</tr>\n<tr>\n<td>location</td>\n<td>配置<code>请求的路由</code>，以及<code>各种页面的处理情况</code>。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"全局块\"> 全局块</h3>\n<blockquote>\n<p>配置影响nginx全局的指令</p>\n</blockquote>\n<div><p>配置项</p>\n<ul>\n<li>错误日志的存放路径</li>\n<li>Nginx进程PID存放路径</li>\n<li>配置运行Nginx服务器用户（组）</li>\n<li>允许生成<code>worker process</code>数</li>\n<li>配置文件的引入</li>\n</ul>\n</div>\n<div><pre><code><span># 以下统称为全局块</span>\n<span># error_log代表Nginx错误日志存放的位置</span>\n<span># pid是Nginx运行的一个标识</span>\n\nuser  nginx<span>;</span>\nworker_processes  <span>1</span><span>;</span>\nerror_log  /var/log/nginx/error.log warn<span>;</span>\npid        /var/run/nginx.pid<span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id=\"events块\"> events块</h3>\n<blockquote>\n<p>该部分配置主要影响Nginx服务器与用户的网络连接</p>\n</blockquote>\n<div><p>配置项</p>\n<ul>\n<li>每个进程的最大连接数</li>\n<li>选取哪种事件驱动模型处理连接请求</li>\n<li>是否允许同时接受多个网路连接</li>\n<li>开启多个<code>网络连接序列化</code></li>\n</ul>\n</div>\n<div><pre><code><span># events块</span>\n<span># worker_connections的数值越大，Nginx的并发能力就越强</span>\nevents <span>{</span>\n    worker_connections  <span>1024</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id=\"http块\"> http块</h3>\n<blockquote>\n<p>可以嵌套多个server，配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置</p>\n</blockquote>\n<div><p>配置项</p>\n<ul>\n<li>定义MIMI-Type</li>\n<li>自定义服务日志</li>\n<li>允许sendfile方式传输文件</li>\n<li>连接超时时间</li>\n<li>单连接请求数上限</li>\n</ul>\n</div>\n<div><pre><code><span># http块</span>\n<span># include代表引入一个外部文件</span>\n<span># include       /etc/nginx/mime.types;\tmime.types中存放着大量媒体类型</span>\n<span>#include /etc/nginx/conf.d/*.conf;\t引入了conf.d下以.conf为结尾的配置文件</span>\n\nhttp <span>{</span>\n    include       /etc/nginx/mime.types<span>;</span>\n    default_type  application/octet-stream<span>;</span>\n\n    log_format  main  <span>'$remote_addr - $remote_user [$time_local] \"$request\" '</span>\n                      <span>'$status $body_bytes_sent \"$http_referer\" '</span>\n                      <span>'\"$http_user_agent\" \"$http_x_forwarded_for\"'</span><span>;</span>\n\n    access_log  /var/log/nginx/access.log  main<span>;</span>\n\n    sendfile        on<span>;</span>\n    <span>#tcp_nopush     on;</span>\n\n    keepalive_timeout  <span>65</span><span>;</span>\n\n    <span>#gzip  on;</span>\n\n    include /etc/nginx/conf.d/*.conf<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><h3 id=\"server块\"> server块</h3>\n<blockquote>\n<p>配置<code>虚拟主机的相关参数</code></p>\n</blockquote>\n<div><p>配置项</p>\n<ul>\n<li>配置网络监听</li>\n<li>基于名称的虚拟主机配置</li>\n<li>基于IP的虚拟主机配置</li>\n</ul>\n</div>\n<h3 id=\"location块\"> location块</h3>\n<blockquote>\n<p>配置<code>请求的路由</code>，以及<code>各种页面的处理情况</code>。</p>\n</blockquote>\n<div><p>配置项</p>\n<ul>\n<li>请求根目录配置</li>\n<li>更改location的URI</li>\n<li>网站默认首页配置</li>\n</ul>\n</div>\n<h3 id=\"nginx-conf\"> nginx.conf</h3>\n<p><img src=\"./images/Nginx-basicNote&deployment/Nginx_configuration_examples.jpg\" alt=\"nginx配置举例\" /></p>\n<p><strong><code>nginx.conf</code>默认配置示例</strong></p>\n\n          <div\n            id=\"code-demo-061fb844\"\n           \n  \n data-title=\"nginx.conf%E9%BB%98%E8%AE%A4%E9%85%8D%E7%BD%AE%E7%A4%BA%E4%BE%8B\"\n\n            data-code=\"%7B%22bash%22%3A%22%23%20%E4%BB%A5%E4%B8%8B%E7%BB%9F%E7%A7%B0%E4%B8%BA%E5%85%A8%E5%B1%80%E5%9D%97%5Cn%5Cn%23%E5%AE%9A%E4%B9%89Nginx%E8%BF%90%E8%A1%8C%E7%9A%84%E7%94%A8%E6%88%B7%E5%92%8C%E7%94%A8%E6%88%B7%E7%BB%84%5Cnuser%20%20nginx%3B%5Cn%5Cn%23nginx%E8%BF%9B%E7%A8%8B%E6%95%B0%EF%BC%8C%E5%BB%BA%E8%AE%AE%E8%AE%BE%E7%BD%AE%E4%B8%BA%E7%AD%89%E4%BA%8ECPU%E6%80%BB%E6%A0%B8%E5%BF%83%E6%95%B0%E3%80%82%5Cnworker_processes%20%201%3B%5Cn%5Cn%23%E5%85%A8%E5%B1%80%E9%94%99%E8%AF%AF%E6%97%A5%E5%BF%97%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%EF%BC%8C%5B%20debug%20%7C%20info%20%7C%20notice%20%7C%20warn%20%7C%20error%20%7C%20crit%20%5D%5Cnerror_log%20%20%2Fvar%2Flog%2Fnginx%2Ferror.log%20warn%3B%5Cn%5Cn%23%E8%BF%9B%E7%A8%8Bpid%E6%96%87%E4%BB%B6%5Cnpid%20%20%20%20%20%20%20%20%2Fvar%2Frun%2Fnginx.pid%3B%5Cn%5Cn%5Cn%5Cn%5Cn%23%20events%E5%9D%97%5Cn%23%20worker_connections%E7%9A%84%E6%95%B0%E5%80%BC%E8%B6%8A%E5%A4%A7%EF%BC%8CNginx%E7%9A%84%E5%B9%B6%E5%8F%91%E8%83%BD%E5%8A%9B%E5%B0%B1%E8%B6%8A%E5%BC%BA%5Cn%5Cnevents%20%7B%5Cn%20%20%20%20worker_connections%20%201024%3B%5Cn%7D%5Cn%5Cn%5Cn%5Cn%5Cn%23%20http%E5%9D%97%5Cn%23%20include%E4%BB%A3%E8%A1%A8%E5%BC%95%E5%85%A5%E4%B8%80%E4%B8%AA%E5%A4%96%E9%83%A8%E6%96%87%E4%BB%B6%5Cn%23%20include%20%20%20%20%20%20%20%2Fetc%2Fnginx%2Fmime.types%3B%5Ctmime.types%E4%B8%AD%E5%AD%98%E6%94%BE%E7%9D%80%E5%A4%A7%E9%87%8F%E5%AA%92%E4%BD%93%E7%B1%BB%E5%9E%8B%5Cn%23%20include%20%2Fetc%2Fnginx%2Fconf.d%2F*.conf%3B%5Ct%E5%BC%95%E5%85%A5%E4%BA%86conf.d%E4%B8%8B%E4%BB%A5.conf%E4%B8%BA%E7%BB%93%E5%B0%BE%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%5Cn%5Cnhttp%20%7B%5Cn%20%20%20%20include%20%20%20%20%20%20%20%2Fetc%2Fnginx%2Fmime.types%3B%5Cn%20%20%20%20default_type%20%20application%2Foctet-stream%3B%5Cn%5Cn%20%20%20%20log_format%20%20main%20%20'%24remote_addr%20-%20%24remote_user%20%5B%24time_local%5D%20%5C%22%24request%5C%22%20'%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20'%24status%20%24body_bytes_sent%20%5C%22%24http_referer%5C%22%20'%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20'%5C%22%24http_user_agent%5C%22%20%5C%22%24http_x_forwarded_for%5C%22'%3B%5Cn%5Cn%20%20%20%20access_log%20%20%2Fvar%2Flog%2Fnginx%2Faccess.log%20%20main%3B%5Cn%5Cn%20%20%20%20sendfile%20%20%20%20%20%20%20%20on%3B%5Cn%20%20%20%20%23tcp_nopush%20%20%20%20%20on%3B%5Cn%5Cn%20%20%20%20keepalive_timeout%20%2065%3B%5Cn%5Cn%20%20%20%20%23gzip%20%20on%3B%5Cn%5Cn%20%20%20%20%23include%20%2Fetc%2Fnginx%2Fconf.d%2F*.conf%3B%5Cn%20%20%20%20%23%20server%E5%9D%97%5Cn%5Ct%5Ct%23%20listen%E4%BB%A3%E8%A1%A8Nginx%E7%9B%91%E5%90%AC%E7%9A%84%E7%AB%AF%E5%8F%A3%E5%8F%B7%5Cn%5Ct%5Ct%23%20server_name%E4%BB%A3%E8%A1%A8Nginx%E6%8E%A5%E5%8F%97%E8%AF%B7%E6%B1%82%E7%9A%84IP%5Cn%5Ctserver%20%7B%5Cn%20%20%20%20%5Ctlisten%20%20%20%20%20%20%2080%3B%5Cn%20%20%20%20%5Ctlisten%20%20%5B%3A%3A%5D%3A80%3B%5Cn%20%20%20%20%5Ctserver_name%20%20localhost%3B%5Cn%5Cn%20%20%20%20%5Ct%23charset%20koi8-r%3B%5Cn%20%20%20%20%5Ct%23access_log%20%20%2Fvar%2Flog%2Fnginx%2Fhost.access.log%20%20main%3B%5Cn%5Cn%5Cn%20%20%20%20%5Ct%23location%E5%9D%97%5Cn%20%20%20%20%5Ct%23%20root%3A%E5%B0%86%E6%8E%A5%E5%8F%97%E5%88%B0%E7%9A%84%E8%AF%B7%E6%B1%82%E6%A0%B9%E6%8D%AE%2Fusr%2Fshare%2Fnginx%2Fhtml%E5%8E%BB%E6%9F%A5%E6%89%BE%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%5Cn%20%20%20%20%5Ct%23%20index%3A%E9%BB%98%E8%AE%A4%E5%8E%BB%E4%B8%8A%E8%BF%B0%E7%9A%84%E8%B7%AF%E5%BE%84%E4%B8%AD%E6%89%BE%E5%88%B0index.html%E6%88%96index.htm%5Cn%20%20%20%20%5Ctlocation%20%2F%20%7B%5Cn%20%20%20%20%20%20%20%20%5Ctroot%20%20%20%2Fusr%2Fshare%2Fnginx%2Fhtml%3B%5Cn%20%20%20%20%20%20%20%20%5Ctindex%20%20index.html%20index.htm%3B%5Cn%20%20%20%20%5Ct%7D%5Cn%5Cn%20%20%20%20%5Ct%23error_page%20%20404%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F404.html%3B%5Cn%5Cn%20%20%20%20%5Ct%23%20redirect%20server%20error%20pages%20to%20the%20static%20page%20%2F50x.html%5Cn%20%20%20%20%5Ct%23%5Cn%20%20%20%20%5Cterror_page%20%20%20500%20502%20503%20504%20%20%2F50x.html%3B%5Cn%20%20%20%20%5Ctlocation%20%3D%20%2F50x.html%20%7B%5Cn%20%20%20%20%20%20%20%20%5Ctroot%20%20%20%2Fusr%2Fshare%2Fnginx%2Fhtml%3B%5Cn%20%20%20%20%5Ct%7D%5Cn%5Ct%5Ct%7D%5Cn%7D%5Cn%22%7D\"\n          >\n              \n              <div>\n                <div>\n<div><pre><code><span># 以下统称为全局块</span>\n\n<span>#定义Nginx运行的用户和用户组</span>\nuser  nginx<span>;</span>\n\n<span>#nginx进程数，建议设置为等于CPU总核心数。</span>\nworker_processes  <span>1</span><span>;</span>\n\n<span>#全局错误日志定义类型，[ debug | info | notice | warn | error | crit ]</span>\nerror_log  /var/log/nginx/error.log warn<span>;</span>\n\n<span>#进程pid文件</span>\npid        /var/run/nginx.pid<span>;</span>\n\n\n\n\n<span># events块</span>\n<span># worker_connections的数值越大，Nginx的并发能力就越强</span>\n\nevents <span>{</span>\n    worker_connections  <span>1024</span><span>;</span>\n<span>}</span>\n\n\n\n\n<span># http块</span>\n<span># include代表引入一个外部文件</span>\n<span># include       /etc/nginx/mime.types;\tmime.types中存放着大量媒体类型</span>\n<span># include /etc/nginx/conf.d/*.conf;\t引入了conf.d下以.conf为结尾的配置文件</span>\n\nhttp <span>{</span>\n    include       /etc/nginx/mime.types<span>;</span>\n    default_type  application/octet-stream<span>;</span>\n\n    log_format  main  <span>'$remote_addr - $remote_user [$time_local] \"$request\" '</span>\n                      <span>'$status $body_bytes_sent \"$http_referer\" '</span>\n                      <span>'\"$http_user_agent\" \"$http_x_forwarded_for\"'</span><span>;</span>\n\n    access_log  /var/log/nginx/access.log  main<span>;</span>\n\n    sendfile        on<span>;</span>\n    <span>#tcp_nopush     on;</span>\n\n    keepalive_timeout  <span>65</span><span>;</span>\n\n    <span>#gzip  on;</span>\n\n    <span>#include /etc/nginx/conf.d/*.conf;</span>\n    <span># server块</span>\n\t\t<span># listen代表Nginx监听的端口号</span>\n\t\t<span># server_name代表Nginx接受请求的IP</span>\n\tserver <span>{</span>\n    \tlisten       <span>80</span><span>;</span>\n    \tlisten  <span>[</span>::<span>]</span>:80<span>;</span>\n    \tserver_name  localhost<span>;</span>\n\n    \t<span>#charset koi8-r;</span>\n    \t<span>#access_log  /var/log/nginx/host.access.log  main;</span>\n\n\n    \t<span>#location块</span>\n    \t<span># root:将接受到的请求根据/usr/share/nginx/html去查找静态资源</span>\n    \t<span># index:默认去上述的路径中找到index.html或index.htm</span>\n    \tlocation / <span>{</span>\n        \troot   /usr/share/nginx/html<span>;</span>\n        \tindex  index.html index.htm<span>;</span>\n    \t<span>}</span>\n\n    \t<span>#error_page  404              /404.html;</span>\n\n    \t<span># redirect server error pages to the static page /50x.html</span>\n    \t<span>#</span>\n    \terror_page   <span>500</span> <span>502</span> <span>503</span> <span>504</span>  /50x.html<span>;</span>\n    \tlocation <span>=</span> /50x.html <span>{</span>\n        \troot   /usr/share/nginx/html<span>;</span>\n    \t<span>}</span>\n\t\t<span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br></div></div>\n            </div>\n          </div>\n          \n        </div>\n<p><strong><code>nginx.conf</code>详细配置示例</strong></p>\n\n          <div\n            id=\"code-demo-12f871a1\"\n           \n  \n data-title=\"nginx.conf%E8%AF%A6%E7%BB%86%E9%85%8D%E7%BD%AE%E7%A4%BA%E4%BE%8B\"\n\n            data-code=\"%7B%22bash%22%3A%22%23%23%23%23%23%23Nginx%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6nginx.conf%E4%B8%AD%E6%96%87%E8%AF%A6%E8%A7%A3%23%23%23%23%23%5Cn%20%5Cn%23%E5%AE%9A%E4%B9%89Nginx%E8%BF%90%E8%A1%8C%E7%9A%84%E7%94%A8%E6%88%B7%E5%92%8C%E7%94%A8%E6%88%B7%E7%BB%84%5Cnuser%20www%20www%3B%5Cn%20%5Cn%23nginx%E8%BF%9B%E7%A8%8B%E6%95%B0%EF%BC%8C%E5%BB%BA%E8%AE%AE%E8%AE%BE%E7%BD%AE%E4%B8%BA%E7%AD%89%E4%BA%8ECPU%E6%80%BB%E6%A0%B8%E5%BF%83%E6%95%B0%E3%80%82%5Cnworker_processes%208%3B%5Cn%20%20%5Cn%23%E5%85%A8%E5%B1%80%E9%94%99%E8%AF%AF%E6%97%A5%E5%BF%97%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%EF%BC%8C%5B%20debug%20%7C%20info%20%7C%20notice%20%7C%20warn%20%7C%20error%20%7C%20crit%20%5D%5Cnerror_log%20%2Fusr%2Flocal%2Fnginx%2Flogs%2Ferror.log%20info%3B%5Cn%20%5Cn%23%E8%BF%9B%E7%A8%8Bpid%E6%96%87%E4%BB%B6%5Cnpid%20%2Fusr%2Flocal%2Fnginx%2Flogs%2Fnginx.pid%3B%5Cn%20%5Cn%23%E6%8C%87%E5%AE%9A%E8%BF%9B%E7%A8%8B%E5%8F%AF%E4%BB%A5%E6%89%93%E5%BC%80%E7%9A%84%E6%9C%80%E5%A4%A7%E6%8F%8F%E8%BF%B0%E7%AC%A6%EF%BC%9A%E6%95%B0%E7%9B%AE%5Cn%23%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%E4%B8%8E%E8%BF%9E%E6%8E%A5%E6%95%B0%E4%B8%8A%E9%99%90%5Cn%23%E8%BF%99%E4%B8%AA%E6%8C%87%E4%BB%A4%E6%98%AF%E6%8C%87%E5%BD%93%E4%B8%80%E4%B8%AAnginx%E8%BF%9B%E7%A8%8B%E6%89%93%E5%BC%80%E7%9A%84%E6%9C%80%E5%A4%9A%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E6%95%B0%E7%9B%AE%EF%BC%8C%E7%90%86%E8%AE%BA%E5%80%BC%E5%BA%94%E8%AF%A5%E6%98%AF%E6%9C%80%E5%A4%9A%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E6%95%B0%EF%BC%88ulimit%20-n%EF%BC%89%E4%B8%8Enginx%E8%BF%9B%E7%A8%8B%E6%95%B0%E7%9B%B8%E9%99%A4%EF%BC%8C%E4%BD%86%E6%98%AFnginx%E5%88%86%E9%85%8D%E8%AF%B7%E6%B1%82%E5%B9%B6%E4%B8%8D%E6%98%AF%E9%82%A3%E4%B9%88%E5%9D%87%E5%8C%80%EF%BC%8C%E6%89%80%E4%BB%A5%E6%9C%80%E5%A5%BD%E4%B8%8Eulimit%20-n%20%E7%9A%84%E5%80%BC%E4%BF%9D%E6%8C%81%E4%B8%80%E8%87%B4%E3%80%82%5Cn%23%E7%8E%B0%E5%9C%A8%E5%9C%A8linux%202.6%E5%86%85%E6%A0%B8%E4%B8%8B%E5%BC%80%E5%90%AF%E6%96%87%E4%BB%B6%E6%89%93%E5%BC%80%E6%95%B0%E4%B8%BA65535%EF%BC%8Cworker_rlimit_nofile%E5%B0%B1%E7%9B%B8%E5%BA%94%E5%BA%94%E8%AF%A5%E5%A1%AB%E5%86%9965535%E3%80%82%5Cn%23%E8%BF%99%E6%98%AF%E5%9B%A0%E4%B8%BAnginx%E8%B0%83%E5%BA%A6%E6%97%B6%E5%88%86%E9%85%8D%E8%AF%B7%E6%B1%82%E5%88%B0%E8%BF%9B%E7%A8%8B%E5%B9%B6%E4%B8%8D%E6%98%AF%E9%82%A3%E4%B9%88%E7%9A%84%E5%9D%87%E8%A1%A1%EF%BC%8C%E6%89%80%E4%BB%A5%E5%81%87%E5%A6%82%E5%A1%AB%E5%86%9910240%EF%BC%8C%E6%80%BB%E5%B9%B6%E5%8F%91%E9%87%8F%E8%BE%BE%E5%88%B03-4%E4%B8%87%E6%97%B6%E5%B0%B1%E6%9C%89%E8%BF%9B%E7%A8%8B%E5%8F%AF%E8%83%BD%E8%B6%85%E8%BF%8710240%E4%BA%86%EF%BC%8C%E8%BF%99%E6%97%B6%E4%BC%9A%E8%BF%94%E5%9B%9E502%E9%94%99%E8%AF%AF%E3%80%82%5Cnworker_rlimit_nofile%2065535%3B%5Cn%20%5Cnevents%5Cn%7B%5Cn%20%20%20%20%23%E5%8F%82%E8%80%83%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B%EF%BC%8Cuse%20%5B%20kqueue%20%7C%20rtsig%20%7C%20epoll%20%7C%20%2Fdev%2Fpoll%20%7C%20select%20%7C%20poll%20%5D%3B%20epoll%E6%A8%A1%E5%9E%8B%5Cn%20%20%20%20%23%E6%98%AFLinux%202.6%E4%BB%A5%E4%B8%8A%E7%89%88%E6%9C%AC%E5%86%85%E6%A0%B8%E4%B8%AD%E7%9A%84%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9CI%2FO%E6%A8%A1%E5%9E%8B%EF%BC%8Clinux%E5%BB%BA%E8%AE%AEepoll%EF%BC%8C%E5%A6%82%E6%9E%9C%E8%B7%91%E5%9C%A8FreeBSD%E4%B8%8A%E9%9D%A2%EF%BC%8C%E5%B0%B1%E7%94%A8kqueue%E6%A8%A1%E5%9E%8B%E3%80%82%5Cn%20%20%20%20%23%E8%A1%A5%E5%85%85%E8%AF%B4%E6%98%8E%EF%BC%9A%5Cn%20%20%20%20%23%E4%B8%8Eapache%E7%9B%B8%E7%B1%BB%EF%BC%8Cnginx%E9%92%88%E5%AF%B9%E4%B8%8D%E5%90%8C%E7%9A%84%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%8C%E6%9C%89%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B%5Cn%20%20%20%20%23A%EF%BC%89%E6%A0%87%E5%87%86%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B%5Cn%20%20%20%20%23Select%E3%80%81poll%E5%B1%9E%E4%BA%8E%E6%A0%87%E5%87%86%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%BD%93%E5%89%8D%E7%B3%BB%E7%BB%9F%E4%B8%8D%E5%AD%98%E5%9C%A8%E6%9B%B4%E6%9C%89%E6%95%88%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%8Cnginx%E4%BC%9A%E9%80%89%E6%8B%A9select%E6%88%96poll%5Cn%20%20%20%20%23B%EF%BC%89%E9%AB%98%E6%95%88%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B%5Cn%20%20%20%20%23Kqueue%EF%BC%9A%E4%BD%BF%E7%94%A8%E4%BA%8EFreeBSD%204.1%2B%2C%20OpenBSD%202.9%2B%2C%20NetBSD%202.0%20%E5%92%8C%20MacOS%20X.%E4%BD%BF%E7%94%A8%E5%8F%8C%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84MacOS%20X%E7%B3%BB%E7%BB%9F%E4%BD%BF%E7%94%A8kqueue%E5%8F%AF%E8%83%BD%E4%BC%9A%E9%80%A0%E6%88%90%E5%86%85%E6%A0%B8%E5%B4%A9%E6%BA%83%E3%80%82%5Cn%20%20%20%20%23Epoll%EF%BC%9A%E4%BD%BF%E7%94%A8%E4%BA%8ELinux%E5%86%85%E6%A0%B82.6%E7%89%88%E6%9C%AC%E5%8F%8A%E4%BB%A5%E5%90%8E%E7%9A%84%E7%B3%BB%E7%BB%9F%E3%80%82%5Cn%20%20%20%20%23%2Fdev%2Fpoll%EF%BC%9A%E4%BD%BF%E7%94%A8%E4%BA%8ESolaris%207%2011%2F99%2B%EF%BC%8CHP%2FUX%2011.22%2B%20(eventport)%EF%BC%8CIRIX%206.5.15%2B%20%E5%92%8C%20Tru64%20UNIX%205.1A%2B%E3%80%82%5Cn%20%20%20%20%23Eventport%EF%BC%9A%E4%BD%BF%E7%94%A8%E4%BA%8ESolaris%2010%E3%80%82%20%E4%B8%BA%E4%BA%86%E9%98%B2%E6%AD%A2%E5%87%BA%E7%8E%B0%E5%86%85%E6%A0%B8%E5%B4%A9%E6%BA%83%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%8C%20%E6%9C%89%E5%BF%85%E8%A6%81%E5%AE%89%E8%A3%85%E5%AE%89%E5%85%A8%E8%A1%A5%E4%B8%81%E3%80%82%5Cn%20%20%20%20use%20epoll%3B%5Cn%20%5Cn%20%20%20%20%23%E5%8D%95%E4%B8%AA%E8%BF%9B%E7%A8%8B%E6%9C%80%E5%A4%A7%E8%BF%9E%E6%8E%A5%E6%95%B0%EF%BC%88%E6%9C%80%E5%A4%A7%E8%BF%9E%E6%8E%A5%E6%95%B0%3D%E8%BF%9E%E6%8E%A5%E6%95%B0*%E8%BF%9B%E7%A8%8B%E6%95%B0%EF%BC%89%5Cn%20%20%20%20%23%E6%A0%B9%E6%8D%AE%E7%A1%AC%E4%BB%B6%E8%B0%83%E6%95%B4%EF%BC%8C%E5%92%8C%E5%89%8D%E9%9D%A2%E5%B7%A5%E4%BD%9C%E8%BF%9B%E7%A8%8B%E9%85%8D%E5%90%88%E8%B5%B7%E6%9D%A5%E7%94%A8%EF%BC%8C%E5%B0%BD%E9%87%8F%E5%A4%A7%EF%BC%8C%E4%BD%86%E6%98%AF%E5%88%AB%E6%8A%8Acpu%E8%B7%91%E5%88%B0100%25%E5%B0%B1%E8%A1%8C%E3%80%82%E6%AF%8F%E4%B8%AA%E8%BF%9B%E7%A8%8B%E5%85%81%E8%AE%B8%E7%9A%84%E6%9C%80%E5%A4%9A%E8%BF%9E%E6%8E%A5%E6%95%B0%EF%BC%8C%E7%90%86%E8%AE%BA%E4%B8%8A%E6%AF%8F%E5%8F%B0nginx%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E8%BF%9E%E6%8E%A5%E6%95%B0%E4%B8%BA%E3%80%82%5Cn%20%20%20%20worker_connections%2065535%3B%5Cn%20%5Cn%20%20%20%20%23keepalive%E8%B6%85%E6%97%B6%E6%97%B6%E9%97%B4%E3%80%82%5Cn%20%20%20%20keepalive_timeout%2060%3B%5Cn%20%5Cn%20%20%20%20%23%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AF%B7%E6%B1%82%E5%A4%B4%E9%83%A8%E7%9A%84%E7%BC%93%E5%86%B2%E5%8C%BA%E5%A4%A7%E5%B0%8F%E3%80%82%E8%BF%99%E4%B8%AA%E5%8F%AF%E4%BB%A5%E6%A0%B9%E6%8D%AE%E4%BD%A0%E7%9A%84%E7%B3%BB%E7%BB%9F%E5%88%86%E9%A1%B5%E5%A4%A7%E5%B0%8F%E6%9D%A5%E8%AE%BE%E7%BD%AE%EF%BC%8C%E4%B8%80%E8%88%AC%E4%B8%80%E4%B8%AA%E8%AF%B7%E6%B1%82%E5%A4%B4%E7%9A%84%E5%A4%A7%E5%B0%8F%E4%B8%8D%E4%BC%9A%E8%B6%85%E8%BF%871k%EF%BC%8C%E4%B8%8D%E8%BF%87%E7%94%B1%E4%BA%8E%E4%B8%80%E8%88%AC%E7%B3%BB%E7%BB%9F%E5%88%86%E9%A1%B5%E9%83%BD%E8%A6%81%E5%A4%A7%E4%BA%8E1k%EF%BC%8C%E6%89%80%E4%BB%A5%E8%BF%99%E9%87%8C%E8%AE%BE%E7%BD%AE%E4%B8%BA%E5%88%86%E9%A1%B5%E5%A4%A7%E5%B0%8F%E3%80%82%5Cn%20%20%20%20%23%E5%88%86%E9%A1%B5%E5%A4%A7%E5%B0%8F%E5%8F%AF%E4%BB%A5%E7%94%A8%E5%91%BD%E4%BB%A4getconf%20PAGESIZE%20%E5%8F%96%E5%BE%97%E3%80%82%5Cn%20%20%20%20%23%5Broot%40web001%20~%5D%23%20getconf%20PAGESIZE%5Cn%20%20%20%20%234096%5Cn%20%20%20%20%23%E4%BD%86%E4%B9%9F%E6%9C%89client_header_buffer_size%E8%B6%85%E8%BF%874k%E7%9A%84%E6%83%85%E5%86%B5%EF%BC%8C%E4%BD%86%E6%98%AFclient_header_buffer_size%E8%AF%A5%E5%80%BC%E5%BF%85%E9%A1%BB%E8%AE%BE%E7%BD%AE%E4%B8%BA%E2%80%9C%E7%B3%BB%E7%BB%9F%E5%88%86%E9%A1%B5%E5%A4%A7%E5%B0%8F%E2%80%9D%E7%9A%84%E6%95%B4%E5%80%8D%E6%95%B0%E3%80%82%5Cn%20%20%20%20client_header_buffer_size%204k%3B%5Cn%20%5Cn%20%20%20%20%23%E8%BF%99%E4%B8%AA%E5%B0%86%E4%B8%BA%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E6%8C%87%E5%AE%9A%E7%BC%93%E5%AD%98%EF%BC%8C%E9%BB%98%E8%AE%A4%E6%98%AF%E6%B2%A1%E6%9C%89%E5%90%AF%E7%94%A8%E7%9A%84%EF%BC%8Cmax%E6%8C%87%E5%AE%9A%E7%BC%93%E5%AD%98%E6%95%B0%E9%87%8F%EF%BC%8C%E5%BB%BA%E8%AE%AE%E5%92%8C%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E6%95%B0%E4%B8%80%E8%87%B4%EF%BC%8Cinactive%E6%98%AF%E6%8C%87%E7%BB%8F%E8%BF%87%E5%A4%9A%E9%95%BF%E6%97%B6%E9%97%B4%E6%96%87%E4%BB%B6%E6%B2%A1%E8%A2%AB%E8%AF%B7%E6%B1%82%E5%90%8E%E5%88%A0%E9%99%A4%E7%BC%93%E5%AD%98%E3%80%82%5Cn%20%20%20%20open_file_cache%20max%3D65535%20inactive%3D60s%3B%5Cn%20%5Cn%20%20%20%20%23%E8%BF%99%E4%B8%AA%E6%98%AF%E6%8C%87%E5%A4%9A%E9%95%BF%E6%97%B6%E9%97%B4%E6%A3%80%E6%9F%A5%E4%B8%80%E6%AC%A1%E7%BC%93%E5%AD%98%E7%9A%84%E6%9C%89%E6%95%88%E4%BF%A1%E6%81%AF%E3%80%82%5Cn%20%20%20%20%23%E8%AF%AD%E6%B3%95%3Aopen_file_cache_valid%20time%20%E9%BB%98%E8%AE%A4%E5%80%BC%3Aopen_file_cache_valid%2060%20%E4%BD%BF%E7%94%A8%E5%AD%97%E6%AE%B5%3Ahttp%2C%20server%2C%20location%20%E8%BF%99%E4%B8%AA%E6%8C%87%E4%BB%A4%E6%8C%87%E5%AE%9A%E4%BA%86%E4%BD%95%E6%97%B6%E9%9C%80%E8%A6%81%E6%A3%80%E6%9F%A5open_file_cache%E4%B8%AD%E7%BC%93%E5%AD%98%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%9C%89%E6%95%88%E4%BF%A1%E6%81%AF.%5Cn%20%20%20%20open_file_cache_valid%2080s%3B%5Cn%20%5Cn%20%20%20%20%23open_file_cache%E6%8C%87%E4%BB%A4%E4%B8%AD%E7%9A%84inactive%E5%8F%82%E6%95%B0%E6%97%B6%E9%97%B4%E5%86%85%E6%96%87%E4%BB%B6%E7%9A%84%E6%9C%80%E5%B0%91%E4%BD%BF%E7%94%A8%E6%AC%A1%E6%95%B0%EF%BC%8C%E5%A6%82%E6%9E%9C%E8%B6%85%E8%BF%87%E8%BF%99%E4%B8%AA%E6%95%B0%E5%AD%97%EF%BC%8C%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E4%B8%80%E7%9B%B4%E6%98%AF%E5%9C%A8%E7%BC%93%E5%AD%98%E4%B8%AD%E6%89%93%E5%BC%80%E7%9A%84%EF%BC%8C%E5%A6%82%E4%B8%8A%E4%BE%8B%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%9C%89%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E5%9C%A8inactive%E6%97%B6%E9%97%B4%E5%86%85%E4%B8%80%E6%AC%A1%E6%B2%A1%E8%A2%AB%E4%BD%BF%E7%94%A8%EF%BC%8C%E5%AE%83%E5%B0%86%E8%A2%AB%E7%A7%BB%E9%99%A4%E3%80%82%5Cn%20%20%20%20%23%E8%AF%AD%E6%B3%95%3Aopen_file_cache_min_uses%20number%20%E9%BB%98%E8%AE%A4%E5%80%BC%3Aopen_file_cache_min_uses%201%20%E4%BD%BF%E7%94%A8%E5%AD%97%E6%AE%B5%3Ahttp%2C%20server%2C%20location%20%20%E8%BF%99%E4%B8%AA%E6%8C%87%E4%BB%A4%E6%8C%87%E5%AE%9A%E4%BA%86%E5%9C%A8open_file_cache%E6%8C%87%E4%BB%A4%E6%97%A0%E6%95%88%E7%9A%84%E5%8F%82%E6%95%B0%E4%B8%AD%E4%B8%80%E5%AE%9A%E7%9A%84%E6%97%B6%E9%97%B4%E8%8C%83%E5%9B%B4%E5%86%85%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E7%9A%84%E6%9C%80%E5%B0%8F%E6%96%87%E4%BB%B6%E6%95%B0%2C%E5%A6%82%E6%9E%9C%E4%BD%BF%E7%94%A8%E6%9B%B4%E5%A4%A7%E7%9A%84%E5%80%BC%2C%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%9C%A8cache%E4%B8%AD%E6%80%BB%E6%98%AF%E6%89%93%E5%BC%80%E7%8A%B6%E6%80%81.%5Cn%20%20%20%20open_file_cache_min_uses%201%3B%5Cn%20%20%20%20%20%5Cn%20%20%20%20%23%E8%AF%AD%E6%B3%95%3Aopen_file_cache_errors%20on%20%7C%20off%20%E9%BB%98%E8%AE%A4%E5%80%BC%3Aopen_file_cache_errors%20off%20%E4%BD%BF%E7%94%A8%E5%AD%97%E6%AE%B5%3Ahttp%2C%20server%2C%20location%20%E8%BF%99%E4%B8%AA%E6%8C%87%E4%BB%A4%E6%8C%87%E5%AE%9A%E6%98%AF%E5%90%A6%E5%9C%A8%E6%90%9C%E7%B4%A2%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E6%98%AF%E8%AE%B0%E5%BD%95cache%E9%94%99%E8%AF%AF.%5Cn%20%20%20%20open_file_cache_errors%20on%3B%5Cn%7D%5Cn%20%20%5Cn%20%20%5Cn%20%20%5Cn%23%E8%AE%BE%E5%AE%9Ahttp%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%8C%E5%88%A9%E7%94%A8%E5%AE%83%E7%9A%84%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E5%8A%9F%E8%83%BD%E6%8F%90%E4%BE%9B%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%94%AF%E6%8C%81%5Cnhttp%5Cn%7B%5Cn%20%20%20%20%23%E6%96%87%E4%BB%B6%E6%89%A9%E5%B1%95%E5%90%8D%E4%B8%8E%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84%E8%A1%A8%5Cn%20%20%20%20include%20%2Fetc%2Fnginx%2Fmime.types%3B%5Cn%20%5Cn%20%20%20%20%23%E9%BB%98%E8%AE%A4%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%5Cn%20%20%20%20default_type%20application%2Foctet-stream%3B%5Cn%20%5Cn%20%20%20%20%23%E9%BB%98%E8%AE%A4%E7%BC%96%E7%A0%81%5Cn%20%20%20%20%23charset%20utf-8%3B%5Cn%20%5Cn%20%20%20%20%23%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%90%8D%E5%AD%97%E7%9A%84hash%E8%A1%A8%E5%A4%A7%E5%B0%8F%5Cn%20%20%20%20%23%E4%BF%9D%E5%AD%98%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%90%8D%E5%AD%97%E7%9A%84hash%E8%A1%A8%E6%98%AF%E7%94%B1%E6%8C%87%E4%BB%A4server_names_hash_max_size%20%E5%92%8Cserver_names_hash_bucket_size%E6%89%80%E6%8E%A7%E5%88%B6%E7%9A%84%E3%80%82%E5%8F%82%E6%95%B0hash%20bucket%20size%E6%80%BB%E6%98%AF%E7%AD%89%E4%BA%8Ehash%E8%A1%A8%E7%9A%84%E5%A4%A7%E5%B0%8F%EF%BC%8C%E5%B9%B6%E4%B8%94%E6%98%AF%E4%B8%80%E8%B7%AF%E5%A4%84%E7%90%86%E5%99%A8%E7%BC%93%E5%AD%98%E5%A4%A7%E5%B0%8F%E7%9A%84%E5%80%8D%E6%95%B0%E3%80%82%E5%9C%A8%E5%87%8F%E5%B0%91%E4%BA%86%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AD%98%E5%8F%96%E6%AC%A1%E6%95%B0%E5%90%8E%EF%BC%8C%E4%BD%BF%E5%9C%A8%E5%A4%84%E7%90%86%E5%99%A8%E4%B8%AD%E5%8A%A0%E9%80%9F%E6%9F%A5%E6%89%BEhash%E8%A1%A8%E9%94%AE%E5%80%BC%E6%88%90%E4%B8%BA%E5%8F%AF%E8%83%BD%E3%80%82%E5%A6%82%E6%9E%9Chash%20bucket%20size%E7%AD%89%E4%BA%8E%E4%B8%80%E8%B7%AF%E5%A4%84%E7%90%86%E5%99%A8%E7%BC%93%E5%AD%98%E7%9A%84%E5%A4%A7%E5%B0%8F%EF%BC%8C%E9%82%A3%E4%B9%88%E5%9C%A8%E6%9F%A5%E6%89%BE%E9%94%AE%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E6%9C%80%E5%9D%8F%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E6%9F%A5%E6%89%BE%E7%9A%84%E6%AC%A1%E6%95%B0%E4%B8%BA2%E3%80%82%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%98%AF%E7%A1%AE%E5%AE%9A%E5%AD%98%E5%82%A8%E5%8D%95%E5%85%83%E7%9A%84%E5%9C%B0%E5%9D%80%EF%BC%8C%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%98%AF%E5%9C%A8%E5%AD%98%E5%82%A8%E5%8D%95%E5%85%83%E4%B8%AD%E6%9F%A5%E6%89%BE%E9%94%AE%20%E5%80%BC%E3%80%82%E5%9B%A0%E6%AD%A4%EF%BC%8C%E5%A6%82%E6%9E%9CNginx%E7%BB%99%E5%87%BA%E9%9C%80%E8%A6%81%E5%A2%9E%E5%A4%A7hash%20max%20size%20%E6%88%96%20hash%20bucket%20size%E7%9A%84%E6%8F%90%E7%A4%BA%EF%BC%8C%E9%82%A3%E4%B9%88%E9%A6%96%E8%A6%81%E7%9A%84%E6%98%AF%E5%A2%9E%E5%A4%A7%E5%89%8D%E4%B8%80%E4%B8%AA%E5%8F%82%E6%95%B0%E7%9A%84%E5%A4%A7%E5%B0%8F.%5Cn%20%20%20%20server_names_hash_bucket_size%20128%3B%5Cn%20%5Cn%20%20%20%20%23%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AF%B7%E6%B1%82%E5%A4%B4%E9%83%A8%E7%9A%84%E7%BC%93%E5%86%B2%E5%8C%BA%E5%A4%A7%E5%B0%8F%E3%80%82%E8%BF%99%E4%B8%AA%E5%8F%AF%E4%BB%A5%E6%A0%B9%E6%8D%AE%E4%BD%A0%E7%9A%84%E7%B3%BB%E7%BB%9F%E5%88%86%E9%A1%B5%E5%A4%A7%E5%B0%8F%E6%9D%A5%E8%AE%BE%E7%BD%AE%EF%BC%8C%E4%B8%80%E8%88%AC%E4%B8%80%E4%B8%AA%E8%AF%B7%E6%B1%82%E7%9A%84%E5%A4%B4%E9%83%A8%E5%A4%A7%E5%B0%8F%E4%B8%8D%E4%BC%9A%E8%B6%85%E8%BF%871k%EF%BC%8C%E4%B8%8D%E8%BF%87%E7%94%B1%E4%BA%8E%E4%B8%80%E8%88%AC%E7%B3%BB%E7%BB%9F%E5%88%86%E9%A1%B5%E9%83%BD%E8%A6%81%E5%A4%A7%E4%BA%8E1k%EF%BC%8C%E6%89%80%E4%BB%A5%E8%BF%99%E9%87%8C%E8%AE%BE%E7%BD%AE%E4%B8%BA%E5%88%86%E9%A1%B5%E5%A4%A7%E5%B0%8F%E3%80%82%E5%88%86%E9%A1%B5%E5%A4%A7%E5%B0%8F%E5%8F%AF%E4%BB%A5%E7%94%A8%E5%91%BD%E4%BB%A4getconf%20PAGESIZE%E5%8F%96%E5%BE%97%E3%80%82%5Cn%20%20%20%20client_header_buffer_size%2032k%3B%5Cn%20%5Cn%20%20%20%20%23%E5%AE%A2%E6%88%B7%E8%AF%B7%E6%B1%82%E5%A4%B4%E7%BC%93%E5%86%B2%E5%A4%A7%E5%B0%8F%E3%80%82nginx%E9%BB%98%E8%AE%A4%E4%BC%9A%E7%94%A8client_header_buffer_size%E8%BF%99%E4%B8%AAbuffer%E6%9D%A5%E8%AF%BB%E5%8F%96header%E5%80%BC%EF%BC%8C%E5%A6%82%E6%9E%9Cheader%E8%BF%87%E5%A4%A7%EF%BC%8C%E5%AE%83%E4%BC%9A%E4%BD%BF%E7%94%A8large_client_header_buffers%E6%9D%A5%E8%AF%BB%E5%8F%96%E3%80%82%5Cn%20%20%20%20large_client_header_buffers%204%2064k%3B%5Cn%20%5Cn%20%20%20%20%23%E8%AE%BE%E5%AE%9A%E9%80%9A%E8%BF%87nginx%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E7%9A%84%E5%A4%A7%E5%B0%8F%5Cn%20%20%20%20client_max_body_size%208m%3B%5Cn%20%5Cn%20%20%20%20%23%E5%BC%80%E5%90%AF%E9%AB%98%E6%95%88%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E6%A8%A1%E5%BC%8F%EF%BC%8Csendfile%E6%8C%87%E4%BB%A4%E6%8C%87%E5%AE%9Anginx%E6%98%AF%E5%90%A6%E8%B0%83%E7%94%A8sendfile%E5%87%BD%E6%95%B0%E6%9D%A5%E8%BE%93%E5%87%BA%E6%96%87%E4%BB%B6%EF%BC%8C%E5%AF%B9%E4%BA%8E%E6%99%AE%E9%80%9A%E5%BA%94%E7%94%A8%E8%AE%BE%E4%B8%BA%20on%EF%BC%8C%E5%A6%82%E6%9E%9C%E7%94%A8%E6%9D%A5%E8%BF%9B%E8%A1%8C%E4%B8%8B%E8%BD%BD%E7%AD%89%E5%BA%94%E7%94%A8%E7%A3%81%E7%9B%98IO%E9%87%8D%E8%B4%9F%E8%BD%BD%E5%BA%94%E7%94%A8%EF%BC%8C%E5%8F%AF%E8%AE%BE%E7%BD%AE%E4%B8%BAoff%EF%BC%8C%E4%BB%A5%E5%B9%B3%E8%A1%A1%E7%A3%81%E7%9B%98%E4%B8%8E%E7%BD%91%E7%BB%9CI%2FO%E5%A4%84%E7%90%86%E9%80%9F%E5%BA%A6%EF%BC%8C%E9%99%8D%E4%BD%8E%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%B4%9F%E8%BD%BD%E3%80%82%E6%B3%A8%E6%84%8F%EF%BC%9A%E5%A6%82%E6%9E%9C%E5%9B%BE%E7%89%87%E6%98%BE%E7%A4%BA%E4%B8%8D%E6%AD%A3%E5%B8%B8%E6%8A%8A%E8%BF%99%E4%B8%AA%E6%94%B9%E6%88%90off%E3%80%82%5Cn%20%20%20%20%23sendfile%E6%8C%87%E4%BB%A4%E6%8C%87%E5%AE%9A%20nginx%20%E6%98%AF%E5%90%A6%E8%B0%83%E7%94%A8sendfile%20%E5%87%BD%E6%95%B0%EF%BC%88zero%20copy%20%E6%96%B9%E5%BC%8F%EF%BC%89%E6%9D%A5%E8%BE%93%E5%87%BA%E6%96%87%E4%BB%B6%EF%BC%8C%E5%AF%B9%E4%BA%8E%E6%99%AE%E9%80%9A%E5%BA%94%E7%94%A8%EF%BC%8C%E5%BF%85%E9%A1%BB%E8%AE%BE%E4%B8%BAon%E3%80%82%E5%A6%82%E6%9E%9C%E7%94%A8%E6%9D%A5%E8%BF%9B%E8%A1%8C%E4%B8%8B%E8%BD%BD%E7%AD%89%E5%BA%94%E7%94%A8%E7%A3%81%E7%9B%98IO%E9%87%8D%E8%B4%9F%E8%BD%BD%E5%BA%94%E7%94%A8%EF%BC%8C%E5%8F%AF%E8%AE%BE%E7%BD%AE%E4%B8%BAoff%EF%BC%8C%E4%BB%A5%E5%B9%B3%E8%A1%A1%E7%A3%81%E7%9B%98%E4%B8%8E%E7%BD%91%E7%BB%9CIO%E5%A4%84%E7%90%86%E9%80%9F%E5%BA%A6%EF%BC%8C%E9%99%8D%E4%BD%8E%E7%B3%BB%E7%BB%9Fuptime%E3%80%82%5Cn%20%20%20%20sendfile%20on%3B%5Cn%20%5Cn%20%20%20%20%23%E5%BC%80%E5%90%AF%E7%9B%AE%E5%BD%95%E5%88%97%E8%A1%A8%E8%AE%BF%E9%97%AE%EF%BC%8C%E5%90%88%E9%80%82%E4%B8%8B%E8%BD%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%8C%E9%BB%98%E8%AE%A4%E5%85%B3%E9%97%AD%E3%80%82%5Cn%20%20%20%20autoindex%20on%3B%5Cn%20%5Cn%20%20%20%20%23%E6%AD%A4%E9%80%89%E9%A1%B9%E5%85%81%E8%AE%B8%E6%88%96%E7%A6%81%E6%AD%A2%E4%BD%BF%E7%94%A8socke%E7%9A%84TCP_CORK%E7%9A%84%E9%80%89%E9%A1%B9%EF%BC%8C%E6%AD%A4%E9%80%89%E9%A1%B9%E4%BB%85%E5%9C%A8%E4%BD%BF%E7%94%A8sendfile%E7%9A%84%E6%97%B6%E5%80%99%E4%BD%BF%E7%94%A8%5Cn%20%20%20%20tcp_nopush%20on%3B%5Cn%20%20%20%20%20%20%5Cn%20%20%20%20tcp_nodelay%20on%3B%5Cn%20%5Cn%20%20%20%20%23%E9%95%BF%E8%BF%9E%E6%8E%A5%E8%B6%85%E6%97%B6%E6%97%B6%E9%97%B4%EF%BC%8C%E5%8D%95%E4%BD%8D%E6%98%AF%E7%A7%92%5Cn%20%20%20%20keepalive_timeout%20120%3B%5Cn%20%5Cn%20%20%20%20%23FastCGI%E7%9B%B8%E5%85%B3%E5%8F%82%E6%95%B0%E6%98%AF%E4%B8%BA%E4%BA%86%E6%94%B9%E5%96%84%E7%BD%91%E7%AB%99%E7%9A%84%E6%80%A7%E8%83%BD%EF%BC%9A%E5%87%8F%E5%B0%91%E8%B5%84%E6%BA%90%E5%8D%A0%E7%94%A8%EF%BC%8C%E6%8F%90%E9%AB%98%E8%AE%BF%E9%97%AE%E9%80%9F%E5%BA%A6%E3%80%82%E4%B8%8B%E9%9D%A2%E5%8F%82%E6%95%B0%E7%9C%8B%E5%AD%97%E9%9D%A2%E6%84%8F%E6%80%9D%E9%83%BD%E8%83%BD%E7%90%86%E8%A7%A3%E3%80%82%5Cn%20%20%20%20fastcgi_connect_timeout%20300%3B%5Cn%20%20%20%20fastcgi_send_timeout%20300%3B%5Cn%20%20%20%20fastcgi_read_timeout%20300%3B%5Cn%20%20%20%20fastcgi_buffer_size%2064k%3B%5Cn%20%20%20%20fastcgi_buffers%204%2064k%3B%5Cn%20%20%20%20fastcgi_busy_buffers_size%20128k%3B%5Cn%20%20%20%20fastcgi_temp_file_write_size%20128k%3B%5Cn%20%5Cn%20%20%20%20%23gzip%E6%A8%A1%E5%9D%97%E8%AE%BE%E7%BD%AE%5Cn%20%20%20%20gzip%20on%3B%20%23%E5%BC%80%E5%90%AFgzip%E5%8E%8B%E7%BC%A9%E8%BE%93%E5%87%BA%5Cn%20%20%20%20gzip_min_length%201k%3B%20%20%20%20%23%E6%9C%80%E5%B0%8F%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F%5Cn%20%20%20%20gzip_buffers%204%2016k%3B%20%20%20%20%23%E5%8E%8B%E7%BC%A9%E7%BC%93%E5%86%B2%E5%8C%BA%5Cn%20%20%20%20gzip_http_version%201.0%3B%20%20%20%20%23%E5%8E%8B%E7%BC%A9%E7%89%88%E6%9C%AC%EF%BC%88%E9%BB%98%E8%AE%A41.1%EF%BC%8C%E5%89%8D%E7%AB%AF%E5%A6%82%E6%9E%9C%E6%98%AFsquid2.5%E8%AF%B7%E4%BD%BF%E7%94%A81.0%EF%BC%89%5Cn%20%20%20%20gzip_comp_level%202%3B%20%20%20%20%23%E5%8E%8B%E7%BC%A9%E7%AD%89%E7%BA%A7%5Cn%20%20%20%20gzip_types%20text%2Fplain%20application%2Fx-javascript%20text%2Fcss%20application%2Fxml%3B%20%20%20%20%23%E5%8E%8B%E7%BC%A9%E7%B1%BB%E5%9E%8B%EF%BC%8C%E9%BB%98%E8%AE%A4%E5%B0%B1%E5%B7%B2%E7%BB%8F%E5%8C%85%E5%90%ABtextml%EF%BC%8C%E6%89%80%E4%BB%A5%E4%B8%8B%E9%9D%A2%E5%B0%B1%E4%B8%8D%E7%94%A8%E5%86%8D%E5%86%99%E4%BA%86%EF%BC%8C%E5%86%99%E4%B8%8A%E5%8E%BB%E4%B9%9F%E4%B8%8D%E4%BC%9A%E6%9C%89%E9%97%AE%E9%A2%98%EF%BC%8C%E4%BD%86%E6%98%AF%E4%BC%9A%E6%9C%89%E4%B8%80%E4%B8%AAwarn%E3%80%82%5Cn%20%20%20%20gzip_vary%20on%3B%5Cn%20%5Cn%20%20%20%20%23%E5%BC%80%E5%90%AF%E9%99%90%E5%88%B6IP%E8%BF%9E%E6%8E%A5%E6%95%B0%E7%9A%84%E6%97%B6%E5%80%99%E9%9C%80%E8%A6%81%E4%BD%BF%E7%94%A8%5Cn%20%20%20%20%23limit_zone%20crawler%20%24binary_remote_addr%2010m%3B%5Cn%20%5Cn%20%5Cn%20%5Cn%20%20%20%20%23%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E9%85%8D%E7%BD%AE%5Cn%20%20%20%20upstream%20piao.jd.com%20%7B%5Cn%20%20%20%20%20%20%5Cn%20%20%20%20%20%20%20%20%23upstream%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%EF%BC%8Cweight%E6%98%AF%E6%9D%83%E9%87%8D%EF%BC%8C%E5%8F%AF%E4%BB%A5%E6%A0%B9%E6%8D%AE%E6%9C%BA%E5%99%A8%E9%85%8D%E7%BD%AE%E5%AE%9A%E4%B9%89%E6%9D%83%E9%87%8D%E3%80%82weigth%E5%8F%82%E6%95%B0%E8%A1%A8%E7%A4%BA%E6%9D%83%E5%80%BC%EF%BC%8C%E6%9D%83%E5%80%BC%E8%B6%8A%E9%AB%98%E8%A2%AB%E5%88%86%E9%85%8D%E5%88%B0%E7%9A%84%E5%87%A0%E7%8E%87%E8%B6%8A%E5%A4%A7%E3%80%82%5Cn%20%20%20%20%20%20%20%20server%20192.168.80.121%3A80%20weight%3D3%3B%5Cn%20%20%20%20%20%20%20%20server%20192.168.80.122%3A80%20weight%3D2%3B%5Cn%20%20%20%20%20%20%20%20server%20192.168.80.123%3A80%20weight%3D3%3B%5Cn%20%5Cn%20%20%20%20%20%20%20%20%23nginx%E7%9A%84upstream%E7%9B%AE%E5%89%8D%E6%94%AF%E6%8C%814%E7%A7%8D%E6%96%B9%E5%BC%8F%E7%9A%84%E5%88%86%E9%85%8D%5Cn%20%20%20%20%20%20%20%20%231%E3%80%81%E8%BD%AE%E8%AF%A2%EF%BC%88%E9%BB%98%E8%AE%A4%EF%BC%89%5Cn%20%20%20%20%20%20%20%20%23%E6%AF%8F%E4%B8%AA%E8%AF%B7%E6%B1%82%E6%8C%89%E6%97%B6%E9%97%B4%E9%A1%BA%E5%BA%8F%E9%80%90%E4%B8%80%E5%88%86%E9%85%8D%E5%88%B0%E4%B8%8D%E5%90%8C%E7%9A%84%E5%90%8E%E7%AB%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%90%8E%E7%AB%AF%E6%9C%8D%E5%8A%A1%E5%99%A8down%E6%8E%89%EF%BC%8C%E8%83%BD%E8%87%AA%E5%8A%A8%E5%89%94%E9%99%A4%E3%80%82%5Cn%20%20%20%20%20%20%20%20%232%E3%80%81weight%5Cn%20%20%20%20%20%20%20%20%23%E6%8C%87%E5%AE%9A%E8%BD%AE%E8%AF%A2%E5%87%A0%E7%8E%87%EF%BC%8Cweight%E5%92%8C%E8%AE%BF%E9%97%AE%E6%AF%94%E7%8E%87%E6%88%90%E6%AD%A3%E6%AF%94%EF%BC%8C%E7%94%A8%E4%BA%8E%E5%90%8E%E7%AB%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%80%A7%E8%83%BD%E4%B8%8D%E5%9D%87%E7%9A%84%E6%83%85%E5%86%B5%E3%80%82%5Cn%20%20%20%20%20%20%20%20%23%E4%BE%8B%E5%A6%82%EF%BC%9A%5Cn%20%20%20%20%20%20%20%20%23upstream%20bakend%20%7B%5Cn%20%20%20%20%20%20%20%20%23%20%20%20%20server%20192.168.0.14%20weight%3D10%3B%5Cn%20%20%20%20%20%20%20%20%23%20%20%20%20server%20192.168.0.15%20weight%3D10%3B%5Cn%20%20%20%20%20%20%20%20%23%7D%5Cn%20%20%20%20%20%20%20%20%232%E3%80%81ip_hash%5Cn%20%20%20%20%20%20%20%20%23%E6%AF%8F%E4%B8%AA%E8%AF%B7%E6%B1%82%E6%8C%89%E8%AE%BF%E9%97%AEip%E7%9A%84hash%E7%BB%93%E6%9E%9C%E5%88%86%E9%85%8D%EF%BC%8C%E8%BF%99%E6%A0%B7%E6%AF%8F%E4%B8%AA%E8%AE%BF%E5%AE%A2%E5%9B%BA%E5%AE%9A%E8%AE%BF%E9%97%AE%E4%B8%80%E4%B8%AA%E5%90%8E%E7%AB%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%8C%E5%8F%AF%E4%BB%A5%E8%A7%A3%E5%86%B3session%E7%9A%84%E9%97%AE%E9%A2%98%E3%80%82%5Cn%20%20%20%20%20%20%20%20%23%E4%BE%8B%E5%A6%82%EF%BC%9A%5Cn%20%20%20%20%20%20%20%20%23upstream%20bakend%20%7B%5Cn%20%20%20%20%20%20%20%20%23%20%20%20%20ip_hash%3B%5Cn%20%20%20%20%20%20%20%20%23%20%20%20%20server%20192.168.0.14%3A88%3B%5Cn%20%20%20%20%20%20%20%20%23%20%20%20%20server%20192.168.0.15%3A80%3B%5Cn%20%20%20%20%20%20%20%20%23%7D%5Cn%20%20%20%20%20%20%20%20%233%E3%80%81fair%EF%BC%88%E7%AC%AC%E4%B8%89%E6%96%B9%EF%BC%89%5Cn%20%20%20%20%20%20%20%20%23%E6%8C%89%E5%90%8E%E7%AB%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4%E6%9D%A5%E5%88%86%E9%85%8D%E8%AF%B7%E6%B1%82%EF%BC%8C%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4%E7%9F%AD%E7%9A%84%E4%BC%98%E5%85%88%E5%88%86%E9%85%8D%E3%80%82%5Cn%20%20%20%20%20%20%20%20%23upstream%20backend%20%7B%5Cn%20%20%20%20%20%20%20%20%23%20%20%20%20server%20server1%3B%5Cn%20%20%20%20%20%20%20%20%23%20%20%20%20server%20server2%3B%5Cn%20%20%20%20%20%20%20%20%23%20%20%20%20fair%3B%5Cn%20%20%20%20%20%20%20%20%23%7D%5Cn%20%20%20%20%20%20%20%20%234%E3%80%81url_hash%EF%BC%88%E7%AC%AC%E4%B8%89%E6%96%B9%EF%BC%89%5Cn%20%20%20%20%20%20%20%20%23%E6%8C%89%E8%AE%BF%E9%97%AEurl%E7%9A%84hash%E7%BB%93%E6%9E%9C%E6%9D%A5%E5%88%86%E9%85%8D%E8%AF%B7%E6%B1%82%EF%BC%8C%E4%BD%BF%E6%AF%8F%E4%B8%AAurl%E5%AE%9A%E5%90%91%E5%88%B0%E5%90%8C%E4%B8%80%E4%B8%AA%E5%90%8E%E7%AB%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%8C%E5%90%8E%E7%AB%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%BA%E7%BC%93%E5%AD%98%E6%97%B6%E6%AF%94%E8%BE%83%E6%9C%89%E6%95%88%E3%80%82%5Cn%20%20%20%20%20%20%20%20%23%E4%BE%8B%EF%BC%9A%E5%9C%A8upstream%E4%B8%AD%E5%8A%A0%E5%85%A5hash%E8%AF%AD%E5%8F%A5%EF%BC%8Cserver%E8%AF%AD%E5%8F%A5%E4%B8%AD%E4%B8%8D%E8%83%BD%E5%86%99%E5%85%A5weight%E7%AD%89%E5%85%B6%E4%BB%96%E7%9A%84%E5%8F%82%E6%95%B0%EF%BC%8Chash_method%E6%98%AF%E4%BD%BF%E7%94%A8%E7%9A%84hash%E7%AE%97%E6%B3%95%5Cn%20%20%20%20%20%20%20%20%23upstream%20backend%20%7B%5Cn%20%20%20%20%20%20%20%20%23%20%20%20%20server%20squid1%3A3128%3B%5Cn%20%20%20%20%20%20%20%20%23%20%20%20%20server%20squid2%3A3128%3B%5Cn%20%20%20%20%20%20%20%20%23%20%20%20%20hash%20%24request_uri%3B%5Cn%20%20%20%20%20%20%20%20%23%20%20%20%20hash_method%20crc32%3B%5Cn%20%20%20%20%20%20%20%20%23%7D%5Cn%20%5Cn%20%20%20%20%20%20%20%20%23tips%3A%5Cn%20%20%20%20%20%20%20%20%23upstream%20bakend%7B%23%E5%AE%9A%E4%B9%89%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E8%AE%BE%E5%A4%87%E7%9A%84Ip%E5%8F%8A%E8%AE%BE%E5%A4%87%E7%8A%B6%E6%80%81%7D%7B%5Cn%20%20%20%20%20%20%20%20%23%20%20%20%20ip_hash%3B%5Cn%20%20%20%20%20%20%20%20%23%20%20%20%20server%20127.0.0.1%3A9090%20down%3B%5Cn%20%20%20%20%20%20%20%20%23%20%20%20%20server%20127.0.0.1%3A8080%20weight%3D2%3B%5Cn%20%20%20%20%20%20%20%20%23%20%20%20%20server%20127.0.0.1%3A6060%3B%5Cn%20%20%20%20%20%20%20%20%23%20%20%20%20server%20127.0.0.1%3A7070%20backup%3B%5Cn%20%20%20%20%20%20%20%20%23%7D%5Cn%20%20%20%20%20%20%20%20%23%E5%9C%A8%E9%9C%80%E8%A6%81%E4%BD%BF%E7%94%A8%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%9A%84server%E4%B8%AD%E5%A2%9E%E5%8A%A0%20proxy_pass%20http%3A%2F%2Fbakend%2F%3B%5Cn%20%5Cn%20%20%20%20%20%20%20%20%23%E6%AF%8F%E4%B8%AA%E8%AE%BE%E5%A4%87%E7%9A%84%E7%8A%B6%E6%80%81%E8%AE%BE%E7%BD%AE%E4%B8%BA%3A%5Cn%20%20%20%20%20%20%20%20%231.down%E8%A1%A8%E7%A4%BA%E5%8D%95%E5%89%8D%E7%9A%84server%E6%9A%82%E6%97%B6%E4%B8%8D%E5%8F%82%E4%B8%8E%E8%B4%9F%E8%BD%BD%5Cn%20%20%20%20%20%20%20%20%232.weight%E4%B8%BAweight%E8%B6%8A%E5%A4%A7%EF%BC%8C%E8%B4%9F%E8%BD%BD%E7%9A%84%E6%9D%83%E9%87%8D%E5%B0%B1%E8%B6%8A%E5%A4%A7%E3%80%82%5Cn%20%20%20%20%20%20%20%20%233.max_fails%EF%BC%9A%E5%85%81%E8%AE%B8%E8%AF%B7%E6%B1%82%E5%A4%B1%E8%B4%A5%E7%9A%84%E6%AC%A1%E6%95%B0%E9%BB%98%E8%AE%A4%E4%B8%BA1.%E5%BD%93%E8%B6%85%E8%BF%87%E6%9C%80%E5%A4%A7%E6%AC%A1%E6%95%B0%E6%97%B6%EF%BC%8C%E8%BF%94%E5%9B%9Eproxy_next_upstream%E6%A8%A1%E5%9D%97%E5%AE%9A%E4%B9%89%E7%9A%84%E9%94%99%E8%AF%AF%5Cn%20%20%20%20%20%20%20%20%234.fail_timeout%3Amax_fails%E6%AC%A1%E5%A4%B1%E8%B4%A5%E5%90%8E%EF%BC%8C%E6%9A%82%E5%81%9C%E7%9A%84%E6%97%B6%E9%97%B4%E3%80%82%5Cn%20%20%20%20%20%20%20%20%235.backup%EF%BC%9A%20%E5%85%B6%E5%AE%83%E6%89%80%E6%9C%89%E7%9A%84%E9%9D%9Ebackup%E6%9C%BA%E5%99%A8down%E6%88%96%E8%80%85%E5%BF%99%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E8%AF%B7%E6%B1%82backup%E6%9C%BA%E5%99%A8%E3%80%82%E6%89%80%E4%BB%A5%E8%BF%99%E5%8F%B0%E6%9C%BA%E5%99%A8%E5%8E%8B%E5%8A%9B%E4%BC%9A%E6%9C%80%E8%BD%BB%E3%80%82%5Cn%20%5Cn%20%20%20%20%20%20%20%20%23nginx%E6%94%AF%E6%8C%81%E5%90%8C%E6%97%B6%E8%AE%BE%E7%BD%AE%E5%A4%9A%E7%BB%84%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%EF%BC%8C%E7%94%A8%E6%9D%A5%E7%BB%99%E4%B8%8D%E7%94%A8%E7%9A%84server%E6%9D%A5%E4%BD%BF%E7%94%A8%E3%80%82%5Cn%20%20%20%20%20%20%20%20%23client_body_in_file_only%E8%AE%BE%E7%BD%AE%E4%B8%BAOn%20%E5%8F%AF%E4%BB%A5%E8%AE%B2client%20post%E8%BF%87%E6%9D%A5%E7%9A%84%E6%95%B0%E6%8D%AE%E8%AE%B0%E5%BD%95%E5%88%B0%E6%96%87%E4%BB%B6%E4%B8%AD%E7%94%A8%E6%9D%A5%E5%81%9Adebug%5Cn%20%20%20%20%20%20%20%20%23client_body_temp_path%E8%AE%BE%E7%BD%AE%E8%AE%B0%E5%BD%95%E6%96%87%E4%BB%B6%E7%9A%84%E7%9B%AE%E5%BD%95%20%E5%8F%AF%E4%BB%A5%E8%AE%BE%E7%BD%AE%E6%9C%80%E5%A4%9A3%E5%B1%82%E7%9B%AE%E5%BD%95%5Cn%20%20%20%20%20%20%20%20%23location%E5%AF%B9URL%E8%BF%9B%E8%A1%8C%E5%8C%B9%E9%85%8D.%E5%8F%AF%E4%BB%A5%E8%BF%9B%E8%A1%8C%E9%87%8D%E5%AE%9A%E5%90%91%E6%88%96%E8%80%85%E8%BF%9B%E8%A1%8C%E6%96%B0%E7%9A%84%E4%BB%A3%E7%90%86%20%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%5Cn%20%20%20%20%7D%5Cn%22%7D\"\n          >\n              \n              <div>\n                <div>\n<div><pre><code><span>######Nginx配置文件nginx.conf中文详解#####</span>\n \n<span>#定义Nginx运行的用户和用户组</span>\nuser www www<span>;</span>\n \n<span>#nginx进程数，建议设置为等于CPU总核心数。</span>\nworker_processes <span>8</span><span>;</span>\n  \n<span>#全局错误日志定义类型，[ debug | info | notice | warn | error | crit ]</span>\nerror_log /usr/local/nginx/logs/error.log info<span>;</span>\n \n<span>#进程pid文件</span>\npid /usr/local/nginx/logs/nginx.pid<span>;</span>\n \n<span>#指定进程可以打开的最大描述符：数目</span>\n<span>#工作模式与连接数上限</span>\n<span>#这个指令是指当一个nginx进程打开的最多文件描述符数目，理论值应该是最多打开文件数（ulimit -n）与nginx进程数相除，但是nginx分配请求并不是那么均匀，所以最好与ulimit -n 的值保持一致。</span>\n<span>#现在在linux 2.6内核下开启文件打开数为65535，worker_rlimit_nofile就相应应该填写65535。</span>\n<span>#这是因为nginx调度时分配请求到进程并不是那么的均衡，所以假如填写10240，总并发量达到3-4万时就有进程可能超过10240了，这时会返回502错误。</span>\nworker_rlimit_nofile <span>65535</span><span>;</span>\n \nevents\n<span>{</span>\n    <span>#参考事件模型，use [ kqueue | rtsig | epoll | /dev/poll | select | poll ]; epoll模型</span>\n    <span>#是Linux 2.6以上版本内核中的高性能网络I/O模型，linux建议epoll，如果跑在FreeBSD上面，就用kqueue模型。</span>\n    <span>#补充说明：</span>\n    <span>#与apache相类，nginx针对不同的操作系统，有不同的事件模型</span>\n    <span>#A）标准事件模型</span>\n    <span>#Select、poll属于标准事件模型，如果当前系统不存在更有效的方法，nginx会选择select或poll</span>\n    <span>#B）高效事件模型</span>\n    <span>#Kqueue：使用于FreeBSD 4.1+, OpenBSD 2.9+, NetBSD 2.0 和 MacOS X.使用双处理器的MacOS X系统使用kqueue可能会造成内核崩溃。</span>\n    <span>#Epoll：使用于Linux内核2.6版本及以后的系统。</span>\n    <span>#/dev/poll：使用于Solaris 7 11/99+，HP/UX 11.22+ (eventport)，IRIX 6.5.15+ 和 Tru64 UNIX 5.1A+。</span>\n    <span>#Eventport：使用于Solaris 10。 为了防止出现内核崩溃的问题， 有必要安装安全补丁。</span>\n    use epoll<span>;</span>\n \n    <span>#单个进程最大连接数（最大连接数=连接数*进程数）</span>\n    <span>#根据硬件调整，和前面工作进程配合起来用，尽量大，但是别把cpu跑到100%就行。每个进程允许的最多连接数，理论上每台nginx服务器的最大连接数为。</span>\n    worker_connections <span>65535</span><span>;</span>\n \n    <span>#keepalive超时时间。</span>\n    keepalive_timeout <span>60</span><span>;</span>\n \n    <span>#客户端请求头部的缓冲区大小。这个可以根据你的系统分页大小来设置，一般一个请求头的大小不会超过1k，不过由于一般系统分页都要大于1k，所以这里设置为分页大小。</span>\n    <span>#分页大小可以用命令getconf PAGESIZE 取得。</span>\n    <span>#[root@web001 ~]# getconf PAGESIZE</span>\n    <span>#4096</span>\n    <span>#但也有client_header_buffer_size超过4k的情况，但是client_header_buffer_size该值必须设置为“系统分页大小”的整倍数。</span>\n    client_header_buffer_size 4k<span>;</span>\n \n    <span>#这个将为打开文件指定缓存，默认是没有启用的，max指定缓存数量，建议和打开文件数一致，inactive是指经过多长时间文件没被请求后删除缓存。</span>\n    open_file_cache <span>max</span><span>=</span><span>65535</span> <span>inactive</span><span>=</span>60s<span>;</span>\n \n    <span>#这个是指多长时间检查一次缓存的有效信息。</span>\n    <span>#语法:open_file_cache_valid time 默认值:open_file_cache_valid 60 使用字段:http, server, location 这个指令指定了何时需要检查open_file_cache中缓存项目的有效信息.</span>\n    open_file_cache_valid 80s<span>;</span>\n \n    <span>#open_file_cache指令中的inactive参数时间内文件的最少使用次数，如果超过这个数字，文件描述符一直是在缓存中打开的，如上例，如果有一个文件在inactive时间内一次没被使用，它将被移除。</span>\n    <span>#语法:open_file_cache_min_uses number 默认值:open_file_cache_min_uses 1 使用字段:http, server, location  这个指令指定了在open_file_cache指令无效的参数中一定的时间范围内可以使用的最小文件数,如果使用更大的值,文件描述符在cache中总是打开状态.</span>\n    open_file_cache_min_uses <span>1</span><span>;</span>\n     \n    <span>#语法:open_file_cache_errors on | off 默认值:open_file_cache_errors off 使用字段:http, server, location 这个指令指定是否在搜索一个文件是记录cache错误.</span>\n    open_file_cache_errors on<span>;</span>\n<span>}</span>\n  \n  \n  \n<span>#设定http服务器，利用它的反向代理功能提供负载均衡支持</span>\nhttp\n<span>{</span>\n    <span>#文件扩展名与文件类型映射表</span>\n    include /etc/nginx/mime.types<span>;</span>\n \n    <span>#默认文件类型</span>\n    default_type application/octet-stream<span>;</span>\n \n    <span>#默认编码</span>\n    <span>#charset utf-8;</span>\n \n    <span>#服务器名字的hash表大小</span>\n    <span>#保存服务器名字的hash表是由指令server_names_hash_max_size 和server_names_hash_bucket_size所控制的。参数hash bucket size总是等于hash表的大小，并且是一路处理器缓存大小的倍数。在减少了在内存中的存取次数后，使在处理器中加速查找hash表键值成为可能。如果hash bucket size等于一路处理器缓存的大小，那么在查找键的时候，最坏的情况下在内存中查找的次数为2。第一次是确定存储单元的地址，第二次是在存储单元中查找键 值。因此，如果Nginx给出需要增大hash max size 或 hash bucket size的提示，那么首要的是增大前一个参数的大小.</span>\n    server_names_hash_bucket_size <span>128</span><span>;</span>\n \n    <span>#客户端请求头部的缓冲区大小。这个可以根据你的系统分页大小来设置，一般一个请求的头部大小不会超过1k，不过由于一般系统分页都要大于1k，所以这里设置为分页大小。分页大小可以用命令getconf PAGESIZE取得。</span>\n    client_header_buffer_size 32k<span>;</span>\n \n    <span>#客户请求头缓冲大小。nginx默认会用client_header_buffer_size这个buffer来读取header值，如果header过大，它会使用large_client_header_buffers来读取。</span>\n    large_client_header_buffers <span>4</span> 64k<span>;</span>\n \n    <span>#设定通过nginx上传文件的大小</span>\n    client_max_body_size 8m<span>;</span>\n \n    <span>#开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载。注意：如果图片显示不正常把这个改成off。</span>\n    <span>#sendfile指令指定 nginx 是否调用sendfile 函数（zero copy 方式）来输出文件，对于普通应用，必须设为on。如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络IO处理速度，降低系统uptime。</span>\n    sendfile on<span>;</span>\n \n    <span>#开启目录列表访问，合适下载服务器，默认关闭。</span>\n    autoindex on<span>;</span>\n \n    <span>#此选项允许或禁止使用socke的TCP_CORK的选项，此选项仅在使用sendfile的时候使用</span>\n    tcp_nopush on<span>;</span>\n      \n    tcp_nodelay on<span>;</span>\n \n    <span>#长连接超时时间，单位是秒</span>\n    keepalive_timeout <span>120</span><span>;</span>\n \n    <span>#FastCGI相关参数是为了改善网站的性能：减少资源占用，提高访问速度。下面参数看字面意思都能理解。</span>\n    fastcgi_connect_timeout <span>300</span><span>;</span>\n    fastcgi_send_timeout <span>300</span><span>;</span>\n    fastcgi_read_timeout <span>300</span><span>;</span>\n    fastcgi_buffer_size 64k<span>;</span>\n    fastcgi_buffers <span>4</span> 64k<span>;</span>\n    fastcgi_busy_buffers_size 128k<span>;</span>\n    fastcgi_temp_file_write_size 128k<span>;</span>\n \n    <span>#gzip模块设置</span>\n    <span>gzip</span> on<span>;</span> <span>#开启gzip压缩输出</span>\n    gzip_min_length 1k<span>;</span>    <span>#最小压缩文件大小</span>\n    gzip_buffers <span>4</span> 16k<span>;</span>    <span>#压缩缓冲区</span>\n    gzip_http_version <span>1.0</span><span>;</span>    <span>#压缩版本（默认1.1，前端如果是squid2.5请使用1.0）</span>\n    gzip_comp_level <span>2</span><span>;</span>    <span>#压缩等级</span>\n    gzip_types text/plain application/x-javascript text/css application/xml<span>;</span>    <span>#压缩类型，默认就已经包含textml，所以下面就不用再写了，写上去也不会有问题，但是会有一个warn。</span>\n    gzip_vary on<span>;</span>\n \n    <span>#开启限制IP连接数的时候需要使用</span>\n    <span>#limit_zone crawler $binary_remote_addr 10m;</span>\n \n \n \n    <span>#负载均衡配置</span>\n    upstream piao.jd.com <span>{</span>\n      \n        <span>#upstream的负载均衡，weight是权重，可以根据机器配置定义权重。weigth参数表示权值，权值越高被分配到的几率越大。</span>\n        server <span>192.168</span>.80.121:80 <span>weight</span><span>=</span><span>3</span><span>;</span>\n        server <span>192.168</span>.80.122:80 <span>weight</span><span>=</span><span>2</span><span>;</span>\n        server <span>192.168</span>.80.123:80 <span>weight</span><span>=</span><span>3</span><span>;</span>\n \n        <span>#nginx的upstream目前支持4种方式的分配</span>\n        <span>#1、轮询（默认）</span>\n        <span>#每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。</span>\n        <span>#2、weight</span>\n        <span>#指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。</span>\n        <span>#例如：</span>\n        <span>#upstream bakend {</span>\n        <span>#    server 192.168.0.14 weight=10;</span>\n        <span>#    server 192.168.0.15 weight=10;</span>\n        <span>#}</span>\n        <span>#2、ip_hash</span>\n        <span>#每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。</span>\n        <span>#例如：</span>\n        <span>#upstream bakend {</span>\n        <span>#    ip_hash;</span>\n        <span>#    server 192.168.0.14:88;</span>\n        <span>#    server 192.168.0.15:80;</span>\n        <span>#}</span>\n        <span>#3、fair（第三方）</span>\n        <span>#按后端服务器的响应时间来分配请求，响应时间短的优先分配。</span>\n        <span>#upstream backend {</span>\n        <span>#    server server1;</span>\n        <span>#    server server2;</span>\n        <span>#    fair;</span>\n        <span>#}</span>\n        <span>#4、url_hash（第三方）</span>\n        <span>#按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。</span>\n        <span>#例：在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method是使用的hash算法</span>\n        <span>#upstream backend {</span>\n        <span>#    server squid1:3128;</span>\n        <span>#    server squid2:3128;</span>\n        <span>#    hash $request_uri;</span>\n        <span>#    hash_method crc32;</span>\n        <span>#}</span>\n \n        <span>#tips:</span>\n        <span>#upstream bakend{#定义负载均衡设备的Ip及设备状态}{</span>\n        <span>#    ip_hash;</span>\n        <span>#    server 127.0.0.1:9090 down;</span>\n        <span>#    server 127.0.0.1:8080 weight=2;</span>\n        <span>#    server 127.0.0.1:6060;</span>\n        <span>#    server 127.0.0.1:7070 backup;</span>\n        <span>#}</span>\n        <span>#在需要使用负载均衡的server中增加 proxy_pass http://bakend/;</span>\n \n        <span>#每个设备的状态设置为:</span>\n        <span>#1.down表示单前的server暂时不参与负载</span>\n        <span>#2.weight为weight越大，负载的权重就越大。</span>\n        <span>#3.max_fails：允许请求失败的次数默认为1.当超过最大次数时，返回proxy_next_upstream模块定义的错误</span>\n        <span>#4.fail_timeout:max_fails次失败后，暂停的时间。</span>\n        <span>#5.backup： 其它所有的非backup机器down或者忙的时候，请求backup机器。所以这台机器压力会最轻。</span>\n \n        <span>#nginx支持同时设置多组的负载均衡，用来给不用的server来使用。</span>\n        <span>#client_body_in_file_only设置为On 可以讲client post过来的数据记录到文件中用来做debug</span>\n        <span>#client_body_temp_path设置记录文件的目录 可以设置最多3层目录</span>\n        <span>#location对URL进行匹配.可以进行重定向或者进行新的代理 负载均衡</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br><span>111</span><br><span>112</span><br><span>113</span><br><span>114</span><br><span>115</span><br><span>116</span><br><span>117</span><br><span>118</span><br><span>119</span><br><span>120</span><br><span>121</span><br><span>122</span><br><span>123</span><br><span>124</span><br><span>125</span><br><span>126</span><br><span>127</span><br><span>128</span><br><span>129</span><br><span>130</span><br><span>131</span><br><span>132</span><br><span>133</span><br><span>134</span><br><span>135</span><br><span>136</span><br><span>137</span><br><span>138</span><br><span>139</span><br><span>140</span><br><span>141</span><br><span>142</span><br><span>143</span><br><span>144</span><br><span>145</span><br><span>146</span><br><span>147</span><br><span>148</span><br><span>149</span><br><span>150</span><br><span>151</span><br><span>152</span><br><span>153</span><br><span>154</span><br><span>155</span><br><span>156</span><br><span>157</span><br><span>158</span><br><span>159</span><br><span>160</span><br><span>161</span><br><span>162</span><br><span>163</span><br><span>164</span><br><span>165</span><br><span>166</span><br><span>167</span><br><span>168</span><br><span>169</span><br><span>170</span><br><span>171</span><br><span>172</span><br><span>173</span><br><span>174</span><br><span>175</span><br><span>176</span><br><span>177</span><br><span>178</span><br><span>179</span><br><span>180</span><br><span>181</span><br><span>182</span><br><span>183</span><br><span>184</span><br><span>185</span><br><span>186</span><br><span>187</span><br><span>188</span><br><span>189</span><br><span>190</span><br><span>191</span><br><span>192</span><br><span>193</span><br><span>194</span><br><span>195</span><br></div></div>\n            </div>\n          </div>\n          \n        </div>\n<h3 id=\"default-conf\"> default.conf</h3>\n<hr>\n<p>是<code>nginx.conf</code>中通过<code>include</code>引入的配置</p>\n<div><pre><code>include /etc/nginx/conf.d/*.conf\n</code></pre>\n<div><span>1</span><br></div></div><p>默认在<code>/etc/nginx/conf.d/</code>中</p>\n<p><code>default.conf</code>默认配置示例</p>\n\n          <div\n            id=\"code-demo-6922eb8e\"\n           \n  \n data-title=\"default.conf%E9%BB%98%E8%AE%A4%E9%85%8D%E7%BD%AE%E7%A4%BA%E4%BE%8B\"\n\n            data-code=\"%7B%22bash%22%3A%22%23%20server%E5%9D%97%5Cn%23%20listen%E4%BB%A3%E8%A1%A8Nginx%E7%9B%91%E5%90%AC%E7%9A%84%E7%AB%AF%E5%8F%A3%E5%8F%B7%5Cn%23%20server_name%E4%BB%A3%E8%A1%A8Nginx%E6%8E%A5%E5%8F%97%E8%AF%B7%E6%B1%82%E7%9A%84IP%5Cnserver%20%7B%5Cn%20%20%20%20listen%20%20%20%20%20%20%2080%3B%5Cn%20%20%20%20listen%20%20%5B%3A%3A%5D%3A80%3B%5Cn%20%20%20%20server_name%20%20localhost%3B%5Cn%5Cn%20%20%20%20%23charset%20koi8-r%3B%5Cn%20%20%20%20%23access_log%20%20%2Fvar%2Flog%2Fnginx%2Fhost.access.log%20%20main%3B%5Cn%5Cn%5Cn%20%20%20%20%23location%E5%9D%97%5Cn%20%20%20%20%23%20root%3A%E5%B0%86%E6%8E%A5%E5%8F%97%E5%88%B0%E7%9A%84%E8%AF%B7%E6%B1%82%E6%A0%B9%E6%8D%AE%2Fusr%2Fshare%2Fnginx%2Fhtml%E5%8E%BB%E6%9F%A5%E6%89%BE%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%5Cn%20%20%20%20%23%20index%3A%E9%BB%98%E8%AE%A4%E5%8E%BB%E4%B8%8A%E8%BF%B0%E7%9A%84%E8%B7%AF%E5%BE%84%E4%B8%AD%E6%89%BE%E5%88%B0index.html%E6%88%96index.htm%5Cn%20%20%20%20location%20%2F%20%7B%5Cn%20%20%20%20%20%20%20%20root%20%20%20%2Fusr%2Fshare%2Fnginx%2Fhtml%3B%5Cn%20%20%20%20%20%20%20%20index%20%20index.html%20index.htm%3B%5Cn%20%20%20%20%7D%5Cn%5Cn%20%20%20%20%23error_page%20%20404%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F404.html%3B%5Cn%5Cn%20%20%20%20%23%20redirect%20server%20error%20pages%20to%20the%20static%20page%20%2F50x.html%5Cn%20%20%20%20%23%5Cn%20%20%20%20error_page%20%20%20500%20502%20503%20504%20%20%2F50x.html%3B%5Cn%20%20%20%20location%20%3D%20%2F50x.html%20%7B%5Cn%20%20%20%20%20%20%20%20root%20%20%20%2Fusr%2Fshare%2Fnginx%2Fhtml%3B%5Cn%20%20%20%20%7D%5Cn%5Cn%20%20%20%20%23%20proxy%20the%20PHP%20scripts%20to%20Apache%20listening%20on%20127.0.0.1%3A80%5Cn%20%20%20%20%23%5Cn%20%20%20%20%23location%20~%20%5C%5C.php%24%20%7B%5Cn%20%20%20%20%23%20%20%20%20proxy_pass%20%20%20http%3A%2F%2F127.0.0.1%3B%5Cn%20%20%20%20%23%7D%5Cn%5Cn%20%20%20%20%23%20pass%20the%20PHP%20scripts%20to%20FastCGI%20server%20listening%20on%20127.0.0.1%3A9000%5Cn%20%20%20%20%23%5Cn%20%20%20%20%23location%20~%20%5C%5C.php%24%20%7B%5Cn%20%20%20%20%23%20%20%20%20root%20%20%20%20%20%20%20%20%20%20%20html%3B%5Cn%20%20%20%20%23%20%20%20%20fastcgi_pass%20%20%20127.0.0.1%3A9000%3B%5Cn%20%20%20%20%23%20%20%20%20fastcgi_index%20%20index.php%3B%5Cn%20%20%20%20%23%20%20%20%20fastcgi_param%20%20SCRIPT_FILENAME%20%20%2Fscripts%24fastcgi_script_name%3B%5Cn%20%20%20%20%23%20%20%20%20include%20%20%20%20%20%20%20%20fastcgi_params%3B%5Cn%20%20%20%20%23%7D%5Cn%5Cn%20%20%20%20%23%20deny%20access%20to%20.htaccess%20files%2C%20if%20Apache's%20document%20root%5Cn%20%20%20%20%23%20concurs%20with%20nginx's%20one%5Cn%20%20%20%20%23%5Cn%20%20%20%20%23location%20~%20%2F%5C%5C.ht%20%7B%5Cn%20%20%20%20%23%20%20%20%20deny%20%20all%3B%5Cn%20%20%20%20%23%7D%5Cn%7D%5Cn%5Cn%22%7D\"\n          >\n              \n              <div>\n                <div>\n<div><pre><code><span># server块</span>\n<span># listen代表Nginx监听的端口号</span>\n<span># server_name代表Nginx接受请求的IP</span>\nserver <span>{</span>\n    listen       <span>80</span><span>;</span>\n    listen  <span>[</span>::<span>]</span>:80<span>;</span>\n    server_name  localhost<span>;</span>\n\n    <span>#charset koi8-r;</span>\n    <span>#access_log  /var/log/nginx/host.access.log  main;</span>\n\n\n    <span>#location块</span>\n    <span># root:将接受到的请求根据/usr/share/nginx/html去查找静态资源</span>\n    <span># index:默认去上述的路径中找到index.html或index.htm</span>\n    location / <span>{</span>\n        root   /usr/share/nginx/html<span>;</span>\n        index  index.html index.htm<span>;</span>\n    <span>}</span>\n\n    <span>#error_page  404              /404.html;</span>\n\n    <span># redirect server error pages to the static page /50x.html</span>\n    <span>#</span>\n    error_page   <span>500</span> <span>502</span> <span>503</span> <span>504</span>  /50x.html<span>;</span>\n    location <span>=</span> /50x.html <span>{</span>\n        root   /usr/share/nginx/html<span>;</span>\n    <span>}</span>\n\n    <span># proxy the PHP scripts to Apache listening on 127.0.0.1:80</span>\n    <span>#</span>\n    <span>#location ~ \\.php$ {</span>\n    <span>#    proxy_pass   http://127.0.0.1;</span>\n    <span>#}</span>\n\n    <span># pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span>\n    <span>#</span>\n    <span>#location ~ \\.php$ {</span>\n    <span>#    root           html;</span>\n    <span>#    fastcgi_pass   127.0.0.1:9000;</span>\n    <span>#    fastcgi_index  index.php;</span>\n    <span>#    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</span>\n    <span>#    include        fastcgi_params;</span>\n    <span>#}</span>\n\n    <span># deny access to .htaccess files, if Apache's document root</span>\n    <span># concurs with nginx's one</span>\n    <span>#</span>\n    <span>#location ~ /\\.ht {</span>\n    <span>#    deny  all;</span>\n    <span>#}</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br></div></div>\n            </div>\n          </div>\n          \n        </div>\n<p><strong><code>default.conf</code>详细配置示例</strong></p>\n\n          <div\n            id=\"code-demo-d18f4338\"\n           \n  \n data-title=\"default.conf%E8%AF%A6%E7%BB%86%E9%85%8D%E7%BD%AE%E7%A4%BA%E4%BE%8B\"\n\n            data-code=\"%7B%22bash%22%3A%22%20%20%20%20server%5Cn%20%20%20%20%7B%5Cn%20%20%20%20%20%20%20%20%23%E7%9B%91%E5%90%AC%E7%AB%AF%E5%8F%A3%5Cn%20%20%20%20%20%20%20%20listen%2080%3B%5Cn%20%5Cn%20%20%20%20%20%20%20%20%23%E5%9F%9F%E5%90%8D%E5%8F%AF%E4%BB%A5%E6%9C%89%E5%A4%9A%E4%B8%AA%EF%BC%8C%E7%94%A8%E7%A9%BA%E6%A0%BC%E9%9A%94%E5%BC%80%5Cn%20%20%20%20%20%20%20%20server_name%20www.jd.com%20jd.com%3B%5Cn%20%20%20%20%20%20%20%20index%20index.html%20index.htm%20index.php%3B%5Cn%20%20%20%20%20%20%20%20root%20%2Fdata%2Fwww%2Fjd%3B%5Cn%20%5Cn%20%20%20%20%20%20%20%20%23%E5%AF%B9******%E8%BF%9B%E8%A1%8C%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%5Cn%20%20%20%20%20%20%20%20location%20~%20.*.(php%7Cphp5)%3F%24%5Cn%20%20%20%20%20%20%20%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20fastcgi_pass%20127.0.0.1%3A9000%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20fastcgi_index%20index.php%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20include%20fastcgi.conf%3B%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20%20%20%5Cn%20%20%20%20%20%20%20%20%23%E5%9B%BE%E7%89%87%E7%BC%93%E5%AD%98%E6%97%B6%E9%97%B4%E8%AE%BE%E7%BD%AE%5Cn%20%20%20%20%20%20%20%20location%20~%20.*.(gif%7Cjpg%7Cjpeg%7Cpng%7Cbmp%7Cswf)%24%5Cn%20%20%20%20%20%20%20%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20expires%2010d%3B%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20%20%20%5Cn%20%20%20%20%20%20%20%20%23JS%E5%92%8CCSS%E7%BC%93%E5%AD%98%E6%97%B6%E9%97%B4%E8%AE%BE%E7%BD%AE%5Cn%20%20%20%20%20%20%20%20location%20~%20.*.(js%7Ccss)%3F%24%5Cn%20%20%20%20%20%20%20%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20expires%201h%3B%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20%20%20%5Cn%20%20%20%20%20%20%20%20%23%E6%97%A5%E5%BF%97%E6%A0%BC%E5%BC%8F%E8%AE%BE%E5%AE%9A%5Cn%20%20%20%20%20%20%20%20%23%24remote_addr%E4%B8%8E%24http_x_forwarded_for%E7%94%A8%E4%BB%A5%E8%AE%B0%E5%BD%95%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84ip%E5%9C%B0%E5%9D%80%EF%BC%9B%5Cn%20%20%20%20%20%20%20%20%23%24remote_user%EF%BC%9A%E7%94%A8%E6%9D%A5%E8%AE%B0%E5%BD%95%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%94%A8%E6%88%B7%E5%90%8D%E7%A7%B0%EF%BC%9B%5Cn%20%20%20%20%20%20%20%20%23%24time_local%EF%BC%9A%20%E7%94%A8%E6%9D%A5%E8%AE%B0%E5%BD%95%E8%AE%BF%E9%97%AE%E6%97%B6%E9%97%B4%E4%B8%8E%E6%97%B6%E5%8C%BA%EF%BC%9B%5Cn%20%20%20%20%20%20%20%20%23%24request%EF%BC%9A%20%E7%94%A8%E6%9D%A5%E8%AE%B0%E5%BD%95%E8%AF%B7%E6%B1%82%E7%9A%84url%E4%B8%8Ehttp%E5%8D%8F%E8%AE%AE%EF%BC%9B%5Cn%20%20%20%20%20%20%20%20%23%24status%EF%BC%9A%20%E7%94%A8%E6%9D%A5%E8%AE%B0%E5%BD%95%E8%AF%B7%E6%B1%82%E7%8A%B6%E6%80%81%EF%BC%9B%E6%88%90%E5%8A%9F%E6%98%AF200%EF%BC%8C%5Cn%20%20%20%20%20%20%20%20%23%24body_bytes_sent%20%EF%BC%9A%E8%AE%B0%E5%BD%95%E5%8F%91%E9%80%81%E7%BB%99%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%96%87%E4%BB%B6%E4%B8%BB%E4%BD%93%E5%86%85%E5%AE%B9%E5%A4%A7%E5%B0%8F%EF%BC%9B%5Cn%20%20%20%20%20%20%20%20%23%24http_referer%EF%BC%9A%E7%94%A8%E6%9D%A5%E8%AE%B0%E5%BD%95%E4%BB%8E%E9%82%A3%E4%B8%AA%E9%A1%B5%E9%9D%A2%E9%93%BE%E6%8E%A5%E8%AE%BF%E9%97%AE%E8%BF%87%E6%9D%A5%E7%9A%84%EF%BC%9B%5Cn%20%20%20%20%20%20%20%20%23%24http_user_agent%EF%BC%9A%E8%AE%B0%E5%BD%95%E5%AE%A2%E6%88%B7%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF%EF%BC%9B%5Cn%20%20%20%20%20%20%20%20%23%E9%80%9A%E5%B8%B8web%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%94%BE%E5%9C%A8%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E7%9A%84%E5%90%8E%E9%9D%A2%EF%BC%8C%E8%BF%99%E6%A0%B7%E5%B0%B1%E4%B8%8D%E8%83%BD%E8%8E%B7%E5%8F%96%E5%88%B0%E5%AE%A2%E6%88%B7%E7%9A%84IP%E5%9C%B0%E5%9D%80%E4%BA%86%EF%BC%8C%E9%80%9A%E8%BF%87%24remote_add%E6%8B%BF%E5%88%B0%E7%9A%84IP%E5%9C%B0%E5%9D%80%E6%98%AF%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84iP%E5%9C%B0%E5%9D%80%E3%80%82%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9C%A8%E8%BD%AC%E5%8F%91%E8%AF%B7%E6%B1%82%E7%9A%84http%E5%A4%B4%E4%BF%A1%E6%81%AF%E4%B8%AD%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%A2%9E%E5%8A%A0x_forwarded_for%E4%BF%A1%E6%81%AF%EF%BC%8C%E7%94%A8%E4%BB%A5%E8%AE%B0%E5%BD%95%E5%8E%9F%E6%9C%89%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84IP%E5%9C%B0%E5%9D%80%E5%92%8C%E5%8E%9F%E6%9D%A5%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E8%AF%B7%E6%B1%82%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9C%B0%E5%9D%80%E3%80%82%5Cn%20%20%20%20%20%20%20%20log_format%20access%20'%24remote_addr%20-%20%24remote_user%20%5B%24time_local%5D%20%5C%22%24request%5C%22%20'%5Cn%20%20%20%20%20%20%20%20'%24status%20%24body_bytes_sent%20%5C%22%24http_referer%5C%22%20'%5Cn%20%20%20%20%20%20%20%20'%5C%22%24http_user_agent%5C%22%20%24http_x_forwarded_for'%3B%5Cn%20%20%20%20%20%20%20%20%20%20%5Cn%20%20%20%20%20%20%20%20%23%E5%AE%9A%E4%B9%89%E6%9C%AC%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA%E7%9A%84%E8%AE%BF%E9%97%AE%E6%97%A5%E5%BF%97%5Cn%20%20%20%20%20%20%20%20access_log%20%20%2Fusr%2Flocal%2Fnginx%2Flogs%2Fhost.access.log%20%20main%3B%5Cn%20%20%20%20%20%20%20%20access_log%20%20%2Fusr%2Flocal%2Fnginx%2Flogs%2Fhost.access.404.log%20%20log404%3B%5Cn%20%20%20%20%20%20%20%20%20%20%5Cn%20%20%20%20%20%20%20%20%23%E5%AF%B9%20%5C%22%2F%5C%22%20%E5%90%AF%E7%94%A8%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%5Cn%20%20%20%20%20%20%20%20location%20%2F%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20proxy_pass%20http%3A%2F%2F127.0.0.1%3A88%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20proxy_redirect%20off%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20proxy_set_header%20X-Real-IP%20%24remote_addr%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%23%E5%90%8E%E7%AB%AF%E7%9A%84Web%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87X-Forwarded-For%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E7%9C%9F%E5%AE%9EIP%5Cn%20%20%20%20%20%20%20%20%20%20%20%20proxy_set_header%20X-Forwarded-For%20%24proxy_add_x_forwarded_for%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%23%E4%BB%A5%E4%B8%8B%E6%98%AF%E4%B8%80%E4%BA%9B%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E7%9A%84%E9%85%8D%E7%BD%AE%EF%BC%8C%E5%8F%AF%E9%80%89%E3%80%82%5Cn%20%20%20%20%20%20%20%20%20%20%20%20proxy_set_header%20Host%20%24host%3B%5Cn%20%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%23%E5%85%81%E8%AE%B8%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AF%B7%E6%B1%82%E7%9A%84%E6%9C%80%E5%A4%A7%E5%8D%95%E6%96%87%E4%BB%B6%E5%AD%97%E8%8A%82%E6%95%B0%5Cn%20%20%20%20%20%20%20%20%20%20%20%20client_max_body_size%2010m%3B%5Cn%20%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%23%E7%BC%93%E5%86%B2%E5%8C%BA%E4%BB%A3%E7%90%86%E7%BC%93%E5%86%B2%E7%94%A8%E6%88%B7%E7%AB%AF%E8%AF%B7%E6%B1%82%E7%9A%84%E6%9C%80%E5%A4%A7%E5%AD%97%E8%8A%82%E6%95%B0%EF%BC%8C%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%23%E5%A6%82%E6%9E%9C%E6%8A%8A%E5%AE%83%E8%AE%BE%E7%BD%AE%E4%B8%BA%E6%AF%94%E8%BE%83%E5%A4%A7%E7%9A%84%E6%95%B0%E5%80%BC%EF%BC%8C%E4%BE%8B%E5%A6%82256k%EF%BC%8C%E9%82%A3%E4%B9%88%EF%BC%8C%E6%97%A0%E8%AE%BA%E4%BD%BF%E7%94%A8firefox%E8%BF%98%E6%98%AFIE%E6%B5%8F%E8%A7%88%E5%99%A8%EF%BC%8C%E6%9D%A5%E6%8F%90%E4%BA%A4%E4%BB%BB%E6%84%8F%E5%B0%8F%E4%BA%8E256k%E7%9A%84%E5%9B%BE%E7%89%87%EF%BC%8C%E9%83%BD%E5%BE%88%E6%AD%A3%E5%B8%B8%E3%80%82%E5%A6%82%E6%9E%9C%E6%B3%A8%E9%87%8A%E8%AF%A5%E6%8C%87%E4%BB%A4%EF%BC%8C%E4%BD%BF%E7%94%A8%E9%BB%98%E8%AE%A4%E7%9A%84client_body_buffer_size%E8%AE%BE%E7%BD%AE%EF%BC%8C%E4%B9%9F%E5%B0%B1%E6%98%AF%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%A1%B5%E9%9D%A2%E5%A4%A7%E5%B0%8F%E7%9A%84%E4%B8%A4%E5%80%8D%EF%BC%8C8k%E6%88%96%E8%80%8516k%EF%BC%8C%E9%97%AE%E9%A2%98%E5%B0%B1%E5%87%BA%E7%8E%B0%E4%BA%86%E3%80%82%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%23%E6%97%A0%E8%AE%BA%E4%BD%BF%E7%94%A8firefox4.0%E8%BF%98%E6%98%AFIE8.0%EF%BC%8C%E6%8F%90%E4%BA%A4%E4%B8%80%E4%B8%AA%E6%AF%94%E8%BE%83%E5%A4%A7%EF%BC%8C200k%E5%B7%A6%E5%8F%B3%E7%9A%84%E5%9B%BE%E7%89%87%EF%BC%8C%E9%83%BD%E8%BF%94%E5%9B%9E500%20Internal%20Server%20Error%E9%94%99%E8%AF%AF%5Cn%20%20%20%20%20%20%20%20%20%20%20%20client_body_buffer_size%20128k%3B%5Cn%20%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%23%E8%A1%A8%E7%A4%BA%E4%BD%BFnginx%E9%98%BB%E6%AD%A2HTTP%E5%BA%94%E7%AD%94%E4%BB%A3%E7%A0%81%E4%B8%BA400%E6%88%96%E8%80%85%E6%9B%B4%E9%AB%98%E7%9A%84%E5%BA%94%E7%AD%94%E3%80%82%5Cn%20%20%20%20%20%20%20%20%20%20%20%20proxy_intercept_errors%20on%3B%5Cn%20%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%23%E5%90%8E%E7%AB%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%9E%E6%8E%A5%E7%9A%84%E8%B6%85%E6%97%B6%E6%97%B6%E9%97%B4_%E5%8F%91%E8%B5%B7%E6%8F%A1%E6%89%8B%E7%AD%89%E5%80%99%E5%93%8D%E5%BA%94%E8%B6%85%E6%97%B6%E6%97%B6%E9%97%B4%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%23nginx%E8%B7%9F%E5%90%8E%E7%AB%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%9E%E6%8E%A5%E8%B6%85%E6%97%B6%E6%97%B6%E9%97%B4(%E4%BB%A3%E7%90%86%E8%BF%9E%E6%8E%A5%E8%B6%85%E6%97%B6)%5Cn%20%20%20%20%20%20%20%20%20%20%20%20proxy_connect_timeout%2090%3B%5Cn%20%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%23%E5%90%8E%E7%AB%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%95%B0%E6%8D%AE%E5%9B%9E%E4%BC%A0%E6%97%B6%E9%97%B4(%E4%BB%A3%E7%90%86%E5%8F%91%E9%80%81%E8%B6%85%E6%97%B6)%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%23%E5%90%8E%E7%AB%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%95%B0%E6%8D%AE%E5%9B%9E%E4%BC%A0%E6%97%B6%E9%97%B4_%E5%B0%B1%E6%98%AF%E5%9C%A8%E8%A7%84%E5%AE%9A%E6%97%B6%E9%97%B4%E4%B9%8B%E5%86%85%E5%90%8E%E7%AB%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BF%85%E9%A1%BB%E4%BC%A0%E5%AE%8C%E6%89%80%E6%9C%89%E7%9A%84%E6%95%B0%E6%8D%AE%5Cn%20%20%20%20%20%20%20%20%20%20%20%20proxy_send_timeout%2090%3B%5Cn%20%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%23%E8%BF%9E%E6%8E%A5%E6%88%90%E5%8A%9F%E5%90%8E%EF%BC%8C%E5%90%8E%E7%AB%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4(%E4%BB%A3%E7%90%86%E6%8E%A5%E6%94%B6%E8%B6%85%E6%97%B6)%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%23%E8%BF%9E%E6%8E%A5%E6%88%90%E5%8A%9F%E5%90%8E_%E7%AD%89%E5%80%99%E5%90%8E%E7%AB%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4_%E5%85%B6%E5%AE%9E%E5%B7%B2%E7%BB%8F%E8%BF%9B%E5%85%A5%E5%90%8E%E7%AB%AF%E7%9A%84%E6%8E%92%E9%98%9F%E4%B9%8B%E4%B8%AD%E7%AD%89%E5%80%99%E5%A4%84%E7%90%86%EF%BC%88%E4%B9%9F%E5%8F%AF%E4%BB%A5%E8%AF%B4%E6%98%AF%E5%90%8E%E7%AB%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E7%9A%84%E6%97%B6%E9%97%B4%EF%BC%89%5Cn%20%20%20%20%20%20%20%20%20%20%20%20proxy_read_timeout%2090%3B%5Cn%20%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%23%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88nginx%EF%BC%89%E4%BF%9D%E5%AD%98%E7%94%A8%E6%88%B7%E5%A4%B4%E4%BF%A1%E6%81%AF%E7%9A%84%E7%BC%93%E5%86%B2%E5%8C%BA%E5%A4%A7%E5%B0%8F%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%23%E8%AE%BE%E7%BD%AE%E4%BB%8E%E8%A2%AB%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AF%BB%E5%8F%96%E7%9A%84%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%E5%BA%94%E7%AD%94%E7%9A%84%E7%BC%93%E5%86%B2%E5%8C%BA%E5%A4%A7%E5%B0%8F%EF%BC%8C%E9%80%9A%E5%B8%B8%E6%83%85%E5%86%B5%E4%B8%8B%E8%BF%99%E9%83%A8%E5%88%86%E5%BA%94%E7%AD%94%E4%B8%AD%E5%8C%85%E5%90%AB%E4%B8%80%E4%B8%AA%E5%B0%8F%E7%9A%84%E5%BA%94%E7%AD%94%E5%A4%B4%EF%BC%8C%E9%BB%98%E8%AE%A4%E6%83%85%E5%86%B5%E4%B8%8B%E8%BF%99%E4%B8%AA%E5%80%BC%E7%9A%84%E5%A4%A7%E5%B0%8F%E4%B8%BA%E6%8C%87%E4%BB%A4proxy_buffers%E4%B8%AD%E6%8C%87%E5%AE%9A%E7%9A%84%E4%B8%80%E4%B8%AA%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E5%A4%A7%E5%B0%8F%EF%BC%8C%E4%B8%8D%E8%BF%87%E5%8F%AF%E4%BB%A5%E5%B0%86%E5%85%B6%E8%AE%BE%E7%BD%AE%E4%B8%BA%E6%9B%B4%E5%B0%8F%5Cn%20%20%20%20%20%20%20%20%20%20%20%20proxy_buffer_size%204k%3B%5Cn%20%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%23proxy_buffers%E7%BC%93%E5%86%B2%E5%8C%BA%EF%BC%8C%E7%BD%91%E9%A1%B5%E5%B9%B3%E5%9D%87%E5%9C%A832k%E4%BB%A5%E4%B8%8B%E7%9A%84%E8%AE%BE%E7%BD%AE%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%23%E8%AE%BE%E7%BD%AE%E7%94%A8%E4%BA%8E%E8%AF%BB%E5%8F%96%E5%BA%94%E7%AD%94%EF%BC%88%E6%9D%A5%E8%87%AA%E8%A2%AB%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%89%E7%9A%84%E7%BC%93%E5%86%B2%E5%8C%BA%E6%95%B0%E7%9B%AE%E5%92%8C%E5%A4%A7%E5%B0%8F%EF%BC%8C%E9%BB%98%E8%AE%A4%E6%83%85%E5%86%B5%E4%B9%9F%E4%B8%BA%E5%88%86%E9%A1%B5%E5%A4%A7%E5%B0%8F%EF%BC%8C%E6%A0%B9%E6%8D%AE%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%B8%8D%E5%90%8C%E5%8F%AF%E8%83%BD%E6%98%AF4k%E6%88%96%E8%80%858k%5Cn%20%20%20%20%20%20%20%20%20%20%20%20proxy_buffers%204%2032k%3B%5Cn%20%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%23%E9%AB%98%E8%B4%9F%E8%8D%B7%E4%B8%8B%E7%BC%93%E5%86%B2%E5%A4%A7%E5%B0%8F%EF%BC%88proxy_buffers*2%EF%BC%89%5Cn%20%20%20%20%20%20%20%20%20%20%20%20proxy_busy_buffers_size%2064k%3B%5Cn%20%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%23%E8%AE%BE%E7%BD%AE%E5%9C%A8%E5%86%99%E5%85%A5proxy_temp_path%E6%97%B6%E6%95%B0%E6%8D%AE%E7%9A%84%E5%A4%A7%E5%B0%8F%EF%BC%8C%E9%A2%84%E9%98%B2%E4%B8%80%E4%B8%AA%E5%B7%A5%E4%BD%9C%E8%BF%9B%E7%A8%8B%E5%9C%A8%E4%BC%A0%E9%80%92%E6%96%87%E4%BB%B6%E6%97%B6%E9%98%BB%E5%A1%9E%E5%A4%AA%E9%95%BF%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%23%E8%AE%BE%E5%AE%9A%E7%BC%93%E5%AD%98%E6%96%87%E4%BB%B6%E5%A4%B9%E5%A4%A7%E5%B0%8F%EF%BC%8C%E5%A4%A7%E4%BA%8E%E8%BF%99%E4%B8%AA%E5%80%BC%EF%BC%8C%E5%B0%86%E4%BB%8Eupstream%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BC%A0%5Cn%20%20%20%20%20%20%20%20%20%20%20%20proxy_temp_file_write_size%2064k%3B%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20%20%20%5Cn%20%20%20%20%20%20%20%20%20%20%5Cn%20%20%20%20%20%20%20%20%23%E8%AE%BE%E5%AE%9A%E6%9F%A5%E7%9C%8BNginx%E7%8A%B6%E6%80%81%E7%9A%84%E5%9C%B0%E5%9D%80%5Cn%20%20%20%20%20%20%20%20location%20%2FNginxStatus%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20stub_status%20on%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20access_log%20on%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20auth_basic%20%5C%22NginxStatus%5C%22%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20auth_basic_user_file%20confpasswd%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%23htpasswd%E6%96%87%E4%BB%B6%E7%9A%84%E5%86%85%E5%AE%B9%E5%8F%AF%E4%BB%A5%E7%94%A8apache%E6%8F%90%E4%BE%9B%E7%9A%84htpasswd%E5%B7%A5%E5%85%B7%E6%9D%A5%E4%BA%A7%E7%94%9F%E3%80%82%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20%20%20%5Cn%20%20%20%20%20%20%20%20%23%E6%9C%AC%E5%9C%B0%E5%8A%A8%E9%9D%99%E5%88%86%E7%A6%BB%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E9%85%8D%E7%BD%AE%5Cn%20%20%20%20%20%20%20%20%23%E6%89%80%E6%9C%89jsp%E7%9A%84%E9%A1%B5%E9%9D%A2%E5%9D%87%E4%BA%A4%E7%94%B1tomcat%E6%88%96resin%E5%A4%84%E7%90%86%5Cn%20%20%20%20%20%20%20%20location%20~%20.(jsp%7Cjspx%7Cdo)%3F%24%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20proxy_set_header%20Host%20%24host%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20proxy_set_header%20X-Real-IP%20%24remote_addr%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20proxy_set_header%20X-Forwarded-For%20%24proxy_add_x_forwarded_for%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20proxy_pass%20http%3A%2F%2F127.0.0.1%3A8080%3B%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20%20%20%5Cn%20%20%20%20%20%20%20%20%23%E6%89%80%E6%9C%89%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E7%94%B1nginx%E7%9B%B4%E6%8E%A5%E8%AF%BB%E5%8F%96%E4%B8%8D%E7%BB%8F%E8%BF%87tomcat%E6%88%96resin%5Cn%20%20%20%20%20%20%20%20location%20~%20.*.(htm%7Chtml%7Cgif%7Cjpg%7Cjpeg%7Cpng%7Cbmp%7Cswf%7Cioc%7Crar%7Czip%7Ctxt%7Cflv%7Cmid%7Cdoc%7Cppt%7C%5Cn%20%20%20%20%20%20%20%20pdf%7Cxls%7Cmp3%7Cwma)%24%5Cn%20%20%20%20%20%20%20%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20expires%2015d%3B%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20%20%20%5Cn%20%20%20%20%20%20%20%20location%20~%20.*.(js%7Ccss)%3F%24%5Cn%20%20%20%20%20%20%20%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20expires%201h%3B%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%7D%5Cn%7D%5Cn%22%7D\"\n          >\n              \n              <div>\n                <div>\n<div><pre><code>    server\n    <span>{</span>\n        <span>#监听端口</span>\n        listen <span>80</span><span>;</span>\n \n        <span>#域名可以有多个，用空格隔开</span>\n        server_name www.jd.com jd.com<span>;</span>\n        index index.html index.htm index.php<span>;</span>\n        root /data/www/jd<span>;</span>\n \n        <span>#对******进行负载均衡</span>\n        location ~ .*.<span>(</span>php<span>|</span>php5<span>)</span>?$\n        <span>{</span>\n            fastcgi_pass <span>127.0</span>.0.1:9000<span>;</span>\n            fastcgi_index index.php<span>;</span>\n            include fastcgi.conf<span>;</span>\n        <span>}</span>\n          \n        <span>#图片缓存时间设置</span>\n        location ~ .*.<span>(</span>gif<span>|</span>jpg<span>|</span>jpeg<span>|</span>png<span>|</span>bmp<span>|</span>swf<span>)</span>$\n        <span>{</span>\n            expires 10d<span>;</span>\n        <span>}</span>\n          \n        <span>#JS和CSS缓存时间设置</span>\n        location ~ .*.<span>(</span>js<span>|</span>css<span>)</span>?$\n        <span>{</span>\n            expires 1h<span>;</span>\n        <span>}</span>\n          \n        <span>#日志格式设定</span>\n        <span>#$remote_addr与$http_x_forwarded_for用以记录客户端的ip地址；</span>\n        <span>#$remote_user：用来记录客户端用户名称；</span>\n        <span>#$time_local： 用来记录访问时间与时区；</span>\n        <span>#$request： 用来记录请求的url与http协议；</span>\n        <span>#$status： 用来记录请求状态；成功是200，</span>\n        <span>#$body_bytes_sent ：记录发送给客户端文件主体内容大小；</span>\n        <span>#$http_referer：用来记录从那个页面链接访问过来的；</span>\n        <span>#$http_user_agent：记录客户浏览器的相关信息；</span>\n        <span>#通常web服务器放在反向代理的后面，这样就不能获取到客户的IP地址了，通过$remote_add拿到的IP地址是反向代理服务器的iP地址。反向代理服务器在转发请求的http头信息中，可以增加x_forwarded_for信息，用以记录原有客户端的IP地址和原来客户端的请求的服务器地址。</span>\n        log_format access <span>'$remote_addr - $remote_user [$time_local] \"$request\" '</span>\n        <span>'$status $body_bytes_sent \"$http_referer\" '</span>\n        <span>'\"$http_user_agent\" $http_x_forwarded_for'</span><span>;</span>\n          \n        <span>#定义本虚拟主机的访问日志</span>\n        access_log  /usr/local/nginx/logs/host.access.log  main<span>;</span>\n        access_log  /usr/local/nginx/logs/host.access.404.log  log404<span>;</span>\n          \n        <span>#对 \"/\" 启用反向代理</span>\n        location / <span>{</span>\n            proxy_pass http://127.0.0.1:88<span>;</span>\n            proxy_redirect off<span>;</span>\n            proxy_set_header X-Real-IP <span>$remote_addr</span><span>;</span>\n              \n            <span>#后端的Web服务器可以通过X-Forwarded-For获取用户真实IP</span>\n            proxy_set_header X-Forwarded-For <span>$proxy_add_x_forwarded_for</span><span>;</span>\n              \n            <span>#以下是一些反向代理的配置，可选。</span>\n            proxy_set_header Host <span>$host</span><span>;</span>\n \n            <span>#允许客户端请求的最大单文件字节数</span>\n            client_max_body_size 10m<span>;</span>\n \n            <span>#缓冲区代理缓冲用户端请求的最大字节数，</span>\n            <span>#如果把它设置为比较大的数值，例如256k，那么，无论使用firefox还是IE浏览器，来提交任意小于256k的图片，都很正常。如果注释该指令，使用默认的client_body_buffer_size设置，也就是操作系统页面大小的两倍，8k或者16k，问题就出现了。</span>\n            <span>#无论使用firefox4.0还是IE8.0，提交一个比较大，200k左右的图片，都返回500 Internal Server Error错误</span>\n            client_body_buffer_size 128k<span>;</span>\n \n            <span>#表示使nginx阻止HTTP应答代码为400或者更高的应答。</span>\n            proxy_intercept_errors on<span>;</span>\n \n            <span>#后端服务器连接的超时时间_发起握手等候响应超时时间</span>\n            <span>#nginx跟后端服务器连接超时时间(代理连接超时)</span>\n            proxy_connect_timeout <span>90</span><span>;</span>\n \n            <span>#后端服务器数据回传时间(代理发送超时)</span>\n            <span>#后端服务器数据回传时间_就是在规定时间之内后端服务器必须传完所有的数据</span>\n            proxy_send_timeout <span>90</span><span>;</span>\n \n            <span>#连接成功后，后端服务器响应时间(代理接收超时)</span>\n            <span>#连接成功后_等候后端服务器响应时间_其实已经进入后端的排队之中等候处理（也可以说是后端服务器处理请求的时间）</span>\n            proxy_read_timeout <span>90</span><span>;</span>\n \n            <span>#设置代理服务器（nginx）保存用户头信息的缓冲区大小</span>\n            <span>#设置从被代理服务器读取的第一部分应答的缓冲区大小，通常情况下这部分应答中包含一个小的应答头，默认情况下这个值的大小为指令proxy_buffers中指定的一个缓冲区的大小，不过可以将其设置为更小</span>\n            proxy_buffer_size 4k<span>;</span>\n \n            <span>#proxy_buffers缓冲区，网页平均在32k以下的设置</span>\n            <span>#设置用于读取应答（来自被代理服务器）的缓冲区数目和大小，默认情况也为分页大小，根据操作系统的不同可能是4k或者8k</span>\n            proxy_buffers <span>4</span> 32k<span>;</span>\n \n            <span>#高负荷下缓冲大小（proxy_buffers*2）</span>\n            proxy_busy_buffers_size 64k<span>;</span>\n \n            <span>#设置在写入proxy_temp_path时数据的大小，预防一个工作进程在传递文件时阻塞太长</span>\n            <span>#设定缓存文件夹大小，大于这个值，将从upstream服务器传</span>\n            proxy_temp_file_write_size 64k<span>;</span>\n        <span>}</span>\n          \n          \n        <span>#设定查看Nginx状态的地址</span>\n        location /NginxStatus <span>{</span>\n            stub_status on<span>;</span>\n            access_log on<span>;</span>\n            auth_basic <span>\"NginxStatus\"</span><span>;</span>\n            auth_basic_user_file confpasswd<span>;</span>\n            <span>#htpasswd文件的内容可以用apache提供的htpasswd工具来产生。</span>\n        <span>}</span>\n          \n        <span>#本地动静分离反向代理配置</span>\n        <span>#所有jsp的页面均交由tomcat或resin处理</span>\n        location ~ .<span>(</span>jsp<span>|</span>jspx<span>|</span><span>do</span><span>)</span>?$ <span>{</span>\n            proxy_set_header Host <span>$host</span><span>;</span>\n            proxy_set_header X-Real-IP <span>$remote_addr</span><span>;</span>\n            proxy_set_header X-Forwarded-For <span>$proxy_add_x_forwarded_for</span><span>;</span>\n            proxy_pass http://127.0.0.1:8080<span>;</span>\n        <span>}</span>\n          \n        <span>#所有静态文件由nginx直接读取不经过tomcat或resin</span>\n        location ~ .*.<span>(</span>htm<span>|</span>html<span>|</span>gif<span>|</span>jpg<span>|</span>jpeg<span>|</span>png<span>|</span>bmp<span>|</span>swf<span>|</span>ioc<span>|</span><span>rar</span><span>|</span><span>zip</span><span>|</span>txt<span>|</span>flv<span>|</span>mid<span>|</span>doc<span>|</span>ppt<span>|</span>\n        pdf<span>|</span>xls<span>|</span>mp3<span>|</span>wma<span>)</span>$\n        <span>{</span>\n            expires 15d<span>;</span>\n        <span>}</span>\n          \n        location ~ .*.<span>(</span>js<span>|</span>css<span>)</span>?$\n        <span>{</span>\n            expires 1h<span>;</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br><span>111</span><br><span>112</span><br><span>113</span><br><span>114</span><br><span>115</span><br><span>116</span><br><span>117</span><br><span>118</span><br><span>119</span><br><span>120</span><br><span>121</span><br><span>122</span><br><span>123</span><br><span>124</span><br><span>125</span><br><span>126</span><br><span>127</span><br><span>128</span><br><span>129</span><br><span>130</span><br><span>131</span><br></div></div>\n            </div>\n          </div>\n          \n        </div>\n<h2 id=\"nginx集群\"> Nginx集群</h2>\n<p>单点故障，避免nginx的宕机，导致整个程序的崩溃</p>\n<p>准备</p>\n<div><p>准备</p>\n<ul>\n<li>准备多台Nginx</li>\n<li>准备<code>keepalived</code>，监听nginx的健康情况</li>\n<li>准备<code>haproxy</code>，提供一个虚拟的路径，统一的去接收用户的请求</li>\n</ul>\n</div>\n<p><img src=\"./images/Nginx-basicNote&deployment/nginx-cluster.png\" alt=\"nginx集群\" /></p>\n<h2 id=\"grafana-prometheus监控-docker\"> Grafana+Prometheus监控(docker)</h2>\n<div><p>参考</p>\n<ul>\n<li>https://www.cnblogs.com/xiao987334176/p/12870942.html</li>\n</ul>\n</div>\n",
      "date_published": "2020-12-19T16:07:12.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": []
    },
    {
      "title": "Nginx学习目录",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/nginx/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/nginx/",
      "content_html": "<h2 id=\"参考\"> 参考</h2>\n<div><p>参考</p>\n<ul>\n<li><a href=\"https://www.w3cschool.cn/nginxsysc/\" target=\"_blank\" rel=\"noopener noreferrer\">W3CSCHOOL-Nginx使用手册</a></li>\n<li><a href=\"https://blog.csdn.net/m0_49558851/article/details/107786372\" target=\"_blank\" rel=\"noopener noreferrer\">Nginx学习笔记 基于docker</a></li>\n<li><a href=\"https://www.jianshu.com/p/e90050dc89b6\" target=\"_blank\" rel=\"noopener noreferrer\">当初我要是这么学习Nginx就好了！多图详解</a></li>\n<li><a href=\"https://blog.csdn.net/yujing1314/article/details/107000737\" target=\"_blank\" rel=\"noopener noreferrer\">搞懂Nginx一篇文章就够了</a></li>\n<li><a href=\"https://www.runoob.com/w3cnote/nginx-setup-intro.html\" target=\"_blank\" rel=\"noopener noreferrer\">Nginx 配置详解</a></li>\n<li><a href=\"https://www.nginx.cn/nginx-how-to\" target=\"_blank\" rel=\"noopener noreferrer\">nginx中文手册</a></li>\n<li><a href=\"https://blog.csdn.net/u011863024/article/details/107407905\" target=\"_blank\" rel=\"noopener noreferrer\">尚硅谷Nginx教程(nginx快速上手)笔记</a></li>\n</ul>\n</div>\n<p>视频教程</p>\n<div><p>参考</p>\n<ul>\n<li><a href=\"https://www.bilibili.com/video/BV1zJ411w7SV\" target=\"_blank\" rel=\"noopener noreferrer\">尚硅谷Nginx教程(nginx快速上手)</a></li>\n<li><a href=\"https://www.bilibili.com/video/BV1W54y1z7GM\" target=\"_blank\" rel=\"noopener noreferrer\">千锋教育-2020最新 Nginx教程全面讲解（Nginx快速上手）</a></li>\n</ul>\n</div>\n<h2 id=\"笔记目录\"> 笔记目录</h2>\n<div><p>笔记目录</p>\n<ul>\n<li><a href=\"Nginx-basicNote&amp;deployment\">Nginx基础笔记和安装配置</a></li>\n<li><a href=\"Nginx-LoadBalance\">Nginx-负载均衡</a></li>\n<li><a href=\"Nginx-ReverseProxy\">Nginx-反向代理</a></li>\n<li><a href=\"Nginx-Dynamic&amp;static\">Nginx-动静分离</a></li>\n</ul>\n</div>\n",
      "date_published": "2020-11-25T22:10:27.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": []
    },
    {
      "title": "修改Host以访问Github",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/other/Modify-Host-to-access-Github/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/other/Modify-Host-to-access-Github/",
      "summary": "修改Host以访问Github",
      "content_html": "<p>修改文件：C:\\Windows\\System32\\drivers\\etc\\HOST</p>\n<div><pre><code># Github\n192.30.253.113 github.com\n151.101.185.194 github.global.ssl.fastly.net\n203.98.7.65 gist.github.com\n13.229.189.0 codeload.github.com\n185.199.109.153 desktop.github.com \n185.199.108.153 guides.github.com  \n185.199.108.153 blog.github.com\n18.204.240.114 status.github.com\n185.199.108.153 developer.github.com\n185.199.108.153 services.github.com\n192.30.253.175 enterprise.github.com   \n34.195.49.195 education.github.com    \n185.199.108.153 pages.github.com  \n34.196.237.103 classroom.github.com\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>然后cmd用<code>ipconfig/flushdns</code>刷新</p>\n",
      "date_published": "2020-04-16T23:46:17.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": []
    },
    {
      "title": "My Project",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/project/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/project/",
      "content_html": "",
      "date_published": "2022-03-06T10:17:18.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": []
    },
    {
      "title": "Blog Home",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/",
      "content_html": "",
      "date_published": "2022-03-06T10:17:18.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": []
    },
    {
      "title": "Slide page",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/slides/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/slides/",
      "content_html": "\n<i>Not supported content</i>",
      "image": "https://vuepress-theme-hope-demo.mrhope.site/logo.svg",
      "date_published": "2022-03-06T10:17:18.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": []
    },
    {
      "title": "HttpServletrequest与HttpServletResponse",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/spring/HttpServletrequest&HttpServletResponse/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/spring/HttpServletrequest&HttpServletResponse/",
      "content_html": "<h2 id=\"参考\"> 参考</h2>\n<blockquote>\n<ul>\n<li>https://www.cnblogs.com/liu1459310172/p/9551722.html</li>\n<li>https://www.cnblogs.com/liu1459310172/p/9551722.html</li>\n</ul>\n</blockquote>\n<h2 id=\"_1-概念\"> 1. 概念</h2>\n<p>Web服务器收到一个http请求，会针对每个请求创建一个<code>HttpServletRequest</code>和<code>HttpServletResponse</code>对象，向客户端发送数据<code>HttpServletResponse</code>,从客户端取数据找<code>HttpServletRequest</code>.</p>\n<h2 id=\"_2-httpservletrequest\"> 2. HttpServletRequest</h2>\n<p>公共接口类<code>HttpServletRequest</code>继承自<code>ServletRequest</code>.客户端浏览器发出的请求被封装成为一个<code>HttpServletRequest</code>对象。所有的信息包括：</p>\n<blockquote>\n<ul>\n<li>请求的地址</li>\n<li>请求的参数</li>\n<li>提交的数据</li>\n<li>上传的文件客户端的ip</li>\n<li>客户端操作系统都包含在其内。</li>\n</ul>\n</blockquote>\n<h3 id=\"_2-1-客户端请求信息\"> 2.1 客户端请求信息</h3>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>getRequestURL()</td>\n<td>浏览器发出请求时的完整URL，包括协议 主机名 端口(如果有)</td>\n</tr>\n<tr>\n<td>getRequestURI()</td>\n<td>浏览器发出请求的资源名部分，去掉了协议和主机名</td>\n</tr>\n<tr>\n<td>getRemoteAddr()</td>\n<td>获取客户端的IP地址</td>\n</tr>\n<tr>\n<td>getRemoteHost()</td>\n<td>获取客户端的主机名</td>\n</tr>\n<tr>\n<td>getRemotePort()</td>\n<td>浏览器所处于的客户机使用的网络端口</td>\n</tr>\n<tr>\n<td>getRemoteUser()</td>\n<td>获取客户端的用户</td>\n</tr>\n<tr>\n<td>getHeader(String)</td>\n<td>获取浏览器传递过来的头信息,“user-agent”可以判断浏览器</td>\n</tr>\n<tr>\n<td>getMethod()</td>\n<td>客户机请求方式一般是GET或者POST</td>\n</tr>\n<tr>\n<td>getQueryString()</td>\n<td>请求行中的参数部分，只能显示以get方式发出的参数，post方式的看不到</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"_2-2-服务器端信息\"> 2.2 服务器端信息</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">名称</th>\n<th style=\"text-align:center\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">getLocalAddr()</td>\n<td style=\"text-align:center\">服务器的IP地址</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">getLocalName()</td>\n<td style=\"text-align:center\">服务器的主机名</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">getLocalPort()</td>\n<td style=\"text-align:center\">获取服务器端口号，即Tomcat端口号</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">getServerName()</td>\n<td style=\"text-align:center\">返回接受请求的服务器的名字</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">getServerPath()</td>\n<td style=\"text-align:center\">获取请求的文件的路径</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">getContextPath()</td>\n<td style=\"text-align:center\">context路径</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">getServerPort()</td>\n<td style=\"text-align:center\">服务器端口</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">getServletPath()</td>\n<td style=\"text-align:center\">Servlet路径</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">getServletContext()</td>\n<td style=\"text-align:center\"></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"_2-3-获取客户端请求参数\"> 2.3 获取客户端请求参数</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">名称</th>\n<th style=\"text-align:center\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">getParameter(String name)</td>\n<td style=\"text-align:center\">获取请求中的参数，该参数是由name指定的</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">getParameterValues(String name)</td>\n<td style=\"text-align:center\">获取请求中的参数，该参数是由name指定下的所有值</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">getParameterMap()</td>\n<td style=\"text-align:center\">获取请求参数的Map集合</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">getParameterNames()</td>\n<td style=\"text-align:center\">获取一个包含请求消息中的所有参数名的 Enumeration对象</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">getAttributeNames()</td>\n<td style=\"text-align:center\">返回当前请求的所有属性的名字集合</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">getAttribute(String name)</td>\n<td style=\"text-align:center\">返回name指定的属性值</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">getCookies()</td>\n<td style=\"text-align:center\">返回客户端发送的Cookie</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">getSession()</td>\n<td style=\"text-align:center\">返回和客户端相关的session，如果没有给客户端分配session，则返回null</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">getsession(boolean create)</td>\n<td style=\"text-align:center\">返回和客户端相关的session，如果没有给客户端分配session，则创建一个session并返回</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"_2-4-设置响应编码\"> 2.4 设置响应编码</h3>\n<ol>\n<li>response.setContentType(“text/html; charset=UTF-8”);</li>\n<li>response.setCharacterEncoding(“UTF-8”);</li>\n</ol>\n<p>这两种方式都需要在response.getWriter调用之前执行才能生效。第一种不仅发送到浏览器的内容会使用UTF-8编码，而且还通知浏览器使用UTF-8编码方式进行显示。所以总能正常显示中文</p>\n",
      "date_published": "2020-10-07T21:36:51.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": []
    },
    {
      "title": "Spring面试题",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/spring/Spring-Interview/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/spring/Spring-Interview/",
      "content_html": "<h2 id=\"bean\"> bean</h2>\n<h3 id=\"bean生命周期\"> bean生命周期</h3>\n<h3 id=\"bean作用域\"> bean作用域</h3>\n<h3 id=\"注入私有静态属性\"> 注入私有静态属性</h3>\n<div><pre><code><span>@Autowired</span>\n<span>private</span> <span>static</span> <span>RedisHelperManager</span> redisHelperManager<span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>这样肯定是不行，并且在用到该变量时会抛出运行时异常java.lang.NullPointerException,静态变量不属于对象的属性，属于类属性，spring是基于对象层面的注入。</p>\n<h4 id=\"解决方法\"> 解决方法</h4>\n<ul>\n<li>使用setter方法注入，在setter方法上加@Autowired注解</li>\n<li>@PostConstruct标记的方法手动注入，将会在初始化前调用该方法</li>\n</ul>\n<h3 id=\"spring-中的单例-bean-的线程安全问题了解吗\"> Spring 中的单例 bean 的线程安全问题了解吗？</h3>\n<p>大部分时候我们并没有在系统中使用多线程，所以很少有人会关注这个问题。</p>\n<p>单例 bean 存在线程问题，主要是因为当多个线程操作同一个对象的时候，对这个对象的非静态成员变量的写操作会存在线程安全问题。</p>\n<p>常见的有两种解决办法：</p>\n<div><p>常见的有两种解决办法</p>\n<ol>\n<li>在Bean对象中尽量避免定义可变的成员变量（不太现实）。</li>\n<li>在类中定义一个<code>ThreadLocal</code>成员变量，将需要的可变成员变量保存在 <code>ThreadLocal</code> 中（推荐的一种方式）。</li>\n</ol>\n</div>\n<h3 id=\"component-和-bean-的相同和区别是什么\"> @Component 和 @Bean 的相同和区别是什么？</h3>\n<p><code>@Component</code>和<code>@Bean</code>都是用来注册Bean并装配到<code>Spring容器</code>中，但是<code>Bean</code>比<code>Component</code>的自定义性更强。可以实现一些Component实现不了的自定义加载类。</p>\n<div><p>@Component 和 @Bean 的区别是什么</p>\n<ul>\n<li>\n<p>作⽤对象不同: @Component 注解作⽤于<code>类</code>，⽽ @Bean 注解作⽤于<code>⽅法</code>。</p>\n</li>\n<li>\n<p>@Component （@Controller、@Service、@Repository）通常是通过类路径扫描来⾃动侦测以及⾃动装配到Spring容器中（我们可以使⽤ <code>@ComponentScan</code> 注解定义要扫描的路径从中找出标识了需要装配的类⾃动装配到 Spring 的 bean 容器中）。 @Bean 注解通常是我们在标有该注解的⽅法中定义产⽣这个 bean, @Bean告诉了Spring这是某个类的示例，当我需要⽤它的时候还给我。</p>\n</li>\n<li>\n<p>@Bean 注解⽐ Component 注解的⾃定义性更强，⽽且很多地⽅我们只能通过 @Bean 注解 来注册bean。⽐如当我们引⽤第三⽅库中的类需要装配到 Spring 容器时，则只能通过 @Bean 来实现</p>\n</li>\n</ul>\n</div>\n<h2 id=\"过滤器和拦截器\"> 过滤器和拦截器</h2>\n<p>参考</p>\n<ul>\n<li><a href=\"https://blog.csdn.net/yjc0403/article/details/84924548\" target=\"_blank\" rel=\"noopener noreferrer\">https://blog.csdn.net/yjc0403/article/details/84924548</a></li>\n<li><a href=\"https://www.zhihu.com/question/30212464/answer/1786967139\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.zhihu.com/question/30212464/answer/1786967139</a></li>\n</ul>\n<p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/Spring-Interview/过滤器与拦截器区别.jpg\" alt=\"img\" /></p>\n<ul>\n<li>\n<p>实现：过滤器 是基于函数回调的；拦截器 则是基于Java的反射机制（动态代理）实现的。</p>\n</li>\n<li>\n<p>范围：过滤器 实现的是 javax.servlet.Filter 接口，而这个接口是在Servlet规范中定义的，也就是说过滤器Filter 的使用要依赖于Tomcat等容器，导致它只能在web程序中使用；拦截器(Interceptor) 它是一个Spring组件，并由Spring容器管理，并不依赖Tomcat等容器，是可以单独使用的。不仅能应用在web程序中，也可以用于Application、Swing等程序中。</p>\n</li>\n<li>\n<p>触发时机：过滤器Filter是在请求进入容器后，但在进入servlet之前进行预处理，请求结束是在servlet处理完以后；</p>\n<p>拦截器 Interceptor 是在请求进入servlet后，在进入Controller之前进行预处理的，Controller 中渲染了对应的视图之后请求结束。</p>\n</li>\n</ul>\n<h2 id=\"spring用到了哪些设计模式\"> Spring用到了哪些设计模式</h2>\n<div><p>参考</p>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247485303&amp;idx=1&amp;sn=9e4626a1e3f001f9b0d84a6fa0cff04a&amp;chksm=cea248bcf9d5c1aaf48b67cc52bac74eb29d6037848d6cf213b0e5466f2d1fda970db700ba41&amp;token=255050878&amp;lang=zh_CN%23rd\" target=\"_blank\" rel=\"noopener noreferrer\">Spring设计模式</a></li>\n<li>https://zhuanlan.zhihu.com/p/114244039</li>\n</ul>\n</div>\n<ul>\n<li>1.简单工厂(非23种设计模式中的一种)</li>\n<li>2.工厂方法</li>\n<li>3.单例模式</li>\n<li>4.适配器模式</li>\n<li>5.装饰器模式</li>\n<li>6.代理模式</li>\n<li>7.观察者模式</li>\n<li>8.策略模式</li>\n<li>9.模版方法模式</li>\n</ul>\n<h2 id=\"springmvc\"> SpringMVC</h2>\n<h3 id=\"springmvc组件\"> SpringMVC组件</h3>\n<ul>\n<li><code>DispatcherServlet</code>：前端控制器。也称为中央控制器，它是整个请求响应的控制中心，组件的调用由它统一调度。有了他就减少了其他组件之间的耦合度。</li>\n<li><code>HandlerMapping</code>：处理器映射器。它根据用户访问的 URL 映射到对应的后端处理器 Handler。也就是说它知道处理用户请求的后端处理器，但是它并不执行后端处理器，而是将处理器告诉给中央处理器。</li>\n<li><code>HandlerAdapter</code>：处理器适配器。根据传过来不同类型的<code>Hadnle</code>它调用后端处理器中的方法，返回逻辑视图 <code>ModelAndView</code> 对象给<code>DispatcherServlet</code>。</li>\n<li><code>ViewResolver</code>：视图解析器。将 <code>ModelAndView</code> 逻辑视图解析为具体的视图（如 JSP）。</li>\n<li><code>Handler</code>：后端处理器。对用户具体请求进行处理，也就是我们编写的 <code>Controller</code> 类。需要程序员开发</li>\n</ul>\n<h3 id=\"springmvc工作流程\"> SpringMVC工作流程</h3>\n<p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/Spring-Interview/spring mvc工作流程.jpg\" alt=\"Springmvc工作原理图\" /></p>\n<div><p>流程详解</p>\n<ol>\n<li>\n<p>用户向服务端发送一次请求，这个请求会先到前端控制器<code>DispatcherServlet</code>(也叫中央控制器)。</p>\n</li>\n<li>\n<p><code>DispatcherServlet</code>接收到请求后会调用<code>HandlerMapping</code>处理器映射器来，根据配置或注解获取不同的<code>Handle</code>，并返回给<code>DispatcherServlet</code>。由此得知，该请求该由哪个<code>Controller</code>来处理（并未调用Controller，只是得知）</p>\n</li>\n<li>\n<p><code>DispatcherServlet</code>调用<code>HandlerAdapter</code>处理器适配器，告诉处理器适配器应该要去执行哪个<code>Controller</code></p>\n</li>\n<li>\n<p><code>HandlerAdapter</code>处理器适配器去执行<code>Controller</code>并得到<code>ModelAndView</code>(数据和视图)，并层层返回给<code>DispatcherServlet</code></p>\n</li>\n<li>\n<p><code>DispatcherServlet</code>将<code>ModelAndView</code>交给<code>ViewReslover</code>视图解析器解析，然后返回真正的视图<code>View</code>。</p>\n</li>\n<li>\n<p><code>DispatcherServlet</code>将模型数据填充到视图中</p>\n</li>\n<li>\n<p><code>DispatcherServlet</code>将结果响应给用户</p>\n</li>\n</ol>\n</div>\n",
      "image": "https://blog-1300186248.cos.ap-shanghai.myqcloud.com/Spring-Interview/%E8%BF%87%E6%BB%A4%E5%99%A8%E4%B8%8E%E6%8B%A6%E6%88%AA%E5%99%A8%E5%8C%BA%E5%88%AB.jpg",
      "date_published": "2021-10-24T22:03:04.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": []
    },
    {
      "title": "Spring-RestTemplate",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/spring/Spring-RestTemplate/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/spring/Spring-RestTemplate/",
      "content_html": "<h2 id=\"spring-resttemplate\"> Spring-RestTemplate</h2>\n<div><pre><code><span>@Configuration</span>\n<span>public</span> <span>class</span> <span>ApplicationContextConfig</span> <span>{</span>\n\n    <span>@Bean</span>\n    <span>@LoadBalanced</span>\n    <span>public</span> <span>RestTemplate</span> <span>restTemplate</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>new</span> <span>RestTemplate</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div>",
      "date_published": "2021-11-30T23:40:09.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": []
    },
    {
      "title": "Spring注解",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/spring/Spring-annotation/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/spring/Spring-annotation/",
      "content_html": "<h2 id=\"spring注解\"> Spring注解</h2>\n<p>注解本质是一个继承了 Annotation的特殊接口,其具体实现类是Java运行时生成的动态代理类。我们通过反射获取注解时,返回的是Java运行时生成的动态代理对象。通过代理对象调用自定义注解的方法,会最终调用AnnotationInvocationHandler的 invoke方法。该方法会从 membervalues这个Map中索引出对应的值。而 membervalues的来源是Java常量池</p>\n<p>Controller类使用继承@Component注解的方法，将其以单例的形式放入spring容器，如果仔细看的话会发现每个注解里面都有一个默认的value()方法，它的作用是为当前的注解声明一个名字，一般默认为类名，然后spring会通过配置文件中的context:component-scan的配置，进行如下操作：</p>\n<ul>\n<li>使用asm技术扫描.class文件，并将包含@Component及元注解为@Component的注解@Controller、@Service、@Repository或者其他自定义的的bean注册到beanFactory中，</li>\n<li>然后spring在注册处理器</li>\n<li>实例化处理器，然后将其放到beanPostFactory中，然后我们就可以在类中进行使用了。</li>\n<li>创建bean时，会自动调用相应的处理器进行处理。</li>\n</ul>\n<h2 id=\"常用注解\"> 常用注解</h2>\n<p>参考</p>\n<blockquote>\n<ul>\n<li>https://www.cnblogs.com/leskang/p/5445698.html</li>\n</ul>\n</blockquote>\n<ul>\n<li>\n<p><strong>@Controller</strong></p>\n<blockquote>\n<p><code>@Controller</code>注解在类上，表明这个类是Spring MVC里的<code>Controller</code>，将其声明为Spring的一个Bean，<code>DispatchServlet</code>会自动扫描注解了此注解的类，并将Web请求映射到注解了<code>@RequestMapping</code>的方法上，需要注意的是，在Spring MVC声明控制器Bean的时候，只能使用@Controller。</p>\n</blockquote>\n</li>\n<li>\n<p><strong>@RestController</strong></p>\n<blockquote>\n<p><code>@RestController</code>是一个组合注解，组合了<code>@Controller</code>和<code>@ResponseBody</code>，意味着当只开发一个和页面交互数据的控制的时候，需要使用此注解。 若没有此注解，要想实现上述功能，则需自己在代码中加<code>@Controller</code>和<code>@ResponseBody</code>两个注解。</p>\n</blockquote>\n</li>\n<li>\n<p><strong>@RequestMapping</strong></p>\n<blockquote>\n<p><code>@RequestMapping</code>注解是用来映射Web请求（访问路径和参数）、处理类和方法的。它可以注解在类和方法上。注解在方法上的<code>@RequestMapping</code>路径会继承注解在类上的路径，<code>@RequestMapping</code>支持Servlet的request和response作为参数，也支持对它们的媒体类型进行配置。</p>\n</blockquote>\n</li>\n<li>\n<p><strong>@ResponseBody</strong></p>\n<blockquote>\n<p><code>@ResponseBody</code>支持将返回值放在<code>response</code>体内，而不是返回一个页面。我们很多机遇<code>Ajax</code>的程序，可以以此注解返回数据而不是返回页面；此注解可以放在返回值或者方法上。</p>\n</blockquote>\n</li>\n<li>\n<p><strong>@RequestBody</strong></p>\n<blockquote>\n<p><code>@RequestBody</code>允许<code>request</code>的参数在<code>request</code>体中，而不是在直接链接在地址后面。此注解放在参数前。</p>\n</blockquote>\n</li>\n<li>\n<p><strong>@PathVariable</strong></p>\n<blockquote>\n<p><code>@PathVariable</code> 用来接收路径参数，如<code>/news/001</code>,可接收001作为参数，此注解放置在参数前。</p>\n</blockquote>\n</li>\n<li>\n<p><strong>@Resource和@Autowired</strong></p>\n<blockquote>\n<p>@Resource和@Autowired都是做bean的注入时使用，其实@Resource并不是Spring的注解，它的包是javax.annotation.Resource，需要导入，但是Spring支持该注解的注入。</p>\n</blockquote>\n</li>\n<li>\n<p><strong>@Repository</strong></p>\n<blockquote>\n<p>用于注解dao层，在daoImpl类上面注解。</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"bean\"> Bean</h2>\n<ul>\n<li>@Configuration：定义类上，代替xml中的beans标签</li>\n<li>@ComponentScan：定义类上，等价于&lt;context:component-scan base-package=&quot;com.dxz.demo&quot;/&gt;</li>\n<li>@ImportResource：定义类上，引入外部xml文件</li>\n<li>@Import：定义类上，引入其它@Configuration标记的配置类</li>\n<li>@Bean：定义方法上，代替xml中的bean标签，等到的bean的beanName默认与方法名相同</li>\n<li>@Scope：定义方法上，bean作用域，一般搭配@Bean作用在方法上</li>\n</ul>\n<p>常用标记为bean</p>\n<ul>\n<li>@Controller：对应 Spring MVC 控制层，主要用户接受用户请求并调用 Service 层返回数据给前端页面。</li>\n<li>@Component：通用的注解，可标注任意类为 <code>Spring</code> 组件。如果一个 Bean 不知道属于哪个层可以使用</li>\n<li>@Service：对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层</li>\n<li>@Repository： 对应持久层即 Dao 层，主要用于数据库相关操作。</li>\n</ul>\n<h3 id=\"configuration\"> @Configuration</h3>\n<p>参考</p>\n<ul>\n<li><a href=\"https://www.cnblogs.com/duanxz/p/7493276.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.cnblogs.com/duanxz/p/7493276.html</a></li>\n<li><a href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Configuration.html\" target=\"_blank\" rel=\"noopener noreferrer\">Spring官方文档</a></li>\n</ul>\n<p>@Configuration用于定义配置类，可替换xml配置文件，被注解的类内部包含有一个或多个被@Bean注解的方法，这些方法将会被AnnotationConfigApplicationContext或AnnotationConfigWebApplicationContext类进行扫描，并用于构建bean定义，初始化Spring容器。</p>\n<div><pre><code><span>//代替xml里面的&lt;beans>，模拟@SpringBootApplication注解标记的启动类</span>\n<span>@Configuration</span>\n<span>@ComponentScan</span><span>(</span>basePackages <span>=</span> <span>{</span><span>\"com.longchen\"</span><span>}</span><span>)</span>\n<span>//引入外部xml文件</span>\n<span>@ImportResource</span><span>(</span><span>\"classpath:bean_annotation.xml\"</span><span>)</span>\n<span>//引入其它注解配置</span>\n<span>@Import</span><span>(</span><span>MyConfiguration</span><span>.</span><span>class</span><span>)</span>\n<span>public</span> <span>class</span> <span>MyConfiguration</span> <span>{</span>\n\n    <span>//类似xml中的bean标签</span>\n    <span>@Bean</span>\n    <span>public</span> <span>UserService</span> <span>getUserService</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>new</span> <span>UserServiceImpl</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>//嵌套，必须是static</span>\n    <span>@Configuration</span>\n    <span>static</span> <span>class</span> <span>DatabaseConfig</span> <span>{</span>\n\n        <span>@Bean</span>\n        <span>public</span> <span>UserService</span> <span>getUserService</span><span>(</span><span>)</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"根据DatabaseConfig中的@Bean获得\"</span><span>)</span><span>;</span>\n            <span>return</span> <span>new</span> <span>UserServiceImpl</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>//基于注解注入属性</span>\n    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>test</span><span>(</span><span>)</span><span>{</span>\n        <span>ApplicationContext</span> context <span>=</span> <span>new</span> <span>AnnotationConfigApplicationContext</span><span>(</span><span>MyConfiguration</span><span>.</span><span>class</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div><h4 id=\"要求\"> 要求</h4>\n<ol>\n<li>@Configuration不可以是final类型；</li>\n<li>@Configuration不可以是匿名类；</li>\n<li>嵌套的configuration必须是静态类。</li>\n</ol>\n<h4 id=\"组成\"> 组成</h4>\n<div><pre><code><span>@Target</span><span>(</span><span>ElementType</span><span>.</span>TYPE<span>)</span>\n<span>@Retention</span><span>(</span><span>RetentionPolicy</span><span>.</span>RUNTIME<span>)</span>\n<span>@Documented</span>\n<span>@Component</span>\n<span>public</span> <span>@interface</span> <span>Configuration</span> <span>{</span> <span>.</span><span>.</span><span>.</span> <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>这里有<code>@Component</code>说明意味也将会注册为bean, 其内部也可以依赖注入</p>\n<h3 id=\"bean-2\"> @Bean</h3>\n<p>作用于方法，用于在@Configuration注解的类中，替代xml中的bean标签</p>\n<h4 id=\"属性\"> 属性</h4>\n<ul>\n<li>name：bean名称</li>\n<li>init-method</li>\n<li>destroy-method</li>\n</ul>\n<p>通常配合@Scope来指定bean作用域</p>\n<div><pre><code><span>@Configuration</span>\n<span>public</span> <span>class</span> <span>AppConfig</span> <span>{</span>\n    <span>@Bean</span><span>(</span>name <span>=</span> <span>\"transferService\"</span><span>,</span> init<span>-</span>method<span>,</span> destroy<span>-</span>method<span>)</span>\n    <span>@Scope</span><span>(</span><span>\"singleton\"</span><span>)</span>\n    <span>public</span> <span>TransferService</span> <span>transferService</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>new</span> <span>TransferServiceImpl</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>上⾯的代码相当于下⾯的 xml 配置</p>\n<div><pre><code><span><span><span>&lt;</span>beans</span><span>></span></span>\n <span><span><span>&lt;</span>bean</span> <span>id</span><span><span>=</span><span>\"</span>transferService<span>\"</span></span> <span>class</span><span><span>=</span><span>\"</span>com.acme.TransferServiceImpl<span>\"</span></span><span>/></span></span>\n<span><span><span>&lt;/</span>beans</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id=\"属性注入\"> 属性注入</h2>\n<ul>\n<li>@Autowired</li>\n<li>@Resource</li>\n<li>@Qualifier</li>\n<li>@Primary</li>\n<li>@Value</li>\n</ul>\n<h3 id=\"autowired\"> @Autowired</h3>\n<p>@Autowired为Spring提供的注解，<code>根据类型注入</code>，需要导入包<code>org.springframework.beans.factory.annotation.Autowired</code>;</p>\n<h4 id=\"作用范围\"> 作用范围</h4>\n<p>可以作用在</p>\n<ul>\n<li>构造器</li>\n<li>方法（普通方法，setter方法）</li>\n<li>参数</li>\n<li>成员变量</li>\n<li>注解</li>\n</ul>\n<h4 id=\"属性-2\"> 属性</h4>\n<ul>\n<li>required(true)：默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它required属性为false。</li>\n</ul>\n<div><pre><code><span>@Data</span>\n<span>@RestController</span>\n<span>public</span> <span>class</span> <span>UserController</span> <span>{</span>\n\n    <span>private</span> <span>UserService</span> userService<span>;</span>\n    <span>private</span> <span>UserService</span> userService2<span>;</span>\n\n    <span>//注入集合</span>\n    <span>private</span> <span>UserService</span><span>[</span><span>]</span> userArray<span>;</span>\n    <span>private</span> <span>List</span><span><span>&lt;</span><span>UserService</span><span>></span></span> userList<span>;</span>\n    <span>private</span> <span>Set</span><span><span>&lt;</span><span>UserService</span><span>></span></span> userSet<span>;</span>\n    <span>private</span> <span>Map</span><span><span>&lt;</span><span>String</span><span>,</span> <span>UserService</span><span>></span></span> userMap<span>;</span>\n\n    <span>@Autowired</span>\n    <span>public</span> <span>UserController</span><span>(</span><span>@Qualifier</span><span>(</span><span>\"userServiceImpl\"</span><span>)</span> <span>UserService</span> userService<span>,</span> <span>@Qualifier</span><span>(</span><span>\"userServiceImpl_2\"</span><span>)</span> <span>UserService</span> userService2<span>,</span> <span>UserService</span><span>[</span><span>]</span> userArray<span>,</span>\n        <span>List</span><span><span>&lt;</span><span>UserService</span><span>></span></span> userList<span>,</span>\n        <span>Set</span><span><span>&lt;</span><span>UserService</span><span>></span></span> userSet<span>,</span> <span>Map</span><span><span>&lt;</span><span>String</span><span>,</span> <span>UserService</span><span>></span></span> userMap<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>userService <span>=</span> userService<span>;</span>\n        <span>this</span><span>.</span>userService2 <span>=</span> userService2<span>;</span>\n        <span>this</span><span>.</span>userArray <span>=</span> userArray<span>;</span>\n        <span>this</span><span>.</span>userList <span>=</span> userList<span>;</span>\n        <span>this</span><span>.</span>userSet <span>=</span> userSet<span>;</span>\n        <span>this</span><span>.</span>userMap <span>=</span> userMap<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><h4 id=\"装配顺序\"> 装配顺序</h4>\n<p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/Spring-annotation/@Autowired装配顺序.jpg\" alt=\"img\" /></p>\n<h4 id=\"失效原因\"> 失效原因</h4>\n<ul>\n<li>在类上面没有加声明bean注解</li>\n<li>注入Filter或Listener：web应用启动的顺序是：<code>listener</code>-&gt;<code>filter</code>-&gt;<code>servlet</code>，springmvc的启动是在DisptachServlet里面做的，而它是在listener和filter之后执行。如果我们想在listener和filter里面@Autowired某个bean，肯定是不行的，因为filter初始化的时候，此时bean还没有初始化，无法自动装配。使用WebApplicationContextUtils.getWebApplicationContext获取当前的ApplicationContext，再通过它获取到bean实例。</li>\n<li>注解未被@ComponentScan扫描</li>\n<li>循环依赖问题</li>\n</ul>\n<h3 id=\"resource\"> @Resource</h3>\n<p>@Resource默认按照<code>ByName</code>自动注入，由J2EE提供，需要导入包javax.annotation.Resource。@Resource有两个重要的属性：<code>name</code>和<code>type</code>，而Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以，如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不制定name也不制定type属性，这时将通过反射机制使用byName自动注入策略。</p>\n<div><pre><code><span>public</span> <span>class</span> <span>TestServiceImpl</span> <span>{</span>\n    <span>// 下面两种@Resource只要使用一种即可</span>\n    <span>@Resource</span><span>(</span>name<span>=</span><span>\"userDao\"</span><span>,</span> type <span>=</span> <span>UserDao</span><span>.</span><span>class</span><span>)</span>\n    <span>private</span> <span>UserDao</span> userDao<span>;</span> <span>// 用于字段上</span>\n    \n    <span>@Resource</span><span>(</span>name<span>=</span><span>\"userDao\"</span><span>)</span>\n    <span>public</span> <span>void</span> <span>setUserDao</span><span>(</span><span>UserDao</span> userDao<span>)</span> <span>{</span> <span>// 用于属性的setter方法上</span>\n        <span>this</span><span>.</span>userDao <span>=</span> userDao<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>注：最好是将@Resource放在setter方法上，因为这样更符合面向对象的思想，通过set、get去操作属性，而不是直接去操作属性。</p>\n<h4 id=\"属性-3\"> 属性</h4>\n<ul>\n<li>name：指定的beanName</li>\n<li>type：指定的class类型</li>\n</ul>\n<h4 id=\"装配顺序-2\"> 装配顺序</h4>\n<ol>\n<li>如果同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常。</li>\n<li>如果指定了name，则从上下文中查找名称（id）匹配的bean进行装配，找不到则抛出异常。</li>\n<li>如果指定了type，则从上下文中找到类似匹配的唯一bean进行装配，找不到或是找到多个，都会抛出异常。</li>\n<li>如果既没有指定name，又没有指定type，则自动按照byName方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配。</li>\n</ol>\n<h3 id=\"resource和-autowired不同点\"> @Resource和@Autowired不同点</h3>\n<p>参考</p>\n<ul>\n<li>\n<p><a href=\"https://www.zhihu.com/question/39356740\" target=\"_blank\" rel=\"noopener noreferrer\">@Resource和@Autowired不同点</a></p>\n</li>\n<li>\n<p>@Autowired默认按byType自动装配，而@Resource默认byName自动装配。</p>\n</li>\n<li>\n<p>@Autowired只包含一个参数：required，表示是否开启自动准入，默认是true。而@Resource包含七个参数，其中最重要的两个参数是：name 和 type。</p>\n</li>\n<li>\n<p>@Autowired如果要使用byName，需要使用@Qualifier一起配合。而@Resource如果指定了name，则用byName自动装配，如果指定了type，则用byType自动装配。</p>\n</li>\n<li>\n<p>@Autowired能够用在：构造器、方法、参数、成员变量和注解上，而@Resource能用在：类、成员变量和方法上。</p>\n</li>\n<li>\n<p>@Autowired是spring定义的注解，而@Resource是JSR-250定义的注解。</p>\n</li>\n</ul>\n<h3 id=\"qualifier\"> @Qualifier</h3>\n<p>搭配@Autowired使用，常用于注入接口引用时，该引用有多个实现类，使用@Autowired根据类型注入Spring不知道注入那个实现类，这时候使用@Qualifier指定具体的beanName使得注入变为根据名称注入</p>\n<div><pre><code><span>//在属性定义上</span>\n<span>@Autowired</span><span>(</span>required <span>=</span> <span>false</span><span>)</span>\n<span>@Qualifier</span><span>(</span><span>\"userServiceImpl\"</span><span>)</span>\n<span>private</span> <span>UserService</span> userService<span>;</span>\n\n<span>//在构造器上</span>\n<span>@Autowired</span><span>(</span>required <span>=</span> <span>false</span><span>)</span>\n<span>public</span> <span>UserController</span><span>(</span><span>@Qualifier</span><span>(</span><span>\"userServiceImpl\"</span><span>)</span> <span>UserService</span> userService<span>,</span> <span>@Qualifier</span><span>(</span><span>\"userServiceImpl_2\"</span><span>)</span> <span>UserService</span> userService2<span>)</span> <span>{</span>\n    <span>this</span><span>.</span>userService <span>=</span> userService<span>;</span>\n    <span>this</span><span>.</span>userService2 <span>=</span> userService2<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h3 id=\"primary\"> @Primary</h3>\n<p>作用于注入的bean，当根据类型装配没有使用@Qualifier的时候，如果存在多个实现类，那么会优先找到有@Primary注解的实现类进行注入</p>\n<h3 id=\"value\"> @Value</h3>\n<p>注入普通类型，可以从配置中取值赋值</p>\n<div><pre><code><span>public</span> <span>class</span> <span>User</span> <span>{</span>\n    <span>@Value</span><span>(</span><span>\"1\"</span><span>)</span>\n    <span>private</span> <span>Integer</span> id<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h4 id=\"value-2\"> @Value(“#{}”)</h4>\n<p>表示SpEl表达式通常用来获取bean的属性，或者调用bean的某个方法。当然还有可以表示常量</p>\n<div><pre><code><span>@Value</span><span>(</span><span>\"#{dataSource.url}\"</span><span>)</span> <span>//获取bean的属性  </span>\n<span>private</span> <span>String</span> jdbcUrl<span>;</span>  \n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h4 id=\"value-3\"> @Value(“${}”)</h4>\n<p>注解从配置文件读取值的用法</p>\n<div><pre><code><span>@Value</span><span>(</span><span>\"${init.password}\"</span><span>)</span>  \n<span>private</span> <span>String</span> initPwd<span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h2 id=\"web层\"> Web层</h2>\n<h3 id=\"controller控制器\"> @Controller控制器</h3>\n<p>在SpringMVC 中，控制器Controller 负责处理由<code>DispatcherServlet</code> 分发的请求，它把用户请求的数据经过业务处理层处理之后封装成一个<code>Model</code> ，然后再把该<code>Model</code> 返回给对应的<code>View</code> 进行展示。在<code>SpringMVC</code> 中提供了一个非常简便的定义<code>Controller</code> 的方法，你无需继承特定的类或实现特定的接口，只需使用<code>@Controller</code> 标记一个类是Controller ，然后使用<code>@RequestMapping</code> 和@<code>RequestParam</code> 等一些注解用以定义URL 请求和Controller 方法之间的映射，这样的Controller 就能被外界访问到。此外Controller 不会直接依赖于<code>HttpServletRequest</code> 和<code>HttpServletResponse</code> 等HttpServlet 对象，它们可以通过Controller 的方法参数灵活的获取到。</p>\n<p>@Controller 用于标记在一个类上，使用它标记的类就是一个SpringMVC Controller 对象。分发处理器将会扫描使用了该注解的类的方法，并检测该方法是否使用了@RequestMapping 注解。@Controller 只是定义了一个控制器类，而使用@RequestMapping 注解的方法才是真正处理请求的处理器。单单使用@Controller 标记在一个类上还不能真正意义上的说它就是SpringMVC 的一个控制器类，因为这个时候Spring 还不认识它。那么要如何做Spring 才能认识它呢？这个时候就需要我们把这个控制器类交给Spring 来管理。</p>\n<p>单独使⽤ <code>@Controller</code> 不加 <code>@ResponseBody</code> 的话⼀般使⽤在要返回⼀个视图的情况，这种情况 属于比较传统的Spring MVC 的应⽤，对应于<code>前后端不分离</code>的情况。</p>\n<p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/Spring-Interview/@Controller.jpg\" alt=\"@Controller\" /></p>\n<h3 id=\"restcontroller\"> @RestController</h3>\n<p>可以发现，<code>@RestController</code>注解里面包含了<code>@Controller</code>注解和@<code>ResponseBody</code>注解，<code>@ResponseBody</code> 注解是将返回的数据结构转换为 <code>JSON</code> 格式，所以说可以这么理解：@RestController = @Controller + @ResponseBody ，省了很多事，我们使用 @RestController 之后就不需要再使用 @Controller 了。</p>\n<p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/Spring-Interview/@RestController.jpg\" alt=\"@RestController\" /></p>\n<h3 id=\"responsebody\"> @ResponseBody</h3>\n<p>作用： 该注解用于将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到<code>Response</code>对象的<code>body</code>数据区。</p>\n<p>使用时机：返回的数据不是<code>html</code>标签的页面，而是其他某种格式的数据时（如<code>json</code>、<code>xml</code>等）使用；</p>\n<h3 id=\"requestmapping请求映射\"> @RequestMapping请求映射</h3>\n<p>RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。<code>@RequestMapping</code>注解是用来映射Web请求（访问路径和参数）、处理类和方法的。它可以注解在类和方法上。注解在方法上的<code>@RequestMapping</code>路径会继承注解在类上的路径，<code>@RequestMapping</code>支持Servlet的<code>request</code>和<code>response</code>作为参数，也支持对它们的媒体类型进行配置。</p>\n<h4 id=\"属性-4\"> 属性</h4>\n<ul>\n<li>\n<p>value， method</p>\n<blockquote>\n<ul>\n<li>value：   指定请求的实际地址，指定的地址可以是URI Template 模式。value 可以省略不写</li>\n<li>method： 指定请求的method类型， GET、POST、PUT、DELETE等；默认为GET。不用每次在 @RequestMapping 注解中加 method 属性来指定，上面的 GET 方式请求可以直接使用 @GetMapping(&quot;/get&quot;) 注解，效果一样。相应地，PUT 方式、POST 方式和 DELETE 方式对应的注解分别为<code>@GetMapping</code>， <code>@PutMapping</code>、<code>@PostMapping</code> 和 <code>DeleteMapping</code>。</li>\n</ul>\n</blockquote>\n</li>\n<li>\n<p>consumes，produces</p>\n<blockquote>\n<ul>\n<li>consumes： 指定处理请求的提交内容类型（Content-Type），例如application/json, text/html;</li>\n<li>produces:  指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回；如 produces = “application/json; charset=UTF-8”，prodeces=&quot;image/jpeg&quot;(可以用来配合swagger文档返回图片乱码的情况)</li>\n</ul>\n</blockquote>\n</li>\n<li>\n<p>params，headers</p>\n<blockquote>\n<ul>\n<li>params： 指定request中必须包含某些参数值是，才让该方法处理。</li>\n<li>headers： 指定request中必须包含某些指定的header值，才能让该方法处理请求。</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"requestbody\"> @RequestBody</h3>\n<p>参考</p>\n<blockquote>\n<ul>\n<li>https://blog.csdn.net/weixin_38004638/article/details/99655322</li>\n</ul>\n</blockquote>\n<p>RequestBody 注解用于接收<code>contentType: &quot;application/json;&quot;</code>的body，接收参数可以是实体，比如前端通过 JSON 提交传来两个参数 username 和 password，此时我们需要在后端封装一个实体来接收。在传递的参数比较多的情况下，使用 @RequestBody 接收会非常方便。</p>\n<h3 id=\"pathvariable\"> @PathVariable</h3>\n<p>@PathVariable 注解主要用来获取 URL 参数，Spring Boot 支持 <code>Restfull</code> 风格的 URL，比如一个 GET 请求携带一个参数 id，我们将 id 作为参数接收，可以使用 @PathVariable 注解。前提是青请求值中要有括号包含对应的参数如下：</p>\n<div><pre><code><span>@Controller</span>  \n<span>public</span> <span>class</span> <span>TestController</span> <span>{</span>  \n     <span>@RequestMapping</span><span>(</span>value<span>=</span><span>\"/user/{userId}/roles/{roleId}\"</span><span>,</span>method <span>=</span> <span>RequestMethod</span><span>.</span>GET<span>)</span>  \n     <span>public</span> <span>String</span> <span>getLogin</span><span>(</span><span>@PathVariable</span><span>(</span><span>\"userId\"</span><span>)</span> <span>String</span> userId<span>,</span>  \n         <span>@PathVariable</span><span>(</span><span>\"roleId\"</span><span>)</span> <span>String</span> roleId<span>)</span><span>{</span>  \n         <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"User Id : \"</span> <span>+</span> userId<span>)</span><span>;</span>  \n         <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"Role Id : \"</span> <span>+</span> roleId<span>)</span><span>;</span>  \n         <span>return</span> <span>\"hello\"</span><span>;</span>  \n     <span>}</span>  \n     <span>@RequestMapping</span><span>(</span>value<span>=</span><span>\"/product/{productId}\"</span><span>,</span>method <span>=</span> <span>RequestMethod</span><span>.</span>GET<span>)</span>  \n     <span>public</span> <span>String</span> <span>getProduct</span><span>(</span><span>@PathVariable</span><span>(</span><span>\"productId\"</span><span>)</span> <span>String</span> productId<span>)</span><span>{</span>  \n           <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"Product Id : \"</span> <span>+</span> productId<span>)</span><span>;</span>  \n           <span>return</span> <span>\"hello\"</span><span>;</span>  \n     <span>}</span>  \n     <span>@RequestMapping</span><span>(</span>value<span>=</span><span>\"/javabeat/{regexp1:[a-z-]+}\"</span><span>,</span>  \n           method <span>=</span> <span>RequestMethod</span><span>.</span>GET<span>)</span>  \n     <span>public</span> <span>String</span> <span>getRegExp</span><span>(</span><span>@PathVariable</span><span>(</span><span>\"regexp1\"</span><span>)</span> <span>String</span> regexp1<span>)</span><span>{</span>  \n           <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"URI Part 1 : \"</span> <span>+</span> regexp1<span>)</span><span>;</span>  \n           <span>return</span> <span>\"hello\"</span><span>;</span>  \n     <span>}</span>  \n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><h3 id=\"requestparam\"> @RequestParam</h3>\n<p>@RequestParam 注解顾名思义，也是获取请求参数的，主要用于在SpringMVC后台控制层获取参数，类似一种request.getParameter(&quot;name&quot;)。上面我们介绍了 @PathValiable 注解也是获取请求参数的，那么 @RequestParam 和 @PathVariable 有什么不同呢：</p>\n<p>@PathValiable 是从 URL 模板中获取参数值，类似Restfull</p>\n<div><pre><code>http<span>:</span><span>/</span><span>/</span>localhost<span>:</span><span>8080</span><span>/</span>user<span>/</span><span>{</span>id<span>}</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>@RequestParam 是从 Request 里获取参数值，即这种风格的 URL：</p>\n<div><pre><code>http<span>:</span><span>/</span><span>/</span>localhost<span>:</span><span>8080</span><span>/</span>user<span>?</span>id<span>=</span><span>1</span>\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"属性-5\"> 属性</h4>\n<p>defaultValue = &quot;0&quot;, required = false, value = &quot;isApp&quot;；</p>\n<ul>\n<li><strong>required</strong>：true 表示该参数必须要传，否则就会报 404 错误，false 表示可有可无。</li>\n<li><strong>defaultValue</strong>：表示设置默认值</li>\n<li><strong>value</strong>:值表示接受的传入的参数类型</li>\n</ul>\n<h2 id=\"其它\"> 其它</h2>\n<h3 id=\"lazy\"> @Lazy</h3>\n",
      "image": "https://blog-1300186248.cos.ap-shanghai.myqcloud.com/Spring-annotation/@Autowired%E8%A3%85%E9%85%8D%E9%A1%BA%E5%BA%8F.jpg",
      "date_published": "2021-10-24T22:04:04.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": []
    },
    {
      "title": "Spring错误&坑记录",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/spring/Spring-error&hole/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/spring/Spring-error&hole/",
      "content_html": "<h2 id=\"springboot相关\"> SpringBoot相关</h2>\n<h3 id=\"解决springboot无法注入service的原因之一testcontroller-required-a-bean-of-type-com-yifeng-study-service-userservice-that-could-not-be-found-报错\"> 解决SpringBoot无法注入service的原因之一TestController required a bean of type ‘com.yifeng.study.service.UserService’ that could not be found.报错</h3>\n<p>参考</p>\n<div><p>Tips</p>\n<p><a href=\"https://blog.csdn.net/xzxToney/article/details/105248704?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1.control\" target=\"_blank\" rel=\"noopener noreferrer\">参考</a></p>\n</div>\n<h4 id=\"原因\"> 原因</h4>\n<p>如果此时service上已经加了注解<code>@Service</code>或者没有其他基本问题，那么可能是<strong>主启动类与被扫描的文件夹不在同一路径</strong>下，所以扫描不到。</p>\n<p><img src=\"./images/Spring-error&hole/springboot_error_1-1.png\" alt=\"\" /></p>\n<h4 id=\"解决办法\"> 解决办法</h4>\n<p>将启动器类放在与扫描包同级即可，一般是和controller包的上一层的包的同一级。例如</p>\n<blockquote>\n<p>我在这里多了一层web,将主启动类放入study文件夹下，和web同级即可。</p>\n</blockquote>\n<p><img src=\"./images/Spring-error&hole/springboot_error_1-2.png\" alt=\"\" /></p>\n<h3 id=\"将枚举类型输出时转换为json类型\"> 将枚举类型输出时转换为JSON类型</h3>\n<p>加上注解</p>\n<div><pre><code><span>@JsonFormat</span><span>(</span>shape <span>=</span> <span>JsonFormat<span>.</span>Shape</span><span>.</span>OBJECT<span>)</span>\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"security的key最短四个字符\"> security的key最短四个字符</h3>\n<p>报错</p>\n<p>secret key byte array cannot be null or empty.</p>\n<h3 id=\"不自动注入datasource而启动springboot\"> 不自动注入dataSource而启动Springboot</h3>\n<p>参考：<a href=\"https://blog.csdn.net/qq_25811101/article/details/109410072\" target=\"_blank\" rel=\"noopener noreferrer\">@SpringBootApplication(exclude = DataSourceAutoConfiguration.class)不生效</a></p>\n<p>方案一：在启动方法添加exclude</p>\n<div><pre><code><span>@SpringBootApplication</span><span>(</span>exclude <span>=</span> <span>{</span><span>DataSourceAutoConfiguration</span><span>.</span><span>class</span><span>,</span>\n    <span>DataSourceTransactionManagerAutoConfiguration</span><span>.</span><span>class</span><span>,</span>\n    <span>DruidDataSourceAutoConfigure</span><span>.</span><span>class</span><span>,</span>\n    <span>HibernateJpaAutoConfiguration</span><span>.</span><span>class</span><span>}</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>方案二：在yml文件中配置</p>\n<div><pre><code><span>spring</span><span>:</span>\n  <span>application</span><span>:</span>\n    <span>name</span><span>:</span> order\n  <span>autoconfigure</span><span>:</span>\n    <span>exclude</span><span>:</span> org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id=\"gradle\"> Gradle</h2>\n<h3 id=\"no-cached-version-of-com-android-tools-build-gradle-3-6-2-available-for-offline-mode\"> No cached version of com.android.tools.build:gradle:3.6.2 available for offline mode</h3>\n<p>参考：<a href=\"https://www.cnblogs.com/flay/p/12641381.html\" target=\"_blank\" rel=\"noopener noreferrer\">No cached version of com.android.tools.build:gradle:3.6.2 available for offlin 解决办法</a></p>\n<p>在IDEA中点击右边Gradle设为非无线模式</p>\n<h2 id=\"mybatisplus\"> MybatisPlus</h2>\n<h3 id=\"myabtisplus执行方法异常-cause-java-lang-indexoutofboundsexception-index-22-size-22\"> myabtisplus执行方法异常 Cause: java.lang.IndexOutOfBoundsException: Index: 22, Size: 22</h3>\n<p>调用自带方法  selectById()</p>\n<h3 id=\"the-error-occurred-while-handling-results\"> The error occurred while handling results</h3>\n<h3 id=\"cause-java-lang-indexoutofboundsexception-index-22-size-22\"> Cause: java.lang.IndexOutOfBoundsException: Index: 22, Size: 22</h3>\n<p>解决办法\n方法一：去除@Builder注解。</p>\n<p>方法二：增加构造函数，如Lombok提供的@NoArgsConstructor、@AllArgsConstructor。</p>\n",
      "date_published": "2021-01-13T12:00:37.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": []
    },
    {
      "title": "Spring基础笔记",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/spring/Spring/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/spring/Spring/",
      "content_html": "<h2 id=\"参考\"> 参考</h2>\n<div><p>Tips</p>\n<ul>\n<li><a href=\"https://www.processon.com/mindmap/60abc60407912906fbcf50ba\" target=\"_blank\" rel=\"noopener noreferrer\">脑图参考</a></li>\n<li><a href=\"https://my.oschina.net/u/3080373/blog/891918\" target=\"_blank\" rel=\"noopener noreferrer\">脑图参考</a></li>\n<li><a href=\"https://blog.csdn.net/weixin_47872288/article/details/117921644?spm=1001.2014.3001.5501\" target=\"_blank\" rel=\"noopener noreferrer\">尚硅谷笔记</a></li>\n</ul>\n</div>\n<p>什么是 Spring 框架? Spring 是⼀种轻量级开发框架，旨在提⾼开发⼈员的开发效率以及系统的可维护性。</p>\n<p>Spring 官⽹：https://spring.io/。</p>\n<p>我们⼀般说 Spring 框架指的都是 Spring Framework，它是很多模块的集合，使⽤这些模块可以很⽅ 便地协助我们进⾏开发。这些模块是：核⼼容器、数据访问/集成,、Web、AOP（⾯向切⾯编程）、⼯ 具、消息和测试模块。⽐如：Core Container 中的 Core 组件是Spring 所有组件的核⼼，Beans 组件 和 Context 组件是实现IOC和依赖注⼊的基础，AOP组件⽤来实现⾯向切⾯编程。</p>\n<h2 id=\"spring特征\"> Spring特征</h2>\n<p>Spring 官⽹列出的 Spring 的 6 个特征:</p>\n<div><p>Spring 的 6 个特征</p>\n<ul>\n<li><strong>核心技术</strong> ：依赖注⼊(DI)，AOP，事件(events)，资源，i18n，验证，数据绑定，类型转换， SpEL。</li>\n<li><strong>测试</strong> ：模拟对象，TestContext框架，Spring MVC 测试，WebTestClient。</li>\n<li><strong>数据访问</strong> ：事务，DAO⽀持，JDBC，ORM，编组XML。</li>\n<li><strong>Web⽀持</strong> : Spring MVC和Spring WebFlux Web框架。</li>\n<li><strong>集成</strong> ：远程处理，JMS，JCA，JMX，电⼦邮件，任务，调度，缓存。</li>\n<li><strong>语⾔</strong> ：Kotlin，Groovy，动态语⾔。</li>\n</ul>\n</div>\n<h2 id=\"spring优点\"> Spring优点</h2>\n<ul>\n<li>IOC方便解耦，简便开发</li>\n<li>AOP不改变源代码，增加其功能</li>\n<li>方便程序测试</li>\n<li>方便其他程序的整合</li>\n<li>降低API的开发难度</li>\n</ul>\n<h2 id=\"spring七大模块\"> Spring七大模块</h2>\n<div><p>参考</p>\n<blockquote>\n<ul>\n<li>https://www.cnblogs.com/lukelook/p/9604609.html</li>\n<li>https://www.cnblogs.com/xiaobaizhiqian/p/7616453.html</li>\n</ul>\n</blockquote>\n</div>\n<p><img src=\"./images/Spring-bacisNote/Spring_Framework_Runtime.jpg\" alt=\"\" /></p>\n<p><img src=\"https://image-1300566513.cos.ap-guangzhou.myqcloud.com/upload/images/20191227/206d8714bd3f0cf904af3c58ef8cd1a9.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240\" alt=\"2、常用模块.png\" /></p>\n<h2 id=\"ioc-控制反转\"> IOC（控制反转）</h2>\n<p>所需依赖</p>\n<ul>\n<li>beans</li>\n<li>context</li>\n<li>core</li>\n<li>expression</li>\n</ul>\n<h3 id=\"概念\"> 概念</h3>\n<p>IOC（Inverse of Control:控制反转）是依赖倒置原则⼀种设计思想，就是把原先在代码里面需要实现的对象创建、对象之间的依赖，通过抽象交由给IOC容器来管理。IOC容器实际上就是个Map（key，value）,Map 中存放的是各种对象。</p>\n<ul>\n<li>将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注⼊。这样可以很⼤程度 上简化应用的开发，把应⽤从复杂的依赖关系中解放出来。</li>\n<li>IoC 容器就像是⼀个工厂⼀样，当我们需 要创建⼀个对象的时候，只需要配置好配置⽂件/注解即可，完全不⽤考虑对象是如何被创建出来的。</li>\n<li>在实际项⽬中⼀个 Service 类可能有⼏百甚⾄上千个类作为它的底层，假如我们需要实例化这个 Service，你可能要每次都要搞清这个 Service 所有底层类的构造函数，这可能会把⼈逼疯。如果利⽤ IoC 的话，你只需要配置好，然后在需要的地⽅引⽤就⾏了，这⼤⼤增加了项⽬的可维护性且降低了开 发难度。</li>\n</ul>\n<p>Spinrg中通过下面来实现</p>\n<ul>\n<li>xml配置</li>\n<li>工厂模式</li>\n<li>反射</li>\n</ul>\n<h3 id=\"好处\"> 好处</h3>\n<ul>\n<li>它将最小化应用程序中的代码量。</li>\n<li>它将使您的应用程序易于测试，因为它不需要单元测试用例中的任何单例或 JNDI 查找机制。</li>\n<li>它以最小的影响和最少的侵入机制促进松耦合。</li>\n<li>它支持即时的实例化和延迟加载服务。</li>\n<li>集中管理，实现类的可配置和易管理。</li>\n<li>降低了类与类之间的耦合度。</li>\n</ul>\n<h3 id=\"ioc容器接口\"> IOC容器接口</h3>\n<ul>\n<li>BeanFactory：Spring内部使用接口，不提供给开发人员。<code>懒加载</code>，加载配置xml解析不会创建对象，只有getBean才会创建对象</li>\n<li>ApplicationContext：是BeanFactory<code>子接口</code>，功能强大，开发人员可使用，加载配置就会创建对象\n<ul>\n<li>ClassPathXmlApplicationContext：相对路径，src下</li>\n<li>FileSystemXmlApplicationContext：绝对路径，src下</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"beanfactory-applicationcontext对比\"> BeanFactory | ApplicationContext对比</h4>\n<p><strong>功能上区别</strong></p>\n<p><code>BeanFactory</code>是Spring里面最底层的接口，包含了各种Bean的定义，读取bean配置文档，管理bean的加载、实例化，控制bean的生命周期，维护bean之间的依赖关系。</p>\n<p><code>ApplicationContext</code>接口作为<code>BeanFactory</code>的派生，是应用上下文，除了提供BeanFactory所具有的功能外，还提供了更完整的框架功能：</p>\n<blockquote>\n<ul>\n<li>国际化（MessageSource）</li>\n<li>访问资源，如URL和文件（ResourceLoader）</li>\n<li>载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的web层</li>\n<li>消息发送、响应机制（ApplicationEventPublisher）</li>\n<li>AOP（拦截器）</li>\n</ul>\n</blockquote>\n<p><strong>两者装载bean的区别</strong></p>\n<blockquote>\n<ul>\n<li><mark>BeanFactory</mark>：BeanFactory在启动的时候不会去实例化Bean，只有从容器中拿Bean的时候才会去实例化</li>\n<li><mark>ApplicationContext</mark>：ApplicationContext在启动的时候就把所有的Bean全部实例化了。它还可以为Bean配置<code>lazy-init=true</code>来让Bean延迟实例化</li>\n</ul>\n</blockquote>\n<p><strong>占用内存空间区别</strong></p>\n<p>相对于基本的<code>BeanFactory</code>，<code>ApplicationContext</code> 唯一的不足是占用内存空间。当应用程序配置Bean较多时，程序启动较慢。</p>\n<p><strong>创建方式区别</strong></p>\n<p><code>BeanFactory</code>通常以<code>编程的方式</code>被创建，<code>ApplicationContext</code>还能以<code>声明的方式</code>创建，如使用ContextLoader。</p>\n<p><strong>我们该用BeanFactory还是ApplicationContent</strong></p>\n<blockquote>\n<ul>\n<li>\n<p><mark>延迟实例化的优点BeanFactory</mark>：应用启动的时候占用资源很少；对资源要求较高的应用，比较有优势</p>\n</li>\n<li>\n<p><mark>不延迟实例化的优点ApplicationContent</mark>：</p>\n<blockquote>\n<ul>\n<li>所有的Bean在启动的时候都加载，系统运行的速度快；</li>\n<li>在启动的时候所有的Bean都加载了，我们就能在系统启动的时候，尽早的发现系统中的<code>配置问题</code></li>\n<li>建议web应用，在启动的时候就把所有的Bean都加载了。（把费时的操作放到系统启动中完成）</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n</blockquote>\n<h3 id=\"bean生命周期管理-基于xml\"> Bean生命周期管理（基于xml)</h3>\n<p>参考</p>\n<ul>\n<li><a href=\"https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-metadata\" target=\"_blank\" rel=\"noopener noreferrer\">xml官方文档</a></li>\n</ul>\n<h4 id=\"对象创建\"> 对象创建</h4>\n<div><pre><code><span><span><span>&lt;</span>bean</span> <span>id</span><span><span>=</span><span>\"</span>userService<span>\"</span></span> <span>class</span><span><span>=</span><span>\"</span>com.atguigu.spring5.service.UserService<span>\"</span></span><span>></span></span>\n</code></pre>\n<div><span>1</span><br></div></div><div><pre><code><span>//1 加载spring配置文件</span>\n<span>ApplicationContext</span> context <span>=</span><span>new</span> <span>ClassPathXmlApplicationContext</span><span>(</span><span>\"bean2.xml\"</span><span>)</span><span>;</span>\n\n<span>//2 获取配置创建的对象</span>\n<span>UserService</span> userService <span>=</span> context<span>.</span><span>getBean</span><span>(</span><span>\"userService\"</span><span>,</span> <span>UserService</span><span>.</span><span>class</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>默认调用的是<code>无参构造函数</code>完成对象创建</p>\n<h4 id=\"属性注入\"> 属性注入</h4>\n<ul>\n<li>使用set方式</li>\n<li>使用有参构造函数</li>\n<li>使用xml注入属性</li>\n</ul>\n<p>使用xml注入属性</p>\n<div><pre><code><span><span><span>&lt;</span>bean</span> <span>id</span><span><span>=</span><span>\"</span>book<span>\"</span></span> <span>class</span><span><span>=</span><span>\"</span>com.atguigu.spring5.Book<span>\"</span></span><span>></span></span>\n    <span><span><span>&lt;</span>property</span> <span>name</span><span><span>=</span><span>\"</span>码农研究僧<span>\"</span></span> <span>value</span><span><span>=</span><span>\"</span>99999<span>\"</span></span><span>></span></span><span><span><span>&lt;/</span>property</span><span>></span></span>\n<span><span><span>&lt;/</span>bean</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>使用有参构造函数</p>\n<div><pre><code><span><span><span>&lt;</span>bean</span> <span>id</span><span><span>=</span><span>\"</span>orders<span>\"</span></span> <span>class</span><span><span>=</span><span>\"</span>com.atguigu.spring5.Orders<span>\"</span></span><span>></span></span>\n    <span><span><span>&lt;</span>constructor-arg</span> <span>name</span><span><span>=</span><span>\"</span>oname<span>\"</span></span> <span>value</span><span><span>=</span><span>\"</span>电脑<span>\"</span></span><span>></span></span><span><span><span>&lt;/</span>constructor-arg</span><span>></span></span>\n    <span><span><span>&lt;</span>constructor-arg</span> <span>name</span><span><span>=</span><span>\"</span>address<span>\"</span></span> <span>value</span><span><span>=</span><span>\"</span>China<span>\"</span></span><span>></span></span><span><span><span>&lt;/</span>constructor-arg</span><span>></span></span>\n<span><span><span>&lt;/</span>bean</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h4 id=\"自动装配\"> 自动装配</h4>\n<p>参考：<a href=\"https://www.cnblogs.com/bear7/p/12531016.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.cnblogs.com/bear7/p/12531016.html</a></p>\n<h3 id=\"基于注解-声明为bean\"> 基于注解：声明为bean</h3>\n<p>我们⼀般使⽤ <code>@Autowired</code> 注解⾃动装配 bean，要想把类标识成可⽤于 <code>@Autowired</code> 注解⾃动装 配的 bean 的类,采⽤以下注解可实现：</p>\n<ul>\n<li>@Component ：通⽤的注解，可标注任意类为 Spring 组件。如果⼀个Bean不知道属于哪个 层，可以使⽤ @Component 注解标注。</li>\n<li>@Repository : 对应持久层即 Dao 层，主要⽤于数据库相关操作。</li>\n<li>@Service : 对应服务层，主要涉及⼀些复杂的逻辑，需要⽤到 Dao层。</li>\n<li>@Controller : 对应 Spring MVC 控制层，主要⽤户接受⽤户请求并调⽤ Service 层返回数 据给前端页面，也可用@RestController</li>\n</ul>\n<h3 id=\"基于注解-属性注入-autowired和-qualifier\"> 基于注解：属性注入@Autowired和@Qualifier</h3>\n<h2 id=\"spring-bean\"> Spring Bean</h2>\n<div><p>参考</p>\n<ul>\n<li>https://www.awaimai.com/2596.html</li>\n<li>https://blog.csdn.net/qq_39411208/article/details/88395875</li>\n<li><a href=\"https://blog.csdn.net/qq_43709204/article/details/109991097\" target=\"_blank\" rel=\"noopener noreferrer\">Spring IOC中Bean的作⽤域与⽣命周期</a></li>\n<li>https://blog.csdn.net/kongmin_123/article/details/82048392</li>\n</ul>\n</div>\n<h3 id=\"什么是bean\"> 什么是bean</h3>\n<p>Spring 官方文档对 Bean 的解释是：</p>\n<blockquote>\n<p>In Spring, the objects that form the backbone of your application and that are managed by the Spring IoC container are called beans. A bean is an object that is instantiated, assembled, and otherwise managed by a Spring IoC container.</p>\n</blockquote>\n<p>翻译过来就是：</p>\n<blockquote>\n<p>在 Spring 中，构成应用程序<code>主干</code>并由<code>Spring IoC容器</code>管理的<code>对象</code>称为<code>bean</code>。bean是一个由<code>Spring IoC</code>容器实例化、组装和管理的对象。</p>\n</blockquote>\n<p>Bean也是基于用户提供容器的配置元数据创建</p>\n<h3 id=\"bean生命周期\"> Bean生命周期</h3>\n<p>参考</p>\n<ul>\n<li><a href=\"https://www.cnblogs.com/javazhiyin/p/10905294.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.cnblogs.com/javazhiyin/p/10905294.html</a></li>\n</ul>\n<p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/Spring/bean生命周期.png\" alt=\"image-20211120194324042\" /></p>\n<p>具体过程</p>\n<p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/Spring-Interview/spring bean生命周期2.jpg\" alt=\"Spring bean 的生命周期2\" /></p>\n<p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/Spring-Interview/spring bean生命周期3.jpg\" alt=\"Spring bean 的生命周期\" /></p>\n<ul>\n<li>如果实现InstantiationAwareBeanPostProcessor接口，那么会调用postProcessBeforeInstantiation方法，如果该方法返回非null则不会走后续流程</li>\n<li>Spring对bean通过构造器进行实例化，构造器的推断可以使用@Autowired注解，如果有多个自定义构造方法，那么根据可注入性，顺序性来注入</li>\n<li>Spring将值和bean的引用注入到bean对应的属性中；</li>\n<li>如果bean实现了BeanNameAware接口，Spring将bean的ID传递给 setBean-Name()方法；</li>\n<li>如果bean实现了BeanFactoryAware接口，Spring将调用 setBeanFactory()方法，将BeanFactory容器实例传入；</li>\n<li>如果bean实现了ApplicationContextAware接口，Spring将调用 setApplicationContext()方法，将bean所在的应用上下文的引用 传入进来；</li>\n<li>如果bean实现了BeanPostProcessor接口，Spring将调用它们的 post-ProcessBeforeInitialization()方法；</li>\n<li>如果bean实现了InitializingBean接口，Spring将调用它们的 after-PropertiesSet()方法。</li>\n<li>调用bean标签指定的属性init-Method初始化方法</li>\n<li>如果bean实现了BeanPostProcessor接口，Spring将调用它们的 post-ProcessAfterInitialization()方法；</li>\n<li>此时，bean已经准备就绪，可以被应用程序使用了，它们将一直驻留在应用上下文中，直到该应用上下文被销毁；</li>\n<li>如果bean实现了DisposableBean接口，Spring将调用它的 destroy()接口方法。同样，如果bean使用destroy-method声明了 销毁方法，该方法也会被调用。</li>\n<li>调用bean标签指定的属性detroy-Method毁灭方法</li>\n</ul>\n<h4 id=\"各种接口方法分类\"> 各种接口方法分类</h4>\n<p>Bean的完整生命周期经历了各种方法调用，这些方法可以划分为以下几类：</p>\n<div><p>Info</p>\n<ul>\n<li>Bean自身的方法：这个包括了Bean本身调用的方法和通过配置文件中&lt;bean&gt;的<code>init-method</code>和<code>destroy-method</code>指定的方法</li>\n<li>Bean级生命周期接口方法：这个包括了BeanNameAware、BeanFactoryAware、InitializingBean和DiposableBean这些接口的方法</li>\n<li>容器级生命周期接口方法：这个包括了InstantiationAwareBeanPostProcessor 和 BeanPostProcessor 这两个接口实现，一般称它们的实现类为“后处理器”。</li>\n<li>工厂后处理器接口方法：这个包括了AspectJWeavingEnabler, ConfigurationClassPostProcessor, CustomAutowireConfigurer等等非常有用的工厂后处理器接口的方法。工厂后处理器也是容器级的。在应用上下文装配配置文件之后立即调用。</li>\n</ul>\n</div>\n<h3 id=\"spring-bean中五种作用域\"> Spring bean中五种作用域?</h3>\n<table>\n<thead>\n<tr>\n<th>作用域</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>singleton</td>\n<td>在spring IoC容器仅存在一个Bean实例，Bean以单例方式存在，bean作用域范围的<code>默认值</code>。</td>\n</tr>\n<tr>\n<td>prototype</td>\n<td>每次从容器中调用Bean时，都返回一个新的实例，即每次调用getBean()时，相当于执行newXxxBean()。</td>\n</tr>\n<tr>\n<td>request</td>\n<td>每次HTTP请求都会创建一个新的Bean，该作用域仅适用于web的Spring WebApplicationContext环境。</td>\n</tr>\n<tr>\n<td>session</td>\n<td>同一个HTTP Session共享一个Bean，不同Session使用不同的Bean。该作用域仅适用于web的Spring WebApplicationContext环境。</td>\n</tr>\n<tr>\n<td>application</td>\n<td>限定一个Bean的作用域为<code>ServletContext</code>的生命周期。该作用域仅适用于web的Spring WebApplicationContext环境。</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"singleton-作用域\"> singleton 作用域</h4>\n<p><img src=\"./images/Spring-bacisNote/singleton_scope.png\" alt=\"singleton 作⽤域\" /></p>\n<div><p>关于lazy-init</p>\n<p>lazy-init是懒加载, 如果等于true时作⽤是指Spring容器启动的时候不会去实例化这个bean,⽽是在程序调⽤时才去实例化. 默认是false即Spring容器启动时实例化.</p>\n</div>\n<p>实例</p>\n<p>创建一个bean:</p>\n<div><p>SingletonBean.java</p>\n<div><pre><code><span>package</span> <span>com<span>.</span>spring<span>.</span>demo</span><span>;</span>\n<span>public</span> <span>class</span>  <span>SingletonBean</span><span>{</span>\n   <span>private</span> <span>String</span> message<span>;</span>\n   <span>public</span> <span>void</span> <span>setMessage</span><span>(</span><span>String</span> message<span>)</span><span>{</span>\n      <span>this</span><span>.</span>message  <span>=</span> message<span>;</span>\n   <span>}</span>\n   <span>public</span> <span>void</span> <span>getMessage</span><span>(</span><span>)</span><span>{</span>\n      <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"Your Message : \"</span> <span>+</span> message<span>)</span><span>;</span>\n   <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div></div>\n<p>在Spring的配置文件中配置该bean:</p>\n<div><p>Bean.xml</p>\n<div><pre><code><span>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?></span>\n<span><span><span>&lt;</span>beans</span> <span>xmlns</span><span><span>=</span><span>\"</span>http://www.springframework.org/schema/beans<span>\"</span></span>\n       <span><span>xmlns:</span>xsi</span><span><span>=</span><span>\"</span>http://www.w3.org/2001/XMLSchema-instance<span>\"</span></span>\n       <span><span>xsi:</span>schemaLocation</span><span><span>=</span><span>\"</span>\n        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd<span>\"</span></span><span>></span></span>\n \n    <span><span><span>&lt;</span>bean</span> <span>id</span><span><span>=</span><span>\"</span>SingletonBean<span>\"</span></span> <span>class</span><span><span>=</span><span>\"</span>com.spring.demo.SingletonBean<span>\"</span></span> <span>scope</span><span><span>=</span><span>\"</span>singleton<span>\"</span></span><span>></span></span><span><span><span>&lt;/</span>bean</span><span>></span></span>\n    <span>&lt;!-- 或者 --></span>\n    <span>&lt;!--  &lt;bean id=\"SingletonBean\" >&lt;/bean> --></span>\n<span><span><span>&lt;/</span>beans</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div></div>\n<p>测试该Bean是否为单例的:</p>\n<div><p>TestBean.java</p>\n<div><pre><code><span>package</span> <span>com<span>.</span>spring<span>.</span>demo</span><span>;</span>\n \n<span>import</span> <span>org<span>.</span>springframework<span>.</span>context<span>.</span></span><span>ApplicationContext</span><span>;</span>\n<span>import</span> <span>org<span>.</span>springframework<span>.</span>context<span>.</span>support<span>.</span></span><span>ClassPathXmlApplicationContext</span><span>;</span>\n<span>import</span> <span>org<span>.</span>junit<span>.</span></span><span>Test</span><span>;</span>\n \n<span>public</span> <span>class</span> <span>TestBean</span> <span>{</span>\n \n    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>textUser</span><span>(</span><span>)</span>\n    <span>{</span>\n        <span>//1.获取spring文件</span>\n        <span>ApplicationContext</span> context <span>=</span> <span>new</span> <span>ClassPathXmlApplicationContext</span><span>(</span><span>\"Bean.xml\"</span><span>)</span><span>;</span>\n        <span>//2.由配置文件返回对象</span>\n        <span>SingletonBean</span> singletonBeanA <span>=</span> <span>(</span><span>SingletonBean</span><span>)</span>context<span>.</span><span>getBean</span><span>(</span><span>\"SingletonBean\"</span><span>)</span><span>;</span>\n        singletonBeanA<span>.</span><span>setMessage</span><span>(</span><span>\"I'm object A\"</span><span>)</span><span>;</span>\n        singletonBeanA<span>.</span><span>getMessage</span><span>(</span><span>)</span><span>;</span>\n        <span>SingletonBean</span> singletonBeanB <span>=</span> <span>(</span><span>SingletonBean</span><span>)</span>context<span>.</span><span>getBean</span><span>(</span><span>\"SingletonBean\"</span><span>)</span><span>;</span>\n        singletonBeanB<span>.</span><span>getMessage</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div></div>\n<p>运行结果:</p>\n<div><p>运行结果</p>\n<p><img src=\"./images/Spring-bacisNote/Singleton_result.png\" alt=\"singleton运行结果\" /></p>\n</div>\n<p><code>lazy-init</code>设置为<code>false</code>的好处</p>\n<div><p>好处</p>\n<p>可以提前发现潜在的配置问题</p>\n<p>Bean 对象存在于缓存中，使⽤时不⽤再去实例化bean，加快程序运⾏效率</p>\n</div>\n<p>适合作为单例的对象</p>\n<div><p>适合作为单例的对象</p>\n<p>就是作为适合创建bean例的类，⼀般来说对于⽆状态或状态不可改变的对象适合使⽤单例模式。（不存在会改变对象状态的成员变量）</p>\n<p>比如：user类定义的是各种属性，但有的时候我们需要的只是user属性的一小部分，所以user就不适合作为单例，而controller层、service层、dao层里面的类似固定的操作固定的属性，不会发生什么变动，所以适合作为单例。</p>\n</div>\n<h4 id=\"prototype-作用域\"> prototype 作⽤域</h4>\n<p><img src=\"./images/Spring-bacisNote/prototype_scope.png\" alt=\"singleton 作⽤域\" /></p>\n<p>当一个bean的作用域为<code>prototype</code>，表示一个bean定义对应多个对象实例。声明为prototype作用域的bean会导致在每次对该bean请求（将其注入到另一个bean中，或者以程序的方式调用容器的getBean()方法）时都会创建一个新的bean实例。prototype是原型类型，它在我们创建容器的时候并没有实例化，而是当我们获取bean的时候才会去创建一个对象，而且我们每次获取到的对象都不是同一个对象。</p>\n<p>根据经验，对<code>有状态的bean</code>应该使用<code>prototype</code>作用域，而对<code>无状态的bean</code>则应该使用<code>singleton</code>作用域。</p>\n<h4 id=\"request-请求作用域\"> request 请求作用域</h4>\n<p>Spring容器会在每次用到<code>loginAction</code>来处理每个HTTP请求的时候都会创建一个新的<code>LoginAction</code>实例。也就是说，<code>loginAction</code>Bean的作用域是HTTP <code>Request</code>级别的。</p>\n<p>当http请求调用作用域为request的bean的时候，每增加一个HTTP请求，Spring就会创建一个新的bean，在请求处理完成之后便及时销毁这个bean。开发者可以随意改变实例的状态，因为通过<code>loginAction</code>请求来创建的其他实例根本看不到开发者改变的实例状态，所有创建的Bean实例都是根据独立的请求来的。</p>\n<h4 id=\"session-会话作用域\"> session 会话作用域</h4>\n<p>Spring容器会在每次调用到<code>userPreferences时，</code>在一个单独的HTTP会话周期来创建一个新的<code>UserPreferences</code>实例。换言之<code>userPreferences</code>Bean的作用域是HTTP <code>Session</code>级别的。</p>\n<p>Session中所有http请求共享同一个请求的bean实例。Session结束后就销毁bean。 在<code>request-scoped</code>作用域的Bean上，开发者可以随意的更改实例的状态。同样，使用从同一个userPreferences bean定义创建的其他HTTP Session实例在看不到不是自己的内部状态的修改，因为他们是单个的HTTP会话。每个Session请求都会创建新的<code>userPreferences</code>实例，所以开发者更改一个Bean的状态，对于其他的Bean仍然是不可见的。</p>\n<h4 id=\"application-全局作用域\"> application 全局作用域</h4>\n<p>Spring容器会在整个web应用范围使用到<code>appPreferences</code>的时候创建一个新的<code>AppPreferences</code>的实例。也就是说，<code>appPreferences</code>Bean是在<code>ServletContext</code>级别的，作为常规的ServletContext属性。这种作用域在一些程度上来说和Spring的单例作用域相似，但是也有如下不同之处：</p>\n<ul>\n<li><code>application</code>作用域是每个<code>ServletContext</code>中包含一个，而不是每个Spring<code>ApplicationContext</code>之中包含一个（某些应用中可能包含不止一个<code>ApplicationContext</code>）。</li>\n<li><code>application</code>作用域仅仅作为<code>ServletContext</code>的属性可见，单例Bean是<code>ApplicationContext</code>可见。</li>\n</ul>\n<p>接下来再来简单的学习下在Spring当中如何自定义作用域：</p>\n<p>在Spring 2.0中，Spring的Bean作用域机制是可以扩展的，这意味着，你不仅可以使用Spring提供的预定义Bean作用域，还可以定义自己的作用域，甚至重新定义现有的作用域（不提倡这么做，而且你不能覆盖内置的singleton和prototype作用域）</p>\n<h3 id=\"beandefinition\"> BeanDefinition</h3>\n<p><code>BeanDefinition</code>表示Bean定义，Spring根据<code>BeanDfinition</code>来创建Bean对象，<code>BeanDfinition</code>有很多属性用来描述Bean。</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>beanClass</td>\n<td>表示一个bean类型。Spring在创建bean过程根据此属性来实例化得到对象</td>\n</tr>\n<tr>\n<td>scope</td>\n<td>作用域</td>\n</tr>\n<tr>\n<td>isLazy</td>\n<td>是否懒加载。表示一个bean是不是需要懒加载,原型bean的 isLazy属性不起作用, 懒加载的单例bean,会在第一次 getBean的时候生成该bean,非懒加 载的单例bean,则会在 Spring启动过程中直接生成好。</td>\n</tr>\n<tr>\n<td>dependsOn</td>\n<td>表示一个bean在创建之前所依赖的其他bean,在一个bean创建之前,它所依赖的这些bean得先全部创建好。</td>\n</tr>\n<tr>\n<td>primary</td>\n<td>表示一个bean是主bean。在Spng中一个类型可以有多个bean对象, 在进行依赖注入时,如果根据类型找到了多个bean,此时会判断这些 bean中是否存在一个主bean,如果存在,则直接将这个bean注入给属性</td>\n</tr>\n<tr>\n<td>initMethodName</td>\n<td>表示一个bean的初始化方法。一个bean的生命周期过程中有一个步骤叫初始化,Spng会在这个步骤中去调用bean的初始化方法,初始化逻辑由程序员自己控制,表示程序员可以自定义逻辑对bean进行加</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"beanfactory\"> BeanFactory</h3>\n<p><code>BeanFactory</code>是创建Bean的Spring容器。</p>\n<p><code>BeanFactory</code>利用<code>BeanDefinition</code>作为模板来生成Bean对象</p>\n<h3 id=\"spring提供了哪些bean配置方式\"> Spring提供了哪些bean配置方式</h3>\n<div><p>参考</p>\n<ul>\n<li>https://blog.csdn.net/qq_35744081/article/details/94986758</li>\n</ul>\n</div>\n<div><p>三种配置方式</p>\n<ul>\n<li>基于xml的配置</li>\n<li>基于注解的配置</li>\n<li>基于Java的配置</li>\n</ul>\n</div>\n<h3 id=\"bean循环依赖问题\"> bean循环依赖问题</h3>\n<div><p>参考</p>\n<ul>\n<li><a href=\"https://www.cnblogs.com/yanggb/p/13125998.html\" target=\"_blank\" rel=\"noopener noreferrer\">spring bean循环依赖的解决方法</a></li>\n<li><a href=\"https://blog.csdn.net/u010853261/article/details/77940767\" target=\"_blank\" rel=\"noopener noreferrer\">Spring-bean的循环依赖以及解决方式</a></li>\n</ul>\n</div>\n<h2 id=\"aop-aspect-oriented-programming-面向切面编程\"> AOP（Aspect-Oriented Programming）：面向切面编程</h2>\n<div><p>参考</p>\n<ul>\n<li>https://www.cnblogs.com/joy99/p/10941543.html</li>\n<li><a href=\"https://blog.csdn.net/u010890358/article/details/80640433\" target=\"_blank\" rel=\"noopener noreferrer\">SpringAOP详细配置与使用</a></li>\n<li>https://www.jianshu.com/p/78ba8bafb90a</li>\n</ul>\n</div>\n<p><code>OOP</code>面向对象，允许开发者定义纵向的关系，但并适用于定义横向的关系，导致了大量代码的重复，而不利于各个模块的重用。</p>\n<p><code>AOP(Aspect-Oriented Programming)</code>:⾯向切⾯编程)能够将那些与业务⽆关，却为业务模块所共同调⽤的逻辑或责任（例如<code>事务处理</code>、<code>⽇志管理</code>、<code>权限控制</code>等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。</p>\n<h3 id=\"使用aop的好处\"> 使用AOP的好处</h3>\n<div><p>好处</p>\n<ul>\n<li>降低模块的耦合度</li>\n<li>使系统容易扩展</li>\n<li>提高代码复用性</li>\n</ul>\n</div>\n<h3 id=\"aop的基本概念\"> AOP的基本概念</h3>\n<div><p>AOP基本概念</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>连接点（JoinPoint）</td>\n<td>需要在程序中插入横切关注点的点，连接点可能是在类初始化、方法调用、字段调用或处理异常等等。Spring中只支持方法执行连接点，通俗来说就是可以被增强的方法</td>\n</tr>\n<tr>\n<td>切入点（Pointcut）</td>\n<td>一组相关连接点的集合，通俗来说就是实际被增强的方法</td>\n</tr>\n<tr>\n<td>通知（Advice）</td>\n<td>在连接点上执行的增强行为逻辑，增强提供了在AOP中需要在切入点所选择的连接点处进行扩展现有行为的手段。包括前置通知、后置通知 、环绕通知、异常通知、最终通知</td>\n</tr>\n<tr>\n<td>切面（Aspect）</td>\n<td>通知和切入点的结合，吧通知应用到切入点的过程</td>\n</tr>\n<tr>\n<td>织入（Weaving）</td>\n<td>织入是一个过程，是将切面应用到目标对象从而创建出AOP代理对象的过程。</td>\n</tr>\n<tr>\n<td>代理（Proxy）</td>\n<td>通过代理方式来对目标对象应用切面。AOP代理可以用JDK动态代理或CGLIB代理实现。</td>\n</tr>\n<tr>\n<td>目标对象（Target）</td>\n<td>需要被织入关注点的对象。即被代理的对象。</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"aop运行原理-设计模式\"> AOP运行原理/设计模式</h3>\n<p><img src=\"./images/Spring-bacisNote/AOP_operational_principle.jpg\" alt=\"七大模块\" /></p>\n<p>实现AOP的主要设计模式就是动态代理。\nSpring的动态代理有两种：一是<code>JDK的动态代理</code>；另一个是<code>cglib动态代理</code>。</p>\n<h4 id=\"使用场景\"> 使用场景</h4>\n<ol>\n<li>如果目标对象实现了接口，默认情况下会采用JDK的动态代理实现AOP ，可以强制使用CGLIB实现AOP</li>\n<li>如果目标对象没有实现了接口，必须采用CGLIB库，spring会自动在JDK动态代理和CGLIB之间转换</li>\n</ol>\n<p>如何强制使用CGLIB实现AOP？</p>\n<ul>\n<li>添加CGLIB库，SPRING_HOME/cglib/*.jar</li>\n<li>在spring配置文件中加入&lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;/&gt;</li>\n</ul>\n<h4 id=\"区别\"> 区别</h4>\n<ul>\n<li>JDK动态代理只能对实现了接口的类生成代理，而不能针对类</li>\n<li>CGLIB是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法因为是继承，所以该类或方法最好不要声明成final</li>\n</ul>\n<h3 id=\"aspectj\"> AspectJ</h3>\n<ul>\n<li>在@Configuration标记的类上加@EnableAspectJAutoProxy注解</li>\n<li>在代理类中加@Component和@AspectJ并自定义通知方法</li>\n</ul>\n<p>示例</p>\n<div><pre><code><span>@Component</span>\n<span>@Aspect</span>\n<span>public</span> <span>class</span> <span>UserDaoProxy</span> <span>{</span>\n    <span>//切入点抽取</span>\n    <span>@Pointcut</span><span>(</span><span>\"execution(* com.longchen.spring5.web.dao.UserDao.add(..))\"</span><span>)</span>\n    <span>private</span> <span>void</span> <span>pointCut</span><span>(</span><span>)</span> <span>{</span>\n\n    <span>}</span>\n\n    <span>//前置通知</span>\n    <span>@Before</span><span>(</span><span>\"pointCut()\"</span><span>)</span>\n    <span>public</span> <span>void</span> <span>before</span><span>(</span><span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"before\"</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>//环绕通知，其中的前置处理比前置通知顺序优先</span>\n    <span>@Around</span><span>(</span><span>\"pointCut()\"</span><span>)</span>\n    <span>public</span> <span>void</span> <span>around</span><span>(</span><span>ProceedingJoinPoint</span> proceedingJoinPoint<span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"around before\"</span><span>)</span><span>;</span>\n        <span>//方法执行</span>\n        <span>try</span> <span>{</span>\n            proceedingJoinPoint<span>.</span><span>proceed</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>Throwable</span> e<span>)</span> <span>{</span>\n            e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"around after\"</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>//非异常时返回通知</span>\n    <span>@AfterReturning</span><span>(</span><span>\"pointCut()\"</span><span>)</span>\n    <span>public</span> <span>void</span> <span>afterReturning</span><span>(</span><span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"afterReturning\"</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>//异常时通知</span>\n    <span>@AfterThrowing</span><span>(</span><span>\"pointCut()\"</span><span>)</span>\n    <span>public</span> <span>void</span> <span>afterThrowing</span><span>(</span><span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"afterThrowing\"</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>//最终通知</span>\n    <span>@After</span><span>(</span><span>\"pointCut()\"</span><span>)</span>\n    <span>public</span> <span>void</span> <span>after</span><span>(</span><span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"after\"</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br></div></div><h3 id=\"spring-aop-和-aspectj-aop-有什么区别\"> Spring AOP 和 AspectJ AOP 有什么区别？</h3>\n<p>Spring AOP 属于运⾏时增强，⽽ AspectJ 是编译时增强。 Spring AOP 基于代理(Proxying)，⽽ AspectJ 基于字节码操作(Bytecode Manipulation)。</p>\n<p>Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java ⽣态系统中最完整的 AOP 框架了。 AspectJ 相⽐于 Spring AOP 功能更加强⼤，但是 Spring AOP 相对来说更简单。</p>\n<p>如果我们的切⾯少，那么两者性能差异不⼤。但是，当切⾯太多的话，最好选择 AspectJ ，它⽐ Spring AOP 快很多。</p>\n<h2 id=\"jdbctemplate\"> jdbcTemplate</h2>\n<ol>\n<li>声明Druid连接池并注入连接数据库四个属性</li>\n<li>声明jdbcTemplate并将Druid作为dataSource注入到其中然后可以使用</li>\n</ol>\n<h3 id=\"源码原理\"> 源码原理</h3>\n<p>参考</p>\n<ul>\n<li><a href=\"https://blog.csdn.net/fighterandknight/article/details/51358140\" target=\"_blank\" rel=\"noopener noreferrer\">spring源码剖析（七）JdbcTemplate数据库封装原理解读</a></li>\n</ul>\n",
      "date_published": "2022-03-06T10:17:18.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": []
    },
    {
      "title": "Maven笔记",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/spring/maven/Maven/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/spring/maven/Maven/",
      "content_html": "<h2 id=\"参考\"> 参考</h2>\n<div><p>Tips</p>\n<ul>\n<li><a href=\"https://www.cnblogs.com/baizihua/p/11519509.html\" target=\"_blank\" rel=\"noopener noreferrer\">maven学习笔记(超详细总结)</a></li>\n<li>https://blog.csdn.net/qq_44839652/article/details/107709822</li>\n</ul>\n</div>\n<h2 id=\"概述\"> 概述</h2>\n<h3 id=\"两大核心\"> 两大核心</h3>\n<ol>\n<li>依赖管理：也就是对jar包的统一管理</li>\n<li>项目构建：在项目编码完成后，原先通过IDE对项目进行编译、测试、打包、部署等一些列操作，都可以通过Maven的命令去完成</li>\n</ol>\n<h2 id=\"标准目录结构\"> 标准目录结构</h2>\n<ul>\n<li><strong>src</strong>：用于存放项目源码\n<ul>\n<li><strong>main</strong>：用于存放运行主要代码\n<ul>\n<li><strong>java</strong>：用于存放主体程序源码</li>\n<li><strong>resources</strong>：用于存放xml等配置文件的</li>\n<li><strong>webapps</strong>：相当于webContent，用于存放WEB-INF、网页页面的素材（html、css、js等）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>test</strong>：用于存放单元测试代码\n<ul>\n<li><strong>java</strong>：用于存放测试代码，单元测试类</li>\n<li><strong>resources</strong>：用于存放测试用的配置文件(一般少用)</li>\n</ul>\n</li>\n<li><strong>target</strong>：用于存放编译好的字节码文件\n<ul>\n<li><strong>classes</strong>：用于存放编译好的字节码文件</li>\n</ul>\n</li>\n<li><strong>pom.xml</strong>：Project Object Module，Maven核心配置文件</li>\n</ul>\n<h2 id=\"pom-xml文件详解\"> pom.xml文件详解</h2>\n<div><p>Tips</p>\n<p><a href=\"https://blog.csdn.net/weixin_38569499/article/details/91456988?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control\" target=\"_blank\" rel=\"noopener noreferrer\">pom.xml文件详解</a></p>\n</div>\n<h2 id=\"常用命令\"> 常用命令</h2>\n<p>格式：<code>mvn [plugin]:[command]</code></p>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>mvn -v</td>\n<td>查看maven版本</td>\n</tr>\n<tr>\n<td>mvn compile</td>\n<td>用来将src/main/java下的文件编译为class文件，并输出到target中。</td>\n</tr>\n<tr>\n<td>mvn package</td>\n<td>打包,将项目进行打包，如果是jar打包为jar，war打包为war。</td>\n</tr>\n<tr>\n<td>mvn install</td>\n<td>将打包jar/war包到本地仓库中，供其他模块使用</td>\n</tr>\n<tr>\n<td>mvn deploy</td>\n<td>将打包jar/war发布到远程仓库</td>\n</tr>\n<tr>\n<td>mvn test</td>\n<td>用来将src/main/test下的测试用例进行编译，同时执行一次</td>\n</tr>\n<tr>\n<td>mvn clean</td>\n<td>删除编译产生的target文件夹</td>\n</tr>\n<tr>\n<td>mvn site</td>\n<td>生成项目相关的网站</td>\n</tr>\n<tr>\n<td>mvn verify</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"参考-2\"> 参考</h2>\n<blockquote>\n<ul>\n<li><a href=\"https://blog.csdn.net/cnweike/article/details/52221410?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param\" target=\"_blank\" rel=\"noopener noreferrer\">Maven POM中的各种scope的行为总结</a></li>\n</ul>\n</blockquote>\n<h2 id=\"maven依赖范围\"> Maven依赖范围</h2>\n<ul>\n<li>**compile，**默认值，适用于所有阶段（开发、测试、部署、运行），本jar会一直存在所有阶段。</li>\n<li>**provided，**只在开发、测试阶段使用，目的是不让Servlet容器和你本地仓库的jar包冲突 。如servlet.jar。</li>\n<li>**runtime，**只在运行时使用，如JDBC驱动，适用运行和测试阶段。</li>\n<li>**test，**只在测试时使用，用于编译和运行测试代码。不会随项目发布。</li>\n<li>**system，**类似provided，需要显式提供包含依赖的jar，Maven不会在Repository中查找它。</li>\n</ul>\n<h3 id=\"compile\"> compile</h3>\n<p>默认的scope。任何定义在compile scope下的依赖将会在所有的class paths下可用。maven工程会将其打包到最终的artifact中。如果你构建一个WAR类型的artifact，那么在compile scope下引用的JAR文件将会被集成到WAR文件内。</p>\n<h3 id=\"provided\"> provided</h3>\n<p>这个scope假定对应的依赖会由运行这个应用的JDK或者容器来提供。最好的例子就是servlet API。任何在provided scope下定义的依赖在构建时的类路径里是可用的，但是不会被打包到最终的artifact中。如果是一个WAR的文件，servlet API在构建时的类路径里是可用的，但是并不会被打包到WAR文件中。</p>\n<h3 id=\"runtime\"> runtime</h3>\n<p>在runtime scope下定义的依赖只会在运行期可用，而在构建期的类路径下不可用。这些依赖将会被打包到最终的artifact中。比如你有一个基于web的应用需要在运行时访问MySQL数据库。你的代码没有任何MySQL数据库驱动的硬依赖。你的代码仅仅是基于JDBC API来编写，在构建期并不需要MySQL数据库驱动。然而，在运行期，就需要相应的驱动来操作MySQL数据库了。因此，这个驱动应该被打包到最终的artifact中。</p>\n<h3 id=\"test\"> test</h3>\n<p>只用于测试变异的依赖（比如JUnit），execution必须定义在test scope下。这些依赖不会被打包到最终的artifact中。</p>\n<h3 id=\"system\"> system</h3>\n<p>于provided scope很像。唯一的区别在于，在system scope中，你需要告诉Maven如何去找到这个依赖。如果你要引用的依赖在Maven仓库中不存在时，就可以用这个scope。不推荐使用system依赖。</p>\n<h3 id=\"import\"> import</h3>\n<p>从其它的pom文件中导入依赖设置。</p>\n<h2 id=\"maven构建多模块项目\"> Maven构建多模块项目</h2>\n<h3 id=\"maven多环境打包\"> Maven多环境打包</h3>\n",
      "date_published": "2021-05-22T22:37:47.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": []
    },
    {
      "title": "EasyExcel导入导出Excel",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/spring/springboot/springboot-tool/EasyExcel-use/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/spring/springboot/springboot-tool/EasyExcel-use/",
      "content_html": "<h2 id=\"参考\"> 参考</h2>\n<blockquote>\n<ul>\n<li>官方文档：https://www.yuque.com/easyexcel/doc/easyexcel</li>\n<li>封装类：https://www.cnblogs.com/proper128/p/12827495.html</li>\n</ul>\n</blockquote>\n<h2 id=\"实体类\"> 实体类</h2>\n<h3 id=\"demodata\"> DemoData</h3>\n<div><pre><code><span>@Data</span>\n<span>public</span> <span>class</span> <span>DemoData</span> <span>{</span>\n    <span>@ExcelProperty</span><span>(</span>value <span>=</span> <span>\"id\"</span><span>)</span>\n    <span>private</span> <span>Integer</span> id<span>;</span>\n\n    <span>@ExcelProperty</span><span>(</span>value <span>=</span> <span>\"title\"</span><span>)</span>\n    <span>private</span> <span>String</span> title<span>;</span>\n\n    <span>@ExcelProperty</span><span>(</span>value <span>=</span> <span>\"date\"</span><span>)</span>\n    <span>private</span> <span>Date</span> date<span>;</span>\n\n    <span>@ExcelProperty</span><span>(</span>value <span>=</span> <span>\"doubleData\"</span><span>)</span>\n    <span>private</span> <span>Double</span> doubleData<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h2 id=\"简单写\"> 简单写</h2>\n<div><pre><code><span>//要写出来的路径</span>\n<span>private</span> <span>final</span> <span>static</span> <span>String</span> PATH <span>=</span> <span>\"C:\\\\Users\\\\a1138\\\\OneDrive\\\\桌面\\\\simpleWrite.xlsx\"</span><span>;</span>\n<span>//从数据库查询出来的List</span>\n<span>List</span><span><span>&lt;</span><span>DemoData</span><span>></span></span> list <span>=</span> demoDataMapper<span>.</span><span>selectByExample</span><span>(</span><span>null</span><span>)</span><span>;</span>\n<span>//调用方法</span>\n<span>EasyExcel</span><span>.</span><span>write</span><span>(</span>PATH<span>,</span> <span>DemoData</span><span>.</span><span>class</span><span>)</span><span>.</span><span>sheet</span><span>(</span><span>\"sheet名字\"</span><span>)</span><span>.</span><span>doWrite</span><span>(</span>list<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id=\"简单读\"> 简单读</h2>\n<p>监听类，用于分析读出来的每条数据和批量插入。Dao方法可以作为参数接收进来</p>\n<h3 id=\"demodatalistener\"> DemoDataListener</h3>\n<div><pre><code><span>// 有个很重要的点 DemoDataListener 不能被spring管理，要每次读取excel都要new,然后里面用到spring可以构造方法传进去</span>\n<span>public</span> <span>class</span> <span>DemoDataListener</span> <span>extends</span> <span>AnalysisEventListener</span><span><span>&lt;</span><span>DemoData</span><span>></span></span> <span>{</span>\n    <span>private</span> <span>static</span> <span>final</span> <span>Logger</span> LOGGER <span>=</span> <span>LoggerFactory</span><span>.</span><span>getLogger</span><span>(</span><span>DemoDataListener</span><span>.</span><span>class</span><span>)</span><span>;</span>\n    <span>/**\n     * 每隔5条存储数据库，实际使用中可以3000条，然后清理list ，方便内存回收\n     */</span>\n    <span>private</span> <span>static</span> <span>final</span> <span>int</span> BATCH_COUNT <span>=</span> <span>5</span><span>;</span>\n    <span>List</span><span><span>&lt;</span><span>DemoData</span><span>></span></span> list <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>DemoData</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n    <span>/**\n     * 假设这个是一个DAO，当然有业务逻辑这个也可以是一个service。当然如果不用存储这个对象没用。\n     */</span>\n    <span>private</span> <span>DemoDataMapper</span> demoDataMapper<span>;</span>\n\n    <span>/**\n     * 如果使用了spring,请使用这个构造方法。每次创建Listener的时候需要把spring管理的类传进来\n     *\n     * @param demoDataMapper\n     */</span>\n    <span>public</span> <span>DemoDataListener</span><span>(</span><span>DemoDataMapper</span> demoDataMapper<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>demoDataMapper <span>=</span> demoDataMapper<span>;</span>\n    <span>}</span>\n    <span>/**\n     * 这个每一条数据解析都会来调用\n     *\n     * @param data\n     *            one row value. Is is same as {@link AnalysisContext#readRowHolder()}\n     * @param context\n     */</span>\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>invoke</span><span>(</span><span>DemoData</span> data<span>,</span> <span>AnalysisContext</span> context<span>)</span> <span>{</span>\n        LOGGER<span>.</span><span>info</span><span>(</span><span>\"解析到一条数据:{}\"</span><span>,</span> JSON<span>.</span><span>toJSONString</span><span>(</span>data<span>)</span><span>)</span><span>;</span>\n        list<span>.</span><span>add</span><span>(</span>data<span>)</span><span>;</span>\n        <span>// 达到BATCH_COUNT了，需要去存储一次数据库，防止数据几万条数据在内存，容易OOM</span>\n        <span>if</span> <span>(</span>list<span>.</span><span>size</span><span>(</span><span>)</span> <span>>=</span> BATCH_COUNT<span>)</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"插入一次数据库\"</span><span>)</span><span>;</span>\n            <span>saveData</span><span>(</span><span>)</span><span>;</span>\n            <span>// 存储完成清理 list</span>\n            list<span>.</span><span>clear</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n    <span>/**\n     * 所有数据解析完成了 都会来调用\n     *\n     * @param context\n     */</span>\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>doAfterAllAnalysed</span><span>(</span><span>AnalysisContext</span> context<span>)</span> <span>{</span>\n        <span>// 这里也要保存数据，确保最后遗留的数据也存储到数据库</span>\n        <span>saveData</span><span>(</span><span>)</span><span>;</span>\n        LOGGER<span>.</span><span>info</span><span>(</span><span>\"所有数据解析完成！\"</span><span>)</span><span>;</span>\n    <span>}</span>\n    <span>/**\n     * 加上存储数据库\n     */</span>\n    <span>private</span> <span>void</span> <span>saveData</span><span>(</span><span>)</span> <span>{</span>\n        LOGGER<span>.</span><span>info</span><span>(</span><span>\"{}条数据，开始存储数据库！\"</span><span>,</span> list<span>.</span><span>size</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        demoDataMapper<span>.</span><span>batchInsert</span><span>(</span>list<span>)</span><span>;</span>\n        LOGGER<span>.</span><span>info</span><span>(</span><span>\"存储数据库成功！\"</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br></div></div><p>之后调用方法</p>\n<div><pre><code><span>// 要读的文件。映射方式是标题</span>\n<span>private</span> <span>final</span> <span>static</span> <span>String</span> PATH <span>=</span> <span>\"C:\\\\Users\\\\a1138\\\\OneDrive\\\\桌面\\\\simpleWrite.xlsx\"</span><span>;</span>\n<span>// 这里 需要指定读用哪个class去读，然后读取第一个sheet 文件流会自动关闭。将Dao方法作为构造参数传入</span>\n<span>EasyExcel</span><span>.</span><span>read</span><span>(</span>PATH<span>,</span> <span>DemoData</span><span>.</span><span>class</span><span>,</span> <span>new</span> <span>DemoDataListener</span><span>(</span>demoDataMapper<span>)</span><span>)</span><span>.</span><span>sheet</span><span>(</span><span>)</span><span>.</span><span>doRead</span><span>(</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id=\"web导出下载\"> Web导出下载</h2>\n<h3 id=\"controller\"> controller</h3>\n<div><pre><code>    <span>@GetMapping</span><span>(</span><span>\"/exportExcel\"</span><span>)</span>\n    <span>public</span> <span>void</span> <span>exportExcel</span><span>(</span><span>HttpServletResponse</span> response<span>)</span> <span>throws</span> <span>IOException</span> <span>{</span>\n        demoDataService<span>.</span><span>exportExcel</span><span>(</span>response<span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id=\"serviceimpl\"> serviceImpl</h3>\n<div><pre><code>    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>exportExcel</span><span>(</span><span>HttpServletResponse</span> response<span>)</span> <span>throws</span> <span>IOException</span> <span>{</span>\n        <span>// 这里注意 有同学反应使用swagger 会导致各种问题，请直接用浏览器或者用postman</span>\n        response<span>.</span><span>setContentType</span><span>(</span><span>\"application/vnd.ms-excel\"</span><span>)</span><span>;</span>\n        response<span>.</span><span>setCharacterEncoding</span><span>(</span><span>\"utf-8\"</span><span>)</span><span>;</span>\n        <span>// 这里URLEncoder.encode可以防止中文乱码 当然和easyexcel没有关系</span>\n        <span>String</span> fileName <span>=</span> <span>\"导出demoData\"</span><span>;</span>\n        response<span>.</span><span>setHeader</span><span>(</span><span>\"Content-disposition\"</span><span>,</span> <span>\"attachment;filename=\"</span> <span>+</span> fileName <span>+</span> <span>\".xlsx\"</span><span>)</span><span>;</span>\n        <span>List</span><span><span>&lt;</span><span>DemoData</span><span>></span></span> list <span>=</span> demoDataMapper<span>.</span><span>selectByExample</span><span>(</span><span>null</span><span>)</span>\n        <span>EasyExcel</span><span>.</span><span>write</span><span>(</span>response<span>.</span><span>getOutputStream</span><span>(</span><span>)</span><span>,</span> <span>DemoData</span><span>.</span><span>class</span><span>)</span><span>.</span><span>sheet</span><span>(</span><span>\"模板\"</span><span>)</span><span>.</span><span>doWrite</span><span>(</span>list<span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h2 id=\"web导入\"> Web导入</h2>\n<h3 id=\"controller-2\"> controller</h3>\n<div><pre><code>    <span>@PostMapping</span><span>(</span><span>\"/importExcel\"</span><span>)</span>\n    <span>public</span> <span>void</span> <span>importExcel</span><span>(</span><span>MultipartFile</span> file<span>)</span> <span>throws</span> <span>IOException</span> <span>{</span>\n        demoDataService<span>.</span><span>importExcel</span><span>(</span>file<span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id=\"serviceimpl-2\"> serviceImpl</h3>\n<div><pre><code>    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>importExcel</span><span>(</span><span>MultipartFile</span> file<span>)</span> <span>throws</span> <span>IOException</span> <span>{</span>\n        <span>EasyExcel</span><span>.</span><span>read</span><span>(</span>file<span>.</span><span>getInputStream</span><span>(</span><span>)</span><span>,</span> <span>DemoData</span><span>.</span><span>class</span><span>,</span> <span>new</span> <span>DemoDataListener</span><span>(</span>demoDataMapper<span>)</span><span>)</span><span>.</span><span>sheet</span><span>(</span><span>0</span><span>)</span><span>.</span><span>doRead</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div>",
      "date_published": "2020-10-01T22:35:50.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": []
    },
    {
      "title": "IDEA初始化SpringBoot项目+逆向工程+配置",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/spring/springboot/springboot-tool/IDEA-Initial-Springboot+reverse-project+Configuration/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/spring/springboot/springboot-tool/IDEA-Initial-Springboot+reverse-project+Configuration/",
      "content_html": "<h2 id=\"_1-使用阿里云镜像作为初始源创建\"> 1. 使用阿里云镜像作为初始源创建</h2>\n<ol>\n<li>选择Spring initializr</li>\n<li>选择来源链接：https://start.aliyun.com/</li>\n</ol>\n<p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/IDEA-Initial-Springboot/使用阿里云镜像.jpg\" alt=\"使用阿里云镜像\" /></p>\n<h2 id=\"_2-项目信息\"> 2. 项目信息</h2>\n<p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/IDEA-Initial-Springboot/项目信息.jpg\" alt=\"\" /></p>\n<h2 id=\"_3-选择依赖\"> 3. 选择依赖</h2>\n<p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/IDEA-Initial-Springboot/选择依赖.jpg\" alt=\"选择依赖\" /></p>\n<h2 id=\"_4-配置application-yml-更新中\"> 4. 配置<code>application.yml</code>(更新中)</h2>\n<p>在<code>resources</code>文件夹下删除<code>application.properties</code>,并创建<code>application.yml</code></p>\n<p>application.yml基本配置如下</p>\n<div><pre><code><span>#指定项目端口号</span>\n<span>server</span><span>:</span>\n  <span>port</span><span>:</span> <span>8001</span>\n\n<span>spring</span><span>:</span>\n  <span>application</span><span>:</span>\n    <span>name</span><span>:</span> springboot_demo\n  <span>datasource</span><span>:</span>\n    <span>username</span><span>:</span> root\n    <span>password</span><span>:</span> 0.00.0\n    <span>url</span><span>:</span> jdbc<span>:</span>mysql<span>:</span>//localhost<span>:</span>3306/labManagement_demo\n    <span>driver-class-name</span><span>:</span> com.mysql.jdbc.Driver\n  <span>#  devtools</span>\n  <span>devtools</span><span>:</span>         <span>#设置开启热部署</span>\n    <span>restart</span><span>:</span>\n      <span>enabled</span><span>:</span> <span>true</span>  <span>#设置开启热部署</span>\n      <span>additional-paths</span><span>:</span> src/main/java <span>#重启目录</span>\n      <span>#热部署设置延时</span>\n      <span>#poll-interval: 3000ms</span>\n  <span>freemarker</span><span>:</span>\n    <span>cache</span><span>:</span> <span>false</span>    <span>#页面不加载缓存，修改即时生效</span>\n\n\n<span>#mybatis映射配置</span>\n<span>mybatis</span><span>:</span>\n\t<span>#实体类包</span>\n  <span>type-aliases-package</span><span>:</span> com.lifeisgg.springboot_demo.pojo\n  <span>mapper-locations</span><span>:</span> classpath<span>:</span>mapper/<span>*.xml</span>\n  <span>configuration</span><span>:</span>\n    <span>map-underscore-to-camel-case</span><span>:</span> <span>true</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><h2 id=\"_5-配置pom-xml依赖-更新中\"> 5. 配置<code>pom.xml</code>依赖(更新中)</h2>\n<p>参考</p>\n<blockquote>\n<ul>\n<li><a href=\"https://blog.csdn.net/IT_lyd/article/details/76423290?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param\" target=\"_blank\" rel=\"noopener noreferrer\">springboot之依赖集锦pom.xml（更新中）</a></li>\n</ul>\n</blockquote>\n<h3 id=\"_5-1-springboot相关\"> 5.1 springboot相关</h3>\n<div><pre><code>\t\t<span>&lt;!-- springboot相关 --></span>\n\t\t<span>&lt;!-- springboot 基础包 --></span>\n\t\t<span><span><span>&lt;</span>dependency</span><span>></span></span>\n\t\t\t<span><span><span>&lt;</span>groupId</span><span>></span></span>org.springframework.boot<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n\t\t\t<span><span><span>&lt;</span>artifactId</span><span>></span></span>spring-boot-starter<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n\t\t<span><span><span>&lt;/</span>dependency</span><span>></span></span>\n \n\t\t<span>&lt;!-- springboot 测试包 --></span>\n\t\t<span><span><span>&lt;</span>dependency</span><span>></span></span>\n\t\t\t<span><span><span>&lt;</span>groupId</span><span>></span></span>org.springframework.boot<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n\t\t\t<span><span><span>&lt;</span>artifactId</span><span>></span></span>spring-boot-starter-test<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n\t\t\t<span><span><span>&lt;</span>scope</span><span>></span></span>test<span><span><span>&lt;/</span>scope</span><span>></span></span>\n\t\t<span><span><span>&lt;/</span>dependency</span><span>></span></span>\n \n\t\t<span>&lt;!-- springboot web包 --></span>\n\t\t<span><span><span>&lt;</span>dependency</span><span>></span></span>\n\t\t  <span><span><span>&lt;</span>groupId</span><span>></span></span>org.springframework.boot<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n\t\t\t<span><span><span>&lt;</span>artifactId</span><span>></span></span>spring-boot-starter-web<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n\t\t<span><span><span>&lt;/</span>dependency</span><span>></span></span>\n\n\t\t<span>&lt;!--spring-boot-starter-security--></span>\n    <span><span><span>&lt;</span>dependency</span><span>></span></span>\n      <span><span><span>&lt;</span>groupId</span><span>></span></span>org.springframework.boot<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n      <span><span><span>&lt;</span>artifactId</span><span>></span></span>spring-boot-starter-security<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n     <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n    <span><span><span>&lt;</span>dependency</span><span>></span></span>\n      <span><span><span>&lt;</span>groupId</span><span>></span></span>org.springframework.security<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n      <span><span><span>&lt;</span>artifactId</span><span>></span></span>spring-security-test<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n      <span><span><span>&lt;</span>scope</span><span>></span></span>test<span><span><span>&lt;/</span>scope</span><span>></span></span>\n    <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n\n     <span>&lt;!-- spring aop --></span>\n    <span><span><span>&lt;</span>dependency</span><span>></span></span>\n      <span><span><span>&lt;</span>groupId</span><span>></span></span>org.springframework.boot<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n      <span><span><span>&lt;</span>artifactId</span><span>></span></span>spring-boot-starter-aop<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n    <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n\n\n\t\t<span>&lt;!-- springboot web开发thymeleaf模板 --></span>\n\t\t<span><span><span>&lt;</span>dependency</span><span>></span></span>\n\t\t\t<span><span><span>&lt;</span>groupId</span><span>></span></span>org.springframework.boot<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n\t\t\t<span><span><span>&lt;</span>artifactId</span><span>></span></span>spring-boot-starter-thymeleaf<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n\t\t<span><span><span>&lt;/</span>dependency</span><span>></span></span>\n\n\n\t\t<span>&lt;!-- springboot工具 修改代码后不需重启即生效 --></span>\n\t\t<span><span><span>&lt;</span>dependency</span><span>></span></span>\n\t\t\t<span><span><span>&lt;</span>groupId</span><span>></span></span>org.springframework<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n\t\t\t<span><span><span>&lt;</span>artifactId</span><span>></span></span>springloaded<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n\t\t<span><span><span>&lt;/</span>dependency</span><span>></span></span>\n\n\t\t<span>&lt;!--devtools热部署--></span>\n        <span><span><span>&lt;</span>dependency</span><span>></span></span>\n            <span><span><span>&lt;</span>groupId</span><span>></span></span>org.springframework.boot<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n            <span><span><span>&lt;</span>artifactId</span><span>></span></span>spring-boot-devtools<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n            <span><span><span>&lt;</span>optional</span><span>></span></span>true<span><span><span>&lt;/</span>optional</span><span>></span></span>\n            <span><span><span>&lt;</span>scope</span><span>></span></span>true<span><span><span>&lt;/</span>scope</span><span>></span></span>\n        <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n\n<span><span><span>&lt;</span>build</span><span>></span></span>\n        <span><span><span>&lt;</span>plugins</span><span>></span></span>\n            <span><span><span>&lt;</span>plugin</span><span>></span></span>\n                <span><span><span>&lt;</span>groupId</span><span>></span></span>org.springframework.boot<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n                <span><span><span>&lt;</span>artifactId</span><span>></span></span>spring-boot-maven-plugin<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n                <span><span><span>&lt;</span>configuration</span><span>></span></span>\n                    <span><span><span>&lt;</span>fork</span><span>></span></span>true<span><span><span>&lt;/</span>fork</span><span>></span></span>\n                <span><span><span>&lt;/</span>configuration</span><span>></span></span>\n            <span><span><span>&lt;/</span>plugin</span><span>></span></span>\n        <span><span><span>&lt;/</span>plugins</span><span>></span></span>\n    <span><span><span>&lt;/</span>build</span><span>></span></span>\n\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br></div></div><h3 id=\"_5-2-数据库相关\"> 5.2 数据库相关</h3>\n<div><pre><code>    <span><span><span>&lt;</span>properties</span><span>></span></span>\n      <span><span><span>&lt;</span>java.version</span><span>></span></span>1.8<span><span><span>&lt;/</span>java.version</span><span>></span></span>\n      <span><span><span>&lt;</span>mybatis.version</span><span>></span></span>2.1.2<span><span><span>&lt;/</span>mybatis.version</span><span>></span></span>\n    <span><span><span>&lt;/</span>properties</span><span>></span></span>\n\n\t\t\t\t<span>&lt;!-- 数据库相关 --></span>\n\n\t\t\t\t<span>&lt;!-- mysql驱动 --></span>\n        <span><span><span>&lt;</span>dependency</span><span>></span></span>\n            <span><span><span>&lt;</span>groupId</span><span>></span></span>mysql<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n            <span><span><span>&lt;</span>artifactId</span><span>></span></span>mysql-connector-java<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n        <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n\n        <span>&lt;!-- jdbc连接工具 --></span>\n        <span><span><span>&lt;</span>dependency</span><span>></span></span>\n            <span><span><span>&lt;</span>groupId</span><span>></span></span>org.springframework.boot<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n            <span><span><span>&lt;</span>artifactId</span><span>></span></span>spring-boot-starter-jdbc<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n        <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n\n\t\t\t\t<span>&lt;!--mybatis--></span>\n        <span><span><span>&lt;</span>dependency</span><span>></span></span>\n            <span><span><span>&lt;</span>groupId</span><span>></span></span>org.mybatis.spring.boot<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n            <span><span><span>&lt;</span>artifactId</span><span>></span></span>mybatis-spring-boot-starter<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n            <span><span><span>&lt;</span>version</span><span>></span></span>${mybatis.version}<span><span><span>&lt;/</span>version</span><span>></span></span>\n        <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n\n        <span>&lt;!-- page helper --></span>\n        <span><span><span>&lt;</span>dependency</span><span>></span></span>\n            <span><span><span>&lt;</span>groupId</span><span>></span></span>com.github.pagehelper<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n            <span><span><span>&lt;</span>artifactId</span><span>></span></span>pagehelper-spring-boot-starter<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n            <span><span><span>&lt;</span>version</span><span>></span></span>1.3.0<span><span><span>&lt;/</span>version</span><span>></span></span>\n        <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n\n        <span>&lt;!-- redis --></span>\n        <span><span><span>&lt;</span>dependency</span><span>></span></span>\n            <span><span><span>&lt;</span>groupId</span><span>></span></span>org.springframework.boot<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n            <span><span><span>&lt;</span>artifactId</span><span>></span></span>spring-boot-starter-data-redis<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n        <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n\n<span>&lt;!-- mybatis逆向工程 --></span>\n<span>&lt;!-- https://mvnrepository.com/artifact/org.mybatis.generator/mybatis-generator-core --></span>\n\t\t\t\t<span><span><span>&lt;</span>dependency</span><span>></span></span>\n    \t\t\t\t<span><span><span>&lt;</span>groupId</span><span>></span></span>org.mybatis.generator<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n    \t\t\t\t<span><span><span>&lt;</span>artifactId</span><span>></span></span>mybatis-generator-core<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n    \t\t\t\t<span><span><span>&lt;</span>version</span><span>></span></span>1.3.7<span><span><span>&lt;/</span>version</span><span>></span></span>\n\t\t\t\t<span><span><span>&lt;/</span>dependency</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br></div></div><h3 id=\"_5-3-工具相关\"> 5.3 工具相关</h3>\n<div><pre><code>    <span><span><span>&lt;</span>properties</span><span>></span></span>\n      <span><span><span>&lt;</span>java.version</span><span>></span></span>1.8<span><span><span>&lt;/</span>java.version</span><span>></span></span>\n      <span><span><span>&lt;</span>swagger.version</span><span>></span></span>2.9.2<span><span><span>&lt;/</span>swagger.version</span><span>></span></span>\n      <span><span><span>&lt;</span>userAgentUtils.version</span><span>></span></span>1.21<span><span><span>&lt;/</span>userAgentUtils.version</span><span>></span></span>\n    <span><span><span>&lt;/</span>properties</span><span>></span></span>\n\n\n\t\t\t\t<span>&lt;!-- 工具类 --></span>\n\t\t\t\t<span>&lt;!-- 日志管理 log4j --></span>\n        <span><span><span>&lt;</span>dependency</span><span>></span></span>\n            <span><span><span>&lt;</span>groupId</span><span>></span></span>org.springframework.boot<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n            <span><span><span>&lt;</span>artifactId</span><span>></span></span>spring-boot-starter-log4j<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n        <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n\n\t\t\t\t<span>&lt;!-- fastjson --></span>\n        <span><span><span>&lt;</span>dependency</span><span>></span></span>\n            <span><span><span>&lt;</span>groupId</span><span>></span></span>com.alibaba<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n            <span><span><span>&lt;</span>artifactId</span><span>></span></span>fastjson<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n            <span><span><span>&lt;</span>version</span><span>></span></span>1.2.15<span><span><span>&lt;/</span>version</span><span>></span></span>\n        <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n\n        <span>&lt;!-- lombok --></span>\n        <span><span><span>&lt;</span>dependency</span><span>></span></span>\n            <span><span><span>&lt;</span>groupId</span><span>></span></span>org.projectlombok<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n            <span><span><span>&lt;</span>artifactId</span><span>></span></span>lombok<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n          \t<span><span><span>&lt;</span>scope</span><span>></span></span>provided<span><span><span>&lt;/</span>scope</span><span>></span></span>\n        <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n\n\n        <span>&lt;!-- simpleEmail --></span>\n        <span><span><span>&lt;</span>dependency</span><span>></span></span>\n            <span><span><span>&lt;</span>groupId</span><span>></span></span>org.springframework.boot<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n            <span><span><span>&lt;</span>artifactId</span><span>></span></span>spring-boot-starter-mail<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n        <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n\n        <span>&lt;!-- easyexcel --></span>\n        <span><span><span>&lt;</span>dependency</span><span>></span></span>\n            <span><span><span>&lt;</span>groupId</span><span>></span></span>com.alibaba<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n            <span><span><span>&lt;</span>artifactId</span><span>></span></span>easyexcel<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n            <span><span><span>&lt;</span>version</span><span>></span></span>2.2.6<span><span><span>&lt;/</span>version</span><span>></span></span>\n        <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n\n        <span>&lt;!-- 获取客户端信息 --></span>\n        <span><span><span>&lt;</span>dependency</span><span>></span></span>\n            <span><span><span>&lt;</span>groupId</span><span>></span></span>eu.bitwalker<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n            <span><span><span>&lt;</span>artifactId</span><span>></span></span>UserAgentUtils<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n            <span><span><span>&lt;</span>version</span><span>></span></span>${userAgentUtils.version}<span><span><span>&lt;/</span>version</span><span>></span></span>\n        <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n\n\n\t\t\t\t<span>&lt;!--        Swagger依赖--></span>\n        <span>&lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger2 --></span>\n        <span><span><span>&lt;</span>dependency</span><span>></span></span>\n            <span><span><span>&lt;</span>groupId</span><span>></span></span>io.springfox<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n            <span><span><span>&lt;</span>artifactId</span><span>></span></span>springfox-swagger2<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n            <span><span><span>&lt;</span>version</span><span>></span></span>3.0.0<span><span><span>&lt;/</span>version</span><span>></span></span>\n        <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n        <span>&lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger-ui --></span>\n        <span><span><span>&lt;</span>dependency</span><span>></span></span>\n            <span><span><span>&lt;</span>groupId</span><span>></span></span>io.springfox<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n            <span><span><span>&lt;</span>artifactId</span><span>></span></span>springfox-swagger-ui<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n            <span><span><span>&lt;</span>version</span><span>></span></span>3.0.0<span><span><span>&lt;/</span>version</span><span>></span></span>\n        <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n\n<span>&lt;!-- https://mvnrepository.com/artifact/com.github.xiaoymin/swagger-bootstrap-ui --></span>\n        <span><span><span>&lt;</span>dependency</span><span>></span></span>\n            <span><span><span>&lt;</span>groupId</span><span>></span></span>com.github.xiaoymin<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n            <span><span><span>&lt;</span>artifactId</span><span>></span></span>swagger-bootstrap-ui<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n            <span><span><span>&lt;</span>version</span><span>></span></span>1.9.6<span><span><span>&lt;/</span>version</span><span>></span></span>\n        <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n\n        <span>&lt;!-- fastdfs --></span>\n        <span><span><span>&lt;</span>dependency</span><span>></span></span>\n            <span><span><span>&lt;</span>groupId</span><span>></span></span>com.luhuiguo<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n            <span><span><span>&lt;</span>artifactId</span><span>></span></span>fastdfs-spring-boot-starter<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n            <span><span><span>&lt;</span>version</span><span>></span></span>0.2.0<span><span><span>&lt;/</span>version</span><span>></span></span>\n        <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br></div></div><h2 id=\"_6-mybatis逆向工程快速搭建\"> 6. Mybatis逆向工程快速搭建</h2>\n<p>参考</p>\n<blockquote>\n<ul>\n<li>http://mybatis.org/generator/index.html</li>\n<li>https://blog.csdn.net/for_my_life/article/details/51228098?utm_medium=distribute.pc_relevant.none-task-blog-title-1&amp;spm=1001.2101.3001.4242</li>\n<li>视频：https://www.bilibili.com/video/av78230600/</li>\n</ul>\n</blockquote>\n<h3 id=\"_6-1-配置pom-xml\"> 6.1 配置<code>pom.xml</code></h3>\n<div><pre><code>        <span><span><span>&lt;</span>dependency</span><span>></span></span>\n            <span><span><span>&lt;</span>groupId</span><span>></span></span>org.mybatis.generator<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n            <span><span><span>&lt;</span>artifactId</span><span>></span></span>mybatis-generator-core<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n            <span><span><span>&lt;</span>version</span><span>></span></span>1.3.2<span><span><span>&lt;/</span>version</span><span>></span></span>\n        <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n\n<span><span><span>&lt;</span>build</span><span>></span></span>\n        <span><span><span>&lt;</span>plugins</span><span>></span></span>\n            <span><span><span>&lt;</span>plugin</span><span>></span></span>\n                <span><span><span>&lt;</span>groupId</span><span>></span></span>org.mybatis.generator<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n                <span><span><span>&lt;</span>artifactId</span><span>></span></span>mybatis-generator-maven-plugin<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n                <span><span><span>&lt;</span>version</span><span>></span></span>1.3.2<span><span><span>&lt;/</span>version</span><span>></span></span>\n                <span><span><span>&lt;</span>configuration</span><span>></span></span>\n                    <span><span><span>&lt;</span>configurationFile</span><span>></span></span>src/main/resources/mybatisGenerator.xml<span><span><span>&lt;/</span>configurationFile</span><span>></span></span>\n                    <span><span><span>&lt;</span>verbose</span><span>></span></span>true<span><span><span>&lt;/</span>verbose</span><span>></span></span>\n                    <span><span><span>&lt;</span>overwrite</span><span>></span></span>true<span><span><span>&lt;/</span>overwrite</span><span>></span></span>\n                <span><span><span>&lt;/</span>configuration</span><span>></span></span>\n                <span><span><span>&lt;</span>executions</span><span>></span></span>\n                    <span><span><span>&lt;</span>execution</span><span>></span></span>\n                        <span><span><span>&lt;</span>id</span><span>></span></span>Generate MyBatis Artifacts<span><span><span>&lt;/</span>id</span><span>></span></span>\n                        <span><span><span>&lt;</span>goals</span><span>></span></span>\n                            <span><span><span>&lt;</span>goal</span><span>></span></span>generate<span><span><span>&lt;/</span>goal</span><span>></span></span>\n                        <span><span><span>&lt;/</span>goals</span><span>></span></span>\n                    <span><span><span>&lt;/</span>execution</span><span>></span></span>\n                <span><span><span>&lt;/</span>executions</span><span>></span></span>\n                <span><span><span>&lt;</span>dependencies</span><span>></span></span>\n                    <span><span><span>&lt;</span>dependency</span><span>></span></span>\n                        <span><span><span>&lt;</span>groupId</span><span>></span></span>org.mybatis.generator<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n                        <span><span><span>&lt;</span>artifactId</span><span>></span></span>mybatis-generator-core<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n                        <span><span><span>&lt;</span>version</span><span>></span></span>1.3.2<span><span><span>&lt;/</span>version</span><span>></span></span>\n                    <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n                    <span><span><span>&lt;</span>dependency</span><span>></span></span>\n                        <span><span><span>&lt;</span>groupId</span><span>></span></span>mysql<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n                        <span><span><span>&lt;</span>artifactId</span><span>></span></span>mysql-connector-java<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n                        <span><span><span>&lt;</span>scope</span><span>></span></span>runtime<span><span><span>&lt;/</span>scope</span><span>></span></span>\n                        <span><span><span>&lt;</span>version</span><span>></span></span>5.1.47<span><span><span>&lt;/</span>version</span><span>></span></span>\n                    <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n                <span><span><span>&lt;/</span>dependencies</span><span>></span></span>\n            <span><span><span>&lt;/</span>plugin</span><span>></span></span>\n        <span><span><span>&lt;/</span>plugins</span><span>></span></span>\n    <span><span><span>&lt;/</span>build</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br></div></div><h3 id=\"_6-2-配置mybatisgenerator-xml\"> 6.2 配置<code>mybatisGenerator.xml</code></h3>\n<p>参考</p>\n<blockquote>\n<ul>\n<li>https://blog.csdn.net/for_my_life/article/details/51228098?utm_medium=distribute.pc_relevant.none-task-blog-title-1&amp;spm=1001.2101.3001.4242</li>\n<li>视频：https://www.bilibili.com/video/av78230600/</li>\n</ul>\n</blockquote>\n<p>通过已经搭建好的项目创建，连接数据库并修改<code>mybatisGenerator.xml</code>后Run即可</p>\n<blockquote>\n<ul>\n<li>Github：https://github.com/LifeAlsoIsGG/MybatisGenerator-Demo</li>\n</ul>\n</blockquote>\n<p>在resources下创建<code>mybatisGenerator.xml</code></p>\n<div><pre><code><span>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?></span>\n<span><span>&lt;!</span><span>DOCTYPE</span> <span>generatorConfiguration</span>\n        <span>PUBLIC</span> <span>\"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\"</span>\n        <span>\"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\"</span><span>></span></span>\n\n<span><span><span>&lt;</span>generatorConfiguration</span><span>></span></span>\n    <span><span><span>&lt;</span>context</span> <span>id</span><span><span>=</span><span>\"</span>DB2Tables<span>\"</span></span> <span>targetRuntime</span><span><span>=</span><span>\"</span>MyBatis3<span>\"</span></span><span>></span></span>\n\n        <span>&lt;!-- optional，旨在创建class时，对注释进行控制 --></span>\n        <span><span><span>&lt;</span>commentGenerator</span><span>></span></span>\n                <span><span><span>&lt;</span>property</span> <span>name</span><span><span>=</span><span>\"</span>suppressDate<span>\"</span></span> <span>value</span><span><span>=</span><span>\"</span>true<span>\"</span></span><span>/></span></span>\n                <span>&lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --></span>\n                <span><span><span>&lt;</span>property</span> <span>name</span><span><span>=</span><span>\"</span>suppressAllComments<span>\"</span></span> <span>value</span><span><span>=</span><span>\"</span>true<span>\"</span></span><span>/></span></span>\n        <span><span><span>&lt;/</span>commentGenerator</span><span>></span></span>\n\n        <span>&lt;!--jdbc数据库连接 --></span>\n        <span><span><span>&lt;</span>jdbcConnection</span> <span>driverClass</span><span><span>=</span><span>\"</span>com.mysql.jdbc.Driver<span>\"</span></span>\n                        <span>connectionURL</span><span><span>=</span><span>\"</span>jdbc:mysql://localhost:3306/database<span>\"</span></span>\n                        <span>userId</span><span><span>=</span><span>\"</span>root<span>\"</span></span>\n                        <span>password</span><span><span>=</span><span>\"</span>root<span>\"</span></span><span>></span></span>\n        <span><span><span>&lt;/</span>jdbcConnection</span><span>></span></span>\n\n        <span>&lt;!-- 默认false，把JDBC DECIMAL 和 NUMERIC 类型解析为 Integer，\n        为true时把JDBC DECIMAL和NUMERIC类型解析为java.math.BigDecimal --></span>\n        <span><span><span>&lt;</span>javaTypeResolver</span> <span>></span></span>\n            <span><span><span>&lt;</span>property</span> <span>name</span><span><span>=</span><span>\"</span>forceBigDecimals<span>\"</span></span> <span>value</span><span><span>=</span><span>\"</span>false<span>\"</span></span> <span>/></span></span>\n        <span><span><span>&lt;/</span>javaTypeResolver</span><span>></span></span>\n\n        <span>&lt;!-- Model模型生成器,用来生成含有主键key的类，记录类 以及查询Example类\n            targetPackage     指定生成的model生成所在的包名\n            targetProject     指定在该项目下所在的路径\n        --></span>\n        <span><span><span>&lt;</span>javaModelGenerator</span> <span>targetPackage</span><span><span>=</span><span>\"</span>com.lifeisgg.springboot_demo.entity<span>\"</span></span> <span>targetProject</span><span><span>=</span><span>\"</span>src/main/java<span>\"</span></span><span>></span></span>\n            <span>&lt;!-- 是否允许子包，即targetPackage.schemaName.tableName --></span>\n            <span><span><span>&lt;</span>property</span> <span>name</span><span><span>=</span><span>\"</span>enableSubPackages<span>\"</span></span> <span>value</span><span><span>=</span><span>\"</span>true<span>\"</span></span> <span>/></span></span>\n            <span>&lt;!-- 是否对model添加 构造函数 --></span>\n            <span><span><span>&lt;</span>property</span> <span>name</span><span><span>=</span><span>\"</span>constructorBased<span>\"</span></span> <span>value</span><span><span>=</span><span>\"</span>false<span>\"</span></span><span>/></span></span>\n            <span>&lt;!-- 是否对类CHAR类型的列的数据进行trim操作 --></span>\n            <span><span><span>&lt;</span>property</span> <span>name</span><span><span>=</span><span>\"</span>trimStrings<span>\"</span></span> <span>value</span><span><span>=</span><span>\"</span>true<span>\"</span></span> <span>/></span></span>\n        <span><span><span>&lt;/</span>javaModelGenerator</span><span>></span></span>\n\n        <span>&lt;!--Mapper映射文件生成所在的目录 为每一个数据库的表生成对应的SqlMap文件 --></span>\n        <span><span><span>&lt;</span>sqlMapGenerator</span> <span>targetPackage</span><span><span>=</span><span>\"</span>mapper<span>\"</span></span>  <span>targetProject</span><span><span>=</span><span>\"</span>src/main/resources<span>\"</span></span><span>></span></span>\n            <span><span><span>&lt;</span>property</span> <span>name</span><span><span>=</span><span>\"</span>enableSubPackages<span>\"</span></span> <span>value</span><span><span>=</span><span>\"</span>true<span>\"</span></span> <span>/></span></span>\n        <span><span><span>&lt;/</span>sqlMapGenerator</span><span>></span></span>\n\n        <span>&lt;!-- 客户端代码，生成易于使用的针对Model对象和XML配置文件 的代码\n                type=\"ANNOTATEDMAPPER\",生成Java Model 和基于注解的Mapper对象\n                type=\"MIXEDMAPPER\",生成基于注解的Java Model 和相应的Mapper对象\n                type=\"XMLMAPPER\",生成SQLMap XML文件和独立的Mapper接口\n        --></span>\n        <span><span><span>&lt;</span>javaClientGenerator</span> <span>type</span><span><span>=</span><span>\"</span>XMLMAPPER<span>\"</span></span> <span>targetPackage</span><span><span>=</span><span>\"</span>com.lifeisgg.springboot_demo.mapper<span>\"</span></span>  <span>targetProject</span><span><span>=</span><span>\"</span>src/main/java<span>\"</span></span><span>></span></span>\n            <span><span><span>&lt;</span>property</span> <span>name</span><span><span>=</span><span>\"</span>enableSubPackages<span>\"</span></span> <span>value</span><span><span>=</span><span>\"</span>true<span>\"</span></span> <span>/></span></span>\n        <span><span><span>&lt;/</span>javaClientGenerator</span><span>></span></span>\n\n        <span><span><span>&lt;</span>table</span> <span>schema</span><span><span>=</span><span>\"</span>labManagement_demo<span>\"</span></span> <span>tableName</span><span><span>=</span><span>\"</span>user<span>\"</span></span> <span>domainObjectName</span><span><span>=</span><span>\"</span>User<span>\"</span></span> <span>/></span></span>\n\n    <span><span><span>&lt;/</span>context</span><span>></span></span>\n<span><span><span>&lt;/</span>generatorConfiguration</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br></div></div><h3 id=\"_6-3-配置run-mybatis-generator\"> 6.3 配置Run mybatis-generator</h3>\n<p>点击右上角<code>Edit Configuration</code></p>\n<p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/IDEA-Initial-Springboot/配置Run mybatis-generator.jpg\" alt=\"选择依赖\" /></p>\n<p>点击Run后会生成三个文件夹，以表User为例子</p>\n<blockquote>\n<ul>\n<li>\n<p>entity</p>\n<blockquote>\n<ul>\n<li>User.java</li>\n<li>UserExample.java</li>\n</ul>\n</blockquote>\n</li>\n<li>\n<p>mapper</p>\n<blockquote>\n<ul>\n<li>UserMapper</li>\n</ul>\n</blockquote>\n</li>\n<li>\n<p>resources/mapper</p>\n<blockquote>\n<ul>\n<li>UserMapper.xml</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n</blockquote>\n<p>之后自己创建<code>Service</code>，<code>ServiceImpl</code>，<code>Controller</code>即可，也可以用<code>EasyCode</code>插件创建</p>\n<h2 id=\"_7-最终基本项目结构\"> 7. 最终基本项目结构</h2>\n<blockquote>\n<ul>\n<li>\n<p><strong>Controller</strong></p>\n<blockquote>\n<ul>\n<li>UserController.java</li>\n</ul>\n</blockquote>\n</li>\n<li>\n<p><strong>Service</strong></p>\n<blockquote>\n<ul>\n<li>\n<p>UserService.java</p>\n</li>\n<li>\n<p><strong>ServiceImpl</strong></p>\n<blockquote>\n<ul>\n<li>UserServiceImpl.java</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n</blockquote>\n</li>\n<li>\n<p><strong>entity</strong></p>\n<blockquote>\n<ul>\n<li>User.java</li>\n<li>UserExample.java</li>\n</ul>\n</blockquote>\n</li>\n<li>\n<p><strong>mapper</strong></p>\n<blockquote>\n<ul>\n<li>UserMapper.java</li>\n</ul>\n</blockquote>\n</li>\n<li>\n<p><strong>resources/mapper</strong></p>\n<blockquote>\n<ul>\n<li>UserMapper.xml</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n</blockquote>\n<p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/IDEA-Initial-Springboot/springboot项目结构.jpg\" alt=\"springboot项目结构\" /></p>\n<h3 id=\"_7-1-usercontroller-java\"> 7.1 UserController.java</h3>\n<p>要加注解<code>@RestController</code>，<code>@RequestMapping(&quot;&quot;)</code></p>\n<div><pre><code><span>/**\n * (User)表控制层\n *\n * @author makejava\n * @since 2020-10-02 22:45:46\n */</span>\n<span>@RestController</span>\n<span>@RequestMapping</span><span>(</span><span>\"user\"</span><span>)</span>\n<span>public</span> <span>class</span> <span>UserController</span> <span>{</span>\n    <span>@Resource</span>\n    <span>private</span> <span>UserService</span> userService<span>;</span>\n\n    <span>@RequestMapping</span><span>(</span><span>\"/user\"</span><span>)</span>\n    <span>public</span> <span>int</span> <span>getCount</span><span>(</span><span>)</span><span>{</span>\n        <span>return</span> userService<span>.</span><span>countUser</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h3 id=\"_7-2-userservice-java\"> 7.2 UserService.java</h3>\n<div><pre><code><span>/**\n * (User)表服务接口\n *\n * @author makejava\n * @since 2020-10-02 22:45:42\n */</span>\n<span>public</span> <span>interface</span> <span>UserService</span> <span>{</span>\n\n    <span>int</span> <span>countUser</span><span>(</span><span>)</span><span>;</span>\n\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h3 id=\"_7-3-userserviceimpl-java\"> 7.3 UserServiceImpl.java</h3>\n<p>要加注解<code>@Service(&quot;&quot;)</code></p>\n<div><pre><code><span>@Service</span><span>(</span><span>\"userService\"</span><span>)</span>\n<span>public</span> <span>class</span> <span>UserServiceImpl</span> <span>implements</span> <span>UserService</span> <span>{</span>\n    <span>@Resource</span>\n    <span>private</span> <span>UserMapper</span> userMapper<span>;</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>int</span> <span>countUser</span><span>(</span><span>)</span> <span>{</span>\n        <span>UserExample</span> userExample <span>=</span> <span>new</span> <span>UserExample</span><span>(</span><span>)</span><span>;</span>\n        <span>return</span> userMapper<span>.</span><span>countByExample</span><span>(</span>userExample<span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h3 id=\"_7-4-user-java\"> 7.4 User.java</h3>\n<div><pre><code><span>@Data</span>\n<span>public</span> <span>class</span> <span>User</span> <span>{</span>\n    <span>private</span> <span>Integer</span> uid<span>;</span>\n\n    <span>private</span> <span>String</span> phone<span>;</span>\n\n    <span>private</span> <span>String</span> email<span>;</span>\n\n    <span>private</span> <span>String</span> realname<span>;</span>\n\n    <span>private</span> <span>String</span> password<span>;</span>\n\n    <span>private</span> <span>Integer</span> level<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h3 id=\"_7-5-userexample-java\"> 7.5 UserExample.java</h3>\n<h3 id=\"_7-6-usermapper-java\"> 7.6 UserMapper.java</h3>\n<p>要加<code>@Mapper</code>，否则会报错mybatis找不到mapper</p>\n<div><pre><code><span>@Mapper</span>\n<span>public</span> <span>interface</span> <span>UserMapper</span> <span>{</span>\n    <span>int</span> <span>countByExample</span><span>(</span><span>UserExample</span> example<span>)</span><span>;</span>\n\n    <span>int</span> <span>deleteByExample</span><span>(</span><span>UserExample</span> example<span>)</span><span>;</span>\n\n    <span>int</span> <span>deleteByPrimaryKey</span><span>(</span><span>Integer</span> uid<span>)</span><span>;</span>\n\n    <span>int</span> <span>insert</span><span>(</span><span>User</span> <span>record</span><span>)</span><span>;</span>\n\n    <span>int</span> <span>insertSelective</span><span>(</span><span>User</span> <span>record</span><span>)</span><span>;</span>\n\n    <span>List</span><span><span>&lt;</span><span>User</span><span>></span></span> <span>selectByExample</span><span>(</span><span>UserExample</span> example<span>)</span><span>;</span>\n\n    <span>User</span> <span>selectByPrimaryKey</span><span>(</span><span>Integer</span> uid<span>)</span><span>;</span>\n\n    <span>int</span> <span>updateByExampleSelective</span><span>(</span><span>@Param</span><span>(</span><span>\"record\"</span><span>)</span> <span>User</span> <span>record</span><span>,</span> <span>@Param</span><span>(</span><span>\"example\"</span><span>)</span> <span>UserExample</span> example<span>)</span><span>;</span>\n\n    <span>int</span> <span>updateByExample</span><span>(</span><span>@Param</span><span>(</span><span>\"record\"</span><span>)</span> <span>User</span> <span>record</span><span>,</span> <span>@Param</span><span>(</span><span>\"example\"</span><span>)</span> <span>UserExample</span> example<span>)</span><span>;</span>\n\n    <span>int</span> <span>updateByPrimaryKeySelective</span><span>(</span><span>User</span> <span>record</span><span>)</span><span>;</span>\n\n    <span>int</span> <span>updateByPrimaryKey</span><span>(</span><span>User</span> <span>record</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><h3 id=\"_7-7-usermapper-xml\"> 7.7 UserMapper.xml</h3>\n<div><pre><code><span>&lt;</span><span>?</span>xml version<span>=</span><span>\"1.0\"</span> encoding<span>=</span><span>\"UTF-8\"</span> <span>?</span><span>></span>\n<span>&lt;</span><span>!</span>DOCTYPE mapper PUBLIC <span>\"-//mybatis.org//DTD Mapper 3.0//EN\"</span> <span>\"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"</span> <span>></span>\n<span>&lt;</span>mapper namespace<span>=</span><span>\"com.lifeisgg.springboot_demo.mapper.UserMapper\"</span> <span>></span>\n  <span>&lt;</span>resultMap id<span>=</span><span>\"BaseResultMap\"</span> type<span>=</span><span>\"com.lifeisgg.springboot_demo.entity.User\"</span> <span>></span>\n    <span>&lt;</span><span>!</span><span>--</span>\n      WARNING <span>-</span> <span>@mbggenerated</span>\n      <span>This</span> element is automatically generated by <span>MyBatis</span> <span>Generator</span><span>,</span> <span>do</span> not <span><span>modify<span>.</span></span>\n      This</span> element was generated on <span>Fri</span> <span>Oct</span> <span>02</span> <span>22</span><span>:</span><span>21</span><span>:</span><span>49</span> CST <span>2020.</span>\n    <span>--</span><span>></span>\n    <span>&lt;</span>id column<span>=</span><span>\"uid\"</span> property<span>=</span><span>\"uid\"</span> jdbcType<span>=</span><span>\"INTEGER\"</span> <span>/</span><span>></span>\n    <span>&lt;</span>result column<span>=</span><span>\"phone\"</span> property<span>=</span><span>\"phone\"</span> jdbcType<span>=</span><span>\"VARCHAR\"</span> <span>/</span><span>></span>\n    <span>&lt;</span>result column<span>=</span><span>\"email\"</span> property<span>=</span><span>\"email\"</span> jdbcType<span>=</span><span>\"VARCHAR\"</span> <span>/</span><span>></span>\n    <span>&lt;</span>result column<span>=</span><span>\"realName\"</span> property<span>=</span><span>\"realname\"</span> jdbcType<span>=</span><span>\"VARCHAR\"</span> <span>/</span><span>></span>\n    <span>&lt;</span>result column<span>=</span><span>\"password\"</span> property<span>=</span><span>\"password\"</span> jdbcType<span>=</span><span>\"VARCHAR\"</span> <span>/</span><span>></span>\n    <span>&lt;</span>result column<span>=</span><span>\"level\"</span> property<span>=</span><span>\"level\"</span> jdbcType<span>=</span><span>\"INTEGER\"</span> <span>/</span><span>></span>\n  <span>&lt;</span><span>/</span>resultMap<span>></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div>",
      "image": "https://blog-1300186248.cos.ap-shanghai.myqcloud.com/IDEA-Initial-Springboot/%E4%BD%BF%E7%94%A8%E9%98%BF%E9%87%8C%E4%BA%91%E9%95%9C%E5%83%8F.jpg",
      "date_published": "2020-10-01T22:40:15.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": []
    },
    {
      "title": "JWT认证原理(更新中)",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/spring/springboot/springboot-tool/JWT-Authorization/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/spring/springboot/springboot-tool/JWT-Authorization/",
      "content_html": "<h2 id=\"参考\"> 参考</h2>\n<div><p>参考</p>\n<ul>\n<li><a href=\"https://zhuanlan.zhihu.com/p/86937325\" target=\"_blank\" rel=\"noopener noreferrer\">五分钟带你了解啥是JWT</a></li>\n<li><a href=\"https://www.bilibili.com/video/BV1i54y1m7cP\" target=\"_blank\" rel=\"noopener noreferrer\">【编程不良人】JWT认证原理、流程整合springboot实战应用,前后端分离认证的解决方案!</a></li>\n</ul>\n</div>\n<h2 id=\"介绍\"> 介绍</h2>\n<h3 id=\"是什么\"> 是什么</h3>\n<div><p>是什么</p>\n<p>JSON Web Token (JWT)是一个开放标准(RFC 7519)，它定义了一种紧凑的、自包含的方式，用于作为JSON对象在各方之间安全地传输信息。该信息可以被验证和信任，因为它是数字签名的。</p>\n</div>\n<h3 id=\"使用场景\"> 使用场景</h3>\n<div><p>使用场景</p>\n<ul>\n<li>Authorization (授权) : 这是使用JWT的最常见场景。一旦用户登录，后续每个请求都将包含JWT，允许用户访问该令牌允许的路由、服务和资源。单点登录是现在广泛使用的JWT的一个特性，因为它的开销很小，并且可以轻松地跨域使用。</li>\n<li>Information Exchange (信息交换) : 对于安全的在各方之间传输信息而言，JSON Web Tokens无疑是一种很好的方式。因为JWT可以被签名，例如，用公钥/私钥对，你可以确定发送人就是它们所说的那个人。另外，由于签名是使用头和有效负载计算的，您还可以验证内容没有被篡改。</li>\n</ul>\n</div>\n<h3 id=\"结构\"> 结构</h3>\n<div><p>结构</p>\n<ul>\n<li>Header</li>\n<li>Payload</li>\n<li>Signature</li>\n</ul>\n<p>因此，一个典型的JWT看起来是这个样子的：</p>\n<blockquote>\n<p>xxxxx.yyyyy.zzzzz</p>\n</blockquote>\n</div>\n<p><strong>Header</strong></p>\n<p>典型的由两部分组成：token的类型（“JWT”）和算法名称（比如：HMAC SHA256或者RSA等等）。</p>\n<p>例如</p>\n<div><pre><code><span>{</span>\n    <span>'alg'</span><span>:</span> <span>\"HS256\"</span><span>,</span>\n    <span>'typ'</span><span>:</span> <span>\"JWT\"</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>然后，用Base64对这个JSON编码就得到JWT的第一部分，只是翻译回原来的样子，并不是<code>解密</code></p>\n<p><strong>Payload</strong></p>\n<p>Payload JWT的第二部分是payload，它包含声明（要求）。声明是关于实体(通常是用户)和其他数据的声明。声明有三种类型: registered, public 和 private。</p>\n<div><p>Info</p>\n<ul>\n<li>Registered claims : 这里有一组预定义的声明，它们不是强制的，但是推荐。比如：iss (issuer), exp (expiration time), sub (subject), aud (audience)等。</li>\n<li>Public claims : 可以随意定义。</li>\n<li>Private claims : 用于在同意使用它们的各方之间共享信息，并且不是注册的或公开的声明。 下面是一个例子：</li>\n</ul>\n</div>\n<p>也可以用Base64编码。注意，不要在JWT的payload或header中放置敏感信息，除非它们是加密的。</p>\n<p><strong>Signature</strong></p>\n<blockquote>\n<p>为了得到签名部分，你必须有编码过的header、编码过的payload、一个秘钥，签名算法是header中指定的那个，然对它们签名即可。</p>\n</blockquote>\n<p>例如</p>\n<blockquote>\n<p>HMACSHA256(base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload), secret)</p>\n</blockquote>\n<p>签名是用于验证消息在传递过程中有没有被更改，并且，对于使用私钥签名的token，它还可以验证JWT的发送方是否为它所称的发送方。</p>\n<p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/JWT-Authorization/signature.jpg\" alt=\"signature\" /></p>\n<p>Signature需要使用编码后的header和payload以及我们提供的一个密钥，最后使用header中指定的签名算法（HS256）进行签名。签名的作用是保证JWT没有被篡改过</p>\n<h3 id=\"如何工作\"> 如何工作</h3>\n<p>在认证的时候，当用户用他们的凭证成功登录以后，一个<code>JSON Web Token</code>将会被返回。此后，token就是用户凭证了，你必须非常小心以防止出现安全问题。一般而言，你保存令牌的时候不应该超过你所需要它的时间。</p>\n<p>无论何时用户想要访问受保护的路由或者资源的时候，用户代理（通常是浏览器）都应该带上JWT，典型的，通常放在<code>Authorization header</code>中，用Bearer schema。</p>\n<p>header应该看起来是这样的：</p>\n<blockquote>\n<p>Authorization: Bearer</p>\n</blockquote>\n<p>服务器上的受保护的路由将会检查Authorization header中的JWT是否有效，如果有效，则用户可以访问受保护的资源。如果JWT包含足够多的必需的数据，那么就可以减少对某些操作的数据库查询的需要，尽管可能并不总是如此。</p>\n<p>如果token是在授权头（Authorization header）中发送的，那么跨源资源共享(CORS)将不会成为问题，因为它不使用cookie。</p>\n<h3 id=\"其他\"> 其他</h3>\n<div><p>参考</p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/86937325\" target=\"_blank\" rel=\"noopener noreferrer\">五分钟带你了解啥是JWT</a></p>\n</div>\n<h2 id=\"基于token的身份认证与基于服务器的身份认证\"> 基于Token的身份认证与基于服务器的身份认证</h2>\n<h3 id=\"基于服务器的身份认证\"> 基于服务器的身份认证</h3>\n<p>在讨论基于Token的身份认证是如何工作的以及它的好处之前，我们先来看一下以前我们是怎么做的：</p>\n<blockquote>\n<p>HTTP协议是无状态的，也就是说，如果我们已经认证了一个用户，那么他下一次请求的时候，服务器不知道我是谁，我们必须再次认证</p>\n</blockquote>\n<p>传统的做法是将已经认证过的用户信息存储在服务器上，比如<code>Session</code>。用户下次请求的时候带着<code>Session ID</code>，然后服务器以此检查用户是否认证过。</p>\n<p>这种基于服务器的身份认证方式存在一些问题：</p>\n<div><p>Info</p>\n<ul>\n<li><strong>Sessions</strong> : 每次用户认证通过以后，服务器需要创建一条记录保存用户信息，通常是在内存中，随着认证通过的用户越来越多，服务器的在这里的开销就会越来越大。</li>\n<li><strong>Scalability</strong> : 由于Session是在内存中的，这就带来一些扩展性的问题。</li>\n<li><strong>CORS</strong> : 当我们想要扩展我们的应用，让我们的数据被多个移动设备使用时，我们必须考虑跨资源共享问题。当使用AJAX调用从另一个域名下获取资源时，我们可能会遇到禁止请求的问题。</li>\n<li><strong><a href=\"https://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html\" target=\"_blank\" rel=\"noopener noreferrer\">CSRF</a></strong> : 用户很容易受到CSRF攻击。CSRF（Cross-site request forgery），中文名称：跨站请求伪造，也被称为：one click attack/session riding，缩写为：CSRF/XSRF。</li>\n</ul>\n</div>\n<h3 id=\"jwt与session的差异\"> JWT与Session的差异</h3>\n<p>相同点是，它们都是存储用户信息；然而，<code>Session</code>是在<code>服务器端</code>的，而<code>JWT</code>是在<code>客户端</code>的。</p>\n<ul>\n<li><code>Session</code>方式存储用户信息的最大问题在于要<code>占用大量服务器内存</code>，增加服务器的开销。而<code>JWT</code>方式将用户状态分散到了客户端中，可以明显减轻服务端的内存压力。</li>\n<li><code>Session</code>的状态是存储在服务器端，客户端只有<code>session id</code>；而<code>Token</code>的状态是存储在<code>客户端</code>。</li>\n</ul>\n<p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/JWT-Authorization/JWT&Session.jpg\" alt=\"\" /></p>\n<h3 id=\"基于token的身份认证是如何工作的\"> 基于Token的身份认证是如何工作的</h3>\n<p>基于Token的身份认证是无状态的，服务器或者Session中不会存储任何用户信息。</p>\n<p>没有会话信息意味着应用程序可以根据需要扩展和添加更多的机器，而不必担心用户登录的位置。</p>\n<p>虽然这一实现可能会有所不同，但其主要流程如下：</p>\n<p>-用户携带用户名和密码请求访问 -服务器校验用户凭据 -应用提供一个token给客户端 -客户端存储token，并且在随后的每一次请求中都带着它 -服务器校验token并返回数据</p>\n<p>注意：</p>\n<p>-每一次请求都需要token -Token应该放在请求header中 -我们还需要将服务器设置为接受来自所有域的请求，用Access-Control-Allow-Origin: *</p>\n<p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/JWT-Authorization/JWT_User_Authorization.jpg\" alt=\"JWT用户认证\" /></p>\n<p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/JWT-Authorization/JWT_User_Authorization_2.jpg\" alt=\"JWT用户认证\" /></p>\n<h3 id=\"用token的好处\"> 用Token的好处</h3>\n<ul>\n<li>无状态和可扩展性：Tokens存储在客户端。完全无状态，可扩展。我们的负载均衡器可以将用户传递到任意服务器，因为在任何地方都没有状态或会话信息。</li>\n<li>安全：Token不是Cookie。（The token, not a cookie.）每次请求的时候Token都会被发送。而且，由于没有Cookie被发送，还有助于防止<code>CSRF</code>攻击。即使在你的实现中将token存储到客户端的Cookie中，这个Cookie也只是一种存储机制，而非身份认证机制。没有基于会话的信息可以操作，因为我们没有会话!</li>\n<li>还有一点，token在一段时间以后会过期，这个时候用户需要重新登录。这有助于我们保持安全。还有一个概念叫token撤销，它允许我们根据相同的授权许可使特定的token甚至一组token无效。</li>\n</ul>\n<h3 id=\"jwt与oauth的区别\"> JWT与OAuth的区别</h3>\n<p>OAuth2是一种授权框架 ，JWT是一种认证协议 -无论使用哪种方式切记用HTTPS来保证数据的安全性</p>\n<p>OAuth2用在使用第三方账号登录的情况(比如使用weibo, qq, github登录某个app)，而JWT是用在前后端分离, 需要简单的对后台API进行保护时使用。</p>\n<h2 id=\"springboot整合jwt\"> SpringBoot整合JWT</h2>\n",
      "image": "https://blog-1300186248.cos.ap-shanghai.myqcloud.com/JWT-Authorization/signature.jpg",
      "date_published": "2021-01-17T11:10:39.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": []
    },
    {
      "title": "服务器上部署SpringBoot",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/spring/springboot/springboot-tool/Server-deployment-SpringBoot/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/spring/springboot/springboot-tool/Server-deployment-SpringBoot/",
      "content_html": "<h2 id=\"_1-第一种-打包为jar包\"> 1. 第一种:打包为jar包</h2>\n<h3 id=\"_1-1-pom-xml配置\"> 1.1 pom.xml配置</h3>\n<p>在<strong>pom.xml</strong>里面配置如下</p>\n<div><pre><code><span><span><span>&lt;</span>package</span><span>></span></span>jar<span><span><span>&lt;/</span>package</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"_1-2-打包为jar包\"> 1.2 打包为jar包</h3>\n<p>点击右边的<strong>Maven</strong>的<strong>clean</strong>，<strong>package</strong>后并运行会打包成<strong>jar</strong>包在<strong>target</strong>下</p>\n<p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/Server-deployment-SpringBoot/jar_start_pack.jpg\" alt=\"har开始打包\" /></p>\n<p>打包成功后的路径如下</p>\n<p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/Server-deployment-SpringBoot/jar_pack_succes.jpg\" alt=\"jar打包成功\" /></p>\n<h3 id=\"_1-3-查看要使用的服务器端口是否被占用\"> 1.3 查看要使用的服务器端口是否被占用</h3>\n<div><pre><code><span>lsof</span> -i tcp:8885\n</code></pre>\n<div><span>1</span><br></div></div><p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/Server-deployment-SpringBoot/view_port.jpg\" alt=\"查看端口\" /></p>\n<p>上方是已经运行的springboot项目在8885端口</p>\n<p>如果端口被占用，就需要杀死进程(也可用于关闭spirngboot项目)，但建议一开始就寻找空端口并在springboot项目配置</p>\n<div><pre><code><span>kill</span> -9 <span>18689</span> <span>#进程PID</span>\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"_1-4-将jar包上传到服务器并运行下面linux命令永久启动\"> 1.4 将jar包上传到服务器并运行下面Linux命令永久启动</h3>\n<div><pre><code><span>nohup</span> java -jar XXX.jar <span>></span>/dev/null <span><span>2</span>></span><span>&amp;1</span> <span>&amp;</span>\n</code></pre>\n<div><span>1</span><br></div></div><blockquote>\n<p>如果仅仅是用java命令运行jar包，在退出远程连接时项目会关闭</p>\n</blockquote>\n<h3 id=\"_1-5-将域名指向端口号\"> 1.5 将域名指向端口号</h3>\n<p>可以配置在<strong>80</strong>端口这样默认域名访问，不需要通过后面加端口号</p>\n<blockquote>\n<p>TODO:指定在其它端口使用域名指向</p>\n</blockquote>\n<h2 id=\"_2-第二种-打包为war包\"> 2. 第二种:打包为war包</h2>\n<h3 id=\"_2-1-pom-xml配置\"> 2.1 pom.xml配置</h3>\n<div><pre><code><span><span><span>&lt;</span>package</span><span>></span></span>war<span><span><span>&lt;/</span>package</span><span>></span></span>\n\n<span>&lt;!-- 找到spring-boot-starter-web依赖节点 --></span>\n<span><span><span>&lt;</span>dependency</span><span>></span></span>\n    <span><span><span>&lt;</span>groupId</span><span>></span></span>org.springframework.boot<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n    <span><span><span>&lt;</span>artifactId</span><span>></span></span>spring-boot-starter-web<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n    <span>&lt;!-- 移除嵌入式tomcat插件 --></span>\n    <span><span><span>&lt;</span>exclusions</span><span>></span></span>\n        <span><span><span>&lt;</span>exclusion</span><span>></span></span>\n            <span><span><span>&lt;</span>groupId</span><span>></span></span>org.springframework.boot<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n            <span><span><span>&lt;</span>artifactId</span><span>></span></span>spring-boot-starter-tomcat<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n        <span><span><span>&lt;/</span>exclusion</span><span>></span></span>\n    <span><span><span>&lt;/</span>exclusions</span><span>></span></span>\n<span><span><span>&lt;/</span>dependency</span><span>></span></span>\n\n<span>&lt;!-- 添加tomcat依赖 --></span>\n<span><span><span>&lt;</span>dependency</span><span>></span></span>\n <span><span><span>&lt;</span>groupId</span><span>></span></span>org.springframework.boot<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n <span><span><span>&lt;</span>artifactId</span><span>></span></span>spring-boot-starter-tomcat<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n <span><span><span>&lt;</span>scope</span><span>></span></span>provided<span><span><span>&lt;/</span>scope</span><span>></span></span>\n<span><span><span>&lt;/</span>dependency</span><span>></span></span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><h3 id=\"_2-2-修改启动类-并重写初始化方法\"> 2.2 修改启动类，并重写初始化方法</h3>\n<div><pre><code><span>@SpringBootApplication</span>\n<span>public</span> <span>class</span> <span>Application</span> <span>extends</span> <span>SpringBootServletInitializer</span> <span>{</span>\n\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>SpringApplication</span><span>.</span><span>run</span><span>(</span><span>Application</span><span>.</span><span>class</span><span>,</span> args<span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"ヾ(◍°∇°◍)ﾉﾞ    bootdo启动成功      ヾ(◍°∇°◍)ﾉﾞ\\n\"</span> <span>+</span>\n                <span>\" ______                    _   ______            \\n\"</span> <span>+</span>\n                <span>\"|_   _ \\\\                  / |_|_   _ `.          \\n\"</span> <span>+</span>\n                <span>\"  | |_) |   .--.    .--. `| |-' | | `. \\\\  .--.   \\n\"</span> <span>+</span>\n                <span>\"  |  __'. / .'`\\\\ \\\\/ .'`\\\\ \\\\| |   | |  | |/ .'`\\\\ \\\\ \\n\"</span> <span>+</span>\n                <span>\" _| |__) || \\\\__. || \\\\__. || |, _| |_.' /| \\\\__. | \\n\"</span> <span>+</span>\n                <span>\"|_______/  '.__.'  '.__.' \\\\__/|______.'  '.__.'  \"</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>@Override</span>\n    <span>protected</span> <span>SpringApplicationBuilder</span> <span>configure</span><span>(</span><span>SpringApplicationBuilder</span> builder<span>)</span> <span>{</span>\n        <span>// 注意这里要指向原先用main方法执行的Application启动类</span>\n        <span>return</span> builder<span>.</span><span>sources</span><span>(</span><span>Application</span><span>.</span><span>class</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><h3 id=\"_2-3-打包为war包\"> 2.3 打包为war包</h3>\n<p>与上面相同</p>\n<p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/Server-deployment-SpringBoot/jar_start_pack.jpg\" alt=\"jar开始打包\" /></p>\n<p>打包成功后的路径如下</p>\n<p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/Server-deployment-SpringBoot/war_pack_success.jpg\" alt=\"war打包成功\" /></p>\n<h3 id=\"_2-4-上传到服务器上的tomcat里的webapps即可\"> 2.4 上传到服务器上的Tomcat里的webapps即可</h3>\n<p>这时候可以用域名指向项目而无需指定端口</p>\n",
      "image": "https://blog-1300186248.cos.ap-shanghai.myqcloud.com/Server-deployment-SpringBoot/jar_start_pack.jpg",
      "date_published": "2020-07-05T13:33:29.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": []
    },
    {
      "title": "SpringBoot&Vue项目搭建(持续更新)",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/spring/springboot/springboot-tool/SpringBoot&Vue/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/spring/springboot/springboot-tool/SpringBoot&Vue/",
      "content_html": "<h2 id=\"参考\"> 参考</h2>\n<div><p>参考</p>\n<p>https://www.bilibili.com/video/BV1dp4y1v7K2</p>\n</div>\n<p>springboot模块拆分</p>\n<p>搭建mybatis-plus框架</p>\n<p>统一结果类封装</p>\n<p>全局异常处理</p>\n<p>同一日志处理（AOP切面写入数据）</p>\n<p>参考</p>\n<div><p>Tips</p>\n<p>https://blog.csdn.net/qq_43757153/article/details/106077811</p>\n</div>\n<p>redis-加载菜单</p>\n<p>springboot-security&amp;jwt</p>\n<p>https://blog.csdn.net/yuanlaijike/category_9283872.html</p>\n<p>Vue</p>\n<div><p>参考</p>\n<p><a href=\"https://linjinp.blog.csdn.net/article/details/90256713?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1.not_use_machine_learn_pai&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1.not_use_machine_learn_pai\" target=\"_blank\" rel=\"noopener noreferrer\">Vue 新手学习笔记：vue-element-admin 之登陆及目录权限控制</a></p>\n</div>\n",
      "date_published": "2021-01-13T17:34:06.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": []
    },
    {
      "title": "Swagger使用",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/spring/springboot/springboot-tool/Swagger-use/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/spring/springboot/springboot-tool/Swagger-use/",
      "content_html": "<h2 id=\"参考\"> 参考</h2>\n<blockquote>\n<ul>\n<li>https://blog.csdn.net/u014231523/article/details/54562695</li>\n<li>https://leongfeng.github.io/2017/02/20/springboot-springfox-swagger2markup-spring-restdoc/</li>\n<li>官方wiki：https://github.com/swagger-api/swagger-core/wiki/Annotations</li>\n</ul>\n</blockquote>\n<h2 id=\"_1-引入依赖\"> 1. 引入依赖</h2>\n<div><pre><code>\t\t\t\t<span>&lt;!--Swagger依赖--></span>\n        <span><span><span>&lt;</span>dependency</span><span>></span></span>\n            <span><span><span>&lt;</span>groupId</span><span>></span></span>io.springfox<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n            <span><span><span>&lt;</span>artifactId</span><span>></span></span>springfox-swagger2<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n            <span><span><span>&lt;</span>version</span><span>></span></span>2.9.2<span><span><span>&lt;/</span>version</span><span>></span></span>\n        <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n        <span><span><span>&lt;</span>dependency</span><span>></span></span>\n            <span><span><span>&lt;</span>groupId</span><span>></span></span>io.springfox<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n            <span><span><span>&lt;</span>artifactId</span><span>></span></span>springfox-swagger-ui<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n            <span><span><span>&lt;</span>version</span><span>></span></span>2.9.2<span><span><span>&lt;/</span>version</span><span>></span></span>\n        <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h2 id=\"_2-配置swaggerconfiguration\"> 2. 配置SwaggerConfiguration</h2>\n<p>创建<code>SwaggerConfiguration.java</code>配置类</p>\n<p>加注解</p>\n<blockquote>\n<ul>\n<li>@Configuration</li>\n<li>@EnableSwagger2</li>\n</ul>\n</blockquote>\n<div><pre><code><span>package</span> <span>com<span>.</span>pactera<span>.</span>sz<span>.</span>cmb202102<span>.</span>config</span><span>;</span>\n\n\n<span>import</span> <span>com<span>.</span>github<span>.</span>xiaoymin<span>.</span>swaggerbootstrapui<span>.</span>annotations<span>.</span></span><span>EnableSwaggerBootstrapUI</span><span>;</span>\n<span>import</span> <span>com<span>.</span>google<span>.</span>common<span>.</span>base<span>.</span></span><span>Function</span><span>;</span>\n<span>import</span> <span>com<span>.</span>google<span>.</span>common<span>.</span>base<span>.</span></span><span>Optional</span><span>;</span>\n<span>import</span> <span>com<span>.</span>google<span>.</span>common<span>.</span>base<span>.</span></span><span>Predicate</span><span>;</span>\n<span>import</span> <span>com<span>.</span>google<span>.</span>common<span>.</span>base<span>.</span></span><span>Predicates</span><span>;</span>\n<span>import</span> <span>org<span>.</span>springframework<span>.</span>context<span>.</span>annotation<span>.</span></span><span>Bean</span><span>;</span>\n<span>import</span> <span>org<span>.</span>springframework<span>.</span>context<span>.</span>annotation<span>.</span></span><span>Configuration</span><span>;</span>\n<span>import</span> <span>springfox<span>.</span>documentation<span>.</span></span><span>RequestHandler</span><span>;</span>\n<span>import</span> <span>springfox<span>.</span>documentation<span>.</span>builders<span>.</span></span><span>ApiInfoBuilder</span><span>;</span>\n<span>import</span> <span>springfox<span>.</span>documentation<span>.</span>builders<span>.</span></span><span>PathSelectors</span><span>;</span>\n<span>import</span> <span>springfox<span>.</span>documentation<span>.</span>builders<span>.</span></span><span>RequestHandlerSelectors</span><span>;</span>\n<span>import</span> <span>springfox<span>.</span>documentation<span>.</span>service<span>.</span></span><span>ApiInfo</span><span>;</span>\n<span>import</span> <span>springfox<span>.</span>documentation<span>.</span>service<span>.</span></span><span>Contact</span><span>;</span>\n<span>import</span> <span>springfox<span>.</span>documentation<span>.</span>spi<span>.</span></span><span>DocumentationType</span><span>;</span>\n<span>import</span> <span>springfox<span>.</span>documentation<span>.</span>spring<span>.</span>web<span>.</span>plugins<span>.</span></span><span>Docket</span><span>;</span>\n<span>import</span> <span>springfox<span>.</span>documentation<span>.</span>swagger2<span>.</span>annotations<span>.</span></span><span>EnableSwagger2</span><span>;</span>\n\n\n\n\n<span>/**\n * @WebName: SwaggerConfig\n * @Description: TODO\n * @author: Chen Long\n * @date: 2020/9/17  15:25\n * “Welcome,my master”\n */</span>\n\n<span>@Configuration</span>\n<span>@EnableSwagger2</span>\n<span>@EnableSwaggerBootstrapUI</span>\n<span>public</span> <span>class</span> <span>SwaggerConfig</span> <span>{</span>\n\n    <span>// 定义分隔符</span>\n    <span>private</span> <span>static</span> <span>final</span> <span>String</span> SPLITOR <span>=</span> <span>\";\"</span><span>;</span>\n\n    <span>private</span> <span>static</span> <span>final</span> <span>String</span> project <span>=</span> <span>\"com.pactera.sz.cmb202102.\"</span><span>;</span>\n    <span>private</span> <span>static</span> <span>final</span> <span>String</span> <span>ChargeModule</span> <span>=</span> <span>\"com.pactera.sz.cmb202102.charge\"</span><span>;</span>\n    <span>private</span> <span>static</span> <span>final</span> <span>String</span> householdServiceModule <span>=</span> <span>\"com.pactera.sz.cmb202102.householdservice\"</span><span>;</span>\n    <span>private</span> <span>static</span> <span>final</span> <span>String</span> financeServiceModule <span>=</span> <span>\"com.pactera.sz.cmb202102.financeservice\"</span><span>;</span>\n    <span>private</span> <span>static</span> <span>final</span> <span>String</span> statisticsServiceModule <span>=</span> <span>\"com.pactera.sz.cmb202102.statisticsservice\"</span><span>;</span>\n    <span>private</span> <span>static</span> <span>final</span> <span>String</span> managementModule <span>=</span> <span>\"com.pactera.sz.cmb202102\"</span><span>;</span>\n\n    <span>/**\n     * 创建API应用\n     * api() 增加API相关信息\n     * 通过select()函数返回一个ApiSelectorBuilder实例,用来控制哪些接口暴露给Swagger来展现，\n     * 本例采用指定扫描的包路径来定义指定要建立API的目录。\n     *\n     * @return\n     */</span>\n\n\n\n    <span>@Bean</span>\n    <span>public</span> <span>Docket</span> <span>merchantDocket</span><span>(</span><span>)</span><span>{</span>\n        <span>return</span> <span>new</span> <span>Docket</span><span>(</span><span>DocumentationType</span><span>.</span>SWAGGER_2<span>)</span>\n                <span>.</span><span>groupName</span><span>(</span><span>\"商户管理平台模块\"</span><span>)</span>\n                <span>.</span><span>apiInfo</span><span>(</span><span>apiInfo</span><span>(</span><span>)</span><span>)</span>\n                <span>.</span><span>select</span><span>(</span><span>)</span>\n                <span>.</span><span>apis</span><span>(</span><span>scanBasePackage</span><span>(</span><span>ChargeModule</span> <span>+</span> SPLITOR <span>+</span> householdServiceModule <span>+</span> SPLITOR <span>+</span> financeServiceModule <span>+</span> SPLITOR <span>+</span> statisticsServiceModule<span>)</span><span>)</span>\n                <span>.</span><span>paths</span><span>(</span><span>PathSelectors</span><span>.</span><span>any</span><span>(</span><span>)</span><span>)</span>\n                <span>.</span><span>build</span><span>(</span><span>)</span><span>;</span>\n\n        <span>//是否将参数显示在请求后面</span>\n    <span>}</span>\n\n    <span>@Bean</span>\n    <span>public</span> <span>Docket</span> <span>systemDocket</span><span>(</span><span>)</span><span>{</span>\n        <span>return</span> <span>new</span> <span>Docket</span><span>(</span><span>DocumentationType</span><span>.</span>SWAGGER_2<span>)</span>\n                <span>.</span><span>groupName</span><span>(</span><span>\"系统后台管理模块\"</span><span>)</span>\n                <span>.</span><span>apiInfo</span><span>(</span><span>apiInfo</span><span>(</span><span>)</span><span>)</span>\n                <span>.</span><span>select</span><span>(</span><span>)</span>\n                <span>.</span><span>apis</span><span>(</span><span>scanBasePackage</span><span>(</span>managementModule<span>)</span><span>)</span>\n                <span>.</span><span>paths</span><span>(</span><span>PathSelectors</span><span>.</span><span>any</span><span>(</span><span>)</span><span>)</span>\n                <span>.</span><span>build</span><span>(</span><span>)</span><span>;</span>\n        <span>//是否将参数显示在请求后面</span>\n    <span>}</span>\n\n    <span>private</span> <span>ApiInfo</span> <span>apiInfo</span><span>(</span><span>)</span><span>{</span>\n        <span>return</span> <span>new</span> <span>ApiInfoBuilder</span><span>(</span><span>)</span>\n                <span>.</span><span>title</span><span>(</span><span>\"CMB202102-Swagger\"</span><span>)</span>\n                <span>.</span><span>description</span><span>(</span><span>\"CMB202102实训项目-后台管理系统/商户管理平台\"</span><span>)</span>\n                <span>.</span><span>termsOfServiceUrl</span><span>(</span><span>\"localhost:8000\"</span><span>)</span>\n                <span>.</span><span>contact</span><span>(</span><span>new</span> <span>Contact</span><span>(</span><span>\"WebSite\"</span><span>,</span> <span>\"http://localhost:8081/login\"</span><span>,</span> <span>\"1138312802@qq.com\"</span><span>)</span><span>)</span>\n                <span>.</span><span>version</span><span>(</span><span>\"Beta\"</span><span>)</span>\n                <span>.</span><span>license</span><span>(</span><span>\"MIT\"</span><span>)</span>\n                <span>.</span><span>licenseUrl</span><span>(</span><span>\"\"</span><span>)</span>\n                <span>.</span><span>build</span><span>(</span><span>)</span><span>;</span>\n\n    <span>}</span>\n\n\n    <span>/**\n     * 切割扫描的包生成Predicate&lt;RequestHandler>\n     * @param basePackage\n     * @return\n     */</span>\n    <span>public</span> <span>static</span> <span>Predicate</span><span><span>&lt;</span><span>RequestHandler</span><span>></span></span> <span>scanBasePackage</span><span>(</span><span>final</span> <span>String</span> basePackage<span>)</span> <span>{</span>\n        <span>if</span><span>(</span>basePackage<span>.</span><span>length</span><span>(</span><span>)</span> <span>==</span> <span>0</span><span>)</span><span>{</span>\n            <span>throw</span> <span>new</span> <span>NullPointerException</span><span>(</span><span>\"basePackage不能为空，多个包扫描使用\"</span><span>+</span>SPLITOR<span>+</span><span>\"分隔\"</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>String</span><span>[</span><span>]</span> controllerPack <span>=</span> basePackage<span>.</span><span>split</span><span>(</span>SPLITOR<span>)</span><span>;</span>\n        <span>Predicate</span><span><span>&lt;</span><span>RequestHandler</span><span>></span></span> predicate <span>=</span> <span>null</span><span>;</span>\n        <span>for</span> <span>(</span><span>int</span> i <span>=</span> controllerPack<span>.</span>length <span>-</span><span>1</span><span>;</span> i <span>>=</span> <span>0</span> <span>;</span> i<span>--</span><span>)</span> <span>{</span>\n            <span>String</span> strBasePackage <span>=</span> controllerPack<span>[</span>i<span>]</span><span>;</span>\n            <span>Predicate</span><span><span>&lt;</span><span>RequestHandler</span><span>></span></span> tempPredicate <span>=</span> <span>RequestHandlerSelectors</span><span>.</span><span>basePackage</span><span>(</span>strBasePackage<span>)</span><span>;</span>\n            predicate <span>=</span> predicate <span>==</span> <span>null</span> <span>?</span> tempPredicate <span>:</span> <span>Predicates</span><span>.</span><span>or</span><span>(</span>tempPredicate<span>,</span>predicate<span>)</span><span>;</span>\n        <span>}</span>\n        <span>if</span><span>(</span>predicate <span>==</span> <span>null</span><span>)</span><span>{</span>\n            <span>throw</span> <span>new</span> <span>NullPointerException</span><span>(</span><span>\"basePackage配置不正确，多个包扫描使用\"</span><span>+</span>SPLITOR<span>+</span><span>\"分隔\"</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>return</span> predicate<span>;</span>\n    <span>}</span>\n\n\n<span>}</span>\n\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br><span>111</span><br><span>112</span><br><span>113</span><br><span>114</span><br><span>115</span><br><span>116</span><br><span>117</span><br><span>118</span><br><span>119</span><br><span>120</span><br><span>121</span><br><span>122</span><br></div></div><p>输入http://localhost:8001/swagger-ui.html</p>\n<p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/Swagger-use/swagger_page.jpg\" alt=\"\" /></p>\n<h3 id=\"_2-1-多包扫描\"> 2.1 多包扫描</h3>\n<p>参考</p>\n<blockquote>\n<ul>\n<li>https://www.jianshu.com/p/b5068f121a49</li>\n</ul>\n</blockquote>\n<h2 id=\"_3-常用注解\"> 3. 常用注解</h2>\n<table>\n<thead>\n<tr>\n<th>注解</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>@Api()</td>\n<td>用于controller类上</td>\n</tr>\n<tr>\n<td>@ApiOperation()</td>\n<td>用于controller类中的请求方法</td>\n</tr>\n<tr>\n<td>@ApiParam()</td>\n<td>用于请求中的参数说明</td>\n</tr>\n<tr>\n<td>@ApiImplicitParam()</td>\n<td>用于请求方法中的参数说明，不过写在请求方法上</td>\n</tr>\n<tr>\n<td>@ApiImplicitParams()</td>\n<td>里面可以包含多个@ApiImplicitParam()</td>\n</tr>\n<tr>\n<td>@ApiModel()</td>\n<td>写在实体类上，描述和重命名实体类</td>\n</tr>\n<tr>\n<td>@ApiModelProperty()</td>\n<td>写在实体类属性上，描述，重命名，示例等</td>\n</tr>\n<tr>\n<td>@ApiResponses()</td>\n<td>用于请求方法上，描述某个返回码</td>\n</tr>\n<tr>\n<td>@ApiIgnore()</td>\n<td>作用于类，方法，属性上，使其忽略</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"api-描述controller类\"> @Api()：描述Controller类</h3>\n<p>作用于<code>controller</code>类上</p>\n<p>属性说明</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>tags</td>\n<td>分组，在类上多个时会复制多个controller。也可以当做名字使用</td>\n</tr>\n<tr>\n<td>description</td>\n<td>小标题描述，已弃用，默认为controller类名</td>\n</tr>\n<tr>\n<td>value</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<p>例如</p>\n<div><pre><code><span>@RestController</span>\n<span>@RequestMapping</span><span>(</span><span>\"demoData\"</span><span>)</span>\n<span>@Api</span><span>(</span>value<span>=</span><span>\"Api_value\"</span><span>,</span>description<span>=</span><span>\"Api_description\"</span><span>,</span>tags<span>=</span><span>{</span><span>\"Api_tags\"</span><span>}</span><span>)</span>\n<span>public</span> <span>class</span> <span>DemoDataController</span> <span>{</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/Swagger-use/@Api_Effect_picture.jpg\" alt=\"@Api效果图\" /></p>\n<h3 id=\"apioperation-描述请求方法\"> @ApiOperation()：描述请求方法</h3>\n<p>作用于controller类中的<code>请求方法</code>上</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>value</td>\n<td style=\"text-align:left\">表示标题，如果有多个值则会复制多个controller</td>\n</tr>\n<tr>\n<td>notes</td>\n<td style=\"text-align:left\">方法内容</td>\n</tr>\n<tr>\n<td>tags</td>\n<td style=\"text-align:left\">分组</td>\n</tr>\n<tr>\n<td>hidden</td>\n<td style=\"text-align:left\">默认为<code>false</code>，<code>true</code>时隐藏</td>\n</tr>\n</tbody>\n</table>\n<p>例如</p>\n<div><pre><code><span>@GetMapping</span><span>(</span><span>\"/exportExcel\"</span><span>)</span>\n<span>@ApiOperation</span><span>(</span>value<span>=</span><span>\"ApiOperation_Value\"</span><span>,</span>notes<span>=</span><span>\"ApiOperation_Notes\"</span><span>)</span>\n<span>public</span> <span>void</span> <span>exportExcel</span><span>(</span><span>)</span> <span>throws</span> <span>IOException</span> <span>{</span>\n  \n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/Swagger-use/@ApiOperation_Effect_picture.jpg\" alt=\"@ApiOperation效果图\" /></p>\n<h3 id=\"apiparam-参数\"> @ApiParam()：参数</h3>\n<p>作用于controller类中的<code>请求方法形参上</code>上。用于方法，参数，字段说明，表示对参数的添加元数据（说明或是否必填等）</p>\n<blockquote>\n<p>注意，作用于参数时，在Swagger中会要求输入body类型(GET和HEAD无法接受BODY类型)。不想使用body可以在参数前加注解<code>@RequestParam</code>。或者直接使用注解<code>@ApiImplicitParam()</code></p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>name</td>\n<td style=\"text-align:left\">参数名</td>\n</tr>\n<tr>\n<td>value</td>\n<td style=\"text-align:left\">参数说明</td>\n</tr>\n<tr>\n<td>required</td>\n<td style=\"text-align:left\">是否必填</td>\n</tr>\n</tbody>\n</table>\n<p>例如</p>\n<div><pre><code><span>public</span> <span>void</span> <span>exportExcel</span><span>(</span><span>@ApiParam</span><span>(</span>name<span>=</span><span>\"param\"</span><span>,</span>value<span>=</span><span>\"ApiParam_value\"</span><span>,</span>required<span>=</span><span>true</span><span>)</span> <span>String</span> param<span>)</span><span>{</span>\n\n <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><code>name</code>可以省略</p>\n<p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/Swagger-use/@ApiParam_Effect_picture.jpg\" alt=\"@ApiParam效果图\" /></p>\n<h3 id=\"apiimplicitparams\"> @ApiImplicitParams()</h3>\n<p>作用于<code>请求方法</code>上，对参数进行说明，包含多个<code>@ApiImplicitParam</code></p>\n<p>参考</p>\n<blockquote>\n<ul>\n<li>https://blog.csdn.net/qq_35494342/article/details/104691636</li>\n</ul>\n</blockquote>\n<h4 id=\"apiimplicitparam\"> @ApiImplicitParam</h4>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>name</td>\n<td style=\"text-align:left\">对应参数名</td>\n</tr>\n<tr>\n<td>value</td>\n<td style=\"text-align:left\">对参数进行说明</td>\n</tr>\n<tr>\n<td>required</td>\n<td style=\"text-align:left\">参数是否必须传</td>\n</tr>\n<tr>\n<td>paramType</td>\n<td style=\"text-align:left\">参数放在哪个地方，具体值在下方</td>\n</tr>\n<tr>\n<td>dataType</td>\n<td style=\"text-align:left\">参数类型，默认String，其它值dataType=&quot;Integer&quot;，也可以写实体类</td>\n</tr>\n<tr>\n<td>dataTypeClass</td>\n<td style=\"text-align:left\">用类当做参数类型，但试过无效</td>\n</tr>\n<tr>\n<td>defaultValue</td>\n<td style=\"text-align:left\">参数的默认值</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"paramtype参数\"> paramType参数</h4>\n<table>\n<thead>\n<tr>\n<th>值</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>header</td>\n<td style=\"text-align:left\">请求参数的获取：@RequestHeader</td>\n</tr>\n<tr>\n<td>query</td>\n<td style=\"text-align:left\">请求参数的获取：@RequestParam</td>\n</tr>\n<tr>\n<td>path</td>\n<td style=\"text-align:left\">用于restful接口， 请求参数的获取：@PathVariable</td>\n</tr>\n<tr>\n<td>body</td>\n<td style=\"text-align:left\">@RequestBody</td>\n</tr>\n<tr>\n<td>form</td>\n<td style=\"text-align:left\">表单</td>\n</tr>\n</tbody>\n</table>\n<p>例如</p>\n<div><pre><code><span>@ApiImplicitParams</span><span>(</span><span>{</span>\n    <span>@ApiImplicitParam</span><span>(</span>name <span>=</span> <span>\"name\"</span><span>,</span> value <span>=</span> <span>\"User's name\"</span><span>,</span> required <span>=</span> <span>true</span><span>,</span> dataType <span>=</span> <span>\"string\"</span><span>,</span> paramType <span>=</span> <span>\"query\"</span><span>)</span><span>,</span>\n    <span>@ApiImplicitParam</span><span>(</span>name <span>=</span> <span>\"email\"</span><span>,</span> value <span>=</span> <span>\"User's email\"</span><span>,</span> required <span>=</span> <span>false</span><span>,</span> dataType <span>=</span> <span>\"string\"</span><span>,</span> paramType <span>=</span> <span>\"query\"</span><span>)</span><span>,</span>\n    <span>@ApiImplicitParam</span><span>(</span>name <span>=</span> <span>\"id\"</span><span>,</span> value <span>=</span> <span>\"User ID\"</span><span>,</span> required <span>=</span> <span>true</span><span>,</span> dataType <span>=</span> <span>\"long\"</span><span>,</span> paramType <span>=</span> <span>\"query\"</span><span>)</span>\n  <span>}</span><span>)</span>\n <span>public</span> <span>void</span> <span>doPost</span><span>(</span><span>HttpServletRequest</span> request<span>,</span> <span>HttpServletResponse</span> response<span>)</span> <span>throws</span> <span>ServletException</span><span>,</span> <span>IOException</span> <span>{</span><span>.</span><span>.</span><span>.</span><span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id=\"apimodel-实体类\"> @ApiModel()：实体类</h3>\n<p>作用于实体类上</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>value</td>\n<td style=\"text-align:left\">实体类名称</td>\n</tr>\n<tr>\n<td>description</td>\n<td style=\"text-align:left\">实体类描述</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"apimodelproperty-实体类参数上\"> @ApiModelProperty：实体类参数上</h3>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>value</td>\n<td style=\"text-align:left\">参数描述</td>\n</tr>\n<tr>\n<td>example</td>\n<td style=\"text-align:left\">举例</td>\n</tr>\n<tr>\n<td>hidden</td>\n<td style=\"text-align:left\">是否显示</td>\n</tr>\n<tr>\n<td>required</td>\n<td style=\"text-align:left\">是否必填</td>\n</tr>\n</tbody>\n</table>\n<p>例如</p>\n<div><pre><code><span>@ApiModel</span><span>(</span>value <span>=</span> <span>\"ApiModel_value\"</span><span>,</span> description <span>=</span> <span>\"ApiModel_description\"</span><span>)</span>\n<span>public</span> <span>class</span> <span>DemoData</span> <span>{</span>\n    <span>@ApiModelProperty</span><span>(</span>value<span>=</span><span>\"用户名id\"</span><span>,</span>required <span>=</span> <span>true</span><span>)</span>\n    <span>private</span> <span>Integer</span> id<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/Swagger-use/@ApiModel.jpg\" alt=\"\" /></p>\n<h3 id=\"apiresponses-返回码描述\"> @ApiResponses：返回码描述</h3>\n<p>作用于请求方法。设置返回码和响应的描述信息，<code>@ApiResponses</code>可以设置多个<code>@ApiResponse</code></p>\n<p>例如</p>\n<div><pre><code>    <span>@ApiResponses</span><span>(</span>value <span>=</span> <span>{</span> \n            <span>@ApiResponse</span><span>(</span>code <span>=</span> <span>400</span><span>,</span> message <span>=</span> <span>\"Invalid ID supplied\"</span><span>)</span><span>,</span>\n            <span>@ApiResponse</span><span>(</span>code <span>=</span> <span>404</span><span>,</span> message <span>=</span> <span>\"Pet not found\"</span><span>)</span> \n    <span>}</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id=\"apiignore-忽略类或方法或实体类属性\"> @ApiIgnore：忽略类或方法或实体类属性</h3>\n<p>可作用于类，方法和实体类属性上</p>\n<h2 id=\"_4-集成swagger-bootstrap-ui\"> 4. 集成swagger-bootstrap-ui</h2>\n<p>功能更强大bootstrap风格的UI界面</p>\n<h3 id=\"_4-1-导入依赖\"> 4.1 导入依赖</h3>\n<div><pre><code>        <span>&lt;</span><span>!</span><span>--</span> https<span>:</span><span>/</span><span>/</span>mvnrepository<span>.</span>com<span>/</span>artifact<span>/</span>com<span>.</span>github<span>.</span>xiaoymin<span>/</span>swagger<span>-</span>bootstrap<span>-</span>ui <span>--</span><span>></span>\n        <span><span>&lt;</span>dependency<span>></span></span>\n            <span><span>&lt;</span>groupId<span>></span></span>com<span>.</span>github<span>.</span>xiaoymin<span>&lt;</span><span>/</span>groupId<span>></span>\n            <span><span>&lt;</span>artifactId<span>></span></span>swagger<span>-</span>bootstrap<span>-</span>ui<span>&lt;</span><span>/</span>artifactId<span>></span>\n            <span><span>&lt;</span>version<span>></span></span><span>1.9</span><span>.6</span><span>&lt;</span><span>/</span>version<span>></span>\n        <span>&lt;</span><span>/</span>dependency<span>></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id=\"_4-2-在swaggerconfig上开启注解\"> 4.2 在SwaggerConfig上开启注解</h3>\n<div><pre><code><span>@EnableSwaggerBootstrapUI</span>\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"_4-3-访问网址\"> 4.3 访问网址</h3>\n<p>http://localhost:8000/doc.html</p>\n<p><img src=\"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/Swagger-use/SwaggerBootstrapUI.jpg\" alt=\"\" /></p>\n",
      "image": "https://blog-1300186248.cos.ap-shanghai.myqcloud.com/Swagger-use/swagger_page.jpg",
      "date_published": "2020-10-10T18:29:09.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": []
    },
    {
      "title": "认识SpringCloud",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/spring/springcloud/Know-SpringCloud/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/spring/springcloud/Know-SpringCloud/",
      "content_html": "<h1 id=\"springcloud课程\"> SpringCloud课程</h1>\n<h2 id=\"一、微服务和微服务架构\"> 一、微服务和微服务架构</h2>\n<h3 id=\"_1-什么是微服务\"> 1.什么是微服务</h3>\n<blockquote>\n<p>https://martinfowler.com/articles/microservices.html，提出者原文</p>\n<p>维基百科上给出的定义是：微服务（Microservices）是一种软件开发技术，是面向服务的架构（Service-Oriented  Architecture，SOA）的变体，微服务架构将应用程序组成一系列松散耦合的服务集合。在微服务体系结构中，服务是细粒度的，协议是轻量级的。</p>\n<p>传统开发模式下，绝大部分的 Web 应用都是采用单体架构的风格来进行构建的，这意味着 Web  应用是作为单个可部署的软件制品进行交付的，所有的接口、业务逻辑、持久层都被打包在一个 Web  应用中，并且部署在一台服务器上。这种开发模式会带来诸多不便，大多数情况下，一个应用程序是交由多个团队来协同开发的，每个开发团队负责各自不同的模块，并且会有自己的定制组件来服务对应的客户。</p>\n<p>问题就出在这里，随着应用程序的规模和复杂度不断增长，多个团队协同开发一个单体应用程序会变得越来越困难、越来越复杂，假设某个团队需要修改接口，那么其他团队与之对应的代码也需要修改，同时整个应用程序都需要重新构建、测试、部署。</p>\n<p>微服务架构就是为了解决上述问题而生的，它的本质在于分布式、去中心化。简单理解就是分解应用程序的功能，把一个大型服务拆分成很多小服务，使它们完全彼此独立，并且可以相互通信，拆分之后的微服务架构如下图所示。</p>\n<p><img src=\"./images/Know-SpringCloud/Microservice.jpg\" alt=\"微服务\" /></p>\n</blockquote>\n<p>​\t<strong>简单点说，微服务化的核心就是将传统的一站式应用，根据业务拆分成一个一个的服务，彻底地去耦合，每一个微服务提供单个业务功能的服务，一个服务做一件事情，从技术角度看就是一种小而独立的处理过程，类似进程的概念，能够自行单独启动或销毁，拥有自己独立的数据库。</strong></p>\n<h3 id=\"_2-什么是微服务架构\"> 2.什么是微服务架构</h3>\n<blockquote>\n<p>https://www.jianshu.com/p/bf3484efa709?utm_source=oschina-app</p>\n</blockquote>\n<h3 id=\"_3-微服务架构的4个核心问题\"> 3.微服务架构的4个核心问题</h3>\n<blockquote>\n<p>1、服务很多，客户端该怎么访问？</p>\n<p>2、这么多服务？服务之间如何通信</p>\n<p>3、这么多服务？如何治理？</p>\n<p>4、服务挂了怎么办？</p>\n</blockquote>\n<h3 id=\"_4-微服务的优缺点\"> 4.微服务的优缺点</h3>\n<h4 id=\"优点\"> 优点</h4>\n<ul>\n<li>每个服务足够内聚，足够小，代码容易理解，这样能聚焦一个指定的业务功能或业务需求；</li>\n<li>开发简单，开发效率提高，一个服务可能就是专一的只干一件事；</li>\n<li>微服务能够被小团队单独开发，这个小团队是2~5人的开发人员组成；</li>\n<li>微服务是松耦合的，是有功能意义的服务，无论是在开发阶段或部署阶段都是独立的；</li>\n<li>微服务能使用不同的语言开发；</li>\n<li>易于和第三方集成，微服务允许容易且灵活的方式集成自动部署，通过持续集成工具，如jenkins；</li>\n<li>微服务易于被一个开发人员理解，修改和维护，这样小团队能够更关注自己的工作成果，无需通过合作才能体现价值</li>\n<li>微服务允许你利用融合最新技术</li>\n<li>微服务只是业务逻辑的代码，不会和HTML，CSS或其它界面混合</li>\n<li>每个微服务都有自己的存储能力，可以有自己的数据库，也可以有统一数据库</li>\n</ul>\n<h4 id=\"缺点\"> 缺点</h4>\n<ul>\n<li>开发人员要处理分布式系统的复杂性</li>\n<li>多服务运维难度，随着服务的增加，运维的压力也在增大</li>\n<li>系统部署依赖</li>\n<li>服务间通信成本</li>\n<li>数据一致性</li>\n<li>系统集成测试</li>\n<li>性能监控</li>\n</ul>\n<h2 id=\"二、微服务解决方案\"> 二、微服务解决方案</h2>\n<h3 id=\"_1-spring-cloud-netflix\"> 1.Spring Cloud NetFlix</h3>\n<blockquote>\n<p>18年停更了。</p>\n</blockquote>\n<h3 id=\"_2-apache-dubbo-zookeeper\"> 2.Apache Dubbo Zookeeper</h3>\n<blockquote>\n<p>api网关：没有，找第三方组件，或自己实现</p>\n<p>Dubbo：基于socket通信，一个rpc框架</p>\n<p>Zookeeper：服务注册与发现</p>\n<p>熔断机制：没有，使用第三方</p>\n</blockquote>\n<h3 id=\"_3-spring-cloud-alibaba\"> 3.Spring Cloud Alibaba</h3>\n<blockquote>\n<p>一站式解决方案！使用更简单</p>\n<p>Nacos：服务注册与发现，配置中心</p>\n</blockquote>\n<h3 id=\"_4-微服务技术栈\"> 4.微服务技术栈</h3>\n<table>\n<thead>\n<tr>\n<th>微服务条目</th>\n<th>落地技术</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>服务开发</td>\n<td>SpringBoot、SSM</td>\n</tr>\n<tr>\n<td>服务配置与管理</td>\n<td>Netflix公司的Archaius、阿里的Diamond等</td>\n</tr>\n<tr>\n<td>服务注册与发现</td>\n<td>Eureka、Zookeeper、Nacos、Consul等</td>\n</tr>\n<tr>\n<td>服务调用</td>\n<td>Rest(Http)、RPC、gRPC</td>\n</tr>\n<tr>\n<td>服务熔断器</td>\n<td>Hystrix、Envoy、Sentinel等</td>\n</tr>\n<tr>\n<td>负载均衡</td>\n<td>Ribbon、Nginx、Feign等</td>\n</tr>\n<tr>\n<td>服务接口调用</td>\n<td>Feign</td>\n</tr>\n<tr>\n<td>消息队列</td>\n<td>Kafka、RabbitMQ、ActiveMQ、RocketMQ</td>\n</tr>\n<tr>\n<td>服务配置中心管理</td>\n<td>config、consul、apollo、nacos</td>\n</tr>\n<tr>\n<td>服务路由(网关)</td>\n<td>Zuul、Gateway等</td>\n</tr>\n<tr>\n<td>服务监控</td>\n<td>Zabbix、Nagios、Metrics、Specatator等</td>\n</tr>\n<tr>\n<td>全链路追踪</td>\n<td>Zipkin、Brave、Dapper等</td>\n</tr>\n<tr>\n<td>服务部署</td>\n<td>Docker、OpenStack、Kubernetes(k8s)等</td>\n</tr>\n<tr>\n<td>数据流操作开发包</td>\n<td>SpringCloud Stream(封装与Redis、Rabbit、Kafka等发送接收消息)</td>\n</tr>\n<tr>\n<td>事件消息总线</td>\n<td>SpringCloud Bus</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"三、常见面试题\"> 三、常见面试题</h2>\n<ul>\n<li>\n<h3 id=\"_1-什么是微服务和微服务架构\"> 1.什么是微服务和微服务架构</h3>\n</li>\n</ul>\n<blockquote>\n<p>1.微服务</p>\n<p>强调的是服务的大小，它关注的是某一个点，是具体解决某一个问题并提供落地对应服务的一个服务应用，狭义的看，可以看做是IDEA中的一个个微服务工程或者Module</p>\n<p>2.微服务架构</p>\n<p>一种新的架构形式，由Martin Fowler，2014提出。</p>\n<p>它提倡将单一应用程序划分成一组小的服务，服务之间相互协调，互相配合，为用户提供最终价值，每个服务运行在其独立的进程中，服务于服务间采用轻量级的通信机制互相协作，每个服务都围绕着具体的业务进行构建，并且能够被独立的部署到生产环境中，另外，应尽量避免统一的集中式的服务管理机制，对具体的一个服务而言，应根据业务上下文，选择合适的语言，工具对其进行构建。</p>\n</blockquote>\n<ul>\n<li>\n<h3 id=\"_2-微服务之间是如何独立通讯的\"> 2.微服务之间是如何独立通讯的</h3>\n</li>\n</ul>\n<blockquote>\n<p>Spring Cloud基于http协议通信</p>\n<p>Dubbo则是典型的rpc协议通信框架</p>\n</blockquote>\n<ul>\n<li>\n<h3 id=\"_3-springcloud和dubbo有哪些区别\"> 3.SpringCloud和Dubbo有哪些区别</h3>\n</li>\n</ul>\n<blockquote></blockquote>\n<ul>\n<li>\n<h3 id=\"_4-springboot和springcloud-请你谈谈对他们的理解\"> 4.SpringBoot和SpringCloud，请你谈谈对他们的理解</h3>\n</li>\n</ul>\n<blockquote></blockquote>\n<ul>\n<li>\n<h3 id=\"_5-什么是服务熔断-什么是服务降级\"> 5.什么是服务熔断？什么是服务降级</h3>\n</li>\n</ul>\n<blockquote></blockquote>\n<ul>\n<li>\n<h3 id=\"_6-微服务的优缺点分别是什么-说下你在项目中遇到的坑\"> 6.微服务的优缺点分别是什么？说下你在项目中遇到的坑</h3>\n</li>\n</ul>\n<blockquote></blockquote>\n<ul>\n<li>\n<h3 id=\"_7-你所知道的微服务技术栈有哪些-请列举一二\"> 7.你所知道的微服务技术栈有哪些？请列举一二</h3>\n</li>\n</ul>\n<blockquote></blockquote>\n<ul>\n<li>\n<h3 id=\"_8-eureka和zookeeper都可以提供服务注册与发现的功能请说说两都之间的区别\"> 8.eureka和zookeeper都可以提供服务注册与发现的功能请说说两都之间的区别</h3>\n</li>\n</ul>\n<blockquote></blockquote>\n<h2 id=\"四、什么是springcloud\"> <a href=\"http://www.macrozheng.com/#/cloud/springcloud?id=%E4%BB%80%E4%B9%88%E6%98%AFspringcloud\" target=\"_blank\" rel=\"noopener noreferrer\">四、什么是SpringCloud</a></h2>\n<h3 id=\"目标\"> <a href=\"http://www.macrozheng.com/#/cloud/springcloud?id=%E7%9B%AE%E6%A0%87\" target=\"_blank\" rel=\"noopener noreferrer\">目标</a></h3>\n<p>协调任何服务，简化分布式系统开发。</p>\n<h3 id=\"简介\"> <a href=\"http://www.macrozheng.com/#/cloud/springcloud?id=%E7%AE%80%E4%BB%8B\" target=\"_blank\" rel=\"noopener noreferrer\">简介</a></h3>\n<p>构建分布式系统不应该是复杂的，SpringCloud对常见的分布式系统模式提供了简单易用的编程模型，帮助开发者构建弹性、可靠、协调的应用程序。 SpringCloud是在SpringBoot的基础上构建的，使开发者可以轻松入门并快速提高工作效率。 SpringCloud为开发人员提供了快速构建分布式系统架构的工具，例如配置管理，服务发现，断路器，智能路由，微代理，控制总线，一次性令牌，全局锁定，领导选举，分布式会话，集群状态等。</p>\n<h3 id=\"整体架构\"> <a href=\"http://www.macrozheng.com/#/cloud/springcloud?id=%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84\" target=\"_blank\" rel=\"noopener noreferrer\">整体架构</a></h3>\n<p><img src=\"./images/Know-SpringCloud/springcloud_architecture.png\" alt=\"Springcloud整体架构\" /></p>\n<h3 id=\"springcloud的版本关系\"> <a href=\"http://www.macrozheng.com/#/cloud/springcloud?id=springcloud%E7%9A%84%E7%89%88%E6%9C%AC%E5%85%B3%E7%B3%BB\" target=\"_blank\" rel=\"noopener noreferrer\">SpringCloud的版本关系</a></h3>\n<p>SpringCloud是一个由许多子项目组成的综合项目，各子项目有不同的发布节奏。 为了管理SpringCloud与各子项目的版本依赖关系，发布了一个清单，其中包括了某个SpringCloud版本对应的子项目版本。 为了避免SpringCloud版本号与子项目版本号混淆，SpringCloud版本采用了名称而非版本号的命名，这些版本的名字采用了伦敦地铁站的名字，根据字母表的顺序来对应版本时间顺序，例如Angel是第一个版本, Brixton是第二个版本。 当SpringCloud的发布内容积累到临界点或者一个重大BUG被解决后，会发布一个&quot;service releases&quot;版本，简称SRX版本，比如Greenwich.SR2就是SpringCloud发布的Greenwich版本的第2个SRX版本。</p>\n<h4 id=\"springcloud和springboot版本对应关系\"> <a href=\"http://www.macrozheng.com/#/cloud/springcloud?id=springcloud%E5%92%8Cspringboot%E7%89%88%E6%9C%AC%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB\" target=\"_blank\" rel=\"noopener noreferrer\">SpringCloud和SpringBoot版本对应关系</a></h4>\n<table>\n<thead>\n<tr>\n<th>SpringCloud Version</th>\n<th>SpringBoot Version</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Hoxton</td>\n<td>2.2.x</td>\n</tr>\n<tr>\n<td>Greenwich</td>\n<td>2.1.x</td>\n</tr>\n<tr>\n<td>Finchley</td>\n<td>2.0.x</td>\n</tr>\n<tr>\n<td>Edgware</td>\n<td>1.5.x</td>\n</tr>\n<tr>\n<td>Dalston</td>\n<td>1.5.x</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"springcloud和springboot关系\"> SpringCloud和SpringBoot关系</h4>\n<ul>\n<li>SpringBoot专注于快速方便的开发单个个体微服务，SpringCloud关注全局的服务治理框架</li>\n<li>SpringCloud是关注全局的微服务协调整理治理框架，它将SpringBoot开发的一个个单体微服务整合并管理起来，为各个微服务之间提供：配置管理，服务发现，断路器，路由，微代理，事件总线，全局锁，决策竞选，分布式会话等集成服务。</li>\n<li>SpringBoot可以离开SpringCloud独立使用，开发项目，但是SpringCloud离不开SpringBoot，属于依赖关系</li>\n</ul>\n<h4 id=\"springcloud和各子项目版本对应关系\"> <a href=\"http://www.macrozheng.com/#/cloud/springcloud?id=springcloud%E5%92%8C%E5%90%84%E5%AD%90%E9%A1%B9%E7%9B%AE%E7%89%88%E6%9C%AC%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB\" target=\"_blank\" rel=\"noopener noreferrer\">SpringCloud和各子项目版本对应关系</a></h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Edgware.SR6</th>\n<th>Greenwich.SR2</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>spring-cloud-bus</td>\n<td>1.3.4.RELEASE</td>\n<td>2.1.2.RELEASE</td>\n</tr>\n<tr>\n<td>spring-cloud-commons</td>\n<td>1.3.6.RELEASE</td>\n<td>2.1.2.RELEASE</td>\n</tr>\n<tr>\n<td>spring-cloud-config</td>\n<td>1.4.7.RELEASE</td>\n<td>2.1.3.RELEASE</td>\n</tr>\n<tr>\n<td>spring-cloud-netflix</td>\n<td>1.4.7.RELEASE</td>\n<td>2.1.2.RELEASE</td>\n</tr>\n<tr>\n<td>spring-cloud-security</td>\n<td>1.2.4.RELEASE</td>\n<td>2.1.3.RELEASE</td>\n</tr>\n<tr>\n<td>spring-cloud-consul</td>\n<td>1.3.6.RELEASE</td>\n<td>2.1.2.RELEASE</td>\n</tr>\n<tr>\n<td>spring-cloud-sleuth</td>\n<td>1.3.6.RELEASE</td>\n<td>2.1.1.RELEASE</td>\n</tr>\n<tr>\n<td>spring-cloud-stream</td>\n<td>Ditmars.SR5</td>\n<td>Fishtown.SR3</td>\n</tr>\n<tr>\n<td>spring-cloud-zookeeper</td>\n<td>1.2.3.RELEASE</td>\n<td>2.1.2.RELEASE</td>\n</tr>\n<tr>\n<td>spring-boot</td>\n<td>1.5.21.RELEASE</td>\n<td>2.1.5.RELEASE</td>\n</tr>\n<tr>\n<td>spring-cloud-task</td>\n<td>1.2.4.RELEASE</td>\n<td>2.1.2.RELEASE</td>\n</tr>\n<tr>\n<td>spring-cloud-gateway</td>\n<td>1.0.3.RELEASE</td>\n<td>2.1.2.RELEASE</td>\n</tr>\n<tr>\n<td>spring-cloud-openfeign</td>\n<td>暂无</td>\n<td>2.1.2.RELEASE</td>\n</tr>\n</tbody>\n</table>\n<p><strong>注意：Greenwich版本是基于SpringBoot 2.1.x版本构建的，不适用于1.5.x版本。随着2019年8月SpringBoot 1.5.x版本停止维护，Edgware版本也将停止维护。</strong></p>\n<h3 id=\"springcloud子项目简介\"> <a href=\"http://www.macrozheng.com/#/cloud/springcloud?id=springcloud%E5%AD%90%E9%A1%B9%E7%9B%AE%E7%AE%80%E4%BB%8B\" target=\"_blank\" rel=\"noopener noreferrer\">SpringCloud子项目简介</a></h3>\n<h4 id=\"spring-cloud-config\"> <a href=\"http://www.macrozheng.com/#/cloud/springcloud?id=spring-cloud-config\" target=\"_blank\" rel=\"noopener noreferrer\">Spring Cloud Config</a></h4>\n<p>集中配置管理工具，分布式系统中统一的外部配置管理，默认使用Git来存储配置，可以支持客户端配置的刷新及加密、解密操作。</p>\n<h4 id=\"spring-cloud-netflix\"> <a href=\"http://www.macrozheng.com/#/cloud/springcloud?id=spring-cloud-netflix\" target=\"_blank\" rel=\"noopener noreferrer\">Spring Cloud Netflix</a></h4>\n<p>Netflix OSS 开源组件集成，包括Eureka、Hystrix、Ribbon、Feign、Zuul等核心组件。</p>\n<ul>\n<li>Eureka：服务治理组件，包括服务端的注册中心和客户端的服务发现机制；</li>\n<li>Ribbon：负载均衡的服务调用组件，具有多种负载均衡调用策略；</li>\n<li>Hystrix：服务容错组件，实现了断路器模式，为依赖服务的出错和延迟提供了容错能力；</li>\n<li>Feign：基于Ribbon和Hystrix的声明式服务调用组件；</li>\n<li>Zuul：API网关组件，对请求提供路由及过滤功能。</li>\n</ul>\n<h4 id=\"spring-cloud-bus\"> <a href=\"http://www.macrozheng.com/#/cloud/springcloud?id=spring-cloud-bus\" target=\"_blank\" rel=\"noopener noreferrer\">Spring Cloud Bus</a></h4>\n<p>用于传播集群状态变化的消息总线，使用轻量级消息代理链接分布式系统中的节点，可以用来动态刷新集群中的服务配置。</p>\n<h4 id=\"spring-cloud-consul\"> <a href=\"http://www.macrozheng.com/#/cloud/springcloud?id=spring-cloud-consul\" target=\"_blank\" rel=\"noopener noreferrer\">Spring Cloud Consul</a></h4>\n<p>基于Hashicorp Consul的服务治理组件。</p>\n<h4 id=\"spring-cloud-security\"> <a href=\"http://www.macrozheng.com/#/cloud/springcloud?id=spring-cloud-security\" target=\"_blank\" rel=\"noopener noreferrer\">Spring Cloud Security</a></h4>\n<p>安全工具包，对Zuul代理中的负载均衡OAuth2客户端及登录认证进行支持。</p>\n<h4 id=\"spring-cloud-sleuth\"> <a href=\"http://www.macrozheng.com/#/cloud/springcloud?id=spring-cloud-sleuth\" target=\"_blank\" rel=\"noopener noreferrer\">Spring Cloud Sleuth</a></h4>\n<p>SpringCloud应用程序的分布式请求链路跟踪，支持使用Zipkin、HTrace和基于日志（例如ELK）的跟踪。</p>\n<h4 id=\"spring-cloud-stream\"> <a href=\"http://www.macrozheng.com/#/cloud/springcloud?id=spring-cloud-stream\" target=\"_blank\" rel=\"noopener noreferrer\">Spring Cloud Stream</a></h4>\n<p>轻量级事件驱动微服务框架，可以使用简单的声明式模型来发送及接收消息，主要实现为Apache Kafka及RabbitMQ。</p>\n<h4 id=\"spring-cloud-task\"> <a href=\"http://www.macrozheng.com/#/cloud/springcloud?id=spring-cloud-task\" target=\"_blank\" rel=\"noopener noreferrer\">Spring Cloud Task</a></h4>\n<p>用于快速构建短暂、有限数据处理任务的微服务框架，用于向应用中添加功能性和非功能性的特性。</p>\n<h4 id=\"spring-cloud-zookeeper\"> <a href=\"http://www.macrozheng.com/#/cloud/springcloud?id=spring-cloud-zookeeper\" target=\"_blank\" rel=\"noopener noreferrer\">Spring Cloud Zookeeper</a></h4>\n<p>基于Apache Zookeeper的服务治理组件。</p>\n<h4 id=\"spring-cloud-gateway\"> <a href=\"http://www.macrozheng.com/#/cloud/springcloud?id=spring-cloud-gateway\" target=\"_blank\" rel=\"noopener noreferrer\">Spring Cloud Gateway</a></h4>\n<p>API网关组件，对请求提供路由及过滤功能。</p>\n<h4 id=\"spring-cloud-openfeign\"> <a href=\"http://www.macrozheng.com/#/cloud/springcloud?id=spring-cloud-openfeign\" target=\"_blank\" rel=\"noopener noreferrer\">Spring Cloud OpenFeign</a></h4>\n<p>基于Ribbon和Hystrix的声明式服务调用组件，可以动态创建基于Spring MVC注解的接口实现用于服务调用，在SpringCloud 2.0中已经取代Feign成为了一等公民。</p>\n<h3 id=\"为什么要选择springcloud\"> 为什么要选择SpringCloud</h3>\n<h4 id=\"_1-选择依据\"> 1.选择依据</h4>\n<ul>\n<li>\n<p>整体解决方案和成熟度</p>\n</li>\n<li>\n<p>社区热度</p>\n</li>\n<li>\n<p>可维护性</p>\n</li>\n<li>\n<p>学习曲线</p>\n</li>\n</ul>\n<h4 id=\"_2-当前各大it公司用的微服务框架有哪些\"> 2.当前各大IT公司用的微服务框架有哪些</h4>\n<ul>\n<li>阿里：Dubbo + HFS</li>\n<li>京东：JSF</li>\n<li>新浪：Motan</li>\n<li>当当网：DubboX</li>\n</ul>\n<h2 id=\"五、什么是dubbo\"> 五、什么是Dubbo</h2>\n<h3 id=\"_1-dubbo简介\"> 1.dubbo简介</h3>\n<blockquote>\n<p>Dubbo是阿里巴巴公司开源的一个高性能优秀的服务框架，使得应用可通过高性能的RPC实现服务的输</p>\n<p>出和输入功能，可以和Spring框架无缝集成。</p>\n<p>Dubbo是一款高性能、轻量级的开源Java RPC框架，它提供了三大核心能力：面向接口的远程方法调</p>\n<p>用，智能容错和负载均衡，以及服务自动注册和发现。</p>\n<p>现已发展成为Apache的顶级孵化开源项目，详见官网：http://dubbo.apache.org/en-us/</p>\n</blockquote>\n<h3 id=\"_2-dubbo组织架构图\"> 2.dubbo组织架构图</h3>\n<p>官网的dubbo组织架构图</p>\n<p><img src=\"./images/Know-SpringCloud/dubbo_architecture.png\" alt=\"dubbo架构\" /></p>\n<p>详细介绍</p>\n<blockquote>\n<ol>\n<li>\n<p>Registry:服务注册与发现中心，作为服务提供者和消费者注册与发现的中心。</p>\n</li>\n<li>\n<p>Provider:服务提供者，在注册中心注册作为服务提供的一方，发布服务到服务注册中心。</p>\n</li>\n<li>\n<p>Consumer:服务消费者，通过注册中心协调，订阅可用的已注册的服务。</p>\n</li>\n<li>\n<p>Container:服务运行容器，独立的容器类似于tomcat/jboss的作用，作为服务运行的容器。</p>\n</li>\n<li>\n<p>Monitor:dubbo的监控中心，用来显示接口暴露、注册情况，也可以看接口的调用明细，调用时</p>\n<p>间等。</p>\n</li>\n</ol>\n</blockquote>\n<h3 id=\"_3-dubbo的优势\"> 3.dubbo的优势</h3>\n<blockquote>\n<ol>\n<li>单一应用架构，当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和 成本。此时，用于简化增删改查工作量的 数据访问框架(ORM)是关键。</li>\n<li>垂直应用架构，当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相 干的几个应用，以提升效率。此时，用于加速前端页面开发的 Web框架(MVC)是关键。</li>\n<li>分布式服务架构，当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立 的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的 分布式服务框架(RPC)是关键。</li>\n<li>流动计算架构当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的 资源 调度和治理中心(SOA)是关键。</li>\n</ol>\n</blockquote>\n<h2 id=\"六、dubbo与springcloud对比\"> 六、Dubbo与SpringCloud对比</h2>\n<table>\n<thead>\n<tr>\n<th>核心要素</th>\n<th>Dubbo</th>\n<th>Spring Cloud</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>服务注册中心</td>\n<td>Zookeeper、Redis、Nacos</td>\n<td>Eureka、Consul、Nacos</td>\n</tr>\n<tr>\n<td>服务调用方式</td>\n<td>RPC</td>\n<td>Restful api(http)</td>\n</tr>\n<tr>\n<td>服务网关</td>\n<td>无</td>\n<td>Zuul、gateway</td>\n</tr>\n<tr>\n<td>断路器</td>\n<td>不完美</td>\n<td>Hystrix</td>\n</tr>\n<tr>\n<td>分布式配置</td>\n<td>无</td>\n<td>Config、Apollo、Nacos、Consul</td>\n</tr>\n<tr>\n<td>分布式追踪系统</td>\n<td>无</td>\n<td>Sleuth</td>\n</tr>\n<tr>\n<td>消息总线</td>\n<td>无</td>\n<td>Bus</td>\n</tr>\n<tr>\n<td>数据流</td>\n<td>无</td>\n<td>Stream基本Redis、Rabbit、Kafka实现消息服务</td>\n</tr>\n<tr>\n<td>指量任务</td>\n<td>无</td>\n<td>Task</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"总结\"> 总结</h3>\n<blockquote>\n<ol>\n<li>\n<p>dubbo由于是二进制的传输，占用带宽会更少</p>\n</li>\n<li>\n<p>springCloud是http协议传输，带宽会比较多，同时使用http协议一般会使用JSON报文，消耗会更</p>\n<p>大</p>\n</li>\n<li>\n<p>dubbo的开发难度较大，原因是dubbo的jar包依赖问题很多大型工程无法解决</p>\n</li>\n<li>\n<p>springcloud的接口协议约定比较自由且松散，需要有强有力的行政措施来限制接口无序升级</p>\n</li>\n<li>\n<p>dubbo的注册中心可以选择zk,redis等多种，springcloud的注册中心只能用eureka或者自研</p>\n</li>\n</ol>\n</blockquote>\n<h2 id=\"七、spring-cloud-alibaba\"> 七、Spring Cloud Alibaba</h2>\n<h3 id=\"_1-springcloud-alibaba简介\"> 1.SpringCloud Alibaba简介</h3>\n<blockquote>\n<p>Spring Cloud Alibaba 致力于提供分布式应用服务开发的一站式解决方案。项目包含开发分布式应用服 务的必需组件，方便开发者通过 Spring Cloud 编程模型轻松使用这些组件来开发分布式应用服务。</p>\n</blockquote>\n<h3 id=\"_2-主要功能\"> 2.主要功能</h3>\n<ol>\n<li>\n<p><strong>服务限流降级</strong>:默认支持 Servlet、Feign、RestTemplate、Dubbo 和 RocketMQ 限流降级功能 的接入，可以在运行时通过控制台实时修改限流降级规则，还支持查看限流降级 Metrics 监控。</p>\n</li>\n<li>\n<p><strong>服务注册与发现</strong>:适配 SpringCloud 服务注册与发现标准，默认集成了 Ribbon的支持。</p>\n</li>\n<li>\n<p><strong>分布式配置管理</strong>:支持分布式系统中的外部化配置，配置更改时自动刷新。</p>\n</li>\n<li>\n<p><strong>消息驱动能力</strong>:基于 SpringCloudStream 为微服务应用构建消息驱动能力。</p>\n</li>\n<li>\n<p><strong>阿里云对象存储</strong>:阿里云提供的海量、安全、低成本、高可靠的云存储服务。支持在任何应用、任</p>\n<p>何时间、任何地点存储和访问任意类型的数据。</p>\n</li>\n<li>\n<p><strong>分布式任务调度</strong>:提供秒级、精准、高可靠、高可用的定时(基于 Cron 表达式)任务调度服务。</p>\n<p>同时提供分布式的任务执行模型，如网格任务。网格任务支持海量子任务均匀分配到所有 Worker(schedulerx-client)上执行。</p>\n</li>\n</ol>\n<h3 id=\"_3-已包括的组件有\"> 3.已包括的组件有</h3>\n<ul>\n<li>\n<p>Sentinel:把流量作为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。</p>\n</li>\n<li>\n<p>Nacos:一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。</p>\n</li>\n<li>\n<p>RocketMQ:一款开源的分布式消息系统，基于高可用分布式集群技术，提供低延时的、高可靠的消息 发布与订阅服务。</p>\n</li>\n<li>\n<p>Dubbo:Apache DubboTM 是一款高性能 Java RPC 框架。</p>\n</li>\n<li>\n<p>Seata:阿里巴巴开源产品，一个易于使用的高性能微服务分布式事务解决方案。</p>\n</li>\n<li>\n<p>Alibaba Cloud ACM:一款在分布式架构环境中对应用配置进行集中管理和推送的应用配置中心产品。</p>\n</li>\n<li>\n<p>Alibaba Cloud OSS: 阿里云对象存储服务(Object Storage Service，简称 OSS)，是阿里云提供的海 量、安全、低成本、高可靠的云存储服务。您可以在任何应用、任何时间、任何地点存储和访问任意类 型的数据。</p>\n</li>\n<li>\n<p>Alibaba Cloud SchedulerX: 阿里中间件团队开发的一款分布式任务调度产品，提供秒级、精准、高可 靠、高可用的定时(基于 Cron 表达式)任务调度服务。</p>\n</li>\n<li>\n<p>Alibaba Cloud SMS: 覆盖全球的短信服务，友好、高效、智能的互联化通讯能力，帮助企业迅速搭建客 户触达通道。</p>\n</li>\n</ul>\n<h3 id=\"_4-与springcloud官方对比\"> 4.与SpringCloud官方对比</h3>\n<p>阿里巴巴提供的方案跟Spring官方提供的方案有一些对应关系:</p>\n<p>Nacos = Eureka/Consule + Config + Admin</p>\n<p>Sentinel = Hystrix + Dashboard + Turbine</p>\n<p>Dubbo = Ribbon + Feign</p>\n<p>RocketMQ = RabbitMQ</p>\n<p>Schedulerx = Quartz</p>\n<p><img src=\"./images/Know-SpringCloud/Compared_with_springcloud_official.png\" alt=\"与springcloud对比\" /></p>\n",
      "date_published": "2020-06-07T17:00:47.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": []
    },
    {
      "title": "SpringSecurity",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/spring/springsecurity/SpringSecurity/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/spring/springsecurity/SpringSecurity/",
      "content_html": "<p>SpringBoot整合SpringSecurity</p>\n",
      "date_published": "2021-01-06T22:55:19.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": []
    },
    {
      "title": "学习路线",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/study-line/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/study-line/",
      "content_html": "<h2 id=\"计算机基础\"> 计算机基础</h2>\n<p>《王道》</p>\n<ul>\n<li>计算机网络</li>\n<li>操作系统</li>\n<li>计算机组成原理</li>\n</ul>\n<h2 id=\"java\"> Java</h2>\n<h3 id=\"java-基础\"> Java-基础</h3>\n<ul>\n<li><a href=\"https://www.bilibili.com/video/BV1Kb411W75N\" target=\"_blank\" rel=\"noopener noreferrer\">尚硅谷</a></li>\n<li>《Java核心技术卷1：基础知识》</li>\n</ul>\n<h3 id=\"java-多线程\"> Java-多线程</h3>\n<ul>\n<li>《尚硅谷》【8】</li>\n<li>《Java多线程编程实战指南：核心篇》</li>\n<li>《Java多线程编程实战指南：设计模式篇》</li>\n<li>《Java多线程核心技术编程》</li>\n</ul>\n<p>知识点</p>\n<ul>\n<li>JUC并发包</li>\n</ul>\n<h3 id=\"java-jvm\"> Java-JVM</h3>\n<ul>\n<li>《深入理解JVM虚拟机》</li>\n</ul>\n<h3 id=\"java-其他\"> Java-其他</h3>\n<p>NIO</p>\n<h3 id=\"设计模式\"> 设计模式</h3>\n<ul>\n<li>《设计模式之禅》</li>\n<li>尚硅谷【6】</li>\n</ul>\n<h3 id=\"jmeter测试工具\"> JMeter测试工具</h3>\n<p><a href=\"https://www.cnblogs.com/stulzq/p/8971531.html\" target=\"_blank\" rel=\"noopener noreferrer\">JMeter测试工具</a></p>\n<h2 id=\"golang\"> Golang</h2>\n<ul>\n<li><input type=\"checkbox\"  disabled=\"disabled\" id=\"task-item-0\"><label for=\"task-item-0\"> Golang基础</label></li>\n</ul>\n<h2 id=\"数据库\"> 数据库</h2>\n<h3 id=\"mysql\"> Mysql</h3>\n<ul>\n<li>Mysql数据库原理</li>\n<li>Mysql优化</li>\n<li>集群部署等</li>\n</ul>\n<h3 id=\"mongodb\"> Mongodb</h3>\n<h3 id=\"postgresql\"> Postgresql</h3>\n<h2 id=\"数据结构与算法\"> 数据结构与算法</h2>\n<h3 id=\"数据结构\"> 数据结构</h3>\n<ul>\n<li>《数据结构C语言版》</li>\n<li>尚硅谷【45】</li>\n</ul>\n<p>leetcode</p>\n<h2 id=\"框架\"> 框架</h2>\n<p>Spring</p>\n<p>SpringBoot</p>\n<p>Mybatis(Plus</p>\n<p>Netty</p>\n<h2 id=\"微服务\"> 微服务</h2>\n<p>SpringCloud</p>\n<p>Dubbo + Zookerper</p>\n<h2 id=\"中间件\"> 中间件</h2>\n<h3 id=\"redis\"> Redis</h3>\n<ul>\n<li>尚硅谷【12】</li>\n<li>Redis设计与实现</li>\n<li>Redis实战</li>\n<li>Redis5源码</li>\n</ul>\n<p>知识点</p>\n<ul>\n<li>Redis6</li>\n<li>底层结构</li>\n<li>分布式锁</li>\n<li>解决方案</li>\n</ul>\n<h3 id=\"docker\"> Docker</h3>\n<ul>\n<li>docker-compose</li>\n</ul>\n<h3 id=\"消息队列\"> 消息队列</h3>\n<p>RocketMQ</p>\n<p>RabbitMQ</p>\n<p>ActiveMQ</p>\n<p>Kafka</p>\n<h3 id=\"elasticsearch\"> ElasticSearch</h3>\n<ul>\n<li>尚硅谷【62】</li>\n<li>实战</li>\n</ul>\n<h3 id=\"k8s\"> K8S</h3>\n<p>kubernetes</p>\n<h2 id=\"编程语言\"> 编程语言</h2>\n<p>Golang</p>\n<p>Python</p>\n<h2 id=\"linux\"> Linux</h2>\n<ul>\n<li>Linux基础，《Linux私房菜》</li>\n<li>ssh</li>\n<li>curl</li>\n</ul>\n<h2 id=\"其他\"> 其他</h2>\n<ul>\n<li><input type=\"checkbox\"  disabled=\"disabled\" id=\"task-item-1\"><label for=\"task-item-1\"> 《clean code》</label></li>\n<li><input type=\"checkbox\" checked=\"checked\" disabled=\"disabled\" id=\"task-item-2\"><label for=\"task-item-2\"> 《Java阿里开发手册》</label></li>\n</ul>\n",
      "date_published": "2022-03-06T10:17:18.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": []
    },
    {
      "title": "组件禁用",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/zh/guide/disable/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/zh/guide/disable/",
      "summary": "<p>你可以通过设置页面的 Frontmatter，在页面禁用一些功能。</p>\n",
      "content_html": "<p>你可以通过设置页面的 Frontmatter，在页面禁用一些功能。</p>\n\n<p>本页面应当禁用了:</p>\n<ul>\n<li>导航栏</li>\n<li>侧边栏</li>\n<li>路径导航</li>\n<li>页面信息</li>\n<li>贡献者</li>\n<li>编辑此页链接</li>\n<li>更新时间</li>\n<li>上一篇/下一篇 链接</li>\n<li>评论</li>\n<li>页脚</li>\n<li>返回顶部按钮</li>\n</ul>\n",
      "date_published": "2022-03-06T10:17:18.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": [
        "使用指南"
      ]
    },
    {
      "title": "密码加密的文章",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/zh/guide/encrypt/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/zh/guide/encrypt/",
      "content_html": "<h1 id=\"密码加密的文章\"> 密码加密的文章</h1>\n<p>实际的文章内容。</p>\n<p>段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字。</p>\n<p>段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字。</p>\n",
      "date_published": "2022-03-06T10:17:18.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": [
        "使用指南"
      ]
    },
    {
      "title": "Markdown 增强",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/zh/guide/markdown/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/zh/guide/markdown/",
      "summary": "<p><code>vuepress-theme-hope</code> 通过内置 <a href=\"https://vuepress-theme-hope.github.io/md-enhance\" target=\"_blank\" rel=\"noopener noreferrer\">md-enhance</a>，在 Markdown 中启用了更多的语法与新功能。</p>\n",
      "content_html": "<p><code>vuepress-theme-hope</code> 通过内置 <a href=\"https://vuepress-theme-hope.github.io/md-enhance\" target=\"_blank\" rel=\"noopener noreferrer\">md-enhance</a>，在 Markdown 中启用了更多的语法与新功能。</p>\n\n<h2 id=\"一键启用\"> 一键启用</h2>\n<p>你可以设置 <code>themeconfig.mdEnhance.enableAll</code> 启用 <a href=\"https://vuepress-theme-hope.github.io/md-enhance\" target=\"_blank\" rel=\"noopener noreferrer\">md-enhance</a> 插件的所有功能。</p>\n<div><div><br><br><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br><br><br></div><pre><code>module<span>.</span>exports <span>=</span> <span>{</span>\n  <span>themeConfig</span><span>:</span> <span>{</span>\n    <span>mdEnhance</span><span>:</span> <span>{</span>\n      <span>enableAll</span><span>:</span> <span>true</span><span>,</span>\n    <span>}</span><span>,</span>\n  <span>}</span><span>,</span>\n<span>}</span><span>;</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id=\"新增的更多语法\"> 新增的更多语法</h2>\n<h3 id=\"上下角标\"> 上下角标</h3>\n<p>19<sup>th</sup> H<sub>2</sub>O</p>\n<details><summary>代码</summary>\n<div><pre><code>19^th^ H<span><span>~</span><span>2</span><span>~</span></span>O\n</code></pre>\n<div><span>1</span><br></div></div></details>\n<ul>\n<li><a href=\"https://vuepress-theme-hope.github.io/zh/guide/markdown/sup-sub/\" target=\"_blank\" rel=\"noopener noreferrer\">点击查看</a></li>\n</ul>\n<h3 id=\"自定义对齐\"> 自定义对齐</h3>\n<div>\n<p>我是居中的</p>\n</div>\n<div>\n<p>我在右对齐</p>\n</div>\n<details><summary>代码</summary>\n<div><pre><code>::: center\n\n我是居中的\n\n:::\n\n::: right\n\n我在右对齐\n\n:::\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div></details>\n<ul>\n<li><a href=\"https://vuepress-theme-hope.github.io/zh/guide/markdown/align/\" target=\"_blank\" rel=\"noopener noreferrer\">点击查看</a></li>\n</ul>\n<h3 id=\"脚注\"> 脚注</h3>\n<p>此文字有脚注<sup></sup>.</p>\n<details><summary>代码</summary>\n<div><pre><code>此文字有脚注[^first].\n\n<span><span>[</span><span>^first</span><span>]</span><span>:</span> 这是脚注内容</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></details>\n<ul>\n<li><a href=\"https://vuepress-theme-hope.github.io/zh/guide/markdown/footnote/\" target=\"_blank\" rel=\"noopener noreferrer\">点击查看</a></li>\n</ul>\n<h3 id=\"标记\"> 标记</h3>\n<p>你可以标记 <mark>重要的内容</mark> 。</p>\n<details><summary>代码</summary>\n<div><pre><code>你可以标记 ==重要的内容== 。\n</code></pre>\n<div><span>1</span><br></div></div></details>\n<ul>\n<li><a href=\"https://vuepress-theme-hope.github.io/zh/guide/markdown/mark/\" target=\"_blank\" rel=\"noopener noreferrer\">点击查看</a></li>\n</ul>\n<h3 id=\"任务列表\"> 任务列表</h3>\n<ul>\n<li><input type=\"checkbox\" checked=\"checked\" disabled=\"disabled\" id=\"task-item-0\"><label for=\"task-item-0\"> 计划 1</label></li>\n<li><input type=\"checkbox\"  disabled=\"disabled\" id=\"task-item-1\"><label for=\"task-item-1\"> 计划 2</label></li>\n</ul>\n<details><summary>Code</summary>\n<div><pre><code><span>-</span> [x] 计划 1\n<span>-</span> [ ] 计划 2\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div></details>\n<ul>\n<li><a href=\"https://vuepress-theme-hope.github.io/guide/markdown/tasklist/\" target=\"_blank\" rel=\"noopener noreferrer\">点击查看</a></li>\n</ul>\n<h3 id=\"流程图\"> 流程图</h3>\n<i>Not supported content</i><details><summary>代码</summary>\n<div><pre><code><span><span>```</span><span>flow</span>\n<span>cond=>condition: Process?\nprocess=>operation: Process\ne=>end: End\n\ncond(yes)->process->e\ncond(no)->e</span>\n<span>```</span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div></details>\n<ul>\n<li><a href=\"https://vuepress-theme-hope.github.io/zh/guide/markdown/flowchart/\" target=\"_blank\" rel=\"noopener noreferrer\">点击查看</a></li>\n</ul>\n<h2 id=\"mermaid\"> Mermaid</h2>\n<Mermaid id=\"mermaid-64a57060\" data-code=\"graph%20TD%3B%0A%20%20%20%20A--%3EB%3B%0A%20%20%20%20A--%3EC%3B%0A%20%20%20%20B--%3ED%3B%0A%20%20%20%20C--%3ED%3B%0A\"></Mermaid><details><summary>代码</summary>\n<div><pre><code><span><span>```</span><span>mermaid</span>\n<span>graph TD;\n    A-->B;\n    A-->C;\n    B-->D;\n    C-->D;</span>\n<span>```</span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div></details>\n<ul>\n<li><a href=\"https://vuepress-theme-hope.github.io/zh/guide/markdown/mermaid/\" target=\"_blank\" rel=\"noopener noreferrer\">点击查看</a></li>\n</ul>\n<h3 id=\"tex-语法\"> Tex 语法</h3>\n<p class='katex-block'><span><span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:2.4em;vertical-align:-0.95em;\"></span><span><span></span><span><span><span><span style=\"height:1.3714em;\"><span style=\"top:-2.314em;\"><span style=\"height:3em;\"></span><span><span style=\"margin-right:0.05556em;\">∂</span><span><span style=\"margin-right:0.03588em;\">ω</span><span><span><span><span style=\"height:0.5904em;\"><span style=\"top:-2.989em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span style=\"margin-right:0.02778em;\">r</span></span></span></span></span></span></span></span></span></span><span style=\"top:-3.23em;\"><span style=\"height:3em;\"></span><span style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span style=\"height:3em;\"></span><span><span><span style=\"margin-right:0.05556em;\">∂</span><span><span><span><span style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span style=\"margin-right:0.02778em;\">r</span></span></span></span></span></span></span></span></span></span></span><span>​</span></span><span><span style=\"height:0.686em;\"><span></span></span></span></span></span><span></span></span><span style=\"margin-right:0.1667em;\"></span><span><span style=\"top:0em;\"><span>(</span></span><span><span></span><span><span><span><span style=\"height:1.3414em;\"><span style=\"top:-2.314em;\"><span style=\"height:3em;\"></span><span><span style=\"margin-right:0.03588em;\">ω</span></span></span><span style=\"top:-3.23em;\"><span style=\"height:3em;\"></span><span style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span style=\"height:3em;\"></span><span><span><span style=\"margin-right:0.03588em;\">y</span><span><span><span><span style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span><span style=\"margin-right:0.03588em;\">ω</span></span></span></span></span></span></span></span></span></span></span></span><span>​</span></span><span><span style=\"height:0.686em;\"><span></span></span></span></span></span><span></span></span><span style=\"top:0em;\"><span>)</span></span></span><span style=\"margin-right:0.2778em;\"></span><span>=</span><span style=\"margin-right:0.2778em;\"></span></span><span><span style=\"height:3.0277em;vertical-align:-1.2777em;\"></span><span><span style=\"top:0em;\"><span>(</span></span><span><span></span><span><span><span><span style=\"height:1.3414em;\"><span style=\"top:-2.314em;\"><span style=\"height:3em;\"></span><span><span style=\"margin-right:0.03588em;\">ω</span></span></span><span style=\"top:-3.23em;\"><span style=\"height:3em;\"></span><span style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span style=\"height:3em;\"></span><span><span><span style=\"margin-right:0.03588em;\">y</span><span><span><span><span style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span><span style=\"margin-right:0.03588em;\">ω</span></span></span></span></span></span></span></span></span></span></span></span><span>​</span></span><span><span style=\"height:0.686em;\"><span></span></span></span></span></span><span></span></span><span style=\"top:0em;\"><span>)</span></span></span><span style=\"margin-right:0.1667em;\"></span><span><span style=\"top:0em;\"><span>{</span></span><span>(</span><span>lo<span style=\"margin-right:0.01389em;\">g</span></span><span style=\"margin-right:0.1667em;\"></span><span style=\"margin-right:0.03588em;\">y</span><span><span>)</span><span><span><span><span style=\"height:0.7144em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span style=\"margin-right:0.02778em;\">r</span></span></span></span></span></span></span></span><span style=\"margin-right:0.2222em;\"></span><span>+</span><span style=\"margin-right:0.2222em;\"></span><span><span><span><span style=\"height:1.6514em;\"><span style=\"top:-1.8723em;margin-left:0em;\"><span style=\"height:3.05em;\"></span><span><span><span>i</span><span>=</span><span>1</span></span></span></span><span style=\"top:-3.05em;\"><span style=\"height:3.05em;\"></span><span><span>∑</span></span></span><span style=\"top:-4.3em;margin-left:0em;\"><span style=\"height:3.05em;\"></span><span><span style=\"margin-right:0.02778em;\">r</span></span></span></span><span>​</span></span><span><span style=\"height:1.2777em;\"><span></span></span></span></span></span><span style=\"margin-right:0.1667em;\"></span><span><span></span><span><span><span><span style=\"height:1.5017em;\"><span style=\"top:-2.314em;\"><span style=\"height:3em;\"></span><span><span><span style=\"margin-right:0.03588em;\">ω</span><span><span><span><span style=\"height:0.7507em;\"><span style=\"top:-2.989em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span>i</span></span></span></span></span></span></span></span></span></span><span style=\"top:-3.23em;\"><span style=\"height:3em;\"></span><span style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span style=\"height:3em;\"></span><span><span>(</span><span>−</span><span>1</span><span><span>)</span><span><span><span><span style=\"height:0.8247em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span>i</span></span></span></span></span></span></span></span><span style=\"margin-right:0.02778em;\">r</span><span style=\"margin-right:0.1667em;\"></span><span>⋯</span><span style=\"margin-right:0.1667em;\"></span><span>(</span><span style=\"margin-right:0.02778em;\">r</span><span style=\"margin-right:0.2222em;\"></span><span>−</span><span style=\"margin-right:0.2222em;\"></span><span>i</span><span style=\"margin-right:0.2222em;\"></span><span>+</span><span style=\"margin-right:0.2222em;\"></span><span>1</span><span>)</span><span>(</span><span>lo<span style=\"margin-right:0.01389em;\">g</span></span><span style=\"margin-right:0.1667em;\"></span><span style=\"margin-right:0.03588em;\">y</span><span><span>)</span><span><span><span><span style=\"height:0.8247em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span><span style=\"margin-right:0.02778em;\">r</span><span>−</span><span>i</span></span></span></span></span></span></span></span></span></span></span></span><span>​</span></span><span><span style=\"height:0.686em;\"><span></span></span></span></span></span><span></span></span><span style=\"top:0em;\"><span>}</span></span></span></span></span></span></span></p>\n<details><summary>代码</summary>\n<div><pre><code>$$\n\\frac {\\partial^r} {\\partial \\omega^r} \\left(\\frac {y^{\\omega}} {\\omega}\\right)\n= \\left(\\frac {y^{\\omega}} {\\omega}\\right) \\left\\{(\\log y)^r + \\sum_{i=1}^r \\frac {(-1)^i r \\cdots (r-i+1) (\\log y)^{r-i}} {\\omega^i} \\right\\}\n$$\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div></details>\n<ul>\n<li><a href=\"https://vuepress-theme-hope.github.io/zh/guide/markdown/tex/\" target=\"_blank\" rel=\"noopener noreferrer\">点击查看</a></li>\n</ul>\n<h3 id=\"代码案例\"> 代码案例</h3>\n\n          <div\n            id=\"code-demo-5ac6bc9f\"\n           \n  \n data-title=\"%E4%B8%80%E4%B8%AA%E6%99%AE%E9%80%9A%20Demo\"\n\n            data-code=\"%7B%22html%22%3A%22%3Ch1%3EMr.Hope%3C%2Fh1%3E%5Cn%3Cp%3E%3Cspan%20id%3D%5C%22very%5C%22%3E%E5%8D%81%E5%88%86%3C%2Fspan%3E%20%E5%B8%85%3C%2Fp%3E%5Cn%22%2C%22js%22%3A%22document.querySelector(%5C%22%23very%5C%22).addEventListener(%5C%22click%5C%22%2C%20()%20%3D%3E%20%7B%5Cn%20%20alert(%5C%22%E5%8D%81%E5%88%86%E5%B8%85%5C%22)%3B%5Cn%7D)%3B%5Cn%22%2C%22css%22%3A%22span%20%7B%5Cn%20%20color%3A%20red%3B%5Cn%7D%5Cn%22%7D\"\n          >\n              \n              <div>\n                <div>\n<div><pre><code><span><span><span>&lt;</span>h1</span><span>></span></span>Mr.Hope<span><span><span>&lt;/</span>h1</span><span>></span></span>\n<span><span><span>&lt;</span>p</span><span>></span></span><span><span><span>&lt;</span>span</span> <span>id</span><span><span>=</span><span>\"</span>very<span>\"</span></span><span>></span></span>十分<span><span><span>&lt;/</span>span</span><span>></span></span> 帅<span><span><span>&lt;/</span>p</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><div><pre><code>document<span>.</span><span>querySelector</span><span>(</span><span>\"#very\"</span><span>)</span><span>.</span><span>addEventListener</span><span>(</span><span>\"click\"</span><span>,</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>\n  <span>alert</span><span>(</span><span>\"十分帅\"</span><span>)</span><span>;</span>\n<span>}</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><div><pre><code><span>span</span> <span>{</span>\n  <span>color</span><span>:</span> red<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div>\n            </div>\n          </div>\n          \n        </div>\n<details><summary>代码</summary>\n<div><pre><code>::: demo 一个普通 Demo\n\n<span><span>```</span><span>html</span>\n<span><span><span><span>&lt;</span>h1</span><span>></span></span>Mr.Hope<span><span><span>&lt;/</span>h1</span><span>></span></span>\n<span><span><span>&lt;</span>p</span><span>></span></span><span><span><span>&lt;</span>span</span> <span>id</span><span><span>=</span><span>\"</span>very<span>\"</span></span><span>></span></span>十分<span><span><span>&lt;/</span>span</span><span>></span></span> 帅<span><span><span>&lt;/</span>p</span><span>></span></span></span>\n<span>```</span></span>\n\n<span><span>```</span><span>js</span>\n<span>document<span>.</span><span>querySelector</span><span>(</span><span>\"#very\"</span><span>)</span><span>.</span><span>addEventListener</span><span>(</span><span>\"click\"</span><span>,</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>\n  <span>alert</span><span>(</span><span>\"十分帅\"</span><span>)</span><span>;</span>\n<span>}</span><span>)</span><span>;</span></span>\n<span>```</span></span>\n\n<span><span>```</span><span>css</span>\n<span><span>span</span> <span>{</span>\n  <span>color</span><span>:</span> red<span>;</span>\n<span>}</span></span>\n<span>```</span></span>\n\n:::\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div></details>\n\n          <div\n            id=\"code-demo-693e1878\"\n           \n  data-type=\"react\"\n data-title=\"%E4%B8%80%E4%B8%AA%20React%20Demo\"\n\n            data-code=\"%7B%22js%22%3A%22export%20default%20class%20App%20extends%20React.Component%20%7B%5Cn%20%20constructor(props)%20%7B%5Cn%20%20%20%20super(props)%3B%5Cn%20%20%20%20this.state%20%3D%20%7B%20message%3A%20%5C%22%E5%8D%81%E5%88%86%E5%B8%85%5C%22%20%7D%3B%5Cn%20%20%7D%5Cn%20%20render()%20%7B%5Cn%20%20%20%20return%20(%5Cn%20%20%20%20%20%20%3Cdiv%20className%3D%5C%22box-react%5C%22%3E%5Cn%20%20%20%20%20%20%20%20Mr.Hope%20%3Cspan%3E%7Bthis.state.message%7D%3C%2Fspan%3E%5Cn%20%20%20%20%20%20%3C%2Fdiv%3E%5Cn%20%20%20%20)%3B%5Cn%20%20%7D%5Cn%7D%5Cn%22%2C%22css%22%3A%22.box-react%20span%20%7B%5Cn%20%20color%3A%20red%3B%5Cn%7D%5Cn%22%7D\"\n          >\n              \n              <div>\n                <div>\n<div><pre><code><span>export</span> <span>default</span> <span>class</span> <span>App</span> <span>extends</span> <span>React<span>.</span>Component</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>props</span><span>)</span> <span>{</span>\n    <span>super</span><span>(</span>props<span>)</span><span>;</span>\n    <span>this</span><span>.</span>state <span>=</span> <span>{</span> <span>message</span><span>:</span> <span>\"十分帅\"</span> <span>}</span><span>;</span>\n  <span>}</span>\n  <span>render</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>(</span>\n      <span>&lt;</span>div className<span>=</span><span>\"box-react\"</span><span>></span>\n        Mr<span>.</span>Hope <span>&lt;</span>span<span>></span><span>{</span><span>this</span><span>.</span>state<span>.</span>message<span>}</span><span>&lt;</span><span>/</span>span<span>></span>\n      <span>&lt;</span><span>/</span>div<span>></span>\n    <span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><div><pre><code><span>.box-react span</span> <span>{</span>\n  <span>color</span><span>:</span> red<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div>\n            </div>\n          </div>\n          \n        </div>\n<details><summary>代码</summary>\n<div><pre><code>::: demo [react] 一个 React Demo\n\n<span><span>```</span><span>js</span>\n<span><span>export</span> <span>default</span> <span>class</span> <span>App</span> <span>extends</span> <span>React<span>.</span>Component</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>props</span><span>)</span> <span>{</span>\n    <span>super</span><span>(</span>props<span>)</span><span>;</span>\n    <span>this</span><span>.</span>state <span>=</span> <span>{</span> <span>message</span><span>:</span> <span>\"十分帅\"</span> <span>}</span><span>;</span>\n  <span>}</span>\n  <span>render</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>(</span>\n      <span>&lt;</span>div className<span>=</span><span>\"box-react\"</span><span>></span>\n        Mr<span>.</span>Hope <span>&lt;</span>span<span>></span><span>{</span><span>this</span><span>.</span>state<span>.</span>message<span>}</span><span>&lt;</span><span>/</span>span<span>></span>\n      <span>&lt;</span><span>/</span>div<span>></span>\n    <span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span></span>\n<span>```</span></span>\n\n<span><span>```</span><span>css</span>\n<span><span>.box-react span</span> <span>{</span>\n  <span>color</span><span>:</span> red<span>;</span>\n<span>}</span></span>\n<span>```</span></span>\n\n:::\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div></details>\n\n          <div\n            id=\"code-demo-2c0b9cdb\"\n           \n  data-type=\"vue\"\n data-title=\"%E4%B8%80%E4%B8%AA%20Vue%20Demo\"\n\n            data-code=\"%7B%22vue%22%3A%22%3Ctemplate%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22box%5C%22%3E%5Cn%20%20%20%20Mr.Hope%20%3Cspan%3E%7B%7B%20message%20%7D%7D%3C%2Fspan%3E%5Cn%20%20%3C%2Fdiv%3E%5Cn%3C%2Ftemplate%3E%5Cn%3Cscript%3E%5Cnexport%20default%20%7B%5Cn%20%20data%3A%20()%20%3D%3E%20(%7B%20message%3A%20%5C%22%E5%8D%81%E5%88%86%E5%B8%85%5C%22%20%7D)%2C%5Cn%7D%3B%5Cn%3C%2Fscript%3E%5Cn%3Cstyle%3E%5Cn.box%20span%20%7B%5Cn%20%20color%3A%20red%3B%5Cn%7D%5Cn%3C%2Fstyle%3E%5Cn%22%7D\"\n          >\n              \n              <div>\n                <div>\n<div><pre><code><span><span><span>&lt;</span>template</span><span>></span></span>\n  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>\"</span>box<span>\"</span></span><span>></span></span>\n    Mr.Hope <span><span><span>&lt;</span>span</span><span>></span></span>{{ message }}<span><span><span>&lt;/</span>span</span><span>></span></span>\n  <span><span><span>&lt;/</span>div</span><span>></span></span>\n<span><span><span>&lt;/</span>template</span><span>></span></span>\n<span><span><span>&lt;</span>script</span><span>></span></span><span><span>\n<span>export</span> <span>default</span> <span>{</span>\n  <span>data</span><span>:</span> <span>(</span><span>)</span> <span>=></span> <span>(</span><span>{</span> <span>message</span><span>:</span> <span>\"十分帅\"</span> <span>}</span><span>)</span><span>,</span>\n<span>}</span><span>;</span>\n</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>\n<span><span><span>&lt;</span>style</span><span>></span></span><span><span>\n<span>.box span</span> <span>{</span>\n  <span>color</span><span>:</span> red<span>;</span>\n<span>}</span>\n</span></span><span><span><span>&lt;/</span>style</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div>\n            </div>\n          </div>\n          \n        </div>\n<details><summary>代码</summary>\n<div><pre><code>::: demo [vue] 一个 Vue Demo\n\n<span><span>```</span><span>vue</span>\n<span>&lt;template>\n  &lt;div>\n    Mr.Hope &lt;span>{{ message }}&lt;/span>\n  &lt;/div>\n&lt;/template>\n&lt;script>\nexport default {\n  data: () => ({ message: \"十分帅\" }),\n};\n&lt;/script>\n&lt;style>\n.box span {\n  color: red;\n}\n&lt;/style></span>\n<span>```</span></span>\n\n:::\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div></details>\n\n          <div\n            id=\"code-demo-2869b0e2\"\n           \n  \n data-title=\"%E4%B8%80%E4%B8%AA%E6%99%AE%E9%80%9A%20Demo\"\n\n            data-code=\"%7B%22md%22%3A%22%23%20%E6%A0%87%E9%A2%98%5Cn%5Cn%E5%8D%81%E5%88%86%E5%B8%85%5Cn%22%2C%22ts%22%3A%22const%20message%3A%20string%20%3D%20%5C%22Mr.Hope%5C%22%3B%5Cn%5Cndocument.querySelector(%5C%22h1%5C%22).innerHTML%20%3D%20message%3B%5Cn%22%2C%22scss%22%3A%22h1%20%7B%5Cn%20%20font-style%3A%20italic%3B%5Cn%5Cn%20%20%2B%20p%20%7B%5Cn%20%20%20%20color%3A%20red%3B%5Cn%20%20%7D%5Cn%7D%5Cn%22%7D\"\n          >\n              \n              <div>\n                <div>\n<div><pre><code><span><span>#</span> 标题</span>\n\n十分帅\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><div><pre><code><span>const</span> message<span>:</span> <span>string</span> <span>=</span> <span>\"Mr.Hope\"</span><span>;</span>\n\ndocument<span>.</span><span>querySelector</span><span>(</span><span>\"h1\"</span><span>)</span><span>.</span>innerHTML <span>=</span> message<span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><div><pre><code><span>h1 </span><span>{</span>\n  <span>font-style</span><span>:</span> italic<span>;</span>\n\n  <span>+ p </span><span>{</span>\n    <span>color</span><span>:</span> red<span>;</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div>\n            </div>\n          </div>\n          \n        </div>\n<details><summary>代码</summary>\n<div><pre><code>::: demo 一个普通 Demo\n\n<span><span>```</span><span>md</span>\n<span><span><span>#</span> 标题</span>\n\n十分帅</span>\n<span>```</span></span>\n\n<span><span>```</span><span>ts</span>\n<span><span>const</span> message<span>:</span> <span>string</span> <span>=</span> <span>\"Mr.Hope\"</span><span>;</span>\n\ndocument<span>.</span><span>querySelector</span><span>(</span><span>\"h1\"</span><span>)</span><span>.</span>innerHTML <span>=</span> message<span>;</span></span>\n<span>```</span></span>\n\n<span><span>```</span><span>scss</span>\n<span><span>h1 </span><span>{</span>\n  <span>font-style</span><span>:</span> italic<span>;</span>\n\n  <span>+ p </span><span>{</span>\n    <span>color</span><span>:</span> red<span>;</span>\n  <span>}</span>\n<span>}</span></span>\n<span>```</span></span>\n\n:::\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div></details>\n<ul>\n<li><a href=\"https://vuepress-theme-hope.github.io/zh/guide/markdown/demo/\" target=\"_blank\" rel=\"noopener noreferrer\">点击查看</a></li>\n</ul>\n<h3 id=\"幻灯片\"> 幻灯片</h3>\n<i>Not supported content</i><details><summary>代码</summary>\n<div><pre><code>@slidestart\n\n<span><span>##</span> 幻灯片 1</span>\n\n一个有文字和 <span>[<span>链接</span>](<span>https://mrhope.site</span>)</span> 的段落\n\n<span>---</span>\n\n<span><span>##</span> 幻灯片 2</span>\n\n<span>-</span> 列表 1\n<span>-</span> 列表 2\n\n<span>---</span>\n\n<span><span>##</span> 幻灯片 3.1</span>\n\n<span><span>```</span><span>js</span>\n<span><span>const</span> a <span>=</span> <span>1</span><span>;</span></span>\n<span>```</span></span>\n\n--\n\n<span><span>##</span> 幻灯片 3.2</span>\n\n$$\nJ(\\theta_0,\\theta_1) = \\sum_{i=0}\n$$\n\n@slideend\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div></details>\n<ul>\n<li><a href=\"https://vuepress-theme-hope.github.io/zh/guide/markdown/presentation/\" target=\"_blank\" rel=\"noopener noreferrer\">点击查看</a></li>\n</ul>\n<h2 id=\"其他语法\"> 其他语法</h2>\n<div><p>自定义标题</p>\n<p>信息容器</p>\n</div>\n<div><p>自定义标题</p>\n<p>提示容器</p>\n</div>\n<div><p>自定义标题</p>\n<p>警告容器</p>\n</div>\n<div><p>自定义标题</p>\n<p>危险容器</p>\n</div>\n<details><summary>自定义标题</summary>\n<p>详情容器</p>\n</details>\n<details><summary>代码</summary>\n<div><pre><code>::: info 自定义标题\n\n信息容器\n\n:::\n\n::: tip 自定义标题\n\n提示容器\n\n:::\n\n::: warning 自定义标题\n\n警告容器\n\n:::\n\n::: danger 自定义标题\n\n危险容器\n\n:::\n\n::: details 自定义标题\n\n详情容器\n\n:::\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div></details>\n<hr>\n<section>\n<ol>\n<li id=\"footnote1\"><p>这是脚注内容 </p>\n</li>\n</ol>\n</section>\n",
      "date_published": "2022-03-06T10:17:18.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": [
        "使用指南"
      ]
    },
    {
      "title": "页面配置",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/zh/guide/page/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/zh/guide/page/",
      "content_html": "<h2 id=\"页面信息\"> 页面信息</h2>\n<p>你可以在 Markdown 的 Frontmatter 中设置页面信息。</p>\n<ul>\n<li>\n<p>作者设置为 Ms.Hope。</p>\n</li>\n<li>\n<p>写作时间应为 2020 年 1 月 1 日</p>\n</li>\n<li>\n<p>分类为 “使用指南”</p>\n</li>\n<li>\n<p>标签为 “页面配置” 和 “使用指南”</p>\n</li>\n</ul>\n<h2 id=\"页面内容\"> 页面内容</h2>\n<p>你可以自由在这里书写你的 Markdown。</p>\n<div><p>Tips</p>\n<ul>\n<li>\n<p>Markdown 文件夹的图片请使用相对链接 <code>./</code> 进行引用。</p>\n</li>\n<li>\n<p><code>.vuepress/public</code> 文件夹的图片，请使用绝对链接 <code>/</code> 进行引用</p>\n</li>\n</ul>\n</div>\n<p>主题包含了一个自定义徽章章可以使用:</p>\n<blockquote>\n<p>文字结尾应该有深蓝色的 徽章文字 徽章。 <i>Not supported content</i></p>\n</blockquote>\n<h2 id=\"页面结构\"> 页面结构</h2>\n<p>此页面应当包含：</p>\n<ul>\n<li>返回顶部按钮</li>\n<li>路径导航</li>\n<li>评论</li>\n<li>页脚</li>\n</ul>\n",
      "date_published": "2020-01-01T00:00:00.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Ms.Hope"
        }
      ],
      "tags": [
        "使用指南"
      ]
    },
    {
      "title": "主要功能与配置演示",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/zh/guide/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/zh/guide/",
      "content_html": "<h1 id=\"主要功能与配置演示\"> 主要功能与配置演示</h1>\n<ul>\n<li>\n<p><a href=\"./page.html\">页面展示</a></p>\n</li>\n<li>\n<p><a href=\"./markdown.html\">Markdown 展示</a></p>\n</li>\n<li>\n<p><a href=\"./disable.html\">禁用展示</a></p>\n</li>\n<li>\n<p><a href=\"./encrypt.html\">加密展示</a></p>\n</li>\n</ul>\n",
      "date_published": "2022-03-06T10:17:18.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": [
        "使用指南"
      ]
    },
    {
      "title": "项目主页",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/zh/home/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/zh/home/",
      "content_html": "<p>这是普通主页的案例。你可以在这里放置你的主体内容。</p>\n<p>想要使用此布局，你需要在页面 front matter 中设置 <code>home: true</code>。</p>\n<p>配置项的相关说明详见 <a href=\"https://vuepress-theme-hope.github.io/zh/guide/layout/home/\" target=\"_blank\" rel=\"noopener noreferrer\">项目主页配置</a>。</p>\n",
      "date_published": "2022-03-06T10:17:18.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": []
    },
    {
      "title": "幻灯片页",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/zh/slides/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/zh/slides/",
      "content_html": "\n<i>Not supported content</i>",
      "image": "https://vuepress-theme-hope-demo.mrhope.site/logo.svg",
      "date_published": "2022-03-06T10:17:18.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": []
    },
    {
      "title": "Blog Home",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/zh/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/zh/",
      "content_html": "",
      "date_published": "2022-03-06T10:17:18.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": []
    },
    {
      "title": "My Project",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/zh/project/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/zh/project/",
      "content_html": "",
      "date_published": "2022-03-06T10:17:18.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": []
    },
    {
      "title": "自定义布局",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/zh/layout/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/zh/layout/",
      "content_html": "<p>您可以使用带有 Markdown 支持的插槽来自定义页面布局。</p>\n<div><p>Note</p>\n<p>此处仅仅是一个演示，你应该自行根据需求添加样式。</p>\n\n\n</div>\n<template #page-top><p>页面顶部内容</p>\n</template><template #page-bottom><p>页面底部内容</p>\n</template><template #content-top><p>内容顶部内容</p>\n</template><template #content-bottom><p>内容底部内容</p>\n</template><template #navbar-start><p>导航栏起始内容</p>\n</template><template #navbar-center><p>导航栏中部内容</p>\n</template><template #navbar-end><p>导航栏末尾内容</p>\n</template><template #sidebar-top><p>侧边栏顶部内容</p>\n</template><template #sidebar-center><p>侧边栏中部内容</p>\n</template><template #sidebar-bottom><p>侧边栏底部内容</p>\n</template><p>更多详情，详见 <a href=\"https://vuepress-theme-hope.github.io/zh/guide/layout/custom/\" target=\"_blank\" rel=\"noopener noreferrer\">自定义布局</a>.</p>\n",
      "date_published": "2022-03-06T10:17:18.000Z",
      "date_modified": "2022-03-06T10:17:18.000Z",
      "authors": [
        {
          "name": "Draco"
        }
      ],
      "tags": []
    }
  ]
}