---
icon: 
title: Java多线程-2
author: Draco
time: 2021-08-04 21:18:29
description: 
image: 
categories: 
  - Java
tags: 
  - 学习笔记
  - Java
  - 多线程


---



## Java线程同步机制



### 同步机制简介

对于同一个个许可证所保护的共享数据而言，任何线程访问这些共享数据前必须先持有该许可证。

- 一个线程只有在持有许可证的情况下才能够对这些共享数据进行访问；
- 一个许可证一 一次只能够被个线程持有；
- 许可证的持有线程在其结束对这些共享数据的访问后必须让出（释放） 其持有的许可证， 以便其他线程能够对这些共享数据进行访问。

一个线程在访间共享数据前必须申请相应的锁（许可证）， 线程的这个动作被称为锁的获得 (Acquire)。一个线程获得某个锁（持有许可证），我们就称该线程为相应锁的持 有线程（线程持有许可证），一个锁一次只能被一个线程持有。锁的持有线程可以对该锁所保护的共享数据进行访问，访问结束后该线程必须释放 (Release) 相应的锁。锁的持有 线程在其获得锁之后和 释放锁之前这段时间内所执行的代码被称为临界区 (Critical Section)。因此，共享数据只允许在临界区内进行访问，临界区一次只能被一个线程执行。



### 临界区

锁的持有线程在获得锁之后和释放锁之前这段时间内所执行的代码被称为临界区。共享数据只能在临界区内进行访问，临界区一次只能被一个线程执行。



### 锁简介

锁具有``排他性``，一次只能被一个线程持有，被称为``排它锁``或``互斥锁``。

按照虚拟机对锁的实现划分，分为

- 内部锁（Intrinsic Lock）：非公平锁，例如`sychronized`
- 显示锁（Explicit Lock）支持``非公平锁``和``公平锁``，例如JUC包下的`Lock`等实现类`ReentrenLock`



![互斥锁示意图](https://blog-1300186248.cos.ap-shanghai.myqcloud.com/Java-MultiThread-2/%E4%BA%92%E6%96%A5%E9%94%81%E7%A4%BA%E6%84%8F%E5%9B%BE.png)





## 锁的概念



### 可重入性

一个线程在持有一个锁的时候还能够继续成功申请该锁，就称该锁具有可重入性，反之则称为非可重入性。

```java
void methodA() { 
  acquireLock(lock);／／申请锁lock
  ／／省略其他代码
  methodB(); 
  releaseLock(lock);／／释放锁lock
}

void methodB() { 
  acquireLock(lock);／／申请锁lock
  releaseLock(lock);／／释放锁lock
}
```

方法methodA使用了锁lock，该锁引导的临界区代码又调用了另外一个方法methodB,而方法methodB也使用了lock。那么， 这就产生了一个问题：methodA的执行线程持有锁 lock 的时候调用了methodB, 而methodB执行的时候又去申请锁lock, 而lock此时正被当前线程持有（未被释放）。那么，此时methodB究竟能否获得（申请成功） lock呢？可重入性就描述了这样一个问题。



#### 实现原理

可重入锁可以被理解为一个对象，该对象包含一个``计数器属性``。计数器属性的初始值为 0, 表示相应的锁还没有被任何线程持有。 

- 每次线程获得一个可重入锁的时候， 该锁的 计数器值会被增加1。 
- 每次一个线程释放锁的时候， 该锁的计数器属性值就会被减1。 

可重入锁的持有线程初次获得该锁时相应的开销相对大，这是因为该锁的持有线程必须与其他线程 ”竞争” 以获得锁。 

可重入锁的持有线程继续荻得相应锁所产生的开销要小得 多，这是因为此时Java虚拟机只需要将相应锁的计数器属性值增加1即可以实现锁的获得。



### 锁的粒度

一个锁实例可以保护一个或者多个共享数据，一个实例所保护的共享数据的数量大小就被称为该锁的粒度，锁保护的共享数据越大，我们就称该锁的粒度越粗，反之则称粒度细。



## 锁的开销



- 锁的申请和释放所产生的开销（主要是时间开销）
- 锁的上下文切换（主要是时间开销）：锁作为一种排他性资源，一旦被争用就可能导致上下文切换，而没有被争用的锁则可能不会导致上下文切换
- 锁泄露
- 死锁锁死活锁饿死等线程其他活性故障。



### 锁泄露

锁泄露指一个线程获得该锁之后，由于程序的错误、缺陷导致该锁一直无法被释放而其他线程一直无法获得该锁的现象。因此，锁泄露会导致同步在该锁上的所有线程都无法进展。





## Sychronized（内部锁）



### 参考

- [关键字: synchronized详解](https://www.pdai.tech/md/java/thread/java-thread-x-key-synchronized.html)
- [jvm：ObjectMonitor源码](https://blog.csdn.net/zwjyyy1203/article/details/106217887)
- [Java并发基石——所谓“阻塞”：Object Monitor和AQS（1）](https://blog.csdn.net/yinwenjie/article/details/84922958)





### 简介

Java平台中的任何一个对象都有唯一一个与之关联的锁。 这种锁被称为``监视器 (Monitor)``或者``内部锁 (Intrinsic Lock)``。内部锁是一种``排他锁``，它能够保障

- 原子性
- 可见性
- 有序性

内部锁是通过 synchronized 关键字实现的。



### 使用方法

- synchronized修饰的实例方法：多线程并发访问时，只能有一个线程进入，获得``对象内置锁``，其他线程阻塞等待，但在此期间线程仍然可以访问其他方法。
- synchronized修饰的静态方法：多线程并发访问时，只能有一个线程进入，获得``类锁``，其他线程阻塞等待，但在此期间线程仍然可以访问其他方法。
- synchronized修饰的代码块，：多线程并发访问时，只能有一个线程进入，根据``括号中的对象或者是类``，获得相应的对象内置锁或者是类锁
- 同步方法的整个方法体就是一个临界区。



> 每个类都有一个类锁，类的每个对象也有一个内置锁，它们是互不干扰的，也就是说一个线程可以同时获得``类锁``和该类实例化``对象的内置锁``，当线程访问非synchronzied修饰的方法时，并不需要获得锁，因此不会产生阻塞。



```java
Synchronized(锁句柄){
    //在此代码块访问共享数据
}
```

synchronized关键字所引导的代码块就是临界区 。锁句柄是一个对象的引用（或者能够返回对象的表达式）。例如，锁句柄可以填写为this 关键字（表示当前对象）。

习惯上我们也直接称锁句柄为锁。锁句柄对应的监视器就被称为相应同步块的引导锁。相应地， 我们称呼相应的同步块为该锁引导的同步块。

> 锁句柄通常采用final修饰（private final）。这是因为锁句柄的值一旦改变，会导致同一个代码块的多个线程实际上使用不同的锁，而导致竞态。



### 同步静态方法

```java
public class SynchronizedMethodExample {
    public static sysnchronized void staticMethod(){
        //在此访问共享数据
    }
    //...
}

//相当于
public class SynchronizedMethodExample {
    public static void staticMethod(){
        sysnchronized(SynchronizedMethodExample.class){
             //在此访问共享数据
        }
    }
    //...
}
```

线程在执行临界区代码的时候必须持有该临界区的``引导锁``。一个线程执行到同步代码块必须申请该同步块的引导锁，只有申请成功该锁的线程才能够执行相的应临界区。

一旦执行完临界区代码，引导该临界区的锁就会被自动释放。整个内部锁申请和释放的过程都是由``java虚拟机``负责实施的，所以synchronized实现的锁被称为``内部锁``。

**内部锁不会导致锁泄露**，java编译器在将同步代码块编译成字节码的时候，对临界区可能抛出的异常（未被捕获）进行了处理，所以即使临界区代码抛出异常也不会妨碍内部锁的释放。





### 内部锁的调度

概念

- 监控区（Entry Set）：锁已被其他线程获取，期待获取锁的线程就进入Monitor对象的监控区
- 待授权区（Wait Set）：曾经获取到锁，但是调用了wait方法，线程进入待授权区



Java虚拟机会为每个内部锁分配一个``入口集(Entry List)``， 用于记录等待获得相应内部锁的线程。

多个线程申请同一个锁的时候，只有一个申请者能够成为该锁的持有线程（即申请锁的操作成功）， 而其他申请者的申请操作会失败。 这些申请失败的线程并不会抛出异常， 而是会被暂停（生命周期状态变为`BLOCKED`) 并被存入相应锁的入口集中等待再次申请锁的机会。 

入口集中的线程就被称为相应内部锁的等待线程。当这些线程申请的锁被其持有线程释放的时候， **该锁的入口集中的一个任意线程会被Java虚拟机唤醒**， 从而得到再次申请锁的机会。 

由于Java虚拟机对内部锁的调度``仅支持非公平调度``， 被唤醒的等待线程占用处理器运行时可能还有其他新的活跃线程 （处于 RUNNABLE状态，且未进入过入口集）与该线程抢占这个被释放锁， 因此被唤醒的线程不一定就能成为该锁的持有 线程。

另外，Java虚拟机如何从一个锁的入口集中选择一个等待线程，作为下一个可以参与再次申请相应锁的线程，这个细节与Java虚拟机的具体实现有关：这个被选中的线程有可能是入口集中等待时间最长的线程， 也可能是等待时间最短的线程，或者完全是随机。



![img](https://blog-1300186248.cos.ap-shanghai.myqcloud.com/Java-MultiThread-2/%E5%86%85%E9%83%A8%E9%94%81%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%9B%BE.png)









## Lock接口（显示锁）

jdk1.5引入的排他锁，其作用于内部锁相同， 但是它提供了一些内部锁所不具备的特性。显示锁是`java.util.concurrent.locks.Lock`接口的实例，`java.util.concurrent.locks.Lock`是它的默认实现类



### 常用方法

|                          |                                      |
| ------------------------ | ------------------------------------ |
| void lock()              | 获取锁                               |
| void lockInterruptibly() | 如果当前线程未被中断，则获取锁       |
| newCondition()           | 返回绑定到此Lock实例的新Conditon实例 |
|                          |                                      |
|                          |                                      |
|                          |                                      |

void lock() 获取锁
void lockInterruptibly() 如果当前线程未被中断，则获取锁
newCondition() 返回绑定到此Lock实例的新Conditon实例
tryLock() 仅在调试时锁为空闲状态才获取锁
tryLock(long time, TimeUnit uinit) 如果说在给定的时间空闲，并且当前线程未被中断，则获取锁
unlock() 释放锁
