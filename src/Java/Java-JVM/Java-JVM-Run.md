---
icon: 
title: JVM-运行时数据区
author: LifeAlsoIsGG
time: 2021-05-12 15:59:28
description: 
original: true
image: 
categories: 
  - Java
tags: 
  - 学习笔记
  - Java
  - JVM
---



## 参考

::: tips

- https://juejin.cn/post/6844904096059621390

:::



## 内存分区与线程



内存是非常重要的系统资源，是硬盘和cpu的中间仓库及桥梁，承载着操作系统和应用程序的实时运行。JVM内存布局规定了JAVA在运行过程中内存申请、分配、管理的策略，保证了JVM的高效稳定运行。**不同的jvm对于内存的划分方式和管理机制存在着部分差异**（对于Hotspot主要指方法区）



![jdk8以后 ，方法区就是元数据区](https://user-gold-cdn.xitu.io/2020/3/18/170ecae266df65ba?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

（图源阿里）JDK8的元数据区+JIT编译产物 就是JDK8以前的方法区





![JVM组成图2](D:/repository/static-blog/src/Java/Java-JVM/images/Java-JVM/JVM_composition_diagram_2.jpg)



### 线程共享/私有

- 线程共享：堆，方法区
- 线程私有：程序计数器，虚拟机栈，本地方法栈





### 方法区 | 永久代 | 元空间



> 《Java虚拟机规范》只是规定了有⽅法区这么个概念和它的作⽤，并没有规定如何去实现它。那 么，在不同的 JVM 上⽅法区的实现肯定是不同的了。 ⽅法区和永久代的关系很像Java中接⼝和类 的关系，类实现了接⼝，⽽永久代就是HotSpot虚拟机对虚拟机规范中⽅法区的⼀种实现⽅式。 也 就是说，永久代是HotSpot的概念，⽅法区是Java虚拟机规范中的定义，是⼀种规范，⽽永久代是⼀ 种实现，⼀个是标准⼀个是实现，其他的虚拟机实现并没有永久带这⼀说法。
>
> 
>
> 目前实现方法区的方式是元空间（Meta Space）



- 在**JDK1.7之前**：永久代

  > 运行时常量池逻辑包含字符串常量池存放在方法区, 此时hotspot虚拟机对方法区的实现为**永久代**

  

- 在**JDK1.7**：永久代和堆

  > 字符串常量池被从方法区拿到了**堆**中, 这里没有提到运行时常量池,也就是说**字符串常量池**被单独拿到**堆**,**运行时常量池剩下的东西**还在**方法区**, 也就是hotspot中的**永久代**

  

- 在**JDK1.8**： 元空间和堆

  > hotspot移除了**永久代**用**元空间(Metaspace)**取而代之, 这时候**字符串常量池还在堆**, **运行时常量池还在方法区**, 只不过方法区的实现从永久代变成了元空间(Metaspace) ，元空间并不在虚拟机中，而是在本地内存(Direct Memory)



#### 为什么要将永久代(PermGen)替换为元空间(MetaSpace)呢?

整个永久代有⼀个 JVM 本身设置固定⼤⼩上线，⽆法进⾏调整，⽽元空间使⽤的是直接内存，受本机 可⽤内存的限制，并且永远不会得到`java.lang.OutOfMemoryError`。你可以使⽤ -XX： MaxMetaspaceSize 标志设置最⼤元空间⼤⼩，默认值为 unlimited，这意味着它只受系统内存的限 制。 -XX：MetaspaceSize 调整标志定义元空间的初始⼤⼩如果未指定此标志，则 Metaspace 将根 据运⾏时的应⽤程序需求动态地重新调整⼤⼩。 当然这只是其中⼀个原因，还有很多底层的原因，这⾥就不提了。





### 线程

- 线程是一个程序里的运行单元，JVM允许一个程序有多个线程并行的执行；
- 在HotSpot JVM，每个线程都与操作系统的本地线程直接映射。
  - 当一个java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。java线程执行终止后。本地线程也会回收。
- 操作系统负责所有线程的安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，它就会调用java线程中的run（）方法.



#### JVM系统线程

- 如果你使用jconsole或者任何一个调试工具，都能看到在后台有许多线程在运行。这些后台线程不包括调用main方法的main线程以及所有这个main线程自己创建的线程；
- 这些主要的后台系统线程在HotSpot JVM里主要是以下几个：
  - **虚拟机线程**：这种线程的操作时需要JVM达到安全点才会出现。这些操作必须在不同的线程中发生的原因是他们都需要JVM达到安全点，这样堆才不会变化。这种线程的执行包括“stop-the-world”的垃圾收集，线程栈收集，线程挂起以及偏向锁撤销
  - **周期任务线程**：这种线程是时间周期事件的提现（比如中断），他们一般用于周期性操作的调度执行。
  - **GC线程**：这种线程对于JVM里不同种类的垃圾收集行为提供了支持
  - **编译线程**：这种线程在运行时会降字节码编译成本地代码
  - **信号调度线程**：这种线程接收信号并发送给JVM,在它内部通过调用适当的方法进行处理。





## 程序计数器（线程私有）

JVM中的程序计数寄存器（Program Counter Register）中，Register的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。CPU只有把数据装载到寄存器才能够运行。JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟。

PC寄存器是用来存储`指向下一条指令的地址`，也即将将要执行的指令代码，`字节码解释器`工作时修改PC寄存器中的值，由`执行引擎`从里面读取下一条指令。



![img](https://user-gold-cdn.xitu.io/2020/3/18/170ecaecbef6c19d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



### 特点

- 它是一块很小的内存空间，几乎可以忽略不计。也是运行速度最快的存储区域
- 在jvm规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致
- 任何时间一个线程都只有一个方法在执行，也就是所谓的**当前方法**。程序计数器会存储当前线程正在执行的java方法的JVM指令地址；或者，如果实在执行native方法，则是未指定值（undefined）。
- 字节码解释器工作时就是通过改变这个计数器的值来选取吓一跳需要执行的字节码指令
- 它是唯一一个在java虚拟机规范中没有规定任何`OOM`情况的区域



### 作用

- 字节码解释器通过改变程序计数器来依次读取指令，从⽽实现代码的流程控制，如：顺序执⾏、 选择、循环、异常处理。 
- 在多线程的情况下，**程序计数器⽤于记录当前线程执⾏的位置**，从⽽当线程被切换回来的时候能 够知道该线程上次运⾏到哪⼉了。




### 代码示例

利用`javap -v xxx.class`反编译字节码文件，查看指令等信息



![img](https://user-gold-cdn.xitu.io/2020/3/18/170ecaef254ef627?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)





### PC寄存器为什么线程私有

我们都知道所谓的多线程在一个特定的时间段内指回执行其中某一个线程的方法，CPU会不停滴做任务切换，这样必然会导致经常中断或恢复，如何保证分毫无差呢？**为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器,**这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。

由于CPU时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。

这样必然导致经常中断或恢复，如何保证分毫无差呢？每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。



### CPU时间片

CPU时间片即CPU分配各各个程序的时间，每个线程被分配一个时间段。称作它的时间片。
在宏观上：我们可以同时打开多个应用程序，每个程序并行不悖，同时运行。 但在微观上：由于只有一个CPU，一次只能处理程序要求的一部分，如何处理公平，一种方法就是引入时间片，每个程序轮流执行。





## 虚拟机栈（线程私有）



### 介绍

由于跨平台性的设计，java的指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的。
**优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。**



与程序计数器⼀样，Java虚拟机栈也是线程私有的，它的⽣命周期和线程相同，描述的是 Java ⽅法执行的内存模型，每次⽅法调⽤的数据都是通过栈传递的。 

Java 内存可以粗糙的区分为堆内存（Heap）和栈内存(Stack),其中栈就是现在说的虚拟机栈，或者说 是虚拟机栈中局部变量表部分。 （实际上，Java虚拟机栈是由⼀个个**栈帧**组成，⽽每个栈帧中都拥 有：**局部变量表、操作数栈、动态链接、⽅法出⼝信息。**）



无论是本地方法栈，还是虚拟机栈，都是线程私有的，当一个线程启动的时候，jvm就会给这个线程分配一个栈，然后每当你调用一个方法的时候，jvm就会往这个栈压入一个栈帧，方法调用完毕，栈帧出栈。注意，一个栈能容纳的栈帧是固定的，有默认的值，当然你也可以通过-Xss去调。但这个栈里面的引用所指向堆内存空间是可以扩展的。简而言之，一个栈的栈帧数目是确定的，而与该栈相关联的堆内存是可以动态扩展的，这些是前提。



局部变量表主要存放了编译器可知的各种数据类型（boolean、byte、char、short、int、float、 long、double）、对象引⽤（reference类型，它不同于对象本身，可能是⼀个指向对象起始地址的引 ⽤指针，也可能是指向⼀个代表对象的句柄或其他与此对象相关的位置）。 





### 特点

- 栈是一种快速有效的分配存储方式，访问速度仅次于PC寄存器（程序计数器）
- JVM直接对java栈的操作只有两个
  - 每个方法执行，伴随着进栈（入栈，压栈）
  - 执行结束后的出栈工作
- 对于栈来说不存在垃圾回收问题



### 出现的异常



java虚拟机规范允许**Java栈的大小是动态的或者是固定不变的**

Java 虚拟机栈会出现两种异常：`StackOverFlowError` 和 `OutOfMemoryError`。

> - **StackOverFlowError**： 若Java虚拟机栈的内存⼤⼩`不允许`动态扩展，那么当线程请求栈的深度 超过当前Java虚拟机栈的最⼤深度的时候，就抛出StackOverFlowError异常。 
>
>   ```java
>   /**
>    * 演示栈中的异常
>    */
>   public class StackErrorTest {
>       public static void main(String[] args) {
>           main(args);
>       }
>   }
>   ```
>
>   
>
> - **OutOfMemoryError**： 若 Java 虚拟机栈的内存⼤⼩`允许`动态扩展，且当线程请求栈时内存⽤完 了，⽆法再动态扩展了，此时抛出OutOfMemoryError异常。









### 设置大小

我们可以使用参数-Xss选项来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度。 （IDEA设置方法：Run-EditConfigurations-VM options 填入指定栈的大小-Xss256k）

```java
/**
 * 演示栈中的异常
 *
 * 默认情况下：count 10818
 * 设置栈的大小： -Xss256k count 1872
 */
public class StackErrorTest {
    private static int count = 1;
    public static void main(String[] args) {
        System.out.println(count);
        count++;
        main(args);
    }
}
```



### 存储结构和运行原理



- 每个线程都有自己的栈，栈中的数据都是以**栈帧(Stack Frame)**的格式存在

- 在这个线程上正在执行的每个方法都对应各自的一个栈帧

- 栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息

- JVM直接对java栈的操作只有两个，就是对栈帧的压栈和出栈，遵循先进后出/后进先出的和原则。

- 在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的，这个栈帧被称为**当前栈帧(Current Frame)**,与当前栈帧对应的方法就是**当前方法（Current Frame）**

- 执行引擎运行的所有字节码指令只针对当前栈帧进行操作

- 如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前栈帧。

- 不同线程中所包含的栈帧是不允许相互引用的，即不可能在另一个栈帧中引用另外一个线程的栈帧

- 如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧

- Java方法有两种返回函数的方式

  **一种是正常的函数返回，使用return指令**

  **另外一种是抛出异常。不管使用哪种方式，都会导致栈帧被弹出**


![img](https://user-gold-cdn.xitu.io/2020/3/18/170ecafb0c5ada68?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)





### 栈帧内部结构

- 局部变量表（Local Variables）
- 操作数栈（Operand Stack）(或表达式栈)
- 动态链接（Dynamic Linking）(或执行运行时常量池的方法引用)
- 方法返回地址（Return Adress）（或方法正常退出或者异常退出的定义）
- 一些附加信息



![img](https://user-gold-cdn.xitu.io/2020/3/18/170ecafe0fab0cb2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)





### 栈帧：局部变量表（Local Variables）



- **定义为一个数字数组**：主要用于存储`方法参数`和定义在方法体内的`局部变量`,这些数据类型包括各类基本数据类型、对象引用（reference），以及returnAddressleixing
- **线程安全**：由于局部变量表是建立在线程的栈上，是线程私有的数据，因此不存在数据安全问题
- **大小确定不会改变**：**局部变量表所需的容量大小是在编译期确定下来的**,并保存在方法的Code属性的maximum local variables数据项中。在方法运行期间是不会改变局部变量表的大小的
- **方法嵌套调用的次数由栈的大小决定。一般来说，栈越大，方法嵌套调用次数越多。**对一个函数而言，他的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。



利用javap命令对字节码文件进行解析查看局部变量表，如图：

![img](https://user-gold-cdn.xitu.io/2020/3/18/170ecb01f86381ee?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



#### 变量槽slot的理解与演示



- 参数值的存放总是在局部变量数组的index0开始，到数组长度-1的索引结束，但需要注意，0索引`默认`是用来传递该方法所属对象实例的引用`this`
- 局部变量表，**最基本的存储单元是Slot(变量槽)**
- 局部变量表中存放编译期可知的各种基本数据类型（8种），引用类型（reference），returnAddress类型的变量。
- 在局部变量表里，**32位以内的类型只占用一个slot（包括returnAddress类型），64位的类型（long和double）占用两个slot。**
  - byte、short、char、float在存储前被转换为int，boolean也被转换为int，0表示false，非0表示true；
  - long和double则占据两个slot。
- 栈帧中的局部变量表中的槽位是可以`重复利用`的，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变量就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的。



![img](https://user-gold-cdn.xitu.io/2020/3/18/170ecb1565b0252f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)




- JVM会为局部变量表中的每一个slot都分配一个`访问索引`，通过这个索引即可成功访问到局部变量表中指定的局部变量值
- 当一个实例方法被调用的时候，它的方法参数和方法体定义的局部变量将会**按照顺序被复制到局部变量表中的每一个slot上**
- **如果需要访问局部变量表中一个64bit的局部变量值时，只需要使用签一个索引即可。**
- 如果当前帧是由构造方法或者实例方法创建的，那么**该对象引用this将会存放在index为0的slot处**,其余的参数按照参数表顺序排列。



```java
public class LocalVariablesTest {

    private int count = 1;
    //静态方法不能使用this
    public static void testStatic(){
        //编译错误，因为this变量不存在与当前方法的局部变量表中！！！
        System.out.println(this.count);
    }
}
```



- 在栈帧中，与性能调优关系最为密切的部分就是`局部变量表`。在方法执行时，虚拟机使用局部变量表完成方法的传递
- **局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收**



### 栈帧：操作数栈（Operand Stack）

操作数栈，**主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。**

![img](https://user-gold-cdn.xitu.io/2020/3/18/170ecb180342dcf0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



- 操作数栈就是jvm执行引擎的一个工作区，当一个方法开始执行的时候，一个新的栈帧也会随之被创建出来，这个方法的

  操作数栈是空的

- 每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译器就定义好了，保存在方法的`code属性`中，为`max_stack`的值。

- 栈中的任何一个元素都是可以任意的java数据类型

  - 32bit的类型占用一个栈单位深度

  - 64bit的类型占用两个栈深度单位

- 操作数栈**并非采用访问索引的方式来进行数据访问**的，而是只能通过标准的入栈push和出栈pop操作来完成一次数据访问

- **如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，**并更新PC寄存器中下一条需要执行的字节码指令。

- 操作数栈中的元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译期间进行验证，同时在类加载过程中的类验证阶段的数据流分析阶段要再次验证。





#### 过程

- 结合上图结合下面的图来看一下一个方法（栈帧）的执行过程

  ①15入栈；②存储15，15进入局部变量表

  ![img](https://user-gold-cdn.xitu.io/2020/3/18/170ecb1c4797b788?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

  ③压入8；④存储8，8进入局部变量表；



![img](https://user-gold-cdn.xitu.io/2020/3/18/170ecb53336d048b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

**⑤从局部变量表中把索引为1和2的是数据取出来，放到操作数栈；⑥iadd相加操作，8和15出栈**





![img](https://user-gold-cdn.xitu.io/2020/3/18/170ecb55fd42e99f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

**⑦iadd操作结果23入栈；⑧将23存储在局部变量表索引为3的位置上**





![img](https://user-gold-cdn.xitu.io/2020/3/18/170ecb5802369d83?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



#### i++ 和 ++i的区别

![img](https://user-gold-cdn.xitu.io/2020/3/18/170ecb6e2832562f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

![img](https://user-gold-cdn.xitu.io/2020/3/18/170ecb702e020973?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



#### 栈顶缓存技术ToS（Top-of-Stack Cashing）

- 基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派（instruction dispatch）次数和内存读/写次数
- 由于操作数是存储在内存中的，因此频繁地执行内存读/写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们提出了栈顶缓存技术，**将栈顶元素全部缓存在屋里CPU的寄存器中，以此降低对内存的读/写次数，提升执行的执行效率**


