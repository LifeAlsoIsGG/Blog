(window.webpackJsonp=window.webpackJsonp||[]).push([[101],{897:function(t,l,v){"use strict";v.r(l);var _=v(2),e=Object(_.a)({},(function(){var t=this,l=t.$createElement,v=t._self._c||l;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h2",{attrs:{id:"动态规划和贪心算法的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#动态规划和贪心算法的区别"}},[t._v("#")]),t._v(" 动态规划和贪心算法的区别")]),t._v(" "),v("p",[t._v("相同点")]),t._v(" "),v("ul",[v("li",[t._v("动态规划和贪心算法都是一种递推算法")]),t._v(" "),v("li",[t._v("均有局部最优解来推导全局最优解")])]),t._v(" "),v("p",[t._v("不同点")]),t._v(" "),v("ul",[v("li",[t._v("贪心算法中，作出的每步贪心决策都无法改变，因为贪心策略是由上一步的最优解推导下一步的最优解，而上一部之前的最优解则不作保留。")]),t._v(" "),v("li",[t._v("可以知道贪心法正确的条件是：每一步的最优解一定包含上一步的最优解。")]),t._v(" "),v("li",[t._v("全局最优解中一定包含某个局部最优解，但不一定包含前一个局部最优解，因此需要记录之前的所有最优解")]),t._v(" "),v("li",[t._v("动态规划的关键是状态转移方程，即如何由以求出的局部最优解来推导全局最优解")]),t._v(" "),v("li",[t._v("边界条件：即最简单的，可以直接得出的局部最优解")])])])}),[],!1,null,null,null);l.default=e.exports}}]);