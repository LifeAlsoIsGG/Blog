(window.webpackJsonp=window.webpackJsonp||[]).push([[85],{921:function(e,t,a){"use strict";a.r(t);var v=a(1),r=Object(v.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h2",{attrs:{id:"bean"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#bean"}},[e._v("#")]),e._v(" bean")]),e._v(" "),a("h3",{attrs:{id:"bean生命周期"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#bean生命周期"}},[e._v("#")]),e._v(" bean生命周期")]),e._v(" "),a("h3",{attrs:{id:"bean作用域"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#bean作用域"}},[e._v("#")]),e._v(" bean作用域")]),e._v(" "),a("h3",{attrs:{id:"注入私有静态属性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#注入私有静态属性"}},[e._v("#")]),e._v(" 注入私有静态属性")]),e._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[e._v("@Autowired")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("private")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("static")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("RedisHelperManager")]),e._v(" redisHelperManager"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br")])]),a("p",[e._v("这样肯定是不行，并且在用到该变量时会抛出运行时异常java.lang.NullPointerException,静态变量不属于对象的属性，属于类属性，spring是基于对象层面的注入。")]),e._v(" "),a("h4",{attrs:{id:"解决方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#解决方法"}},[e._v("#")]),e._v(" 解决方法")]),e._v(" "),a("ul",[a("li",[e._v("使用setter方法注入，在setter方法上加@Autowired注解")]),e._v(" "),a("li",[e._v("@PostConstruct标记的方法手动注入，将会在初始化前调用该方法")])]),e._v(" "),a("h3",{attrs:{id:"spring-中的单例-bean-的线程安全问题了解吗"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#spring-中的单例-bean-的线程安全问题了解吗"}},[e._v("#")]),e._v(" Spring 中的单例 bean 的线程安全问题了解吗？")]),e._v(" "),a("p",[e._v("大部分时候我们并没有在系统中使用多线程，所以很少有人会关注这个问题。")]),e._v(" "),a("p",[e._v("单例 bean 存在线程问题，主要是因为当多个线程操作同一个对象的时候，对这个对象的非静态成员变量的写操作会存在线程安全问题。")]),e._v(" "),a("p",[e._v("常见的有两种解决办法：")]),e._v(" "),a("div",{staticClass:"custom-block info"},[a("p",{staticClass:"custom-block-title"},[e._v("常见的有两种解决办法")]),e._v(" "),a("ol",[a("li",[e._v("在Bean对象中尽量避免定义可变的成员变量（不太现实）。")]),e._v(" "),a("li",[e._v("在类中定义一个"),a("code",[e._v("ThreadLocal")]),e._v("成员变量，将需要的可变成员变量保存在 "),a("code",[e._v("ThreadLocal")]),e._v(" 中（推荐的一种方式）。")])])]),e._v(" "),a("h3",{attrs:{id:"component-和-bean-的相同和区别是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#component-和-bean-的相同和区别是什么"}},[e._v("#")]),e._v(" @Component 和 @Bean 的相同和区别是什么？")]),e._v(" "),a("p",[a("code",[e._v("@Component")]),e._v("和"),a("code",[e._v("@Bean")]),e._v("都是用来注册Bean并装配到"),a("code",[e._v("Spring容器")]),e._v("中，但是"),a("code",[e._v("Bean")]),e._v("比"),a("code",[e._v("Component")]),e._v("的自定义性更强。可以实现一些Component实现不了的自定义加载类。")]),e._v(" "),a("div",{staticClass:"custom-block info"},[a("p",{staticClass:"custom-block-title"},[e._v("@Component 和 @Bean 的区别是什么")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("作⽤对象不同: @Component 注解作⽤于"),a("code",[e._v("类")]),e._v("，⽽ @Bean 注解作⽤于"),a("code",[e._v("⽅法")]),e._v("。")])]),e._v(" "),a("li",[a("p",[e._v("@Component （@Controller、@Service、@Repository）通常是通过类路径扫描来⾃动侦测以及⾃动装配到Spring容器中（我们可以使⽤ "),a("code",[e._v("@ComponentScan")]),e._v(" 注解定义要扫描的路径从中找出标识了需要装配的类⾃动装配到 Spring 的 bean 容器中）。 @Bean 注解通常是我们在标有该注解的⽅法中定义产⽣这个 bean, @Bean告诉了Spring这是某个类的示例，当我需要⽤它的时候还给我。")])]),e._v(" "),a("li",[a("p",[e._v("@Bean 注解⽐ Component 注解的⾃定义性更强，⽽且很多地⽅我们只能通过 @Bean 注解 来注册bean。⽐如当我们引⽤第三⽅库中的类需要装配到 Spring 容器时，则只能通过 @Bean 来实现")])])])]),e._v(" "),a("h2",{attrs:{id:"过滤器和拦截器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#过滤器和拦截器"}},[e._v("#")]),e._v(" 过滤器和拦截器")]),e._v(" "),a("p",[e._v("参考")]),e._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://blog.csdn.net/yjc0403/article/details/84924548",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://blog.csdn.net/yjc0403/article/details/84924548"),a("OutboundLink")],1)]),e._v(" "),a("li",[a("a",{attrs:{href:"https://www.zhihu.com/question/30212464/answer/1786967139",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://www.zhihu.com/question/30212464/answer/1786967139"),a("OutboundLink")],1)])]),e._v(" "),a("p",[a("img",{attrs:{src:"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/Spring-Interview/过滤器与拦截器区别.jpg",alt:"img",loading:"lazy"}})]),e._v(" "),a("ul",[a("li",[a("p",[e._v("实现：过滤器 是基于函数回调的；拦截器 则是基于Java的反射机制（动态代理）实现的。")])]),e._v(" "),a("li",[a("p",[e._v("范围：过滤器 实现的是 javax.servlet.Filter 接口，而这个接口是在Servlet规范中定义的，也就是说过滤器Filter 的使用要依赖于Tomcat等容器，导致它只能在web程序中使用；拦截器(Interceptor) 它是一个Spring组件，并由Spring容器管理，并不依赖Tomcat等容器，是可以单独使用的。不仅能应用在web程序中，也可以用于Application、Swing等程序中。")])]),e._v(" "),a("li",[a("p",[e._v("触发时机：过滤器Filter是在请求进入容器后，但在进入servlet之前进行预处理，请求结束是在servlet处理完以后；")]),e._v(" "),a("p",[e._v("拦截器 Interceptor 是在请求进入servlet后，在进入Controller之前进行预处理的，Controller 中渲染了对应的视图之后请求结束。")])])]),e._v(" "),a("h2",{attrs:{id:"spring用到了哪些设计模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#spring用到了哪些设计模式"}},[e._v("#")]),e._v(" Spring用到了哪些设计模式")]),e._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[e._v("参考")]),e._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485303&idx=1&sn=9e4626a1e3f001f9b0d84a6fa0cff04a&chksm=cea248bcf9d5c1aaf48b67cc52bac74eb29d6037848d6cf213b0e5466f2d1fda970db700ba41&token=255050878&lang=zh_CN%23rd",target:"_blank",rel:"noopener noreferrer"}},[e._v("Spring设计模式"),a("OutboundLink")],1)]),e._v(" "),a("li",[e._v("https://zhuanlan.zhihu.com/p/114244039")])])]),e._v(" "),a("ul",[a("li",[e._v("1.简单工厂(非23种设计模式中的一种)")]),e._v(" "),a("li",[e._v("2.工厂方法")]),e._v(" "),a("li",[e._v("3.单例模式")]),e._v(" "),a("li",[e._v("4.适配器模式")]),e._v(" "),a("li",[e._v("5.装饰器模式")]),e._v(" "),a("li",[e._v("6.代理模式")]),e._v(" "),a("li",[e._v("7.观察者模式")]),e._v(" "),a("li",[e._v("8.策略模式")]),e._v(" "),a("li",[e._v("9.模版方法模式")])]),e._v(" "),a("h2",{attrs:{id:"springmvc"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#springmvc"}},[e._v("#")]),e._v(" SpringMVC")]),e._v(" "),a("h3",{attrs:{id:"springmvc组件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#springmvc组件"}},[e._v("#")]),e._v(" SpringMVC组件")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("DispatcherServlet")]),e._v("：前端控制器。也称为中央控制器，它是整个请求响应的控制中心，组件的调用由它统一调度。有了他就减少了其他组件之间的耦合度。")]),e._v(" "),a("li",[a("code",[e._v("HandlerMapping")]),e._v("：处理器映射器。它根据用户访问的 URL 映射到对应的后端处理器 Handler。也就是说它知道处理用户请求的后端处理器，但是它并不执行后端处理器，而是将处理器告诉给中央处理器。")]),e._v(" "),a("li",[a("code",[e._v("HandlerAdapter")]),e._v("：处理器适配器。根据传过来不同类型的"),a("code",[e._v("Hadnle")]),e._v("它调用后端处理器中的方法，返回逻辑视图 "),a("code",[e._v("ModelAndView")]),e._v(" 对象给"),a("code",[e._v("DispatcherServlet")]),e._v("。")]),e._v(" "),a("li",[a("code",[e._v("ViewResolver")]),e._v("：视图解析器。将 "),a("code",[e._v("ModelAndView")]),e._v(" 逻辑视图解析为具体的视图（如 JSP）。")]),e._v(" "),a("li",[a("code",[e._v("Handler")]),e._v("：后端处理器。对用户具体请求进行处理，也就是我们编写的 "),a("code",[e._v("Controller")]),e._v(" 类。需要程序员开发")])]),e._v(" "),a("h3",{attrs:{id:"springmvc工作流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#springmvc工作流程"}},[e._v("#")]),e._v(" SpringMVC工作流程")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://blog-1300186248.cos.ap-shanghai.myqcloud.com/Spring-Interview/spring mvc工作流程.jpg",alt:"Springmvc工作原理图",loading:"lazy"}})]),e._v(" "),a("div",{staticClass:"custom-block info"},[a("p",{staticClass:"custom-block-title"},[e._v("流程详解")]),e._v(" "),a("ol",[a("li",[a("p",[e._v("用户向服务端发送一次请求，这个请求会先到前端控制器"),a("code",[e._v("DispatcherServlet")]),e._v("(也叫中央控制器)。")])]),e._v(" "),a("li",[a("p",[a("code",[e._v("DispatcherServlet")]),e._v("接收到请求后会调用"),a("code",[e._v("HandlerMapping")]),e._v("处理器映射器来，根据配置或注解获取不同的"),a("code",[e._v("Handle")]),e._v("，并返回给"),a("code",[e._v("DispatcherServlet")]),e._v("。由此得知，该请求该由哪个"),a("code",[e._v("Controller")]),e._v("来处理（并未调用Controller，只是得知）")])]),e._v(" "),a("li",[a("p",[a("code",[e._v("DispatcherServlet")]),e._v("调用"),a("code",[e._v("HandlerAdapter")]),e._v("处理器适配器，告诉处理器适配器应该要去执行哪个"),a("code",[e._v("Controller")])])]),e._v(" "),a("li",[a("p",[a("code",[e._v("HandlerAdapter")]),e._v("处理器适配器去执行"),a("code",[e._v("Controller")]),e._v("并得到"),a("code",[e._v("ModelAndView")]),e._v("(数据和视图)，并层层返回给"),a("code",[e._v("DispatcherServlet")])])]),e._v(" "),a("li",[a("p",[a("code",[e._v("DispatcherServlet")]),e._v("将"),a("code",[e._v("ModelAndView")]),e._v("交给"),a("code",[e._v("ViewReslover")]),e._v("视图解析器解析，然后返回真正的视图"),a("code",[e._v("View")]),e._v("。")])]),e._v(" "),a("li",[a("p",[a("code",[e._v("DispatcherServlet")]),e._v("将模型数据填充到视图中")])]),e._v(" "),a("li",[a("p",[a("code",[e._v("DispatcherServlet")]),e._v("将结果响应给用户")])])])])])}),[],!1,null,null,null);t.default=r.exports}}]);