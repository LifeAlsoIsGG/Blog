<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Java-多线程并发 | Draco&#39;s Blog</title>
    <meta name="generator" content="VuePress 1.7.1">
    <script src="https://cdn.jsdelivr.net/npm/react/umd/react.production.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/react-dom/umd/react-dom.production.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@babel/standalone/babel.min.js"></script>
    <link rel="icon" href="/favicon.ico">
    <link rel="icon" href="/assets/icon/chrome-mask-512.png" type="image/png" sizes="512x512">
    <link rel="icon" href="/assets/icon/chrome-mask-192.png" type="image/png" sizes="192x192">
    <link rel="icon" href="/assets/icon/chrome-512.png" type="image/png" sizes="512x512">
    <link rel="icon" href="/assets/icon/chrome-192.png" type="image/png" sizes="192x192">
    <link rel="manifest" href="/manifest.webmanifest">
    <link rel="apple-touch-icon" href="/assets/icon/apple-icon-152.png">
    <meta name="description" content="This time I will not be silent">
    <meta property="og:url" content="/Java/Java-MultiThread/Java-MultiThread.html">
    <meta property="og:site_name" content="Draco's Blog">
    <meta property="og:title" content="Java-多线程并发">
    <meta property="og:type" content="article">
    <meta property="og:locale" content="zh-CN">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image:alt" content="Draco's Blog">
    <meta property="article:author" content="Draco">
    <meta property="article:tag" content="学习笔记">
    <meta property="article:published_time" content="2020-08-23T20:36:25.000Z">
    <meta name="theme-color" content="#46bd87">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="msapplication-TileImage" content="/assets/icon/ms-icon-144.png">
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    
    <link rel="preload" href="/assets/css/0.styles.ee34f577.css" as="style"><link rel="preload" href="/assets/js/app.20b20573.js" as="script"><link rel="preload" href="/assets/js/layout-Layout.01663f32.js" as="script"><link rel="preload" href="/assets/js/vendors~layout-Blog~layout-Layout~layout-NotFound.29afc31d.js" as="script"><link rel="preload" href="/assets/js/vendors~layout-Blog~layout-Layout~layout-NotFound~layout-Slide.b32f4377.js" as="script"><link rel="preload" href="/assets/js/vendors~layout-Blog~layout-Layout.02c7d76a.js" as="script"><link rel="preload" href="/assets/js/page-Java-多线程并发--31fe9d0a.e5a055a2.js" as="script"><link rel="prefetch" href="/assets/js/118.6946fc1c.js"><link rel="prefetch" href="/assets/js/119.bca2602e.js"><link rel="prefetch" href="/assets/js/120.2832e7f3.js"><link rel="prefetch" href="/assets/js/121.50fe6c17.js"><link rel="prefetch" href="/assets/js/122.0bc17515.js"><link rel="prefetch" href="/assets/js/layout-Blog.fb90deb2.js"><link rel="prefetch" href="/assets/js/layout-NotFound.63ebdf35.js"><link rel="prefetch" href="/assets/js/layout-Slide.f1754089.js"><link rel="prefetch" href="/assets/js/page--0e28e800.d7f6ba3c.js"><link rel="prefetch" href="/assets/js/page-About--5b67d57c.05155aad.js"><link rel="prefetch" href="/assets/js/page-DockerInstallsoftware--8b695bc0.7934e7ef.js"><link rel="prefetch" href="/assets/js/page-Dockerdeployment--35402470.a0225b74.js"><link rel="prefetch" href="/assets/js/page-Docker学习笔记--1e1346ee.a6e6ff47.js"><link rel="prefetch" href="/assets/js/page-Dubbo笔记--d33a24fc.7e3c4347.js"><link rel="prefetch" href="/assets/js/page-EasyExcel导入导出Excel--8536b204.39db5945.js"><link rel="prefetch" href="/assets/js/page-ElasticSearch笔记--4af8c97c.2d20e58c.js"><link rel="prefetch" href="/assets/js/page-ElasticSearch面试--08e46102.5799d512.js"><link rel="prefetch" href="/assets/js/page-Git笔记--74fd8102.f11f94d8.js"><link rel="prefetch" href="/assets/js/page-Golang-介绍和使用--3c13b802.3411401c.js"><link rel="prefetch" href="/assets/js/page-Golang-语法基础--73680002.49ee45c3.js"><link rel="prefetch" href="/assets/js/page-Hadoop伪分布式配置--2a57517c.0766d042.js"><link rel="prefetch" href="/assets/js/page-Home--59130159.58d81bd0.js"><link rel="prefetch" href="/assets/js/page-HttpServletrequest与HttpServletResponse--32be633c.9d5dd518.js"><link rel="prefetch" href="/assets/js/page-IDEA初始化SpringBoot项目+逆向工程+配置--cae6bdf8.b3a8252a.js"><link rel="prefetch" href="/assets/js/page-JVM--5b6ae8ec.c8eef887.js"><link rel="prefetch" href="/assets/js/page-JVM-类加载子系统--1c575f64.4e33c2bc.js"><link rel="prefetch" href="/assets/js/page-JVM-运行时数据区--1b82f764.9f4cff9b.js"><link rel="prefetch" href="/assets/js/page-JWT认证原理(更新中)--681a8776.fa46aee3.js"><link rel="prefetch" href="/assets/js/page-Java-IO--175f83c6.362e3783.js"><link rel="prefetch" href="/assets/js/page-Java-String--451ab620.e94a8dfb.js"><link rel="prefetch" href="/assets/js/page-Java-UML类图--5c22e12c.1a3bbb32.js"><link rel="prefetch" href="/assets/js/page-Java-基础知识笔记--1af93aac.51b96c3b.js"><link rel="prefetch" href="/assets/js/page-Java-基础面试题--54820d7c.ae7e8605.js"><link rel="prefetch" href="/assets/js/page-Java-常用方法汇总--05020b62.9f062be7.js"><link rel="prefetch" href="/assets/js/page-Java-新特性--6be28b66.d24a5518.js"><link rel="prefetch" href="/assets/js/page-Java-注解和反射--3822d062.7536016e.js"><link rel="prefetch" href="/assets/js/page-Java-设计模式--6c560cae.0c9b1d3a.js"><link rel="prefetch" href="/assets/js/page-Java-集合容器--2c3e3402.7d7bcf68.js"><link rel="prefetch" href="/assets/js/page-JavaScript面试题--d2217ec8.df74e51a.js"><link rel="prefetch" href="/assets/js/page-JavaSwing-超市系统--26fb3520.d333a7e4.js"><link rel="prefetch" href="/assets/js/page-Javaweb大学活动管理系统--43580be2.fd79d895.js"><link rel="prefetch" href="/assets/js/page-Java多线程-1--1aca6942.c5467069.js"><link rel="prefetch" href="/assets/js/page-Java多线程-JUC使用--f046a618.cd53fa7a.js"><link rel="prefetch" href="/assets/js/page-Java多线程-关键字锁--e825225c.b1c278a6.js"><link rel="prefetch" href="/assets/js/page-Java学习目录--60ce0d09.eee97e4f.js"><link rel="prefetch" href="/assets/js/page-Java面试整理--1bcb1346.e811a122.js"><link rel="prefetch" href="/assets/js/page-Linux学习目录--e7a528e2.41f1bd3f.js"><link rel="prefetch" href="/assets/js/page-Linux常用命令--0e00a956.38c55e4d.js"><link rel="prefetch" href="/assets/js/page-Linux技巧--b44e087c.ce5a4984.js"><link rel="prefetch" href="/assets/js/page-Markdown增强--7e4e51ec.e317d8a6.js"><link rel="prefetch" href="/assets/js/page-Maven笔记--5989c584.e917ba53.js"><link rel="prefetch" href="/assets/js/page-MyProject--ebe6f4ee.0f231392.js"><link rel="prefetch" href="/assets/js/page-Mybatis-Plus基础笔记--2b1fd47c.20bca26c.js"><link rel="prefetch" href="/assets/js/page-Mybatis基础笔记--575c8762.3324e72b.js"><link rel="prefetch" href="/assets/js/page-Mybatis语法笔记--2048b342.86318652.js"><link rel="prefetch" href="/assets/js/page-Mybatis逆向工程Example类使用--2302d0a2.836969a0.js"><link rel="prefetch" href="/assets/js/page-Mysql理论学习笔记--f8fff61c.5c599d29.js"><link rel="prefetch" href="/assets/js/page-Nginx-动静分离--3bdf05d4.1e8b5c36.js"><link rel="prefetch" href="/assets/js/page-Nginx-反向代理--5a698966.d3df8912.js"><link rel="prefetch" href="/assets/js/page-Nginx-负载均衡--6f6856a2.a5290c7b.js"><link rel="prefetch" href="/assets/js/page-Nginx基础笔记和安装配置--2dd310e8.36ff61c0.js"><link rel="prefetch" href="/assets/js/page-Nginx学习目录--5d803bc3.4a7b342d.js"><link rel="prefetch" href="/assets/js/page-Promise异步调用--26c7ec02.21440666.js"><link rel="prefetch" href="/assets/js/page-RabbitMQ--4585be74.25174e2b.js"><link rel="prefetch" href="/assets/js/page-Redis应用场景--13936b64.5fbc672a.js"><link rel="prefetch" href="/assets/js/page-Redis理论学习笔记--dccd4764.9291ef7c.js"><link rel="prefetch" href="/assets/js/page-Redis部署与基本使用--042fe622.545324ee.js"><link rel="prefetch" href="/assets/js/page-Redis集群和哨兵--7310b8a2.50fa8ee4.js"><link rel="prefetch" href="/assets/js/page-SQL学习笔记--2196c73c.63285ae8.js"><link rel="prefetch" href="/assets/js/page-Spring-RestTemplate--120468b6.862d61dc.js"><link rel="prefetch" href="/assets/js/page-SpringBootVue项目搭建(持续更新)--7bda1ca2.21350296.js"><link rel="prefetch" href="/assets/js/page-SpringCloud笔记--59a0fafc.eb417b29.js"><link rel="prefetch" href="/assets/js/page-SpringSecurity--43f5f362.be185ea2.js"><link rel="prefetch" href="/assets/js/page-Spring基础笔记--a33487fc.e46aa9e9.js"><link rel="prefetch" href="/assets/js/page-Spring注解--44ca7b34.be5298ef.js"><link rel="prefetch" href="/assets/js/page-Spring错误坑记录--c5e621d4.f96b6c80.js"><link rel="prefetch" href="/assets/js/page-Spring错误笔记--a8357668.f3671729.js"><link rel="prefetch" href="/assets/js/page-Spring面试题--2130907c.91f6925a.js"><link rel="prefetch" href="/assets/js/page-Swagger使用--596da9d4.ae66625e.js"><link rel="prefetch" href="/assets/js/page-主要功能与配置演示--8640dd82.d1505257.js"><link rel="prefetch" href="/assets/js/page-修改Host以访问Github--5c5d20f8.237a57dd.js"><link rel="prefetch" href="/assets/js/page-前端学习目录--41b2b489.9b7d9e96.js"><link rel="prefetch" href="/assets/js/page-听歌识曲开放平台--2bb96544.480879bf.js"><link rel="prefetch" href="/assets/js/page-大三下实训期末作业--13a0afc2.bf815300.js"><link rel="prefetch" href="/assets/js/page-字节测开面经--015c16c2.09005bcc.js"><link rel="prefetch" href="/assets/js/page-学习路线--5270a45e.cf4b51f7.js"><link rel="prefetch" href="/assets/js/page-实验室出入管理小程序--276ebfb4.53606f36.js"><link rel="prefetch" href="/assets/js/page-密码加密的文章--308fd1a2.c8715deb.js"><link rel="prefetch" href="/assets/js/page-操作系统--93f406bc.c08bf152.js"><link rel="prefetch" href="/assets/js/page-数据库学习目录--739cb729.7d1105a8.js"><link rel="prefetch" href="/assets/js/page-数据结构--3a868e62.6947e50e.js"><link rel="prefetch" href="/assets/js/page-数据结构算法学习目录--67791793.43e2b207.js"><link rel="prefetch" href="/assets/js/page-数据结构算法题目合集--9708ba24.047fc2f8.js"><link rel="prefetch" href="/assets/js/page-服务器上部署SpringBoot--311ff162.94668636.js"><link rel="prefetch" href="/assets/js/page-概述参考--89ff9fa6.47ca090e.js"><link rel="prefetch" href="/assets/js/page-概述参考--c6980c9e.06961427.js"><link rel="prefetch" href="/assets/js/page-用xshell连接虚拟机中的Centos7--15553b3c.043bf8c7.js"><link rel="prefetch" href="/assets/js/page-算法--3f0414a2.e6fdc55e.js"><link rel="prefetch" href="/assets/js/page-组件禁用--4e03d17c.15fd9db5.js"><link rel="prefetch" href="/assets/js/page-腾讯云学习笔记--5514f34e.dcaf086e.js"><link rel="prefetch" href="/assets/js/page-计算机网络--1420283a.a19623c9.js"><link rel="prefetch" href="/assets/js/page-认识SpringCloud--21ac1f18.e4a02a0f.js"><link rel="prefetch" href="/assets/js/page-认识SpringCloud--353c867c.6f546fee.js"><link rel="prefetch" href="/assets/js/page-设计模式七大原则--4fb9d7fc.4bcfc396.js"><link rel="prefetch" href="/assets/js/page-设计模式七大原则--96b59c3c.34def586.js"><link rel="prefetch" href="/assets/js/page-设计模式之J2EE设计模式--74fd2740.9841eb79.js"><link rel="prefetch" href="/assets/js/page-设计模式之创建型设计模式--421acabc.2c5da3a6.js"><link rel="prefetch" href="/assets/js/page-设计模式之结构型设计模式--07616382.b449c529.js"><link rel="prefetch" href="/assets/js/page-设计模式之行为型设计模式--4a4af782.b6077a7b.js"><link rel="prefetch" href="/assets/js/page-问题随记--24fbad02.1ccb6e44.js"><link rel="prefetch" href="/assets/js/page-面试大纲--02c57342.bb931b02.js"><link rel="prefetch" href="/assets/js/page-页面配置--483f41ca.769e07be.js"><link rel="prefetch" href="/assets/js/vendors~flowchart.e14a9ba9.js"><link rel="prefetch" href="/assets/js/vendors~photo-swipe.52b3d02d.js"><link rel="prefetch" href="/assets/js/vendors~reveal.af77f405.js"><link rel="prefetch" href="/assets/js/vendors~valine.910d88fc.js">
    <link rel="stylesheet" href="/assets/css/0.styles.ee34f577.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container has-anchor"><header class="navbar"><button class="sidebar-button"><span class="icon"></span></button> <a href="/" class="home-link router-link-active"><img src="https://cdn.jsdelivr.net/gh/lifealsoisgg/Blog@gh-pages/logo.png" alt="Draco's Blog" class="logo"> <!----> <span class="site-name can-hide">Draco's Blog</span></a> <div class="links"><button class="color-button"><svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" class="skin-icon"><path d="M224 800c0 9.6 3.2 44.8 6.4 54.4 6.4 48-48 76.8-48 76.8s80 41.6 147.2 0 134.4-134.4
        38.4-195.2c-22.4-12.8-41.6-19.2-57.6-19.2C259.2 716.8 227.2 761.6 224 800zM560 675.2l-32
        51.2c-51.2 51.2-83.2 32-83.2 32 25.6 67.2 0 112-12.8 128 25.6 6.4 51.2 9.6 80 9.6 54.4 0
        102.4-9.6 150.4-32l0 0c3.2 0 3.2-3.2 3.2-3.2 22.4-16 12.8-35.2
        6.4-44.8-9.6-12.8-12.8-25.6-12.8-41.6 0-54.4 60.8-99.2 137.6-99.2 6.4 0 12.8 0 22.4
        0 12.8 0 38.4 9.6 48-25.6 0-3.2 0-3.2 3.2-6.4 0-3.2 3.2-6.4 3.2-6.4 6.4-16 6.4-16 6.4-19.2
        9.6-35.2 16-73.6 16-115.2 0-105.6-41.6-198.4-108.8-268.8C704 396.8 560 675.2 560 675.2zM224
        419.2c0-28.8 22.4-51.2 51.2-51.2 28.8 0 51.2 22.4 51.2 51.2 0 28.8-22.4 51.2-51.2 51.2C246.4
        470.4 224 448 224 419.2zM320 284.8c0-22.4 19.2-41.6 41.6-41.6 22.4 0 41.6 19.2 41.6 41.6 0
        22.4-19.2 41.6-41.6 41.6C339.2 326.4 320 307.2 320 284.8zM457.6 208c0-12.8 12.8-25.6 25.6-25.6
        12.8 0 25.6 12.8 25.6 25.6 0 12.8-12.8 25.6-25.6 25.6C470.4 233.6 457.6 220.8 457.6 208zM128
        505.6C128 592 153.6 672 201.6 736c28.8-60.8 112-60.8 124.8-60.8-16-51.2 16-99.2
        16-99.2l316.8-422.4c-48-19.2-99.2-32-150.4-32C297.6 118.4 128 291.2 128 505.6zM764.8
        86.4c-22.4 19.2-390.4 518.4-390.4 518.4-22.4 28.8-12.8 76.8 22.4 99.2l9.6 6.4c35.2 22.4
        80 12.8 99.2-25.6 0 0 6.4-12.8 9.6-19.2 54.4-105.6 275.2-524.8 288-553.6
        6.4-19.2-3.2-32-19.2-32C777.6 76.8 771.2 80 764.8 86.4z"></path></svg> <div class="color-picker-menu" style="display:none;"><div class="theme-options"><ul class="themecolor-select"><label for="themecolor-select">主题色:</label> <li><a href="#" class="default-theme"></a></li> </ul> <div class="darkmode-toggle"><label for="darkmode-toggle" class="desc">主题模式:</label> <div class="darkmode-switch"><div class="item day"><svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" class="icon light-icon"><path d="M512 256a42.667 42.667 0 0042.667-42.667V128a42.667 42.667 0 00-85.334 0v85.333A42.667 42.667 0 00512 256zm384 213.333h-85.333a42.667 42.667 0 000 85.334H896a42.667 42.667 0 000-85.334zM256 512a42.667 42.667 0 00-42.667-42.667H128a42.667 42.667 0 000 85.334h85.333A42.667 42.667 0 00256 512zm9.387-298.667a42.667 42.667 0 00-59.307 62.72l61.44 59.307a42.667 42.667 0 0031.147 11.947 42.667 42.667 0 0030.72-13.227 42.667 42.667 0 000-60.16zm459.946 133.974a42.667 42.667 0 0029.44-11.947l61.44-59.307a42.667 42.667 0 00-57.6-62.72l-61.44 60.587a42.667 42.667 0 000 60.16 42.667 42.667 0 0028.16 13.227zM512 768a42.667 42.667 0 00-42.667 42.667V896a42.667 42.667 0 0085.334 0v-85.333A42.667 42.667 0 00512 768zm244.48-79.36a42.667 42.667 0 00-59.307 61.44l61.44 60.587a42.667 42.667 0 0029.44 11.946 42.667 42.667 0 0030.72-12.8 42.667 42.667 0 000-60.586zm-488.96 0l-61.44 59.307a42.667 42.667 0 000 60.586 42.667 42.667 0 0030.72 12.8 42.667 42.667 0 0028.587-10.666l61.44-59.307a42.667 42.667 0 00-59.307-61.44zM512 341.333A170.667 170.667 0 10682.667 512 170.667 170.667 0 00512 341.333z" fill="currentColor"></path></svg></div> <div class="item auto active"><svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" class="icon auto-icon"><path d="M460.864 539.072H564.8L510.592 376l-49.728 163.072zM872 362.368V149.504H659.648L510.528 0l-149.12 149.504H149.12v212.928L0 511.872l149.12 149.504v212.928h212.352l149.12 149.504 149.12-149.504h212.352V661.376l149.12-149.504L872 362.368zM614.464 693.12l-31.616-90.624H438.272l-31.616 90.624h-85.888l144.576-407.68h90.368l144.576 407.68h-85.824zm0 0" fill="currentColor"></path></svg></div> <div class="item night"><svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" class="icon dark-icon"><path d="M935.539 630.402c-11.43-11.432-28.674-14.739-43.531-8.354-46.734 20.103-96.363 30.297-147.508 30.297-99.59 0-193.221-38.784-263.64-109.203-108.637-108.637-139.61-270.022-78.908-411.148a39.497 39.497 0 00-51.886-51.887c-52.637 22.64-100.017 54.81-140.826 95.616-85.346 85.346-132.346 198.821-132.346 319.52 0 120.7 47.001 234.172 132.347 319.519S408.063 947.11 528.76 947.11c120.7 0 234.172-47.003 319.52-132.351 40.809-40.81 72.978-88.19 95.616-140.826a39.497 39.497 0 00-8.356-43.532z" fill="currentColor"></path></svg></div></div> <!----></div></div></div></button> <div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/category/" class="nav-link"><i class="iconfont icon-note"></i>
  分类
</a></div><div class="nav-item"><a href="/study-line/" class="nav-link"><i class="iconfont icon-info"></i>
  学习路线
</a></div><div class="nav-item"><a href="/timeline/" class="nav-link"><i class="iconfont icon-time"></i>
  时间线
</a></div><div class="nav-item"><a href="/about/" class="nav-link"><i class="iconfont icon-info"></i>
  关于
</a></div><div class="nav-item"><a href="https://photos.lifeisgg.online/" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont icon-emoji"></i>
  相册
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <a rel="noopener noreferrer" href="https://github.com/LifeAlsoIsGG" target="_blank" class="repo-link">
    Github
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <nav class="nav-links"><div class="nav-item"><a href="/category/" class="nav-link"><i class="iconfont icon-note"></i>
  分类
</a></div><div class="nav-item"><a href="/study-line/" class="nav-link"><i class="iconfont icon-info"></i>
  学习路线
</a></div><div class="nav-item"><a href="/timeline/" class="nav-link"><i class="iconfont icon-time"></i>
  时间线
</a></div><div class="nav-item"><a href="/about/" class="nav-link"><i class="iconfont icon-info"></i>
  关于
</a></div><div class="nav-item"><a href="https://photos.lifeisgg.online/" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont icon-emoji"></i>
  相册
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <a rel="noopener noreferrer" href="https://github.com/LifeAlsoIsGG" target="_blank" class="repo-link">
    Github
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><a href="/study-line/" class="sidebar-link"><i class="iconfont icon-info" style="margin-right:0.2em;"></i>学习路线</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading clickable"><i class="iconfont icon-creative"></i> <span>My-Project</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading clickable"><i class="iconfont icon-creative"></i> <span>面试</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading clickable open"><i class="iconfont icon-code"></i> <span>Java</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/Java/" aria-current="page" class="sidebar-link">Java学习目录</a></li><li><a href="/Java/Java-BasicNotes/" class="sidebar-link">Java-基础知识笔记</a></li><li><a href="/Java/Java-Interview/" class="sidebar-link">Java-基础面试题</a></li><li><a href="/Java/Java-Methods/" class="sidebar-link">Java-常用方法汇总</a></li><li><a href="/Java/Java-Collections/" class="sidebar-link">Java-集合容器</a></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading clickable open"><!----> <span>Java-多线程</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/Java/Java-MultiThread/" aria-current="page" class="sidebar-link">概述/参考</a></li><li><a href="/Java/Java-MultiThread/Java-MultiThread-1/" class="sidebar-link">Java多线程-1</a></li><li><a href="/Java/Java-MultiThread/Java-MultiThread-2/" class="sidebar-link">/Java/Java-MultiThread/Java-MultiThread-2/</a></li><li><a href="/Java/Java-MultiThread/Java-MultiThread-keyword/" class="sidebar-link">Java多线程-关键字&amp;锁</a></li><li><a href="/Java/Java-MultiThread/Java-MultiThread/" aria-current="page" class="active sidebar-link">Java-多线程并发</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Java/Java-MultiThread/Java-MultiThread/#_1-线程、程序、进程的基本概念" class="sidebar-link">1. 线程、程序、进程的基本概念</a></li><li class="sidebar-sub-header"><a href="/Java/Java-MultiThread/Java-MultiThread/#_2-使用多线程可能带来什么问题" class="sidebar-link">2. 使用多线程可能带来什么问题?</a></li><li class="sidebar-sub-header"><a href="/Java/Java-MultiThread/Java-MultiThread/#_3-java多线程的四种实现方式-启动原理" class="sidebar-link">3. Java多线程的四种实现方式&amp;启动原理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Java/Java-MultiThread/Java-MultiThread/#_3-1-线程启动原理" class="sidebar-link">3.1 线程启动原理</a></li><li class="sidebar-sub-header"><a href="/Java/Java-MultiThread/Java-MultiThread/#_3-2-为什么我们调用-start-方法时会执行-run-方法-为什么我们不能直接调用-run-方法" class="sidebar-link">3.2 为什么我们调⽤ start() ⽅法时会执⾏ run() ⽅法，为什么我们不能直接调⽤ run() ⽅法？</a></li><li class="sidebar-sub-header"><a href="/Java/Java-MultiThread/Java-MultiThread/#_3-3-继承thread类创建线程" class="sidebar-link">3.3 继承Thread类创建线程</a></li><li class="sidebar-sub-header"><a href="/Java/Java-MultiThread/Java-MultiThread/#_3-4-实现runnable接口" class="sidebar-link">3.4 实现Runnable接口</a></li><li class="sidebar-sub-header"><a href="/Java/Java-MultiThread/Java-MultiThread/#_3-5-实现callable接口通过futuretask包装器来创建thread线程" class="sidebar-link">3.5 实现Callable接口通过FutureTask包装器来创建Thread线程</a></li><li class="sidebar-sub-header"><a href="/Java/Java-MultiThread/Java-MultiThread/#_3-6-通过线程池创建线程" class="sidebar-link">3.6 通过线程池创建线程</a></li></ul></li><li class="sidebar-sub-header"><a href="/Java/Java-MultiThread/Java-MultiThread/#_4-线程的生命周期和状态" class="sidebar-link">4. 线程的⽣命周期和状态?</a></li><li class="sidebar-sub-header"><a href="/Java/Java-MultiThread/Java-MultiThread/#_5-什么是上下文切换" class="sidebar-link">5. 什么是上下文切换?</a></li><li class="sidebar-sub-header"><a href="/Java/Java-MultiThread/Java-MultiThread/#_6-什么是线程死锁-如何避免死锁" class="sidebar-link">6. 什么是线程死锁?如何避免死锁?</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Java/Java-MultiThread/Java-MultiThread/#_6-1-产生死锁必须具备以下四个条件" class="sidebar-link">6.1 产⽣死锁必须具备以下四个条件</a></li><li class="sidebar-sub-header"><a href="/Java/Java-MultiThread/Java-MultiThread/#_6-2-如何避免线程死锁" class="sidebar-link">6.2 如何避免线程死锁?</a></li></ul></li><li class="sidebar-sub-header"><a href="/Java/Java-MultiThread/Java-MultiThread/#_7-说说-sleep-方法和-wait-方法区别和共同点" class="sidebar-link">7. 说说 sleep() ⽅法和 wait() ⽅法区别和共同点?</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Java/Java-MultiThread/Java-MultiThread/#_7-1-详细" class="sidebar-link">7.1 详细</a></li></ul></li><li class="sidebar-sub-header"><a href="/Java/Java-MultiThread/Java-MultiThread/#_9-synchronized-关键字" class="sidebar-link">9. synchronized 关键字</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Java/Java-MultiThread/Java-MultiThread/#_9-1-三种使用方式" class="sidebar-link">9.1 三种使用方式</a></li><li class="sidebar-sub-header"><a href="/Java/Java-MultiThread/Java-MultiThread/#_9-2-synchronized底层实现" class="sidebar-link">9.2 synchronized底层实现</a></li><li class="sidebar-sub-header"><a href="/Java/Java-MultiThread/Java-MultiThread/#_9-3-说说-jdk1-6-之后的synchronized-关键字底层做了哪些优化-可以详细介绍一下这些优化吗" class="sidebar-link">9.3 说说 JDK1.6 之后的synchronized 关键字底层做了哪些优化，可以详细介绍⼀下这些优化吗</a></li><li class="sidebar-sub-header"><a href="/Java/Java-MultiThread/Java-MultiThread/#_9-4-synchronized-和-reentrantlock-的对比" class="sidebar-link">9.4 Synchronized 和 ReenTrantLock 的对比</a></li></ul></li><li class="sidebar-sub-header"><a href="/Java/Java-MultiThread/Java-MultiThread/#_10-volatile关键字" class="sidebar-link">10. volatile关键字</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Java/Java-MultiThread/Java-MultiThread/#_10-1-两大特性" class="sidebar-link">10.1 两大特性</a></li><li class="sidebar-sub-header"><a href="/Java/Java-MultiThread/Java-MultiThread/#_10-2-java内存模型与volatile" class="sidebar-link">10.2 Java内存模型与volatile</a></li><li class="sidebar-sub-header"><a href="/Java/Java-MultiThread/Java-MultiThread/#_10-3-并发编程的三个重要特性" class="sidebar-link">10.3 并发编程的三个重要特性</a></li><li class="sidebar-sub-header"><a href="/Java/Java-MultiThread/Java-MultiThread/#_10-4-内存可见性" class="sidebar-link">10.4 内存可见性</a></li></ul></li><li class="sidebar-sub-header"><a href="/Java/Java-MultiThread/Java-MultiThread/#_11-synchronized-volatile-关键字的区别" class="sidebar-link">11. synchronized | volatile 关键字的区别</a></li><li class="sidebar-sub-header"><a href="/Java/Java-MultiThread/Java-MultiThread/#_12-java线程池" class="sidebar-link">12. Java线程池</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Java/Java-MultiThread/Java-MultiThread/#_12-1-好处" class="sidebar-link">12.1 好处</a></li><li class="sidebar-sub-header"><a href="/Java/Java-MultiThread/Java-MultiThread/#_12-2-创建线程池" class="sidebar-link">12.2 创建线程池</a></li><li class="sidebar-sub-header"><a href="/Java/Java-MultiThread/Java-MultiThread/#_12-3-threadpoolexecutor-类分析" class="sidebar-link">12.3 ThreadPoolExecutor 类分析</a></li><li class="sidebar-sub-header"><a href="/Java/Java-MultiThread/Java-MultiThread/#_12-4-拒绝策略" class="sidebar-link">12.4 拒绝策略</a></li><li class="sidebar-sub-header"><a href="/Java/Java-MultiThread/Java-MultiThread/#_12-5-线程池执行流程" class="sidebar-link">12.5 线程池执行流程</a></li></ul></li><li class="sidebar-sub-header"><a href="/Java/Java-MultiThread/Java-MultiThread/#_13-java-util-concurrent" class="sidebar-link">13. java.util.concurrent</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Java/Java-MultiThread/Java-MultiThread/#线程池相关类" class="sidebar-link">线程池相关类</a></li><li class="sidebar-sub-header"><a href="/Java/Java-MultiThread/Java-MultiThread/#阻塞队列相关类" class="sidebar-link">阻塞队列相关类</a></li><li class="sidebar-sub-header"><a href="/Java/Java-MultiThread/Java-MultiThread/#concurrentmap类" class="sidebar-link">ConcurrentMap类</a></li><li class="sidebar-sub-header"><a href="/Java/Java-MultiThread/Java-MultiThread/#多线程其他类" class="sidebar-link">多线程其他类</a></li><li class="sidebar-sub-header"><a href="/Java/Java-MultiThread/Java-MultiThread/#cas" class="sidebar-link">CAS</a></li></ul></li><li class="sidebar-sub-header"><a href="/Java/Java-MultiThread/Java-MultiThread/#_14-threadlocal" class="sidebar-link">14. ThreadLocal</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Java/Java-MultiThread/Java-MultiThread/#_14-1-简介" class="sidebar-link">14.1 简介</a></li><li class="sidebar-sub-header"><a href="/Java/Java-MultiThread/Java-MultiThread/#哈希冲突" class="sidebar-link">哈希冲突</a></li><li class="sidebar-sub-header"><a href="/Java/Java-MultiThread/Java-MultiThread/#_14-2-如何使用-原理" class="sidebar-link">14.2 如何使用/原理</a></li><li class="sidebar-sub-header"><a href="/Java/Java-MultiThread/Java-MultiThread/#_14-3-set-方法" class="sidebar-link">14.3 set()方法</a></li><li class="sidebar-sub-header"><a href="/Java/Java-MultiThread/Java-MultiThread/#_14-4-threadlocalmap" class="sidebar-link">14.4 ThreadLocalMap</a></li><li class="sidebar-sub-header"><a href="/Java/Java-MultiThread/Java-MultiThread/#_14-5-get-方法" class="sidebar-link">14.5 get()方法</a></li><li class="sidebar-sub-header"><a href="/Java/Java-MultiThread/Java-MultiThread/#_14-6-内存泄漏问题" class="sidebar-link">14.6 内存泄漏问题</a></li><li class="sidebar-sub-header"><a href="/Java/Java-MultiThread/Java-MultiThread/#_14-7-特性" class="sidebar-link">14.7 特性</a></li></ul></li><li class="sidebar-sub-header"><a href="/Java/Java-MultiThread/Java-MultiThread/#其他面试题" class="sidebar-link">其他面试题</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Java/Java-MultiThread/Java-MultiThread/#i-线程安全吗" class="sidebar-link">i++线程安全吗</a></li></ul></li></ul></li></ul></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading clickable"><!----> <span>Java-JVM</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading clickable"><!----> <span>Java设计模式</span> <span class="arrow right"></span></p> <!----></section></li><li><a href="/Java/Java-String/" class="sidebar-link">Java-String</a></li><li><a href="/Java/Java-annotation&amp;reflection/" class="sidebar-link">Java-注解和反射</a></li><li><a href="/Java/Java-IO/" class="sidebar-link">Java-IO</a></li><li><!----></li><li><a href="/Java/Java-UML-ClassDiagram/" class="sidebar-link">Java-UML类图</a></li><li><a href="/Java/Java-NewFeature/" class="sidebar-link">Java-新特性</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading clickable"><i class="iconfont icon-creative"></i> <span>Golang</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading clickable"><i class="iconfont icon-creative"></i> <span>数据库</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading clickable"><i class="iconfont icon-creative"></i> <span>Spring</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading clickable"><i class="iconfont icon-creative"></i> <span>SpringCloud</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading clickable"><i class="iconfont icon-creative"></i> <span>Mybatis</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading clickable"><i class="iconfont icon-creative"></i> <span>数据结构&amp;算法</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading clickable"><i class="iconfont icon-creative"></i> <span>Linux</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading clickable"><i class="iconfont icon-creative"></i> <span>ElasticSearch</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading clickable"><i class="iconfont icon-creative"></i> <span>Docker</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading clickable"><i class="iconfont icon-creative"></i> <span>Nginx</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading clickable"><i class="iconfont icon-creative"></i> <span>消息队列</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading clickable"><i class="iconfont icon-creative"></i> <span>错误笔记</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading clickable"><i class="iconfont icon-creative"></i> <span>Github</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading clickable"><i class="iconfont icon-creative"></i> <span>前端</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading clickable"><i class="iconfont icon-creative"></i> <span>Guide</span> <span class="arrow right"></span></p> <!----></section></li><li><a href="/about/" class="sidebar-link"><i class="iconfont icon-info" style="margin-right:0.2em;"></i>About</a></li></ul> </aside> <main class="page"><nav class="breadcrumb"><ul><li><a href="/Java/" class="router-link-active"><!---->
        Java学习目录
      </a></li><li><a href="/Java/Java-MultiThread/" class="router-link-active"><!---->
        概述/参考
      </a></li><li class="is-active"><a href="/Java/Java-MultiThread/Java-MultiThread/" aria-current="page" class="router-link-exact-active router-link-active"><!---->
        Java-多线程并发
      </a></li></ul></nav>  <div class="page-title"><h1><!---->
    Java-多线程并发
  </h1> <div class="page-info"><!----> <span aria-label="作者🖊" data-balloon-pos="down"><svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" class="icon author-icon"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z" fill="currentColor"></path></svg> <span>Draco</span></span><span aria-label="访问量🔢" data-balloon-pos="down" class="visitor-info"><svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" class="icon eye-icon"><path d="M992 512.096c0-5.76-.992-10.592-1.28-11.136-.192-2.88-1.152-8.064-2.08-10.816-.256-.672-.544-1.376-.832-2.08-.48-1.568-1.024-3.104-1.6-4.32C897.664 290.112 707.104 160 512 160c-195.072 0-385.632 130.016-473.76 322.592-1.056 2.112-1.792 4.096-2.272 5.856a55.512 55.512 0 00-.64 1.6c-1.76 5.088-1.792 8.64-1.632 7.744-.832 3.744-1.568 11.168-1.568 11.168-.224 2.272-.224 4.032.032 6.304 0 0 .736 6.464 1.088 7.808.128 1.824.576 4.512 1.12 6.976h-.032c.448 2.08 1.12 4.096 1.984 6.08.48 1.536.992 2.976 1.472 4.032C126.432 733.856 316.992 864 512 864c195.136 0 385.696-130.048 473.216-321.696 1.376-2.496 2.24-4.832 2.848-6.912.256-.608.48-1.184.672-1.728 1.536-4.48 1.856-8.32 1.728-8.32l-.032.032c.608-3.104 1.568-7.744 1.568-13.28zM512 672c-88.224 0-160-71.776-160-160s71.776-160 160-160 160 71.776 160 160-71.776 160-160 160z" fill="currentColor"></path></svg> <span id="/Java/Java-MultiThread/Java-MultiThread/" data-flag-title="Java-多线程并发" class="leancloud_visitors"><span class="leancloud-visitors-count">...</span></span></span><span aria-label="写作日期📅" data-balloon-pos="down" class="time-info"><svg viewBox="0 0 1030 1024" xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z" fill="currentColor"></path></svg> <span>2020-08-23 20:36:25</span></span><!----><span aria-label="标签🏷" data-balloon-pos="down"><svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" class="icon tag-icon"><path d="M939.902 458.563L910.17 144.567c-1.507-16.272-14.465-29.13-30.737-30.737L565.438 84.098h-.402c-3.215 0-5.726 1.005-7.634 2.913l-470.39 470.39a10.004 10.004 0 000 14.164l365.423 365.424c1.909 1.908 4.42 2.913 7.132 2.913s5.223-1.005 7.132-2.913l470.39-470.39c2.01-2.11 3.014-5.023 2.813-8.036zm-240.067-72.121c-35.458 0-64.286-28.828-64.286-64.286s28.828-64.285 64.286-64.285 64.286 28.828 64.286 64.285-28.829 64.286-64.286 64.286z" fill="currentColor"></path></svg> <ul class="tags-wrapper"><li class="tag clickable tag0"><span role="navigation">学习笔记</span></li><li class="tag clickable tag1"><span role="navigation">Java</span></li><li class="tag clickable tag2"><span role="navigation">Java-多线程</span></li></ul></span><span aria-label="阅读时间⌛" data-balloon-pos="down" class="read-time-info"><svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" class="icon time-icon"><path d="M511.997 70.568c-243.797 0-441.429 197.633-441.429 441.435 0 243.797 197.632 441.429 441.43 441.429S953.431 755.8 953.431 512.002c0-243.796-197.637-441.434-441.435-441.434zm150.158 609.093l-15.605 15.61c-8.621 8.615-22.596 8.615-31.215 0L472.197 552.126c-4.95-4.944-4.34-14.888-4.34-24.677V247.14c0-12.19 9.882-22.07 22.07-22.07h22.07c12.19 0 22.07 9.882 22.07 22.07v273.218l128.088 128.088c8.62 8.62 8.62 22.595 0 31.215zm0 0" fill="currentColor"></path></svg> <span>大约 52 分钟</span></span></div> <hr></div> <!----> <div class="anchor-place-holder"><aside id="anchor"><div class="anchor-wrapper"><ul class="anchor-list"><li class="anchor anchor2"><a href="/Java/Java-MultiThread/Java-MultiThread/#_1-线程、程序、进程的基本概念" class="anchor-link"><div>1. 线程、程序、进程的基本概念</div></a></li><li class="anchor anchor2"><a href="/Java/Java-MultiThread/Java-MultiThread/#_2-使用多线程可能带来什么问题" class="anchor-link"><div>2. 使用多线程可能带来什么问题?</div></a></li><li class="anchor anchor2"><a href="/Java/Java-MultiThread/Java-MultiThread/#_3-java多线程的四种实现方式-启动原理" class="anchor-link"><div>3. Java多线程的四种实现方式&amp;启动原理</div></a><ul class="anchor-list"><li class="anchor anchor3"><a href="/Java/Java-MultiThread/Java-MultiThread/#_3-1-线程启动原理" class="anchor-link"><div>3.1 线程启动原理</div></a></li><li class="anchor anchor3"><a href="/Java/Java-MultiThread/Java-MultiThread/#_3-2-为什么我们调用-start-方法时会执行-run-方法-为什么我们不能直接调用-run-方法" class="anchor-link"><div>3.2 为什么我们调⽤ start() ⽅法时会执⾏ run() ⽅法，为什么我们不能直接调⽤ run() ⽅法？</div></a></li><li class="anchor anchor3"><a href="/Java/Java-MultiThread/Java-MultiThread/#_3-3-继承thread类创建线程" class="anchor-link"><div>3.3 继承Thread类创建线程</div></a></li><li class="anchor anchor3"><a href="/Java/Java-MultiThread/Java-MultiThread/#_3-4-实现runnable接口" class="anchor-link"><div>3.4 实现Runnable接口</div></a></li><li class="anchor anchor3"><a href="/Java/Java-MultiThread/Java-MultiThread/#_3-5-实现callable接口通过futuretask包装器来创建thread线程" class="anchor-link"><div>3.5 实现Callable接口通过FutureTask包装器来创建Thread线程</div></a></li><li class="anchor anchor3"><a href="/Java/Java-MultiThread/Java-MultiThread/#_3-6-通过线程池创建线程" class="anchor-link"><div>3.6 通过线程池创建线程</div></a></li></ul></li><li class="anchor anchor2"><a href="/Java/Java-MultiThread/Java-MultiThread/#_4-线程的生命周期和状态" class="anchor-link"><div>4. 线程的⽣命周期和状态?</div></a></li><li class="anchor anchor2"><a href="/Java/Java-MultiThread/Java-MultiThread/#_5-什么是上下文切换" class="anchor-link"><div>5. 什么是上下文切换?</div></a></li><li class="anchor anchor2"><a href="/Java/Java-MultiThread/Java-MultiThread/#_6-什么是线程死锁-如何避免死锁" class="anchor-link"><div>6. 什么是线程死锁?如何避免死锁?</div></a><ul class="anchor-list"><li class="anchor anchor3"><a href="/Java/Java-MultiThread/Java-MultiThread/#_6-1-产生死锁必须具备以下四个条件" class="anchor-link"><div>6.1 产⽣死锁必须具备以下四个条件</div></a></li><li class="anchor anchor3"><a href="/Java/Java-MultiThread/Java-MultiThread/#_6-2-如何避免线程死锁" class="anchor-link"><div>6.2 如何避免线程死锁?</div></a></li></ul></li><li class="anchor anchor2"><a href="/Java/Java-MultiThread/Java-MultiThread/#_7-说说-sleep-方法和-wait-方法区别和共同点" class="anchor-link"><div>7. 说说 sleep() ⽅法和 wait() ⽅法区别和共同点?</div></a><ul class="anchor-list"><li class="anchor anchor3"><a href="/Java/Java-MultiThread/Java-MultiThread/#_7-1-详细" class="anchor-link"><div>7.1 详细</div></a></li></ul></li><li class="anchor anchor2"><a href="/Java/Java-MultiThread/Java-MultiThread/#_9-synchronized-关键字" class="anchor-link"><div>9. synchronized 关键字</div></a><ul class="anchor-list"><li class="anchor anchor3"><a href="/Java/Java-MultiThread/Java-MultiThread/#_9-1-三种使用方式" class="anchor-link"><div>9.1 三种使用方式</div></a></li><li class="anchor anchor3"><a href="/Java/Java-MultiThread/Java-MultiThread/#_9-2-synchronized底层实现" class="anchor-link"><div>9.2 synchronized底层实现</div></a></li><li class="anchor anchor3"><a href="/Java/Java-MultiThread/Java-MultiThread/#_9-3-说说-jdk1-6-之后的synchronized-关键字底层做了哪些优化-可以详细介绍一下这些优化吗" class="anchor-link"><div>9.3 说说 JDK1.6 之后的synchronized 关键字底层做了哪些优化，可以详细介绍⼀下这些优化吗</div></a></li><li class="anchor anchor3"><a href="/Java/Java-MultiThread/Java-MultiThread/#_9-4-synchronized-和-reentrantlock-的对比" class="anchor-link"><div>9.4 Synchronized 和 ReenTrantLock 的对比</div></a></li></ul></li><li class="anchor anchor2"><a href="/Java/Java-MultiThread/Java-MultiThread/#_10-volatile关键字" class="anchor-link"><div>10. volatile关键字</div></a><ul class="anchor-list"><li class="anchor anchor3"><a href="/Java/Java-MultiThread/Java-MultiThread/#_10-1-两大特性" class="anchor-link"><div>10.1 两大特性</div></a></li><li class="anchor anchor3"><a href="/Java/Java-MultiThread/Java-MultiThread/#_10-2-java内存模型与volatile" class="anchor-link"><div>10.2 Java内存模型与volatile</div></a></li><li class="anchor anchor3"><a href="/Java/Java-MultiThread/Java-MultiThread/#_10-3-并发编程的三个重要特性" class="anchor-link"><div>10.3 并发编程的三个重要特性</div></a></li><li class="anchor anchor3"><a href="/Java/Java-MultiThread/Java-MultiThread/#_10-4-内存可见性" class="anchor-link"><div>10.4 内存可见性</div></a></li></ul></li><li class="anchor anchor2"><a href="/Java/Java-MultiThread/Java-MultiThread/#_11-synchronized-volatile-关键字的区别" class="anchor-link"><div>11. synchronized | volatile 关键字的区别</div></a></li><li class="anchor anchor2"><a href="/Java/Java-MultiThread/Java-MultiThread/#_12-java线程池" class="anchor-link"><div>12. Java线程池</div></a><ul class="anchor-list"><li class="anchor anchor3"><a href="/Java/Java-MultiThread/Java-MultiThread/#_12-1-好处" class="anchor-link"><div>12.1 好处</div></a></li><li class="anchor anchor3"><a href="/Java/Java-MultiThread/Java-MultiThread/#_12-2-创建线程池" class="anchor-link"><div>12.2 创建线程池</div></a></li><li class="anchor anchor3"><a href="/Java/Java-MultiThread/Java-MultiThread/#_12-3-threadpoolexecutor-类分析" class="anchor-link"><div>12.3 ThreadPoolExecutor 类分析</div></a></li><li class="anchor anchor3"><a href="/Java/Java-MultiThread/Java-MultiThread/#_12-4-拒绝策略" class="anchor-link"><div>12.4 拒绝策略</div></a></li><li class="anchor anchor3"><a href="/Java/Java-MultiThread/Java-MultiThread/#_12-5-线程池执行流程" class="anchor-link"><div>12.5 线程池执行流程</div></a></li></ul></li><li class="anchor anchor2"><a href="/Java/Java-MultiThread/Java-MultiThread/#_13-java-util-concurrent" class="anchor-link"><div>13. java.util.concurrent</div></a><ul class="anchor-list"><li class="anchor anchor3"><a href="/Java/Java-MultiThread/Java-MultiThread/#线程池相关类" class="anchor-link"><div>线程池相关类</div></a></li><li class="anchor anchor3"><a href="/Java/Java-MultiThread/Java-MultiThread/#阻塞队列相关类" class="anchor-link"><div>阻塞队列相关类</div></a></li><li class="anchor anchor3"><a href="/Java/Java-MultiThread/Java-MultiThread/#concurrentmap类" class="anchor-link"><div>ConcurrentMap类</div></a></li><li class="anchor anchor3"><a href="/Java/Java-MultiThread/Java-MultiThread/#多线程其他类" class="anchor-link"><div>多线程其他类</div></a></li><li class="anchor anchor3"><a href="/Java/Java-MultiThread/Java-MultiThread/#cas" class="anchor-link"><div>CAS</div></a></li></ul></li><li class="anchor anchor2"><a href="/Java/Java-MultiThread/Java-MultiThread/#_14-threadlocal" class="anchor-link"><div>14. ThreadLocal</div></a><ul class="anchor-list"><li class="anchor anchor3"><a href="/Java/Java-MultiThread/Java-MultiThread/#_14-1-简介" class="anchor-link"><div>14.1 简介</div></a></li><li class="anchor anchor3"><a href="/Java/Java-MultiThread/Java-MultiThread/#哈希冲突" class="anchor-link"><div>哈希冲突</div></a></li><li class="anchor anchor3"><a href="/Java/Java-MultiThread/Java-MultiThread/#_14-2-如何使用-原理" class="anchor-link"><div>14.2 如何使用/原理</div></a></li><li class="anchor anchor3"><a href="/Java/Java-MultiThread/Java-MultiThread/#_14-3-set-方法" class="anchor-link"><div>14.3 set()方法</div></a></li><li class="anchor anchor3"><a href="/Java/Java-MultiThread/Java-MultiThread/#_14-4-threadlocalmap" class="anchor-link"><div>14.4 ThreadLocalMap</div></a></li><li class="anchor anchor3"><a href="/Java/Java-MultiThread/Java-MultiThread/#_14-5-get-方法" class="anchor-link"><div>14.5 get()方法</div></a></li><li class="anchor anchor3"><a href="/Java/Java-MultiThread/Java-MultiThread/#_14-6-内存泄漏问题" class="anchor-link"><div>14.6 内存泄漏问题</div></a></li><li class="anchor anchor3"><a href="/Java/Java-MultiThread/Java-MultiThread/#_14-7-特性" class="anchor-link"><div>14.7 特性</div></a></li></ul></li><li class="anchor anchor2"><a href="/Java/Java-MultiThread/Java-MultiThread/#其他面试题" class="anchor-link"><div>其他面试题</div></a><ul class="anchor-list"><li class="anchor anchor3"><a href="/Java/Java-MultiThread/Java-MultiThread/#i-线程安全吗" class="anchor-link"><div>i++线程安全吗</div></a></li></ul></li></ul></div></aside></div> <div class="theme-default-content content__default"><h2 id="_1-线程、程序、进程的基本概念"><a href="#_1-线程、程序、进程的基本概念" class="header-anchor">#</a> 1. 线程、程序、进程的基本概念</h2> <p><img src="/assets/img/Thread_program_process.9b018c04.png" alt="线程、程序、进程"></p> <h2 id="_2-使用多线程可能带来什么问题"><a href="#_2-使用多线程可能带来什么问题" class="header-anchor">#</a> 2. 使用多线程可能带来什么问题?</h2> <p>并发编程的⽬的就是为了能提⾼程序的执⾏效率提⾼程序运⾏速度，但是并发编程并不总是能提⾼程序 运⾏速度的，⽽且并发编程可能会遇到很多问题，⽐如：<strong>内存泄漏、上下⽂切换、死锁还有受限于硬件 和软件的资源闲置问题</strong>。</p> <h2 id="_3-java多线程的四种实现方式-启动原理"><a href="#_3-java多线程的四种实现方式-启动原理" class="header-anchor">#</a> 3. Java多线程的四种实现方式&amp;启动原理</h2> <p>参考</p> <blockquote><ul><li>https://www.cnblogs.com/felixzh/p/6036074.html</li> <li>https://www.jianshu.com/p/7950ea349dbb</li></ul></blockquote> <p><img src="/assets/img/Thread_Class_diagram.cb474a11.jpg" alt="线程类图"></p> <p><strong>无返回值</strong>，run()返回为void</p> <ul><li>继承Thread类：<strong>重写run()方法</strong></li> <li>实现Runnable接口：如果自己的类已经extends另一个类，就无法直接<strong>extends Thread</strong>，此时，可以实现一个Runnable接口，<strong>重写run方法</strong>，实现Runnable接口的实现类的实例对象作为Thread构造函数的target</li></ul> <p><strong>有返回值</strong>，通过Callable接口，就要实现call方法，这个方法的返回值是Object</p> <ul><li>实现<strong>Callable</strong>接口通过<strong>FutureTask</strong>包装器来创建Thread线程，调用Thread为</li> <li>线程池，使用<strong>ExecutorService</strong>、Callable、Future实现有返回结果的多线程</li></ul> <h3 id="_3-1-线程启动原理"><a href="#_3-1-线程启动原理" class="header-anchor">#</a> 3.1 线程启动原理</h3> <p>参考</p> <blockquote><ul><li>https://www.jianshu.com/p/8c16aeea7e1a</li> <li>https://www.cnblogs.com/xuyuanpeng/p/11050394.html</li></ul></blockquote> <p>Java多线程，皆始于Thread。Thread是多线程的根，每一个线程的开启都始于Thread的<code>start()</code>方法</p> <h4 id="_3-1-1-start-方法源码"><a href="#_3-1-1-start-方法源码" class="header-anchor">#</a> 3.1.1 start()方法源码</h4> <div class="language-java line-numbers-mode"><pre class="language-java"><code> <span class="token comment">/**
     * Causes this thread to begin execution; the Java Virtual Machine
     * calls the &lt;code&gt;run&lt;/code&gt; method of this thread.
     * 
     * 1、start方法将导致this thread开始执行。由JVM调用this thread的run方法。
     * 
     * The result is that two threads are running concurrently: the
     * current thread (which returns from the call to the
     * &lt;code&gt;start&lt;/code&gt; method) and the other thread (which executes its
     * &lt;code&gt;run&lt;/code&gt; method).
     * 
     * 2、结果是 调用start方法的当前线程 和 执行run方法的另一个线程 同时运行。
     * 
     * It is never legal to start a thread more than once.
     * In particular, a thread may not be restarted once it has completed
     * execution.
     *
     * 3、多次启动线程永远不合法。 特别是，线程一旦完成执行就不会重新启动。
     * 
     * @exception  IllegalThreadStateException  if the thread was already started.
     * 如果线程已启动，则抛出异常。
     * @see        #run()
     * @see        #stop()
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">/**
         * This method is not invoked for the main method thread or &quot;system&quot;
         * group threads created/set up by the VM. Any new functionality added
         * to this method in the future may have to also be added to the VM.
         * 
         * 4、对于由VM创建/设置的main方法线程或“system”组线程，不会调用此方法。 
         *    未来添加到此方法的任何新功能可能也必须添加到VM中。
         * 
         * A zero status value corresponds to state &quot;NEW&quot;.
         * 5、status=0 代表是 status 是 &quot;NEW&quot;。
         */</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>threadStatus <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalThreadStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">/* Notify the group that this thread is about to be started
         * so that it can be added to the group's list of threads
         * and the group's unstarted count can be decremented. 
         * 
         * 6、通知组该线程即将启动，以便将其添加到线程组的列表中，
         *    并且减少线程组的未启动线程数递减。
         * 
         * */</span>
        group<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">boolean</span> started <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token comment">//7、调用native方法，底层开启异步线程，并调用run方法。</span>
            <span class="token function">start0</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            started <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>started<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    group<span class="token punctuation">.</span><span class="token function">threadStartFailed</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> ignore<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">/* do nothing. If start0 threw a Throwable then it will be passed up the call stack 
                 * 8、忽略异常。 如果start0抛出一个Throwable，它将被传递给调用堆栈。
                 */</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

 <span class="token comment">//native方法，JVM创建并启动线程，并调用run方法</span>
 <span class="token keyword">private</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">start0</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br></div></div><blockquote><ul><li><code>start</code>方法用<code>synchronized</code>修饰，为<code>同步方法</code>；</li> <li>虽然为同步方法，但不能避免多次调用问题，用<code>threadStatus</code>来记录线程状态，如果线程被多次start会抛出异常；threadStatus的状态由JVM控制。</li> <li>使用<code>Runnable</code>时，主线程无法捕获子线程中的异常状态。线程的异常，应在线程内部解决。</li></ul></blockquote> <h4 id="_3-1-2-run-方法源码"><a href="#_3-1-2-run-方法源码" class="header-anchor">#</a> 3.1.2 run()方法源码</h4> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">/**
     * If this thread was constructed using a separate
     * &lt;code&gt;Runnable&lt;/code&gt; run object, then that
     * &lt;code&gt;Runnable&lt;/code&gt; object's &lt;code&gt;run&lt;/code&gt; method is called;
     * otherwise, this method does nothing and returns.
     * &lt;p&gt;
     * Subclasses of &lt;code&gt;Thread&lt;/code&gt; should override this method.
     *
     * @see     #start()
     * @see     #stop()
     * @see     #Thread(ThreadGroup, Runnable, String)
     */</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>target <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            target<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>run方法就很简单了，就是回调了Runable的run()接口。导致Thread写的@Overwrite void run() 方法直接是在主线程执行，导致阻塞了主线程。</p> <p>到此我们就知道了，start会使重写的run方法被虚拟机调用，是在子线程中执行的run方法。而直接调用线程的run方法，他是内部回调了run接口，导致直接执行了Runable.run的重写内容。相当于直接在主线程中执行。</p> <h3 id="_3-2-为什么我们调用-start-方法时会执行-run-方法-为什么我们不能直接调用-run-方法"><a href="#_3-2-为什么我们调用-start-方法时会执行-run-方法-为什么我们不能直接调用-run-方法" class="header-anchor">#</a> 3.2 为什么我们调⽤ start() ⽅法时会执⾏ run() ⽅法，为什么我们不能直接调⽤ run() ⽅法？</h3> <p>new ⼀个 Thread，线程进⼊了新建状态;调⽤ start() ⽅法，会启动⼀个线程并使线程进⼊了就绪状 态，当分配到时间⽚后就可以开始运⾏了。 start() 会执⾏线程的相应准备⼯作，然后⾃动执⾏ run() ⽅法的内容，这是真正的多线程⼯作。 ⽽直接执⾏ run() ⽅法，会把 run ⽅法当成⼀个 main 主线程下的普通⽅法去执⾏，并不会在某个线程中执⾏它，所以这并不是多线程⼯作。 总结： 调⽤ start ⽅法⽅可启动线程并使线程进⼊就绪状态，⽽ run ⽅法只是 thread 的⼀个普通 ⽅法调⽤，还是在主线程⾥执⾏。</p> <h3 id="_3-3-继承thread类创建线程"><a href="#_3-3-继承thread类创建线程" class="header-anchor">#</a> 3.3 继承Thread类创建线程</h3> <p>Thread类本质上是实现了Runnable接口的一个实例，代表一个线程的实例。启动线程的唯一方法就是通过Thread类的start()实例方法。start()方法是一个native方法，它将启动一个新线程，并执行run()方法。这种方式实现多线程很简单，通过自己的类直接extend Thread，并复写run()方法，就可以启动新线程并执行自己定义的run()方法。例如：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>  
　　<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  
　　 <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;MyThread.run()&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
　　<span class="token punctuation">}</span>  
<span class="token punctuation">}</span>  
 
<span class="token class-name">MyThread</span> myThread1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token class-name">MyThread</span> myThread2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
myThread1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
myThread2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>这种实现方式是显示的继承了Thread，但从类图中我们可以看到，Thread类本身就继承自Runnable，所以继承Thread的本质依然是实现Runnable接口定义的run方法。</p> <p>需要注意的是继承Thread方式，target对象为null，重写了run方法，导致方式1中的Thread原生的run方法失效，因此并不会调用到target.run()的逻辑，而是直接调用子类重写的run方法。</p> <p>因为java是单根继承，此方式一般不常用。</p> <h3 id="_3-4-实现runnable接口"><a href="#_3-4-实现runnable接口" class="header-anchor">#</a> 3.4 实现Runnable接口</h3> <p>实现run方法，接口的实现类的实例作为<strong>Thread</strong>的<strong>target</strong>作为参数传入带参的<strong>Thread</strong>构造函数，通过调用**start()**方法启动线程。适用于已经有继承的父类无法继承Thread类的时候</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadDemo02</span> <span class="token punctuation">{</span>
 
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span> 
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Thread</span> t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        t1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
 
<span class="token keyword">class</span> <span class="token class-name">MyThread</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// TODO Auto-generated method stub</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">&quot;--&gt;我是通过实现接口的线程实现方式！&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>   
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><h3 id="_3-5-实现callable接口通过futuretask包装器来创建thread线程"><a href="#_3-5-实现callable接口通过futuretask包装器来创建thread线程" class="header-anchor">#</a> 3.5 实现Callable接口通过FutureTask包装器来创建Thread线程</h3> <ul><li>创建Callable接口的实现类 ，并实现Call方法</li> <li>创建Callable实现类的实现，使用FutureTask类包装Callable对象，该FutureTask对象封装了Callable对象的Call方法的返回值</li> <li>使用FutureTask对象作为Thread对象的target创建并启动线程</li> <li>调用FutureTask对象的get()来获取子线程执行结束的返回值</li></ul> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DemoCallable</span> <span class="token keyword">implements</span> <span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
        <span class="token comment">// TODO Auto-generated method stub</span>
        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
        <span class="token class-name">DemoCallable</span> c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DemoCallable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">FutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> future <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span> 
        <span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>future<span class="token punctuation">)</span><span class="token punctuation">;</span>
        t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token class-name">String</span> result <span class="token operator">=</span> future<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//同步获取返回结果</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>这个方法里，明明没有看到run方法，没有看到Runnable，为什么说本质也是实现Runnable接口呢？</p> <p>回看开篇的类图，<code>FutureTask</code>实现了<code>RunnableFuture</code>，<code>RunnableFuture</code>则实现了<code>Runnable</code>和<code>Future</code>两个接口。因此构造Thread时，<code>FutureTask</code>还是被转型为<code>Runnable</code>使用。<strong>因此其本质还是实现Runnable接口。</strong></p> <h3 id="_3-6-通过线程池创建线程"><a href="#_3-6-通过线程池创建线程" class="header-anchor">#</a> 3.6 通过线程池创建线程</h3> <p>ExecutorService、Callable都是属于Executor框架。返回结果的线程是在JDK1.5中引入的新特征，还有Future接口也是属于这个框架，有了这种特征得到返回值就很方便了。
通过分析可以知道，他同样也是实现了Callable接口，实现了Call方法，所以有返回值。这也就是正好符合了前面所说的两种分类</p> <p>执行Callable任务后，可以获取一个Future的对象，在该对象上调用get就可以获取到Callable任务返回的Object了。get方法是阻塞的，即：线程无返回结果，get方法会一直等待。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadDemo05</span><span class="token punctuation">{</span>
 
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> POOL_NUM <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>     <span class="token comment">//线程池数量</span>
 
    <span class="token comment">/**
     * @param args
     * @throws InterruptedException 
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
        <span class="token comment">// TODO Auto-generated method stub</span>
        <span class="token class-name">ExecutorService</span> executorService <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>POOL_NUM<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>  
        <span class="token punctuation">{</span>  
            <span class="token class-name">RunnableThread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RunnableThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
            <span class="token comment">//Thread.sleep(1000);</span>
            executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>thread<span class="token punctuation">)</span><span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>
        <span class="token comment">//关闭线程池</span>
        executorService<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token punctuation">}</span>   
 
<span class="token punctuation">}</span>
 
<span class="token keyword">class</span> <span class="token class-name">RunnableThread</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span>  
<span class="token punctuation">{</span>     
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  
    <span class="token punctuation">{</span>  
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;通过线程池方式创建的线程：&quot;</span> <span class="token operator">+</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot; &quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
 
    <span class="token punctuation">}</span>  
<span class="token punctuation">}</span>  
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br></div></div><h2 id="_4-线程的生命周期和状态"><a href="#_4-线程的生命周期和状态" class="header-anchor">#</a> 4. 线程的⽣命周期和状态?</h2> <p>Java 线程在运⾏的⽣命周期中的指定时刻只可能处于下⾯ 6 种不同状态的其中⼀个状态（图源《Java 并发编程艺术》4.1.4 节）。</p> <p><img src="/assets/img/Thread_life_cycle_state1.bb69a9ce.jpg" alt="线程生命周期状态"></p> <p>线程在⽣命周期中并不是固定处于某⼀个状态⽽是随着代码的执⾏在不同状态之间切换。Java 线程状 态变迁如下图所示（图源《Java 并发编程艺术》4.1.4 节）：</p> <p><img src="/assets/img/Thread_life_cycle_state2.0bea1558.jpg" alt="线程生命周期状态2"></p> <p>由上图可以看出：线程创建之后它将处于 <strong>NEW（新建） 状态</strong>，<strong>调⽤ start() ⽅法后开始运⾏</strong>，线程 这时候处于 <strong>READY（可运⾏） 状态</strong>。可运⾏状态的线程获得了 **CPU 时间⽚（timeslice）**后就处于 <strong>RUNNING（运⾏）</strong> 状态。</p> <p>当线程执⾏ wait() ⽅法之后，线程进⼊ WAITING（等待） 状态。进⼊等待状态的线程需要依靠其他 线程的通知才能够返回到运⾏状态，⽽ TIME_WAITING(超时等待) 状态相当于在等待状态的基础上增加 了超时限制，⽐如通过 sleep（long millis） ⽅法或 wait（long millis） ⽅法可以将 Java 线程置于 TIMED WAITING 状态。当超时时间到达后 Java 线程将会返回到 RUNNABLE 状态。当线程调 ⽤同步⽅法时，在没有获取到锁的情况下，线程将会进⼊到 BLOCKED（阻塞） 状态。线程在执⾏ Runnable 的 run() ⽅法之后将会进⼊到 TERMINATED（终⽌） 状态。</p> <h2 id="_5-什么是上下文切换"><a href="#_5-什么是上下文切换" class="header-anchor">#</a> 5. 什么是上下文切换?</h2> <ul><li>多线程编程中⼀般线程的个数都⼤于 CPU 核⼼的个数，⽽⼀个 CPU 核⼼在任意时刻只能被⼀个线程使 ⽤，为了让这些线程都能得到有效执⾏，CPU 采取的策略是为每个线程分配时间⽚并轮转的形式。当⼀ 个线程的时间⽚⽤完的时候就会重新处于就绪状态让给其他线程使⽤，这个过程就属于⼀次上下⽂切 换。</li> <li>概括来说就是：当前任务在执⾏完 CPU 时间⽚切换到另⼀个任务之前会先保存⾃⼰的状态，以便下次 再切换回这个任务时，可以再加载这个任务的状态。<strong>任务从保存到再加载的过程就是⼀次上下⽂切换</strong>。</li> <li>上下⽂切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒⼏⼗上百次的切换 中，每次切换都需要纳秒量级的时间。所以，上下⽂切换对系统来说意味着消耗⼤量的 CPU 时间，事 实上，可能是操作系统中时间消耗最⼤的操作。</li> <li>Linux 相⽐与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有⼀项就是，其上下⽂切换 和模式切换的时间消耗⾮常少。</li></ul> <h2 id="_6-什么是线程死锁-如何避免死锁"><a href="#_6-什么是线程死锁-如何避免死锁" class="header-anchor">#</a> 6. 什么是线程死锁?如何避免死锁?</h2> <p>线程死锁描述的是这样⼀种情况：多个线程同时被阻塞，它们中的⼀个或者全部都在等待某个资源被释 放。由于线程被⽆限期地阻塞，因此程序不可能正常终⽌。 如下图所示，线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对⽅的资源，所以这两个线 程就会互相等待⽽进⼊死锁状态。</p> <h3 id="_6-1-产生死锁必须具备以下四个条件"><a href="#_6-1-产生死锁必须具备以下四个条件" class="header-anchor">#</a> 6.1 产⽣死锁必须具备以下四个条件</h3> <ul><li>**互斥条件：**该资源任意⼀个时刻只由⼀个线程占⽤。</li> <li>**请求与保持条件：**⼀个进程因请求资源⽽阻塞时，对已获得的资源保持不放。</li> <li>**不剥夺条件：**线程已获得的资源在末使⽤完之前不能被其他线程强⾏剥夺，只有⾃⼰使⽤完毕后 才释放资源。</li> <li>**循环等待条件：**若⼲进程之间形成⼀种头尾相接的循环等待资源关系。</li></ul> <h3 id="_6-2-如何避免线程死锁"><a href="#_6-2-如何避免线程死锁" class="header-anchor">#</a> 6.2 如何避免线程死锁?</h3> <p>只要破坏产⽣死锁的四个条件中的其中⼀个就可以了</p> <ol><li>**破坏互斥条件 ：**这个条件我们没有办法破坏，因为我们⽤锁本来就是想让他们互斥的（临界资 源需要互斥访问）。</li> <li>**破坏请求与保持条件 ：**⼀次性申请所有的资源。</li> <li>**破坏不剥夺条件 ：**占⽤部分资源的线程进⼀步申请其他资源时，如果申请不到，可以主动释放 它占有的资源。</li> <li>**破坏循环等待条件 ：**靠按序申请资源来预防。按某⼀顺序申请资源，释放资源则反序释放。破 坏循环等待条件。</li></ol> <h2 id="_7-说说-sleep-方法和-wait-方法区别和共同点"><a href="#_7-说说-sleep-方法和-wait-方法区别和共同点" class="header-anchor">#</a> 7. 说说 sleep() ⽅法和 wait() ⽅法区别和共同点?</h2> <ul><li>两者最主要的区别在于：<strong>sleep ⽅法没有释放锁，⽽ wait ⽅法释放了锁 。</strong></li> <li>两者都可以暂停线程的执⾏。 Wait 通常被⽤于线程间交互/通信，sleep 通常被⽤于暂停执⾏。</li> <li>wait() ⽅法被调⽤后，线程不会⾃动苏醒，需要别的线程调⽤同⼀个对象上的 notify() 或者 notifyAll() ⽅法。sleep() ⽅法执⾏完成后，线程会⾃动苏醒。或者可以使⽤ wait(long timeout)超时后线程会⾃动苏醒。</li></ul> <h3 id="_7-1-详细"><a href="#_7-1-详细" class="header-anchor">#</a> 7.1 详细</h3> <ol><li>原理不同，<strong>sleep（）方法是Thread类的静态方法</strong>，是线程用来控制自身流程的，它会使此线程暂停执行一段时间，而把执行机会让给其他线程，等到计时时间一到，此线程会自动“苏醒”。例如，当线程执行报时功能时，每一秒钟打印一个时间，那么此时就需要在打印方法前面加上一个Sleep()方法，以便让自己每隔1s执行一次，该过程如同闹钟一样，<strong>而wait（）方法是object类的方法，用于线程间的通信</strong>，这个方法会使当前拥有该对象锁的进程等待，直到其它线程调用notify()方法（或notifyALL方法）时才“醒过来”，不过，开发人员也可以给它指定一个时间，自动“醒”过来。与wait()方法配套的方法还有notify（）方法和notifyALL()方法。</li> <li>对锁的处理机制不同，由于sleep（）方法的主要作用是让线程暂停执行一段时间，时间一到则自动恢复，不涉及线程间的通信，因此，调用sleep（）方法并不会释放锁， 而wait()方法则不同，当调用wan()方法后，线程会释放掉它所占用的锁，从而使线程所在对象中的其他synchronized数据可被别的线程使用。举个简单的例子，如果小明拿遥控器的期间，可以用自己的sleep()方法每隔10min调一次频道，而在这10min里，遥控器还在他的手里。</li> <li>使用的区域不同。由于wait()方法的特殊意义，因此，它必须放在同步控制方法或同步语句块中使用，而 sleep（）方法则可以放在任何地方使用。
sleep（）方法必须捕获异常，而wait（）、notify（）以及notifyALL()不需要捕获异常，在sleep()的过程中，有可能被其他对象调用它的interrupt（），产生interruptException异常。
由于sleep不会释放“锁标志”，容易导致死锁问题的发生，因此，一般情况下，不推荐使用sleep（）方法，而推荐使用wait（）方法。</li></ol> <p>new ⼀个 Thread，线程进⼊了新建状态;调⽤ start() ⽅法，会启动⼀个线程并使线程进⼊了就绪状 态，当分配到时间⽚后就可以开始运⾏了。 start() 会执⾏线程的相应准备⼯作，然后⾃动执⾏ run() ⽅法的内容，这是真正的多线程⼯作。 ⽽直接执⾏ run() ⽅法，会把 run ⽅法当成⼀个 main 线程下的普通⽅法去执⾏，并不会在某个线程中执⾏它，所以这并不是多线程⼯作。 总结： 调⽤ start ⽅法⽅可启动线程并使线程进⼊就绪状态，⽽ run ⽅法只是 thread 的⼀个普通 ⽅法调⽤，还是在主线程⾥执⾏。</p> <h2 id="_9-synchronized-关键字"><a href="#_9-synchronized-关键字" class="header-anchor">#</a> 9. synchronized 关键字</h2> <p>synchronized关键字解决的是多个线程之间访问资源的同步性，synchronized关键字可以保证被它修饰 的⽅法或者代码块在任意时刻只能有⼀个线程执⾏。另外，在 Java 早期版本中，synchronized属于重量级锁，效率低下，<strong>因为监视器锁（monitor）是依 赖于底层的操作系统的 Mutex Lock 来实现的，Java 的线程是映射到操作系统的原⽣线程之上的</strong>。如 果要挂起或者唤醒⼀个线程，都需要操作系统帮忙完成，⽽操作系统实现线程之间的切换时需要从⽤户 态转换到内核态，这个状态之间的转换需要相对⽐较⻓的时间，时间成本相对较⾼，这也是为什么早期 的 synchronized 效率低的原因。庆幸的是在 Java 6 之后 Java 官⽅对从 JVM 层⾯对synchronized 较⼤优化，所以现在的 synchronized 锁效率也优化得很不错了。JDK1.6对锁的实现引⼊了⼤量的优化，如<strong>⾃旋锁、适应性⾃旋锁、锁消除、锁粗化、偏向锁、轻量级锁</strong>等技术来减少锁操作的开销。</p> <h3 id="_9-1-三种使用方式"><a href="#_9-1-三种使用方式" class="header-anchor">#</a> 9.1 三种使用方式</h3> <ul><li>**修饰实例方法，**作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁</li> <li>**修饰静态方法，**作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁 。也就是给当前类加锁，会作
用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是类成员（ static 表明这是该类的一个静态
资源，不管new了多少个对象，只有一份，所以对该类的所有对象都加了锁）。所以如果一个线程A调用一个实
例对象的非静态 synchronized 方法，而线程B需要调用这个实例对象所属类的静态 synchronized 方法，是允
许的，不会发生互斥现象，因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态
synchronized 方法占用的锁是当前实例对象锁。</li> <li>**修饰代码块，**指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。 和 synchronized 方
法一样，synchronized(this)代码块也是锁定当前对象的。synchronized 关键字加到 static 静态方法和
synchronized(class)代码块上都是是给 Class 类上锁。这里再提一下：synchronized关键字加到非 static 静态
方法上是给对象实例上锁。</li></ul> <h3 id="_9-2-synchronized底层实现"><a href="#_9-2-synchronized底层实现" class="header-anchor">#</a> 9.2 synchronized底层实现</h3> <h4 id="_9-2-1-synchronized-同步语句块的情况"><a href="#_9-2-1-synchronized-同步语句块的情况" class="header-anchor">#</a> 9.2.1 synchronized 同步语句块的情况</h4> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SynchronizedDemo</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;synchronized 代码块&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p><img src="/assets/img/synchronized_decompilation.121a6610.jpg" alt="synchronized反编译"></p> <p>synchronized 同步语句块的实现使⽤的是 <strong>monitorenter</strong> 和 <strong>monitorexit</strong> 指令，其中 <strong>monitorenter</strong> 指令指向同步代码块的开始位置，<strong>monitorexit</strong> 指令则指明同步代码块的结束位置。 当执⾏ monitorenter 指令时，线程试图获取锁也就是获取 monitor(<strong>monitor对象存在于每个Java对象的对象 头中，synchronized 锁便是通过这种⽅式获取锁的，也是为什么Java中任意对象可以作为锁的原因</strong>) 的持有权。当计数器为0则可以成功获取，获取后将锁计数器设为1也就是加1。相应的在执⾏ monitorexit 指令后，将锁计数器设为0，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞 等待，直到锁被另外⼀个线程释放为⽌。</p> <h4 id="_9-2-2-synchronized-修饰方法的的情况"><a href="#_9-2-2-synchronized-修饰方法的的情况" class="header-anchor">#</a> 9.2.2 synchronized 修饰⽅法的的情况</h4> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SynchronizedDemo2</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;synchronized ⽅法&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><img src="/assets/img/synchronized_method_decompilation.c5b07b9b.jpg" alt="synchronized方法反编译"></p> <p>synchronized 修饰的⽅法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是 ACC_SYNCHRONIZED 标识，该标识指明了该⽅法是⼀个同步⽅法，<strong>JVM 通过该 ACC_SYNCHRONIZED 访问 标志来辨别⼀个⽅法是否声明为同步⽅法</strong>，从⽽执⾏相应的同步调⽤。</p> <h3 id="_9-3-说说-jdk1-6-之后的synchronized-关键字底层做了哪些优化-可以详细介绍一下这些优化吗"><a href="#_9-3-说说-jdk1-6-之后的synchronized-关键字底层做了哪些优化-可以详细介绍一下这些优化吗" class="header-anchor">#</a> 9.3 说说 JDK1.6 之后的synchronized 关键字底层做了哪些优化，可以详细介绍⼀下这些优化吗</h3> <p>参考</p> <blockquote><ul><li>https://gitee.com/SnailClimb/JavaGuide/blob/master/docs/java/Multithread/synchronized.md</li></ul></blockquote> <p>JDK1.6 对锁的实现引入了大量的优化，如<strong>偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化</strong>等技术来减少锁操作的开销。</p> <p>锁主要存在四中状态，依次是：</p> <ul><li><strong>无锁状态</strong></li> <li><strong>偏向锁状态</strong></li> <li><strong>轻量级锁状态</strong></li> <li><strong>重量级锁状态</strong></li></ul> <p>他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。</p> <h4 id="_1-偏向锁"><a href="#_1-偏向锁" class="header-anchor">#</a> ① 偏向锁</h4> <p><strong>引入偏向锁的目的和引入轻量级锁的目的很像，他们都是为了没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。但是不同是：轻量级锁在无竞争的情况下使用 CAS 操作去代替使用互斥量。而偏向锁在无竞争的情况下会把整个同步都消除掉</strong>。</p> <p>偏向锁的“偏”就是偏心的偏，它的意思是会偏向于第一个获得它的线程，如果在接下来的执行中，该锁没有被其他线程获取，那么持有偏向锁的线程就不需要进行同步！关于偏向锁的原理可以查看《深入理解Java虚拟机：JVM高级特性与最佳实践》第二版的13章第三节锁优化。</p> <p>但是对于锁竞争比较激烈的场合，偏向锁就失效了，因为这样场合极有可能每次申请锁的线程都是不相同的，因此这种场合下不应该使用偏向锁，否则会得不偿失，需要注意的是，偏向锁失败后，并不会立即膨胀为重量级锁，而是先升级为轻量级锁。</p> <h4 id="_2-轻量级锁"><a href="#_2-轻量级锁" class="header-anchor">#</a> ② 轻量级锁</h4> <p>倘若偏向锁失败，虚拟机并不会立即升级为重量级锁，它还会尝试使用一种称为轻量级锁的优化手段(1.6之后加入的)。<strong>轻量级锁不是为了代替重量级锁，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗，因为使用轻量级锁时，不需要申请互斥量。另外，轻量级锁的加锁和解锁都用到了CAS操作。</strong> 关于轻量级锁的加锁和解锁的原理可以查看《深入理解Java虚拟机：JVM高级特性与最佳实践》第二版的13章第三节锁优化。</p> <p><strong>轻量级锁能够提升程序同步性能的依据是“对于绝大部分锁，在整个同步周期内都是不存在竞争的”，这是一个经验数据。如果没有竞争，轻量级锁使用 CAS 操作避免了使用互斥操作的开销。但如果存在锁竞争，除了互斥量开销外，还会额外发生CAS操作，因此在有锁竞争的情况下，轻量级锁比传统的重量级锁更慢！如果锁竞争激烈，那么轻量级将很快膨胀为重量级锁！</strong></p> <h4 id="_3-自旋锁和自适应自旋"><a href="#_3-自旋锁和自适应自旋" class="header-anchor">#</a> ③ 自旋锁和自适应自旋</h4> <p>轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的优化手段。</p> <p>互斥同步对性能最大的影响就是阻塞的实现，因为挂起线程/恢复线程的操作都需要转入内核态中完成（用户态转换到内核态会耗费时间）。</p> <p><strong>一般线程持有锁的时间都不是太长，所以仅仅为了这一点时间去挂起线程/恢复线程是得不偿失的。</strong> 所以，虚拟机的开发团队就这样去考虑：“我们能不能让后面来的请求获取锁的线程等待一会而不被挂起呢？看看持有锁的线程是否很快就会释放锁”。<strong>为了让一个线程等待，我们只需要让线程执行一个忙循环（自旋），这项技术就叫做自旋</strong>。</p> <p>百度百科对自旋锁的解释：</p> <blockquote><p>何谓自旋锁？它是为实现保护共享资源而提出一种锁机制。其实，自旋锁与互斥锁比较类似，它们都是为了解决对某项资源的互斥使用。无论是互斥锁，还是自旋锁，在任何时刻，最多只能有一个保持者，也就说，在任何时刻最多只能有一个执行单元获得锁。但是两者在调度机制上略有不同。对于互斥锁，如果资源已经被占用，资源申请者只能进入睡眠状态。但是自旋锁不会引起调用者睡眠，如果自旋锁已经被别的执行单元保持，调用者就一直循环在那里看是否该自旋锁的保持者已经释放了锁，&quot;自旋&quot;一词就是因此而得名。</p></blockquote> <p>自旋锁在 JDK1.6 之前其实就已经引入了，不过是默认关闭的，需要通过<code>--XX:+UseSpinning</code>参数来开启。JDK1.6及1.6之后，就改为默认开启的了。需要注意的是：自旋等待不能完全替代阻塞，因为它还是要占用处理器时间。如果锁被占用的时间短，那么效果当然就很好了！反之，相反！自旋等待的时间必须要有限度。如果自旋超过了限定次数任然没有获得锁，就应该挂起线程。<strong>自旋次数的默认值是10次，用户可以修改<code>--XX:PreBlockSpin</code>来更改</strong>。</p> <p>另外,<strong>在 JDK1.6 中引入了自适应的自旋锁。自适应的自旋锁带来的改进就是：自旋的时间不在固定了，而是和前一次同一个锁上的自旋时间以及锁的拥有者的状态来决定，虚拟机变得越来越“聪明”了</strong>。</p> <h4 id="_4-锁消除"><a href="#_4-锁消除" class="header-anchor">#</a> ④ 锁消除</h4> <p>锁消除理解起来很简单，它指的就是虚拟机即使编译器在运行时，如果检测到那些共享数据不可能存在竞争，那么就执行锁消除。锁消除可以节省毫无意义的请求锁的时间。</p> <h4 id="_5-锁粗化"><a href="#_5-锁粗化" class="header-anchor">#</a> ⑤ 锁粗化</h4> <p>原则上，我们在编写代码的时候，总是推荐将同步块的作用范围限制得尽量小，——直在共享数据的实际作用域才进行同步，这样是为了使得需要同步的操作数量尽可能变小，如果存在锁竞争，那等待线程也能尽快拿到锁。</p> <p>大部分情况下，上面的原则都是没有问题的，但是如果一系列的连续操作都对同一个对象反复加锁和解锁，那么会带来很多不必要的性能消耗。</p> <h3 id="_9-4-synchronized-和-reentrantlock-的对比"><a href="#_9-4-synchronized-和-reentrantlock-的对比" class="header-anchor">#</a> 9.4 Synchronized 和 ReenTrantLock 的对比</h3> <h4 id="_1-两者都是可重入锁"><a href="#_1-两者都是可重入锁" class="header-anchor">#</a> ① 两者都是可重入锁</h4> <p>两者都是可重入锁。“可重入锁”概念是：自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。</p> <h4 id="_2-synchronized-依赖于-jvm-而-reentrantlock-依赖于-api"><a href="#_2-synchronized-依赖于-jvm-而-reentrantlock-依赖于-api" class="header-anchor">#</a> ② synchronized 依赖于 JVM 而 ReenTrantLock 依赖于 API</h4> <p>synchronized 是依赖于 JVM 实现的，前面我们也讲到了 虚拟机团队在 JDK1.6 为 synchronized 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。ReenTrantLock 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock 方法配合 try/finally 语句块来完成），所以我们可以通过查看它的源代码，来看它是如何实现的。</p> <h4 id="_3-reentrantlock-比-synchronized-增加了一些高级功能"><a href="#_3-reentrantlock-比-synchronized-增加了一些高级功能" class="header-anchor">#</a> ③ ReenTrantLock 比 synchronized 增加了一些高级功能</h4> <p>相比synchronized，ReenTrantLock增加了一些高级功能。主要来说主要有三点：</p> <blockquote><ol><li>等待可中断</li> <li>可指定公平和非公平锁</li> <li>可实现选择性通知（锁可以绑定多个条件）</li></ol></blockquote> <div class="custom-block info"><p class="custom-block-title">ReenTrantLock 比 synchronized 增加了一些高级功能</p> <ul><li><strong>ReenTrantLock提供了一种能够中断等待锁的线程的机制</strong>，通过**lock.lockInterruptibly()**来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。</li> <li><strong>ReenTrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。</strong> ReenTrantLock默认情况是非公平的，可以通过 ReenTrantLock类的<code>ReentrantLock(boolean fair)</code>构造方法来制定是否是公平的。</li> <li><strong>synchronized关键字与wait()和notify/notifyAll()方法相结合可以实现等待/通知机制</strong>，ReentrantLock类当然也可以实现，但是需要借助于Condition接口与newCondition() 方法。Condition是JDK1.5之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个Lock对象中可以创建多个Condition实例（即对象监视器），<strong>线程对象可以注册在指定的Condition中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用notify/notifyAll()方法进行通知时，被通知的线程是由 JVM 选择的，用ReentrantLock类结合Condition实例可以实现“选择性通知”</strong> ，这个功能非常重要，而且是Condition接口默认提供的。而synchronized关键字就相当于整个Lock对象中只有一个Condition实例，所有的线程都注册在它一个身上。如果执行notifyAll()方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，而Condition实例的signalAll()方法 只会唤醒注册在该Condition实例中的所有等待线程。</li></ul> <p>如果你想使用上述功能，那么选择ReenTrantLock是一个不错的选择。</p> <p><strong>synchronized 异常就会释放锁，而 ReenTrantLock 异常需要在 finally 里 unlock</strong></p></div> <h4 id="_4-性能已不是选择标准"><a href="#_4-性能已不是选择标准" class="header-anchor">#</a> ④ 性能已不是选择标准</h4> <p>在JDK1.6之前，synchronized 的性能是比 ReenTrantLock 差很多。<strong>具体表示为：synchronized 关键字吞吐量随线程数的增加，下降得非常严重。而ReenTrantLock 基本保持一个比较稳定的水平</strong>。我觉得这也侧面反映了， synchronized 关键字还有非常大的优化余地。后续的技术发展也证明了这一点，我们上面也讲了在 JDK1.6 之后 JVM 团队对 synchronized 关键字做了很多优化。<strong>JDK1.6 之后，synchronized 和 ReenTrantLock 的性能基本是持平了。所以网上那些说因为性能才选择 ReenTrantLock 的文章都是错的！JDK1.6之后，性能已经不是选择synchronized和ReenTrantLock的影响因素了！而且虚拟机在未来的性能改进中会更偏向于原生的synchronized，所以还是提倡在synchronized能满足你的需求的情况下，优先考虑使用synchronized关键字来进行同步！优化后的synchronized和ReenTrantLock一样，在很多地方都是用到了CAS操作</strong>。</p> <h2 id="_10-volatile关键字"><a href="#_10-volatile关键字" class="header-anchor">#</a> 10. volatile关键字</h2> <p>参考</p> <blockquote><ul><li><a href="https://www.cnblogs.com/dolphin0520/p/3920373.html" target="_blank" rel="noopener noreferrer">Java并发编程：volatile关键字解析<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://www.cnblogs.com/java1024/p/9031560.html" target="_blank" rel="noopener noreferrer">Java面试官最常问的volatile关键字<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></blockquote> <h3 id="_10-1-两大特性"><a href="#_10-1-两大特性" class="header-anchor">#</a> 10.1 两大特性</h3> <ul><li>保证了不同线程对该变量操作的<strong>内存可见性</strong></li> <li>禁止指令重排序</li></ul> <h3 id="_10-2-java内存模型与volatile"><a href="#_10-2-java内存模型与volatile" class="header-anchor">#</a> 10.2 Java内存模型与volatile</h3> <p>在 <strong>JDK1.2</strong> 之前，Java的内存模型实现总是从主存（即共享内存）读取变量，是不需要进⾏特别的注意 的。⽽在当前的 Java 内存模型下，线程可以把变量保存本地内存（⽐如机器的寄存器）中，⽽不是直 接在主存中进⾏读写。<strong>这就可能造成⼀个线程在主存中修改了⼀个变量的值，⽽另外⼀个线程还继续使 ⽤它在寄存器中的变量值的拷⻉，造成数据的不⼀致</strong>。</p> <p><img src="/assets/img/Java_memory_model_and_volatile_1.7a9fe626.jpg" alt="Java内存模型和volatile1"></p> <p>要解决这个问题，就需要把变量声明为<strong>volatile</strong>，这就指示 JVM，这个变量是不稳定的，每次使⽤它都 到主存中进⾏读取。 说⽩了， <strong>volatile 关键字的主要作⽤就是保证变量的可⻅性然后还有⼀个作⽤是防⽌指令重排序。</strong></p> <p><img src="/assets/img/Java_memory_model_and_volatile_2.3207c656.jpg" alt="Java内存模型和volatile2"></p> <h3 id="_10-3-并发编程的三个重要特性"><a href="#_10-3-并发编程的三个重要特性" class="header-anchor">#</a> 10.3 并发编程的三个重要特性</h3> <ol><li><strong>原⼦性 :</strong> ⼀个的操作或者多次操作，要么所有的操作全部都得到执⾏并且不会收到任何因素的 ⼲扰⽽中断，要么所有的操作都执⾏，要么都不执⾏。 <strong>synchronized 可以保证代码⽚段的原⼦性。</strong></li> <li>**可⻅性 ：**当⼀个变量对共享变量进⾏了修改，那么另外的线程都是⽴即可以看到修改后的最新 值。 <strong>volatile 关键字可以保证共享变量的可⻅性。</strong></li> <li>**有序性 ：**代码在执⾏的过程中的先后顺序，Java 在编译器以及运⾏期间的优化，代码的执⾏顺序未必就是编写代码时候的顺序。 <strong>volatile 关键字可以禁⽌指令进⾏重排序优化。</strong></li></ol> <h3 id="_10-4-内存可见性"><a href="#_10-4-内存可见性" class="header-anchor">#</a> 10.4 内存可见性</h3> <p><img src="/assets/img/Memory_visibility.c2e7cef1.jpg" alt="内存可见性"></p> <h2 id="_11-synchronized-volatile-关键字的区别"><a href="#_11-synchronized-volatile-关键字的区别" class="header-anchor">#</a> 11. synchronized | volatile 关键字的区别</h2> <ul><li>volatile关键字是线程同步的轻量级实现，所以volatile性能肯定⽐synchronized关键字要好。 <strong>但是volatile关键字只能⽤于变量⽽synchronized关键字可以修饰⽅法以及代码块。</strong> synchronized关键字在JavaSE1.6之后进⾏了主要包括为了减少获得锁和释放锁带来的性能消耗 ⽽引⼊的偏向锁和轻量级锁以及其它各种优化之后执⾏效率有了显著提升，实际开发中使⽤ synchronized 关键字的场景还是更多⼀些。</li> <li><strong>多线程访问volatile关键字不会发⽣阻塞，⽽synchronized关键字可能会发⽣阻塞</strong></li> <li><strong>volatile关键字能保证数据的可⻅性，但不能保证数据的原⼦性。synchronized关键字两者都能 保证。</strong></li> <li><strong>volatile关键字主要⽤于解决变量在多个线程之间的可⻅性，⽽ synchronized关键字解决的是 多个线程之间访问资源的同步性。</strong></li></ul> <h2 id="_12-java线程池"><a href="#_12-java线程池" class="header-anchor">#</a> 12. Java线程池</h2> <h3 id="_12-1-好处"><a href="#_12-1-好处" class="header-anchor">#</a> 12.1 好处</h3> <ul><li>降低资源消耗。通过重复利⽤已创建的线程降低线程创建和销毁造成的消耗。</li> <li>提⾼响应速度。当任务到达时，任务可以不需要的等到线程创建就能⽴即执⾏。</li> <li>提⾼线程的可管理性。线程是稀缺资源，如果⽆限制的创建，不仅会消耗系统资源，还会降低系 统的稳定性，使⽤线程池可以进⾏统⼀的分配，调优和监控。</li></ul> <h3 id="_12-2-创建线程池"><a href="#_12-2-创建线程池" class="header-anchor">#</a> 12.2 创建线程池</h3> <p>参考</p> <blockquote><ul><li>https://www.cnblogs.com/teach/p/10903164.html</li></ul></blockquote> <p>《阿⾥巴巴Java开发⼿册》中强制<strong>线程池不允许使⽤ Executors 去创建</strong>，⽽是通过 <strong>ThreadPoolExecutor</strong> 的⽅式，这样的处理⽅式让写的同学更加明确线程池的运⾏规则，规避资源耗尽的⻛险</p> <h4 id="_12-2-1-executors创建线程池弊端"><a href="#_12-2-1-executors创建线程池弊端" class="header-anchor">#</a> 12.2.1 Executors创建线程池弊端</h4> <ul><li><strong>FixedThreadPool</strong> 和 <strong>SingleThreadExecutor</strong> ： 允许请求的队列⻓度为 <strong>Integer.MAX_VALUE</strong> ，可能堆积⼤量的请求，从⽽导致OOM。</li> <li><strong>CachedThreadPool</strong> 和 <strong>ScheduledThreadPool</strong> ： 允许创建的线程数量为 <strong>Integer.MAX_VALUE</strong> ，可能会创建⼤量线程，从⽽导致OOM。</li></ul> <h4 id="_12-2-2-第一种方式-threadpoolexecutor的方式"><a href="#_12-2-2-第一种方式-threadpoolexecutor的方式" class="header-anchor">#</a> 12.2.2 第一种方式：ThreadPoolExecutor的方式</h4> <p><img src="/assets/img/ThreadPoolExecutor_construction.1fbfd772.jpg" alt="ThreadPoolExecutor构造方法"></p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span>
                              <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span>
                              <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span>
                              <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">,</span>
                              <span class="token class-name">BlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span> workQueue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">(</span>corePoolSize<span class="token punctuation">,</span> maximumPoolSize<span class="token punctuation">,</span> keepAliveTime<span class="token punctuation">,</span> unit<span class="token punctuation">,</span> workQueue<span class="token punctuation">,</span>
             <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">defaultThreadFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> defaultHandler<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>在这个方法中调用了另外的一个构造方法，即上图中四个构造方法中的第四个，从源码中得知，一个线程池包含的属性共有corePoolSize、maximumPoolSize、keepAliveTime、unit、workQueue、threadFactory、handler七个</p> <p>需要传入的参数说明</p> <table><thead><tr><th>序号</th> <th>名称</th> <th>类型</th> <th>含义</th></tr></thead> <tbody><tr><td>1</td> <td>corePoolSize</td> <td>int</td> <td>线程池的核心线程数</td></tr> <tr><td>2</td> <td>maximumPoolSize</td> <td>int</td> <td>线程池的最大线程数</td></tr> <tr><td>3</td> <td>keepAliveTime</td> <td>long</td> <td>线程池空闲时线程的存活时长</td></tr> <tr><td>4</td> <td>unit</td> <td>TimeUnit</td> <td>线程存活时长时间单位</td></tr> <tr><td>5</td> <td>workQueue</td> <td>BlockingQueue&lt;Runnable&gt;</td> <td>线程等待队列</td></tr> <tr><td>6</td> <td>threadFactory</td> <td>ThreadFactory</td> <td>线程池创建线程的工厂</td></tr> <tr><td>7</td> <td>handler</td> <td>RejectedExecutionHandler</td> <td>拒绝策略</td></tr></tbody></table> <ul><li><strong>handler</strong>：在队列（workQueue）和线程池达到最大线程数（maximumPoolSize）均满时仍有任务的情况下的处理方式；</li></ul> <div class="custom-block info"><p class="custom-block-title">规则</p> <ul><li>线程池的线程数量长期维持在 <code>corePoolSize</code> 个（核心线程数量）</li> <li>线程池的线程数量最大可以扩展到 <code>maximumPoolSize</code> 个</li> <li>在 <code>corePoolSize</code> ~ <code>maximumPoolSize</code> 这个区间的线程，一旦空闲超过<code>keepAliveTime</code>时间，就会被杀掉（时间单位）</li> <li>送来工作的线程数量超过最大数以后，送到 <code>workQueue</code> 里面待业</li> <li>待业队伍也满了，就按照事先约定的策略 <code>RejectedExecutionHandler</code> 给拒绝掉</li></ul></div> <p>我们再来看中间的两个构造方法，和第一个的区别在于，<strong>第二个和第三个指定了创建线程的工厂和线程池满时的处理策略。</strong></p> <h4 id="_12-2-3-第二种方式-通过executor-框架的工具类executors来实现"><a href="#_12-2-3-第二种方式-通过executor-框架的工具类executors来实现" class="header-anchor">#</a> 12.2.3 第二种方式：通过Executor 框架的⼯具类Executors来实现</h4> <blockquote><ul><li><p><strong>FixedThreadPool</strong> ： 该⽅法返回⼀个固定线程数量的线程池。该线程池中的线程数量始终不 变。当有⼀个新的任务提交时，线程池中若有空闲线程，则⽴即执⾏。若没有，则新的任务会被 暂存在⼀个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</p></li> <li><p><strong>SingleThreadExecutor</strong>： ⽅法返回⼀个只有⼀个线程的线程池。若多余⼀个任务被提交到该线 程池，任务会被保存在⼀个任务队列中，待线程空闲，按先⼊先出的顺序执⾏队列中的任务。</p></li> <li><p><strong>CachedThreadPool</strong>： 该⽅法返回⼀个可根据实际情况调整线程数量的线程池。线程池的线程数 量不确定，但若有空闲线程可以复⽤，则会优先使⽤可复⽤的线程。若所有线程均在⼯作，⼜有 新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执⾏完毕后，将返回线程池进 ⾏复⽤。</p></li></ul></blockquote> <p><img src="/assets/img/Executos_tool_class_method.28bf643c.jpg" alt="Executos工具类的方法"></p> <p><img src="/assets/img/Through_construction_of_ThraPoolExecutor_class.992a6479.jpg" alt="通过ThreaPoolExecutor类的构造方法"></p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">ExecutorService</span> <span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token keyword">int</span> nThreads<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span>nThreads<span class="token punctuation">,</span> nThreads<span class="token punctuation">,</span>
                                      <span class="token number">0L</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">,</span>
                                      <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>从上面的代码中可以看出，其返回的是<strong>ThreaPoolExecutor</strong>对象，调用的是ThreaPoolExecutor类四个构造方法中的第一个。</p> <p>总结，上面两种创建线程池的方式，其本质都是通过<strong>ThreaPoolExecutor</strong>类的构造方法的方式，所以<strong>ThreaPoolExecutor</strong>是重点。</p> <h3 id="_12-3-threadpoolexecutor-类分析"><a href="#_12-3-threadpoolexecutor-类分析" class="header-anchor">#</a> 12.3 ThreadPoolExecutor 类分析</h3> <p>参考</p> <blockquote><ul><li>https://www.jianshu.com/p/c41e942bcd64</li></ul></blockquote> <p><img src="data:image/jpeg;base64,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" alt="ThreadPoolExecutor的类图"></p> <p>当在execute(Runnable)方法中提交新任务并且少于corePoolSize线程正在运行时，即使其他工作线程处于空闲状态，也会创建一个新线程来处理该请求。 如果有多于corePoolSize但小于maximumPoolSize线程正在运行，则仅当队列已满时才会创建新线程。 通过设置corePoolSize和maximumPoolSize相同，您可以创建一个固定大小的线程池。 通过将maximumPoolSize设置为基本上无界的值，例如Integer.MAX_VALUE，您可以允许池容纳任意数量的并发任务。 通常，核心和最大池大小仅在构建时设置，但也可以使用<code>setCorePoolSize</code>和<code>setMaximumPoolSize</code>进行动态更改。</p> <h3 id="_12-4-拒绝策略"><a href="#_12-4-拒绝策略" class="header-anchor">#</a> 12.4 拒绝策略</h3> <div class="custom-block tip"><p class="custom-block-title">参考</p> <ul><li>https://www.jianshu.com/p/f0506e098c5b</li></ul></div> <p>所有拒绝策略都实现了接口<code>RejectedExecutionHandler</code></p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">RejectedExecutionHandler</span> <span class="token punctuation">{</span>

    <span class="token comment">/**
     * @param r the runnable task requested to be executed
     * @param executor the executor attempting to execute this task
     * @throws RejectedExecutionException if there is no remedy
     */</span>
    <span class="token keyword">void</span> <span class="token function">rejectedExecution</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> r<span class="token punctuation">,</span> <span class="token class-name">ThreadPoolExecutor</span> executor<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><blockquote><p>这个接口只有一个 rejectedExecution 方法。</p> <p>r 为待执行任务；executor 为线程池；方法可能会抛出拒绝异常。</p></blockquote> <table><thead><tr><th>拒绝策略</th> <th>说明</th></tr></thead> <tbody><tr><td>AbortPolicy</td> <td>直接抛出拒绝异常（默认策略）</td></tr> <tr><td>CallerRunsPolicy</td> <td>在调用者线程中，运行当前被丢弃的任务。</td></tr> <tr><td>DiscardOledestPolicy</td> <td>丢弃队列中最老的，然后再次尝试提交新任务。</td></tr> <tr><td>DiscardPolicy</td> <td>默默丢弃无法加载的任务。</td></tr></tbody></table> <h4 id="_12-4-1-abortpolicy-默认策略"><a href="#_12-4-1-abortpolicy-默认策略" class="header-anchor">#</a> 12.4.1 AbortPolicy（默认策略）</h4> <p>直接抛出拒绝异常（继承自RuntimeException），会中断调用者的处理过程，所以除非有明确需求，一般不推荐</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">AbortPolicy</span> <span class="token keyword">implements</span> <span class="token class-name">RejectedExecutionHandler</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">rejectedExecution</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> r<span class="token punctuation">,</span> <span class="token class-name">ThreadPoolExecutor</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RejectedExecutionException</span><span class="token punctuation">(</span><span class="token string">&quot;Task &quot;</span> <span class="token operator">+</span> r<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span>
                                             <span class="token string">&quot; rejected from &quot;</span> <span class="token operator">+</span>
                                             e<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h4 id="_12-4-2-callerrunspolicy"><a href="#_12-4-2-callerrunspolicy" class="header-anchor">#</a> 12.4.2 CallerRunsPolicy</h4> <p>在调用者线程中（也就是说谁把 r 这个任务甩来的），运行当前被丢弃的任务。</p> <p>只会用调用者所在线程来运行任务，也就是说任务不会进入线程池。</p> <p>如果线程池已经被关闭，则直接丢弃该任务。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">CallerRunsPolicy</span> <span class="token keyword">implements</span> <span class="token class-name">RejectedExecutionHandler</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">rejectedExecution</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> r<span class="token punctuation">,</span> <span class="token class-name">ThreadPoolExecutor</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>e<span class="token punctuation">.</span><span class="token function">isShutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            r<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h4 id="_12-4-3-discardoledestpolicy"><a href="#_12-4-3-discardoledestpolicy" class="header-anchor">#</a> 12.4.3 DiscardOledestPolicy</h4> <p>丢弃队列中最老的，然后再次尝试提交新任务。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">DiscardOldestPolicy</span> <span class="token keyword">implements</span> <span class="token class-name">RejectedExecutionHandler</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">rejectedExecution</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> r<span class="token punctuation">,</span> <span class="token class-name">ThreadPoolExecutor</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>e<span class="token punctuation">.</span><span class="token function">isShutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">getQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            e<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>这里 e.getQueue() 是获得待执行的任务队列，也就是前面提到的待业队列。</p> <p>因为是队列，所以先进先出，一个poll()方法就能直接把队列中最老的抛弃掉，再次尝试执行execute(r)。</p> <p>这个队列在线程池定义的时候就能看到，是一个阻塞队列</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>    <span class="token comment">/**
     * The queue used for holding tasks and handing off to worker
     * threads.  We do not require that workQueue.
     */</span>     
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">BlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span> workQueue<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">BlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span> <span class="token function">getQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> workQueue<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h4 id="_12-4-4-discardpolicy"><a href="#_12-4-4-discardpolicy" class="header-anchor">#</a> 12.4.4 DiscardPolicy</h4> <p>默默丢弃无法加载的任务。</p> <p>这个代码就很简单了，真的是啥也没做</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">DiscardPolicy</span> <span class="token keyword">implements</span> <span class="token class-name">RejectedExecutionHandler</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">rejectedExecution</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> r<span class="token punctuation">,</span> <span class="token class-name">ThreadPoolExecutor</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h4 id="_12-4-5-自定义"><a href="#_12-4-5-自定义" class="header-anchor">#</a> 12.4.5 自定义</h4> <p>通过实现 <code>RejectedExecutionHandler</code> 接口扩展</p> <p>jdk内置的四种拒绝策略（都在ThreadPoolExecutor.java里面）代码都很简洁易懂。</p> <p>我们只要继承接口都可以根据自己需要自定义拒绝策略。下面看两个例子。</p> <p>一是netty自己实现的线程池里面私有的一个拒绝策略。单独启动一个新的临时线程来执行任务。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">NewThreadRunsPolicy</span> <span class="token keyword">implements</span> <span class="token class-name">RejectedExecutionHandler</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">rejectedExecution</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> r<span class="token punctuation">,</span> <span class="token class-name">ThreadPoolExecutor</span> executor<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token keyword">final</span> <span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>r<span class="token punctuation">,</span> <span class="token string">&quot;Temporary task executor&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RejectedExecutionException</span><span class="token punctuation">(</span>
                <span class="token string">&quot;Failed to start a new thread&quot;</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>另外一个是dubbo的一个例子，它直接继承的 AbortPolicy ，加强了日志输出，并且输出dump文件</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AbortPolicyWithReport</span> <span class="token keyword">extends</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">.</span><span class="token class-name">AbortPolicy</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">rejectedExecution</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> r<span class="token punctuation">,</span> <span class="token class-name">ThreadPoolExecutor</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">String</span> msg <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">&quot;Thread pool is EXHAUSTED!&quot;</span> <span class="token operator">+</span>
                        <span class="token string">&quot; Thread Name: %s, Pool Size: %d (active: %d, core: %d, max: %d, largest: %d), Task: %d (completed: %d),&quot;</span> <span class="token operator">+</span>
                        <span class="token string">&quot; Executor status:(isShutdown:%s, isTerminated:%s, isTerminating:%s), in %s://%s:%d!&quot;</span><span class="token punctuation">,</span>
                threadName<span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">getPoolSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">getActiveCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">getCorePoolSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">getMaximumPoolSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">getLargestPoolSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                e<span class="token punctuation">.</span><span class="token function">getTaskCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">getCompletedTaskCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">isShutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">isTerminated</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">isTerminating</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                url<span class="token punctuation">.</span><span class="token function">getProtocol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> url<span class="token punctuation">.</span><span class="token function">getIp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> url<span class="token punctuation">.</span><span class="token function">getPort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        logger<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">dumpJStack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RejectedExecutionException</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><h3 id="_12-5-线程池执行流程"><a href="#_12-5-线程池执行流程" class="header-anchor">#</a> 12.5 线程池执行流程</h3> <h2 id="_13-java-util-concurrent"><a href="#_13-java-util-concurrent" class="header-anchor">#</a> 13. java.util.concurrent</h2> <p>参考</p> <blockquote><ul><li>https://blog.csdn.net/starbxx/article/details/95333992</li> <li><a href="http://tutorials.jenkov.com/java-util-concurrent/index.html" target="_blank" rel="noopener noreferrer">Jakob Jenkov博客<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://blog.csdn.net/defonds/article/details/44021605" target="_blank" rel="noopener noreferrer">Jakob Jenkov博客中文翻译<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://blog.csdn.net/dichengyan0013/article/details/102347395?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param" target="_blank" rel="noopener noreferrer">java并发包java.util.concurrent详解博客导航<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></blockquote> <p><code>java.util.concurrent</code> 是在<code>并发编程</code>中很常用的实用工具类，称为<code>JUC</code>，在<code>JDK5</code>中开始发布</p> <p>在java.util下的集合都是发生<code>fail-fast</code>，而在java.util.concurrent下的发生的都是<code>fail-safe</code></p> <h3 id="线程池相关类"><a href="#线程池相关类" class="header-anchor">#</a> 线程池相关类</h3> <p><img src="/assets/img/Thread_pool_related_classes.9d8d8ea2.png" alt="线程池相关类"></p> <h3 id="阻塞队列相关类"><a href="#阻塞队列相关类" class="header-anchor">#</a> 阻塞队列相关类</h3> <p><img src="/assets/img/Blocking_queue_related_classes.ef8e9022.png" alt="阻塞队列相关类"></p> <h3 id="concurrentmap类"><a href="#concurrentmap类" class="header-anchor">#</a> ConcurrentMap类</h3> <p><img src="/assets/img/ConcurrentMap_class.5d722214.png" alt="ConcurrentMap_class"></p> <h3 id="多线程其他类"><a href="#多线程其他类" class="header-anchor">#</a> 多线程其他类</h3> <p><img src="/assets/img/Multithreading_other_classes.879585d2.png" alt="多线程其他类"></p> <h3 id="cas"><a href="#cas" class="header-anchor">#</a> CAS</h3> <p>参考</p> <blockquote><ul><li>https://blog.csdn.net/v123411739/article/details/79561458</li> <li>https://www.jianshu.com/p/ab2c8fce878b</li></ul></blockquote> <h4 id="概述"><a href="#概述" class="header-anchor">#</a> 概述</h4> <p><code>CAS（Compare-and-Swap）</code>，即比较并替换，是一种实现并发算法时常用到的技术，Java并发包中的很多类都使用了<code>CAS</code>技术。CAS是一种<code>无锁算法</code>，CAS有3个操作数</p> <blockquote><ul><li>内存值V</li> <li>旧的预期值A</li> <li>要修改的新值B。</li></ul></blockquote> <p>当且仅当<code>预期值A</code>和<code>内存值V</code>相同时(说明此时内存中的值没有被其他线程改变)，将<code>内存值V</code>修改为<code>B</code>，否则什么都不做。</p> <p>CAS比较与交换的伪代码可以表示为：</p> <blockquote><p>do{</p> <p>备份旧数据；</p> <p>基于旧数据构造新数据；</p> <p>}while(!CAS( 内存地址，备份的旧数据，新数据 ))</p></blockquote> <hr> <p><img src="data:image/jpeg;base64,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" alt="CAS算法理解"></p> <p>参考<code>getAndAddInt</code>方法源码</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getAndAddInt</span><span class="token punctuation">(</span><span class="token class-name">Object</span> var1<span class="token punctuation">,</span> <span class="token keyword">long</span> var2<span class="token punctuation">,</span> <span class="token keyword">int</span> var4<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> var5<span class="token punctuation">;</span>
        <span class="token keyword">do</span> <span class="token punctuation">{</span>
            var5 <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getIntVolatile</span><span class="token punctuation">(</span>var1<span class="token punctuation">,</span> var2<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span>var1<span class="token punctuation">,</span> var2<span class="token punctuation">,</span> var5<span class="token punctuation">,</span> var5 <span class="token operator">+</span> var4<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">return</span> var5<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>注：t1，t2线程是同时更新<code>同一变量56的值</code></p> <p>因为t1和t2线程都同时去访问<code>同一变量56</code>，所以他们会把<strong>主内存的值完全拷贝一份到自己的工作内存空间</strong>，所以t1和t2线程的预期值都为<code>56</code>。</p> <p>假设t1在与t2线程竞争中线程t1能去更新变量的值，而其他线程都失败。（失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次发起尝试）。t1线程去更新变量值改为57，然后写到内存中。此时对于t2来说，内存值变为了57，与预期值56不一致，就操作失败了（想改的值不再是原来的值）。</p> <p>（上图通俗的解释是：CPU去更新一个值，但如果想改的值不再是原来的值，操作就失败，因为很明显，有其它操作先改变了这个值。）</p> <p>就是指当两者进行比较时</p> <blockquote><ul><li>如果相等，则证明共享数据没有被修改，替换成新值，然后继续往下运行；</li> <li>如果不相等，说明共享数据已经被修改，放弃已经所做的操作，然后重新执行刚才的操作。</li></ul></blockquote> <p>容易看出 CAS 操作是基于共享数据不会被修改的假设，采用了类似于数据库的<code>commit-retry</code> 的模式。当同步冲突出现的机会很少时，这种假设能带来较大的性能提升。</p> <h4 id="使用例子-源码"><a href="#使用例子-源码" class="header-anchor">#</a> 使用例子/源码</h4> <p>创建一个<code>AtomicInteger</code>类型来测试多线程多同一个变量的自增操作</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">AtomicInteger</span> race <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">increase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">/*race++;并非原子操作，经过下面三个步骤，取值，+1，写值*/</span>
        race<span class="token punctuation">.</span><span class="token function">getAndIncrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>getAndIncrement()源码</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getAndIncrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">getAndAddInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> valueOffset<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>getAndAddInt源码</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getAndAddInt</span><span class="token punctuation">(</span><span class="token class-name">Object</span> var1<span class="token punctuation">,</span> <span class="token keyword">long</span> var2<span class="token punctuation">,</span> <span class="token keyword">int</span> var4<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> var5<span class="token punctuation">;</span>
        <span class="token keyword">do</span> <span class="token punctuation">{</span>
            var5 <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getIntVolatile</span><span class="token punctuation">(</span>var1<span class="token punctuation">,</span> var2<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span>var1<span class="token punctuation">,</span> var2<span class="token punctuation">,</span> var5<span class="token punctuation">,</span> var5 <span class="token operator">+</span> var4<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">return</span> var5<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>可以看到最后底层调用的是<code>compareAndSwapInt()</code>，如果 CAS 失败，会一直进行尝试</p> <h4 id="cas缺点"><a href="#cas缺点" class="header-anchor">#</a> CAS缺点</h4> <p>CAS虽然很高效的解决了原子操作问题，但是CAS仍然存在三大问题。</p> <div class="custom-block info"><p class="custom-block-title">CAS缺点</p> <ol><li><p><strong>循环时间长开销很大</strong>：CAS 通常是配合无限循环一起使用的，我们可以看到 <code>getAndAddInt</code> 方法执行时，如果 CAS 失败，会一直进行尝试。如果 CAS 长时间一直不成功，可能会给 CPU 带来很大的开销。</p></li> <li><p><strong>只能保证一个变量的原子操作</strong>：当对一个变量执行操作时，我们可以使用<code>循环 CAS</code> 的方式来保证原子操作，但是对<code>多个变量</code>操作时，CAS 目前无法直接保证操作的原子性。但是我们可以通过以下两种办法来解决：1）使用互斥锁来保证原子性；2）将多个变量封装成对象，通过 <code>AtomicReference</code> 来保证原子性。</p></li> <li><p><strong>ABA问题</strong>：CAS 的使用流程通常如下：1）首先从地址 V 读取值 A；2）根据 A 计算目标值 B；3）通过 CAS 以原子的方式将地址 V 中的值从 A 修改为 B。</p> <p>但是在第1步中读取的值是A，并且在第3步修改成功了，我们就能说它的值在第1步和第3步之间没有被其他线程改变过了吗?</p> <p><strong>如果在这段期间它的值曾经被改成了B，后来又被改回为A</strong>，那CAS操作就会误认为它从来没有被改变过。这个漏洞称为CAS操作的“ABA”问题。Java并发包为了解决这个问题，提供了一个带有标记的原子引用类“<code>AtomicStampedReference</code>”，它可以通过控制<code>变量值的版本</code>来保证CAS的正确性。</p> <p>因此，在使用CAS前要考虑清楚“ABA”问题是否会影响<code>程序并发的正确性</code>，如果需要解决ABA问题，改用<code>传统的互斥同步</code>可能会比原子类更高效。</p></li></ol></div> <h4 id="cas开销"><a href="#cas开销" class="header-anchor">#</a> CAS开销</h4> <h4 id="cas在jdk中的应用"><a href="#cas在jdk中的应用" class="header-anchor">#</a> CAS在JDK中的应用</h4> <p>在原子类变量中，如<code>java.util.concurrent.atomic</code>中的<code>AtomicXXX</code>，都使用了这些底层的JVM支持为数字类型的引用类型提供一种高效的CAS操作，而在<code>java.util.concurrent</code>中的大多数类在实现时都直接或间接的使用了这些原子变量类。</p> <p>Java 1.8中<code>AtomicInteger.incrementAndGet()</code>的实现源码为：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">getAndAddInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> valueOffset<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>


    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getAndAddInt</span><span class="token punctuation">(</span><span class="token class-name">Object</span> var1<span class="token punctuation">,</span> <span class="token keyword">long</span> var2<span class="token punctuation">,</span> <span class="token keyword">int</span> var4<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> var5<span class="token punctuation">;</span>
        <span class="token keyword">do</span> <span class="token punctuation">{</span>
            var5 <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getIntVolatile</span><span class="token punctuation">(</span>var1<span class="token punctuation">,</span> var2<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span>var1<span class="token punctuation">,</span> var2<span class="token punctuation">,</span> var5<span class="token punctuation">,</span> var5 <span class="token operator">+</span> var4<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">return</span> var5<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>由此可见，<code>AtomicInteger.incrementAndGet</code>的实现用了<code>乐观锁</code>技术，调用了类<code>sun.misc.Unsafe</code>库里面的 <code>CAS</code>算法，用<code>CPU指令</code>来实现<code>无锁自增</code>。所以，<code>AtomicInteger.incrementAndGet</code>的自增比用<code>synchronized</code>的锁效率倍增。</p> <h2 id="_14-threadlocal"><a href="#_14-threadlocal" class="header-anchor">#</a> 14. ThreadLocal</h2> <p>参考</p> <blockquote><ul><li>https://www.cnblogs.com/fsmly/p/11020641.html</li> <li>https://www.jianshu.com/p/3c5d7f09dfbd</li></ul></blockquote> <h3 id="_14-1-简介"><a href="#_14-1-简介" class="header-anchor">#</a> 14.1 简介</h3> <p>多线程访问同一个共享变量的时候容易出现并发问题，特别是多个线程对一个变量进行写入的时候，为了保证线程安全，一般使用者在访问共享变量的时候需要进行额外的同步措施才能保证线程安全性。ThreadLocal是除了加锁这种同步方式之外的一种保证一种规避多线程访问出现线程不安全的方法，当我们在创建一个变量后，如果每个线程对其进行访问的时候访问的都是线程自己的变量这样就不会存在线程不安全问题。</p> <p><code>ThreadLocal</code>是JDK包提供的，它提供线程本地变量，如果创建一个<code>ThreadLocal变量</code>，那么访问这个变量的每个线程都会有这个变量的一个<code>副本</code>，在实际多线程操作的时候，操作的是<code>自己本地内存中的变量</code>，从而规避了线程安全问题，如下图所示</p> <p>其实，<code>ThreadLocal</code>并不是一个<code>Thread</code>，而是<code>Thread</code>的<code>局部变量</code>，也许把它命名为<code>ThreadLocalVariable</code>更容易让人理解一些。</p> <p>当使用<code>ThreadLocal</code>维护变量时，ThreadLocal为每个使用该变量的线程提供<code>独立的变量副本</code>，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。</p> <p><img src="/assets/img/Introduction_to_ThreadLocal.44a11c6d.png" alt="ThreadLocal简介"></p> <p>除此之外，threadlocal还可避免很深的方法调用时的参数传递，当一个线程调用很深的方法需要从头吧参数传到底部处理时，可以用threadlocal保存当前线程的这个值，然后再取出就行</p> <h3 id="哈希冲突"><a href="#哈希冲突" class="header-anchor">#</a> 哈希冲突</h3> <p><code>ThreadLocalMap</code>解决<code>哈希冲突</code>的方式是<code>线性探测法</code>，如果当前数组位有值，则判断下一个数组位是否有值，如果有值继续向下寻找，直到一个为空的数组位，这样保证在所有线程的Map中存放的同一个ThreadLocal的位置都是相同的</p> <h3 id="_14-2-如何使用-原理"><a href="#_14-2-如何使用-原理" class="header-anchor">#</a> 14.2 如何使用/原理</h3> <p><img src="/assets/img/ThreadLocal_Thread_ThreadLocalMap.65e42915.jpg" alt="ThreadLocal和Thread以及ThreadLocalMap三者的关系"></p> <p>threadlocal使用方法很简单</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> sThreadLocal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
sThreadLocal<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
sThreadLocal<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><code>threadlocal</code>而是一个线程内部的存储类，可以在<code>指定线程内存储数据</code>，数据存储以后，只有指定线程可以得到存储数据，官方解释如下。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">/**
 * This class provides thread-local variables.  These variables differ from
 * their normal counterparts in that each thread that accesses one (via its
 * {@code get} or {@code set} method) has its own, independently initialized
 * copy of the variable.  {@code ThreadLocal} instances are typically private
 * static fields in classes that wish to associate state with a thread (e.g.,
 * a user ID or Transaction ID).
 */</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>大致意思就是<code>ThreadLocal</code>提供了<code>线程内存储变量</code>的能力，这些变量不同之处在于<code>每一个线程读取的变量是对应的互相独立的</code>。通过<code>get</code>和<code>set</code>方法就可以得到<code>当前线程对应的值</code>。</p> <p>做个不恰当的比喻，从表面上看<code>ThreadLocal</code>相当于维护了一个<code>map</code>，<code>key</code>就是当前的线程，<code>value</code>就是需要存储的对象。</p> <p>这里的这个比喻是不恰当的，实际上是<code>ThreadLocal</code>的<code>静态内部类ThreadLocalMap</code>为每个<code>Thread</code>都维护了<code>一个数组table</code>，<code>ThreadLocal</code>确定了一个数组下标，而这个下标就是<code>value</code>存储的对应位置。。</p> <p>作为一个存储数据的类，关键点就在<code>get</code>和<code>set</code>方法。</p> <h3 id="_14-3-set-方法"><a href="#_14-3-set-方法" class="header-anchor">#</a> 14.3 set()方法</h3> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">//set 方法</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token class-name">T</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">//获取当前线程</span>
      <span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">//实际存储的数据结构类型</span>
      <span class="token class-name">ThreadLocalMap</span> map <span class="token operator">=</span> <span class="token function">getMap</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">//如果存在map就直接set，没有则创建map并set</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>map <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
          map<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">else</span>
          <span class="token function">createMap</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  
<span class="token comment">//getMap方法</span>
<span class="token class-name">ThreadLocalMap</span> <span class="token function">getMap</span><span class="token punctuation">(</span><span class="token class-name">Thread</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">//thred中维护了一个ThreadLocalMap</span>
      <span class="token keyword">return</span> t<span class="token punctuation">.</span>threadLocals<span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
 
<span class="token comment">//createMap</span>
<span class="token keyword">void</span> <span class="token function">createMap</span><span class="token punctuation">(</span><span class="token class-name">Thread</span> t<span class="token punctuation">,</span> <span class="token class-name">T</span> firstValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">//实例化一个新的ThreadLocalMap，并赋值给线程的成员变量threadLocals</span>
      t<span class="token punctuation">.</span>threadLocals <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocalMap</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> firstValue<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><p>从上面代码可以看出每个线程持有一个<code>ThreadLocalMap</code>对象。每一个新的线程<code>Thread</code>都会实例化一个<code>ThreadLocalMap</code>并赋值给<code>成员变量threadLocals</code>，使用时若已经存在<code>threadLocals</code>则直接使用已经存在的对象。</p> <h3 id="_14-4-threadlocalmap"><a href="#_14-4-threadlocalmap" class="header-anchor">#</a> 14.4 ThreadLocalMap</h3> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">//Entry为ThreadLocalMap静态内部类，对ThreadLocal的弱引用</span>
<span class="token comment">//同时让ThreadLocal和储值形成key-value的关系</span>
<span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Entry</span> <span class="token keyword">extends</span> <span class="token class-name">WeakReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ThreadLocal</span><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token comment">/** The value associated with this ThreadLocal. */</span>
    <span class="token class-name">Object</span> value<span class="token punctuation">;</span>

    <span class="token class-name">Entry</span><span class="token punctuation">(</span><span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> k<span class="token punctuation">,</span> <span class="token class-name">Object</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>
           <span class="token keyword">super</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>
            value <span class="token operator">=</span> v<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">//ThreadLocalMap构造方法</span>
<span class="token class-name">ThreadLocalMap</span><span class="token punctuation">(</span><span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> firstKey<span class="token punctuation">,</span> <span class="token class-name">Object</span> firstValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//内部成员数组，INITIAL_CAPACITY值为16的常量</span>
        table <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token punctuation">[</span>INITIAL_CAPACITY<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token comment">//位运算，结果与取模相同，计算出需要存放的位置</span>
        <span class="token comment">//threadLocalHashCode比较有趣，这里计算出索引值</span>
        <span class="token keyword">int</span> i <span class="token operator">=</span> firstKey<span class="token punctuation">.</span>threadLocalHashCode <span class="token operator">&amp;</span> <span class="token punctuation">(</span>INITIAL_CAPACITY <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//new一个新的Entry并赋值table数组中计算出来的索引值</span>
        table<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token punctuation">(</span>firstKey<span class="token punctuation">,</span> firstValue<span class="token punctuation">)</span><span class="token punctuation">;</span>
        size <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token function">setThreshold</span><span class="token punctuation">(</span>INITIAL_CAPACITY<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><p>通过上面的代码不难看出在实例化<code>ThreadLocalMap</code>时创建了一个<code>长度为16的Entry数组</code>。通过<code>hashCode</code>与<code>length</code>位运算确定出一个<code>索引值i</code>，这个i就是<code>被存储在table数组中的位置</code>。</p> <p>前面讲过每个线程<code>Thread</code>持有一个<code>ThreadLocalMap</code>类型的实例<code>threadLocals</code>，结合此处的构造方法可以理解成每个线程Thread都持有一个Entry型的数组table，而一切的读取过程都是通过操作这个数组table完成的。</p> <p><em>显然table是set和get的焦点，在看具体的set和get方法前，先看下面这段代码。</em></p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">//在某一线程声明了ABC三种类型的ThreadLocal</span>
<span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">A</span><span class="token punctuation">&gt;</span></span> sThreadLocalA <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">A</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">B</span><span class="token punctuation">&gt;</span></span> sThreadLocalB <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">B</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">C</span><span class="token punctuation">&gt;</span></span> sThreadLocalC <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">C</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>由前面我们知道对于一个<code>Thread</code>来说只有持有一个<code>ThreadLocalMap</code>，所以<code>ABC</code>对应同一个<code>ThreadLocalMap对象</code>。为了管理<code>ABC</code>，于是将他们存储在<code>一个数组的不同位置</code>，而这个数组就是上面提到的<code>Entry型的数组table</code>。</p> <p>那么问题来了，<code>ABC</code>在<code>table</code>中的位置是如何确定的？为了能正常够正常的访问对应的值，肯定存在一种方法计算出确定的<code>索引值i</code>，show me code。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>  <span class="token comment">//ThreadLocalMap中set方法。</span>
  <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> key<span class="token punctuation">,</span> <span class="token class-name">Object</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>

            <span class="token comment">// We don't use a fast path as with get() because it is at</span>
            <span class="token comment">// least as common to use set() to create new entries as</span>
            <span class="token comment">// it is to replace existing ones, in which case, a fast</span>
            <span class="token comment">// path would fail more often than not.</span>

            <span class="token class-name">Entry</span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab <span class="token operator">=</span> table<span class="token punctuation">;</span>
            <span class="token keyword">int</span> len <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
            <span class="token comment">//获取索引值，这个地方是比较特别的地方</span>
            <span class="token keyword">int</span> i <span class="token operator">=</span> key<span class="token punctuation">.</span>threadLocalHashCode <span class="token operator">&amp;</span> <span class="token punctuation">(</span>len<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token comment">//遍历tab如果已经存在则更新值</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Entry</span> e <span class="token operator">=</span> tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
                 e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                 e <span class="token operator">=</span> tab<span class="token punctuation">[</span>i <span class="token operator">=</span> <span class="token function">nextIndex</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> k <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

                <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">==</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>
                    <span class="token keyword">return</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>

                <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token function">replaceStaleEntry</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">return</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            
            <span class="token comment">//如果上面没有遍历成功则创建新值</span>
            tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">int</span> sz <span class="token operator">=</span> <span class="token operator">++</span>size<span class="token punctuation">;</span>
            <span class="token comment">//满足条件数组扩容x2</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">cleanSomeSlots</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> sz<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> sz <span class="token operator">&gt;=</span> threshold<span class="token punctuation">)</span>
                <span class="token function">rehash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br></div></div><p>在<code>ThreadLocalMap</code>中的<code>set</code>方法与构造方法能看到以下代码片段。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">int</span> i <span class="token operator">=</span> key<span class="token punctuation">.</span>threadLocalHashCode <span class="token operator">&amp;</span> <span class="token punctuation">(</span>len<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token keyword">int</span> i <span class="token operator">=</span> firstKey<span class="token punctuation">.</span>threadLocalHashCode <span class="token operator">&amp;</span> <span class="token punctuation">(</span>INITIAL_CAPACITY <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>简而言之就是将<code>threadLocalHashCode</code>进行一个位运算（取模）得到索引i，</p> <p><code>threadLocalHashCode</code>代码如下：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>    <span class="token comment">//ThreadLocal中threadLocalHashCode相关代码.</span>
    
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> threadLocalHashCode <span class="token operator">=</span> <span class="token function">nextHashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/**
     * The next hash code to be given out. Updated atomically. Starts at
     * zero.
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">AtomicInteger</span> nextHashCode <span class="token operator">=</span>
        <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/**
     * The difference between successively generated hash codes - turns
     * implicit sequential thread-local IDs into near-optimally spread
     * multiplicative hash values for power-of-two-sized tables.
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> HASH_INCREMENT <span class="token operator">=</span> <span class="token number">0x61c88647</span><span class="token punctuation">;</span>

    <span class="token comment">/**
     * Returns the next hash code.
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">nextHashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//自增</span>
        <span class="token keyword">return</span> nextHashCode<span class="token punctuation">.</span><span class="token function">getAndAdd</span><span class="token punctuation">(</span>HASH_INCREMENT<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><p>因为static的原因，在每次<code>new ThreadLocal</code>时因为<code>threadLocalHashCode</code>的初始化，会使<code>threadLocalHashCode</code>值自增一次，增量为<code>0x61c88647</code>。</p> <p><code>0x61c88647</code>是斐波那契散列乘数,它的优点是通过它<code>散列(hash)</code>出来的结果分布会比较均匀，可以很大程度上避免<code>hash冲突</code>，</p> <p>以很大程度上避免<code>hash冲突</code>，已初始<code>容量16</code>为例，hash并与15位运算计算数组下标结果如下：</p> <table><thead><tr><th style="text-align:center;">hashCode</th> <th style="text-align:center;">数组下标</th></tr></thead> <tbody><tr><td style="text-align:center;">0x61c88647</td> <td style="text-align:center;">7</td></tr> <tr><td style="text-align:center;">0xc3910c8e</td> <td style="text-align:center;">14</td></tr> <tr><td style="text-align:center;">0x255992d5</td> <td style="text-align:center;">5</td></tr> <tr><td style="text-align:center;">0x8722191c</td> <td style="text-align:center;">12</td></tr> <tr><td style="text-align:center;">0xe8ea9f63</td> <td style="text-align:center;">3</td></tr> <tr><td style="text-align:center;">0x4ab325aa</td> <td style="text-align:center;">10</td></tr> <tr><td style="text-align:center;">0xac7babf1</td> <td style="text-align:center;">1</td></tr> <tr><td style="text-align:center;">0xe443238</td> <td style="text-align:center;">8</td></tr> <tr><td style="text-align:center;">0x700cb87f</td> <td style="text-align:center;">15</td></tr></tbody></table> <p>总结如下：</p> <div class="custom-block info"><p class="custom-block-title">总结如下</p> <ol><li>对于某一<code>ThreadLocal</code>来讲，他的<code>索引值i</code>是确定的，在不同线程之间访问时访问的是不同的table数组的同一位置即都为table[i]，只不过这个不同线程之间的table是独立的。</li> <li>对于同一线程的不同<code>ThreadLocal</code>来讲，这些<code>ThreadLocal</code>实例共享一个<code>table</code>数组，然后每个<code>ThreadLocal</code>实例在<code>table</code>中的<code>索引i</code>是不同的。</li></ol></div> <h3 id="_14-5-get-方法"><a href="#_14-5-get-方法" class="header-anchor">#</a> 14.5 get()方法</h3> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">//ThreadLocal中get方法</span>
<span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">ThreadLocalMap</span> map <span class="token operator">=</span> <span class="token function">getMap</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>map <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">ThreadLocalMap</span><span class="token punctuation">.</span><span class="token class-name">Entry</span> e <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">getEntry</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">&quot;unchecked&quot;</span><span class="token punctuation">)</span>
            <span class="token class-name">T</span> result <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">)</span>e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
            <span class="token keyword">return</span> result<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token function">setInitialValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
    
<span class="token comment">//ThreadLocalMap中getEntry方法</span>
<span class="token keyword">private</span> <span class="token class-name">Entry</span> <span class="token function">getEntry</span><span class="token punctuation">(</span><span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token keyword">int</span> i <span class="token operator">=</span> key<span class="token punctuation">.</span>threadLocalHashCode <span class="token operator">&amp;</span> <span class="token punctuation">(</span>table<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token class-name">Entry</span> e <span class="token operator">=</span> table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> e<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> key<span class="token punctuation">)</span>
            <span class="token keyword">return</span> e<span class="token punctuation">;</span>
       <span class="token keyword">else</span>
            <span class="token keyword">return</span> <span class="token function">getEntryAfterMiss</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> i<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><p>理解了<code>set</code>方法，<code>get</code>方法也就清楚明了，无非是通过计算出索引直接从数组对应位置读取即可。</p> <p>在进行<code>get</code>之前，必须先<code>set</code>，否则会报<code>空指针异常</code>，当然也可以初始化一个，但是必须重写<code>initialValue()</code>方法。</p> <h3 id="_14-6-内存泄漏问题"><a href="#_14-6-内存泄漏问题" class="header-anchor">#</a> 14.6 内存泄漏问题</h3> <p><img src="/assets/img/ThreadLocal_Thread_ThreadLocalMap.65e42915.jpg" alt=""></p> <p>上面这张图详细的揭示了<code>ThreadLocal</code>和<code>Thread</code>以及<code>ThreadLocalMap</code>三者的关系。</p> <div class="custom-block info"><p class="custom-block-title">关系</p> <ul><li>Thread中有一个map，就是ThreadLocalMap</li> <li>ThreadLocalMap的key是ThreadLocal，值是我们自己设定的。</li> <li>ThreadLocal是一个弱引用，当为null时，会被当成垃圾回收</li></ul></div> <h4 id="那为什么使用弱引用而不是强引用"><a href="#那为什么使用弱引用而不是强引用" class="header-anchor">#</a> 那为什么使用弱引用而不是强引用？？</h4> <p>我们看看Key使用的</p> <ul><li>key 使用强引用：当hreadLocalMap的key为强引用回收ThreadLocal时，因为ThreadLocalMap还持有ThreadLocal的强引用，如果没有手动删除，ThreadLocal不会被回收，导致Entry内存泄漏。这种情况发生在例如ThreadLocal设为null不再使用且线程池处理完线程在复用时依然还持有强引用到ThreadLocal导致一直无法回收。</li> <li>key 使用弱引用：当ThreadLocalMap的key为弱引用回收ThreadLocal时，由于ThreadLocalMap持有ThreadLocal的弱引用，即使没有手动删除，ThreadLocal也会被回收。当key为null，在下一次ThreadLocalMap调用set(),get()，remove()方法的时候会被清除value值。</li></ul> <p>重点来了，突然我们<code>ThreadLocal</code>是<code>null</code>了，也就是要被<code>垃圾回收器</code>回收了，但是此时我们的<code>ThreadLocalMap</code>生命周期和<code>Thread</code>的一样，它不会回收，这时候就出现了一个现象。那就是<code>ThreadLocalMap</code>的<code>key</code>没了，但是<code>value</code>还在，这就造成了<code>内存泄漏</code>。</p> <h4 id="为什么value不设为弱引用"><a href="#为什么value不设为弱引用" class="header-anchor">#</a> 为什么value不设为弱引用</h4> <p>不设置为弱引用，是因为不清楚这个<code>Value</code>除了<code>map</code>的引用还是否还存在其他引用，如果不存在其他引用，当<code>GC</code>的时候就会直接将这个Value干掉了，而此时我们的<code>ThreadLocal</code>还处于使用期间，就会造成Value为null的错误，所以将其设置为强引用。</p> <h4 id="为什么要remove"><a href="#为什么要remove" class="header-anchor">#</a> 为什么要remove</h4> <p>Java为了最小化减少内存泄露的可能性和影响，在ThreadLocal的get,set的时候都会清除线程Map里所有key为null的value。</p> <p>threadLocal对象设null了，开始发生“内存泄露”，然后使用线程池，这个线程结束，线程放回线程池中不销毁，这个线程一直不被使用，或者分配使用了又不再调用get,set方法，那么这个期间就会发生真正的内存泄露。</p> <h4 id="正确食用方法"><a href="#正确食用方法" class="header-anchor">#</a> 正确食用方法</h4> <ul><li>每次使用完ThreadLocal都调用它的remove()方法清除数据</li> <li>将ThreadLocal变量定义成private static，这样就一直存在ThreadLocal的强引用，也就能保证任何时候都能通过ThreadLocal的弱引用访问到Entry的value值，进而清除掉 。</li></ul> <h3 id="_14-7-特性"><a href="#_14-7-特性" class="header-anchor">#</a> 14.7 特性</h3> <p><code>ThreadLocal</code>和<code>Synchronized</code>都是为了解决<code>多线程中相同变量的访问冲突</code>问题，不同的点是</p> <div class="custom-block info"><p class="custom-block-title">不同点</p> <ul><li><code>Synchronized</code>是通过线程等待，<code>牺牲时间</code>来解决访问冲突</li> <li>ThreadLocal是通过每个线程单独一份存储空间，牺牲空间来解决冲突，并且相比于<code>Synchronized</code>，<code>ThreadLocal</code>具有<code>线程隔离</code>的效果，只有在线程内才能获取到对应的值，线程外则不能访问到想要的值。</li></ul></div> <p>正因为ThreadLocal的线程隔离特性，使他的应用场景相对来说更为特殊一些。在android中Looper、ActivityThread以及AMS中都用到了<code>ThreadLocal</code>。当某些数据是以线程为作用域并且不同线程具有不同的数据副本的时候或者说只有在同一个线程共享数据时，就可以考虑采用<code>ThreadLocal</code>。</p> <h2 id="其他面试题"><a href="#其他面试题" class="header-anchor">#</a> 其他面试题</h2> <h3 id="i-线程安全吗"><a href="#i-线程安全吗" class="header-anchor">#</a> i++线程安全吗</h3> <p>参考</p> <blockquote><ul><li>https://blog.csdn.net/weixin_39446980/article/details/90597576</li> <li>https://blog.csdn.net/zbw18297786698/article/details/53420780?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param</li></ul></blockquote></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/LifeAlsoIsGG/edit/master/Java/Java-MultiThread/Java-MultiThread.md" target="_blank" rel="noopener noreferrer">在 GitHub 上编辑此页</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <div class="last-updated"><span class="prefix">上次编辑于:</span> <span class="time">2021年12月26日 15:28</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev"><a href="/Java/Java-MultiThread/Java-MultiThread-keyword/" class="prev"><svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" class="icon prev-icon"><path d="M906.783 588.79c-.02 8.499-6.882 15.36-15.38 15.37l-443.7-.01 75.704 191.682c2.52 6.42.482 13.763-5.038 17.91-5.52 4.168-13.138 4.147-18.616-.092L123.228 524.175a15.362 15.362 0 01-6-12.165c0-4.782 2.222-9.277 6-12.185L499.753 210.35a15.388 15.388 0 019.38-3.195c3.236 0 6.502 1.034 9.236 3.103 5.52 4.147 7.578 11.49 5.038 17.91L447.683 419.84l443.72-.01c8.498.01 15.36 6.881 15.36 15.36l.02 153.6z" fill="currentColor"></path></svg>
        Java多线程-关键字&amp;锁
      </a></span> <span class="next"><a href="/Java/Java-JVM/">
        概述/参考
        <svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" class="icon next-icon"><path d="M906.772 512c0 4.772-2.211 9.267-5.99 12.175L524.257 813.66a15.37 15.37 0 01-18.616.092 15.368 15.368 0 01-5.038-17.91l75.714-191.672h-443.73c-8.488 0-15.36-6.881-15.36-15.36v-153.6c0-8.489 6.872-15.36 15.36-15.36h443.73l-75.714-191.682a15.358 15.358 0 015.048-17.91c5.51-4.158 13.128-4.137 18.606.092l376.525 289.485a15.323 15.323 0 015.99 12.165z" fill="currentColor"></path></svg></a></span></p></div> <div class="comments-wrapper"><div class="valine-wrapper"><div id="valine"></div></div></div> </main> <footer class="footer-wrapper"><div class="media-links-wrapper"><a href="https://github.com/LifeAlsoIsGG" rel="noopener noreferrer" target="_blank" aria-label="Github" data-balloon-pos="up" class="media-link"><span class="sr-only">Github</span> <svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" class="icon icon-github"><path d="M544.06 959.267h-64.95c-228.633 0-415.697-187.064-415.697-415.698V478.62c0-228.633 187.064-415.697 415.698-415.697h64.949c228.633 0 415.697 187.064 415.697 415.697v64.95c0 228.633-187.065 415.697-415.697 415.697z" fill="#171515"></path> <path d="M510.25 263.81c-136.001 0-246.287 110.273-246.287 246.317 0 108.81 70.566 201.128 168.45 233.701 12.315 2.259 16.81-5.345 16.81-11.872 0-5.847-.212-21.337-.332-41.891-68.514 14.884-82.97-33.017-82.97-33.017-11.199-28.454-27.347-36.029-27.347-36.029-22.362-15.282 1.692-14.972 1.692-14.972 24.717 1.742 37.727 25.382 37.727 25.382 21.971 37.64 57.646 26.77 71.681 20.465 2.238-15.917 8.6-26.77 15.638-32.927-54.693-6.216-112.191-27.347-112.191-121.73 0-26.889 9.597-48.876 25.352-66.093-2.533-6.232-10.985-31.274 2.414-65.184 0 0 20.68-6.622 67.731 25.25 19.647-5.464 40.716-8.196 61.663-8.291 20.916.095 41.987 2.828 61.662 8.29 47.023-31.872 67.665-25.249 67.665-25.249 13.437 33.91 4.983 58.952 2.451 65.184 15.785 17.217 25.318 39.203 25.318 66.093 0 94.62-57.588 115.44-112.458 121.538 8.845 7.604 16.721 22.637 16.721 45.612 0 32.927-.302 59.493-.302 67.568 0 6.587 4.437 14.25 16.936 11.843 97.788-32.634 168.295-124.89 168.295-233.672 0-136.043-110.287-246.316-246.319-246.316z" fill="#FFF"></path></svg></a><a href="https://twitter.com/LifeAlsoIsGG" rel="noopener noreferrer" target="_blank" aria-label="Twitter" data-balloon-pos="up" class="media-link"><span class="sr-only">Twitter</span> <svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" class="icon icon-twitter"><path d="M544.06 959.267h-64.95c-228.633 0-415.697-187.064-415.697-415.698V478.62c0-228.633 187.064-415.697 415.698-415.697h64.949c228.633 0 415.697 187.064 415.697 415.697v64.95c0 228.633-187.065 415.697-415.697 415.697z" fill="#5EAADE"></path> <path d="M749.737 364.631c-17.594 7.805-36.513 13.088-56.371 15.459 20.269-12.148 35.836-31.387 43.156-54.312A196.233 196.233 0 01674.2 349.6c-17.894-19.083-43.406-30.997-71.636-30.997-54.2 0-98.137 43.944-98.137 98.157 0 7.695.861 15.19 2.544 22.373-81.57-4.092-153.876-43.174-202.284-102.558-8.443 14.498-13.285 31.356-13.285 49.348 0 34.05 17.326 64.096 43.656 81.697a97.69 97.69 0 01-44.447-12.277c-.01.41-.01.82-.01 1.24 0 47.558 33.822 87.23 78.72 96.249a98.285 98.285 0 01-25.852 3.448 97.491 97.491 0 01-18.465-1.768c12.483 39.002 48.725 67.38 91.672 68.17-33.582 26.334-75.897 42.024-121.884 42.024-7.924 0-15.736-.46-23.408-1.37 43.434 27.844 95.014 44.104 150.443 44.104 180.505 0 279.221-149.576 279.221-279.294 0-4.263-.09-8.494-.278-12.708 19.178-13.835 35.813-31.115 48.967-50.807z" fill="#FFF"></path></svg></a><a href="http://localhost:8083/blog-vuepress/tencent:/AddContact/?fromId=50&amp;fromSubId=1&amp;subcmd=all&amp;uin=1138312802.html" rel="noopener noreferrer" target="_blank" aria-label="QQ" data-balloon-pos="up" class="media-link"><span class="sr-only">QQ</span> <svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" class="icon icon-qq"><path d="M544.06 959.267h-64.95c-228.633 0-415.697-187.064-415.697-415.698V478.62c0-228.633 187.064-415.697 415.698-415.697h64.949c228.633 0 415.697 187.064 415.697 415.697v64.95c0 228.633-187.065 415.697-415.697 415.697z" fill="#5EAADE"></path> <path d="M729.46 627.3c-3.157-39.628-24.045-83.747-32.624-105.91l-22.084-57.047c-.702-23.73 6.312-78.322-30.511-146.61s-110.82-74.446-124.497-75.147c-13.677-.701-99.248-1.403-141.331 72.945-42.084 74.347-30.745 148.812-30.745 148.812l-23.523 57.478c-.001.002-10.962 26.223-20.43 58.135-9.469 31.914-18.938 82.064-9.469 92.234 9.47 10.17 43.837-46.643 46.993-51.903 0 0 2.456 27.18 8.943 41.383l.81 1.776.33.723.38.826.3.652.444.96.203.436a281.465 281.465 0 001.917 4.025l.189.386c.231.473.468.953.711 1.442l.146.292c6.886 13.807 18.61 33.823 37.443 50.42l.018.016-1.184.387c-10.667 3.516-31.694 11.21-40.625 19.82-1.717 1.655-2.987 3.344-3.65 5.045-5.376 13.794 4.208 15.43 20.575 16.366 16.366.934 94.923 3.04 132.564-2.221.407-.056.787-.114 1.17-.171 2.711.094 5.324.142 7.83.16l.151.002c.836.005 1.663.008 2.475.008.496 0 1.015-.002 1.542-.006l.21-.001a222.593 222.593 0 005.462-.107c.26.038.508.076.778.114 37.642 5.26 116.198 3.156 132.564 2.22 16.366-.934 25.951-2.571 20.574-16.365-4.302-11.037-34.175-21.62-45.956-25.413a141.388 141.388 0 007.958-7.645l.237-.245a142.494 142.494 0 002.53-2.702c42.435-46.643 38.928-76.101 40.682-92.935 0 0 35.775 51.553 43.488 53.306 7.713 1.754 10.169-6.31 7.012-45.94z" fill="#FFF"></path></svg></a></div> <div class="footer">粤ICP备19126168号</div> <div class="copyright">Copyright © 2020 Draco</div></footer></div><div class="global-ui"><!----><!----><div id="pwa-install"><!----> <div id="install-modal-wrapper" style="display:none;"><div class="background"></div> <div class="install-modal"><div class="header"><button aria-label="Close" class="close-button"><svg width="23" height="22" xmlns="http://www.w3.org/2000/svg" class="icon close-icon"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.12.358a1.224 1.224 0 011.729 0l8.92 8.914L20.686.358a1.224 1.224 0 011.73 1.728L13.497 11l8.92 8.913a1.222 1.222 0 11-1.73 1.729l-8.919-8.913-8.92 8.913a1.224 1.224 0 01-1.729-1.729L10.04 11l-8.92-8.914a1.222 1.222 0 010-1.728z" fill="currentColor"></path></svg></button> <div class="logo"><!----> <div class="title"><h1></h1> <p class="desc">该应用可以安装在您的 PC 或移动设备上。这将使该 Web 应用程序外观和行为与其他应用程序相同。它将在出现在应用程序列表中，并可以固定到主屏幕，开始菜单或任务栏。此 Web 应用程序还将能够与其他应用程序和您的操作系统安全地进行交互。</p></div></div></div> <div class="content"><div class="highlight"><!----> <!----></div> <div class="description"><h3>详情</h3> <p></p></div></div> <div class="button-wrapper"><button class="install-button">
        安装 <span></span></button> <button class="cancel-button">
        取消
      </button></div></div></div></div><div tabindex="-1" role="dialog" aria-hidden="true" class="pswp"><div class="pswp__bg"></div> <div class="pswp__scroll-wrap"><div class="pswp__container"><div class="pswp__item"></div> <div class="pswp__item"></div> <div class="pswp__item"></div></div> <div class="pswp__ui pswp__ui--hidden"><div class="pswp__top-bar"><div class="pswp__counter"></div> <button title="Close (Esc)" class="pswp__button pswp__button--close"></button> <button title="Share" class="pswp__button pswp__button--share"></button> <button title="Toggle fullscreen" class="pswp__button pswp__button--fs"></button> <button title="Zoom in/out" class="pswp__button pswp__button--zoom"></button> <div class="pswp__preloader"><div class="pswp__preloader__icn"><div class="pswp__preloader__cut"><div class="pswp__preloader__donut"></div></div></div></div></div> <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class="pswp__share-tooltip"></div></div> <button title="Previous (arrow left)" class="pswp__button pswp__button--arrow--left"></button> <button title="Next (arrow right)" class="pswp__button pswp__button--arrow--right"></button> <div class="pswp__caption"><div class="pswp__caption__center"></div></div></div></div></div></div></div>
    <script src="/assets/js/app.20b20573.js" defer></script><script src="/assets/js/layout-Layout.01663f32.js" defer></script><script src="/assets/js/vendors~layout-Blog~layout-Layout~layout-NotFound.29afc31d.js" defer></script><script src="/assets/js/vendors~layout-Blog~layout-Layout~layout-NotFound~layout-Slide.b32f4377.js" defer></script><script src="/assets/js/vendors~layout-Blog~layout-Layout.02c7d76a.js" defer></script><script src="/assets/js/page-Java-多线程并发--31fe9d0a.e5a055a2.js" defer></script>
  </body>
</html>
