<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Redis理论学习笔记 | LifeAlsoIsGG&#39;s Blog</title>
    <meta name="generator" content="VuePress 1.7.1">
    <script src="https://cdn.jsdelivr.net/npm/react/umd/react.production.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/react-dom/umd/react-dom.production.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@babel/standalone/babel.min.js"></script>
    <link rel="icon" href="/static-blog/favicon.ico">
    <link rel="icon" href="/static-blog/assets/icon/chrome-mask-512.png" type="image/png" sizes="512x512">
    <link rel="icon" href="/static-blog/assets/icon/chrome-mask-192.png" type="image/png" sizes="192x192">
    <link rel="icon" href="/static-blog/assets/icon/chrome-512.png" type="image/png" sizes="512x512">
    <link rel="icon" href="/static-blog/assets/icon/chrome-192.png" type="image/png" sizes="192x192">
    <link rel="manifest" href="/static-blog/static-blog/manifest.webmanifest">
    <link rel="apple-touch-icon" href="/static-blog/assets/icon/apple-icon-152.png">
    <meta name="description" content="We found hope in hopeless place">
    <meta property="og:url" content="/database/redis/Redis_theory_note.html">
    <meta property="og:site_name" content="LifeAlsoIsGG's Blog">
    <meta property="og:title" content="Redis理论学习笔记">
    <meta property="og:type" content="article">
    <meta property="og:locale" content="zh-CN">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image:alt" content="LifeAlsoIsGG's Blog">
    <meta property="article:author" content="LifeAlsoIsGG">
    <meta property="article:tag" content="数据库">
    <meta property="article:published_time" content="2020-10-12T20:45:07.000Z">
    <meta name="theme-color" content="#46bd87">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="msapplication-TileImage" content="/assets/icon/ms-icon-144.png">
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    
    <link rel="preload" href="https://cdn.jsdelivr.net/gh/lifealsoisgg/static-blog@gh-pages/assets/css/0.styles.71609caf.css" as="style"><link rel="preload" href="https://cdn.jsdelivr.net/gh/lifealsoisgg/static-blog@gh-pages/assets/js/app.589166b9.js" as="script"><link rel="preload" href="https://cdn.jsdelivr.net/gh/lifealsoisgg/static-blog@gh-pages/assets/js/layout-Layout.db99e56e.js" as="script"><link rel="preload" href="https://cdn.jsdelivr.net/gh/lifealsoisgg/static-blog@gh-pages/assets/js/vendors~layout-Blog~layout-Layout~layout-NotFound.e9b6f9a1.js" as="script"><link rel="preload" href="https://cdn.jsdelivr.net/gh/lifealsoisgg/static-blog@gh-pages/assets/js/vendors~layout-Blog~layout-Layout~layout-NotFound~layout-Slide.8e109616.js" as="script"><link rel="preload" href="https://cdn.jsdelivr.net/gh/lifealsoisgg/static-blog@gh-pages/assets/js/vendors~layout-Blog~layout-Layout.2f613263.js" as="script"><link rel="preload" href="https://cdn.jsdelivr.net/gh/lifealsoisgg/static-blog@gh-pages/assets/js/page-Redis理论学习笔记--1a52f412.8ecda962.js" as="script"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/lifealsoisgg/static-blog@gh-pages/assets/js/64.82200810.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/lifealsoisgg/static-blog@gh-pages/assets/js/65.55c12289.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/lifealsoisgg/static-blog@gh-pages/assets/js/66.53f56401.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/lifealsoisgg/static-blog@gh-pages/assets/js/67.535b6268.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/lifealsoisgg/static-blog@gh-pages/assets/js/68.70756764.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/lifealsoisgg/static-blog@gh-pages/assets/js/layout-Blog.03ef2779.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/lifealsoisgg/static-blog@gh-pages/assets/js/layout-NotFound.19bedb14.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/lifealsoisgg/static-blog@gh-pages/assets/js/layout-Slide.67521334.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/lifealsoisgg/static-blog@gh-pages/assets/js/page-About--1d45e806.ceefbf40.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/lifealsoisgg/static-blog@gh-pages/assets/js/page-DockerInstallsoftware--49ef6be4.9df2f740.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/lifealsoisgg/static-blog@gh-pages/assets/js/page-Dockerdeployment--45ace4e8.dab286f2.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/lifealsoisgg/static-blog@gh-pages/assets/js/page-Docker学习目录--4648a5c5.f1156836.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/lifealsoisgg/static-blog@gh-pages/assets/js/page-Hadoop伪分布式配置--15e2f806.1117456d.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/lifealsoisgg/static-blog@gh-pages/assets/js/page-Home--58f04215.a9ceeeed.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/lifealsoisgg/static-blog@gh-pages/assets/js/page-Java-IO--03bf2f8a.ade5dd7a.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/lifealsoisgg/static-blog@gh-pages/assets/js/page-Java-JDK8新特性--0c8e1b70.44413b7d.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/lifealsoisgg/static-blog@gh-pages/assets/js/page-Java-JVM--c660f774.5d05f35f.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/lifealsoisgg/static-blog@gh-pages/assets/js/page-Java-String--355c4cb4.e70fbf6a.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/lifealsoisgg/static-blog@gh-pages/assets/js/page-Java-反射--758242c0.eea7acfc.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/lifealsoisgg/static-blog@gh-pages/assets/js/page-Java-基础知识笔记--ba9e4320.2c880125.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/lifealsoisgg/static-blog@gh-pages/assets/js/page-Java-基础面试题--e85683f4.04ba936d.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/lifealsoisgg/static-blog@gh-pages/assets/js/page-Java-多线程并发--0bb93550.c538548a.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/lifealsoisgg/static-blog@gh-pages/assets/js/page-Java-常用方法汇总--0920d226.7b1e3774.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/lifealsoisgg/static-blog@gh-pages/assets/js/page-Java-时间处理--6004773a.9070ba97.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/lifealsoisgg/static-blog@gh-pages/assets/js/page-Java-设计模式--ffde5b58.6cd48310.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/lifealsoisgg/static-blog@gh-pages/assets/js/page-Java-集合容器--b6c81274.95b25529.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/lifealsoisgg/static-blog@gh-pages/assets/js/page-JavaScript面试题--26935a60.a89c8f30.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/lifealsoisgg/static-blog@gh-pages/assets/js/page-JavaSwing-超市系统--0ce27734.1b67f9b7.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/lifealsoisgg/static-blog@gh-pages/assets/js/page-Javaweb大学活动管理系统--caa08eb4.1697c365.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/lifealsoisgg/static-blog@gh-pages/assets/js/page-Java学习目录--750e92c5.ce462dc2.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/lifealsoisgg/static-blog@gh-pages/assets/js/page-Java面试整理--1394b30a.2cb7ea72.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/lifealsoisgg/static-blog@gh-pages/assets/js/page-Linux学习目录--db391b6a.44a089bc.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/lifealsoisgg/static-blog@gh-pages/assets/js/page-Linux常用命令--d48f65cc.2940dbb4.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/lifealsoisgg/static-blog@gh-pages/assets/js/page-Markdown增强--4b95fe64.3b04db69.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/lifealsoisgg/static-blog@gh-pages/assets/js/page-MyProject--78e65145.ad88ee4d.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/lifealsoisgg/static-blog@gh-pages/assets/js/page-Mysql理论学习笔记--0c399cb6.c1591977.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/lifealsoisgg/static-blog@gh-pages/assets/js/page-Promise异步调用--640cbe74.9a2d1d84.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/lifealsoisgg/static-blog@gh-pages/assets/js/page-Redis实现单点登录--7b42df90.427f2bc3.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/lifealsoisgg/static-blog@gh-pages/assets/js/page-Redis实现高并发秒杀系统--64ce7608.ba4bb31b.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/lifealsoisgg/static-blog@gh-pages/assets/js/page-Redis持久化配置--bb714ba8.c004085a.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/lifealsoisgg/static-blog@gh-pages/assets/js/page-Redis部署与基本使用--a93cca34.4c493e2a.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/lifealsoisgg/static-blog@gh-pages/assets/js/page-SQL学习笔记--aca945b4.c62ceb01.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/lifealsoisgg/static-blog@gh-pages/assets/js/page-demo--9b847374.999ac29c.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/lifealsoisgg/static-blog@gh-pages/assets/js/page-主要功能与配置演示--79d4d00a.4e28512b.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/lifealsoisgg/static-blog@gh-pages/assets/js/page-修改Host以访问Github--3b3d36bc.c8056941.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/lifealsoisgg/static-blog@gh-pages/assets/js/page-前端学习目录--2ec43f45.c51f0b7c.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/lifealsoisgg/static-blog@gh-pages/assets/js/page-大三下实训期末作业--6a0c5a86.7977e49f.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/lifealsoisgg/static-blog@gh-pages/assets/js/page-实验室出入管理小程序--10da6510.9bf850f5.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/lifealsoisgg/static-blog@gh-pages/assets/js/page-密码加密的文章--f898c734.105ca54e.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/lifealsoisgg/static-blog@gh-pages/assets/js/page-数据库学习目录--906c7e36.bb6d6f1d.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/lifealsoisgg/static-blog@gh-pages/assets/js/page-数据结构算法基础笔记--ae42cccc.cabd91e8.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/lifealsoisgg/static-blog@gh-pages/assets/js/page-数据结构算法学习目录--68e3704f.eff48de8.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/lifealsoisgg/static-blog@gh-pages/assets/js/page-数据结构算法题目合集--566522b2.ca01bb0b.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/lifealsoisgg/static-blog@gh-pages/assets/js/page-用xshell连接虚拟机中的Centos7--17ea1126.a08917bf.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/lifealsoisgg/static-blog@gh-pages/assets/js/page-组件禁用--2c21e206.d4f30fd3.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/lifealsoisgg/static-blog@gh-pages/assets/js/page-腾讯云学习笔记--79348f12.e86faa16.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/lifealsoisgg/static-blog@gh-pages/assets/js/page-计算机其它面试题--c2758204.0bfd4655.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/lifealsoisgg/static-blog@gh-pages/assets/js/page-页面配置--ec9920e4.c1fb5b3b.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/lifealsoisgg/static-blog@gh-pages/assets/js/vendors~flowchart.197ca2f9.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/lifealsoisgg/static-blog@gh-pages/assets/js/vendors~photo-swipe.2cf9fa42.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/lifealsoisgg/static-blog@gh-pages/assets/js/vendors~reveal.d0545102.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/lifealsoisgg/static-blog@gh-pages/assets/js/vendors~valine.2efe809f.js">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/lifealsoisgg/static-blog@gh-pages/assets/css/0.styles.71609caf.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container has-anchor"><header class="navbar"><button class="sidebar-button"><span class="icon"></span></button> <a href="/static-blog/" class="home-link router-link-active"><img src="https://cdn.jsdelivr.net/gh/lifealsoisgg/static-blog@gh-pages/logo.png" alt="LifeAlsoIsGG's Blog" class="logo"> <!----> <span class="site-name can-hide">LifeAlsoIsGG's Blog</span></a> <div class="links"><button class="color-button"><svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" class="skin-icon"><path d="M224 800c0 9.6 3.2 44.8 6.4 54.4 6.4 48-48 76.8-48 76.8s80 41.6 147.2 0 134.4-134.4
        38.4-195.2c-22.4-12.8-41.6-19.2-57.6-19.2C259.2 716.8 227.2 761.6 224 800zM560 675.2l-32
        51.2c-51.2 51.2-83.2 32-83.2 32 25.6 67.2 0 112-12.8 128 25.6 6.4 51.2 9.6 80 9.6 54.4 0
        102.4-9.6 150.4-32l0 0c3.2 0 3.2-3.2 3.2-3.2 22.4-16 12.8-35.2
        6.4-44.8-9.6-12.8-12.8-25.6-12.8-41.6 0-54.4 60.8-99.2 137.6-99.2 6.4 0 12.8 0 22.4
        0 12.8 0 38.4 9.6 48-25.6 0-3.2 0-3.2 3.2-6.4 0-3.2 3.2-6.4 3.2-6.4 6.4-16 6.4-16 6.4-19.2
        9.6-35.2 16-73.6 16-115.2 0-105.6-41.6-198.4-108.8-268.8C704 396.8 560 675.2 560 675.2zM224
        419.2c0-28.8 22.4-51.2 51.2-51.2 28.8 0 51.2 22.4 51.2 51.2 0 28.8-22.4 51.2-51.2 51.2C246.4
        470.4 224 448 224 419.2zM320 284.8c0-22.4 19.2-41.6 41.6-41.6 22.4 0 41.6 19.2 41.6 41.6 0
        22.4-19.2 41.6-41.6 41.6C339.2 326.4 320 307.2 320 284.8zM457.6 208c0-12.8 12.8-25.6 25.6-25.6
        12.8 0 25.6 12.8 25.6 25.6 0 12.8-12.8 25.6-25.6 25.6C470.4 233.6 457.6 220.8 457.6 208zM128
        505.6C128 592 153.6 672 201.6 736c28.8-60.8 112-60.8 124.8-60.8-16-51.2 16-99.2
        16-99.2l316.8-422.4c-48-19.2-99.2-32-150.4-32C297.6 118.4 128 291.2 128 505.6zM764.8
        86.4c-22.4 19.2-390.4 518.4-390.4 518.4-22.4 28.8-12.8 76.8 22.4 99.2l9.6 6.4c35.2 22.4
        80 12.8 99.2-25.6 0 0 6.4-12.8 9.6-19.2 54.4-105.6 275.2-524.8 288-553.6
        6.4-19.2-3.2-32-19.2-32C777.6 76.8 771.2 80 764.8 86.4z"></path></svg> <div class="color-picker-menu" style="display:none;"><div class="theme-options"><ul class="themecolor-select"><label for="themecolor-select">主题色:</label> <li><a href="#" class="default-theme"></a></li> </ul> <div class="darkmode-toggle"><label for="darkmode-toggle" class="desc">主题模式:</label> <div class="darkmode-switch"><div class="item day"><svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" class="icon light-icon"><path d="M512 256a42.667 42.667 0 0042.667-42.667V128a42.667 42.667 0 00-85.334 0v85.333A42.667 42.667 0 00512 256zm384 213.333h-85.333a42.667 42.667 0 000 85.334H896a42.667 42.667 0 000-85.334zM256 512a42.667 42.667 0 00-42.667-42.667H128a42.667 42.667 0 000 85.334h85.333A42.667 42.667 0 00256 512zm9.387-298.667a42.667 42.667 0 00-59.307 62.72l61.44 59.307a42.667 42.667 0 0031.147 11.947 42.667 42.667 0 0030.72-13.227 42.667 42.667 0 000-60.16zm459.946 133.974a42.667 42.667 0 0029.44-11.947l61.44-59.307a42.667 42.667 0 00-57.6-62.72l-61.44 60.587a42.667 42.667 0 000 60.16 42.667 42.667 0 0028.16 13.227zM512 768a42.667 42.667 0 00-42.667 42.667V896a42.667 42.667 0 0085.334 0v-85.333A42.667 42.667 0 00512 768zm244.48-79.36a42.667 42.667 0 00-59.307 61.44l61.44 60.587a42.667 42.667 0 0029.44 11.946 42.667 42.667 0 0030.72-12.8 42.667 42.667 0 000-60.586zm-488.96 0l-61.44 59.307a42.667 42.667 0 000 60.586 42.667 42.667 0 0030.72 12.8 42.667 42.667 0 0028.587-10.666l61.44-59.307a42.667 42.667 0 00-59.307-61.44zM512 341.333A170.667 170.667 0 10682.667 512 170.667 170.667 0 00512 341.333z" fill="currentColor"></path></svg></div> <div class="item auto active"><svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" class="icon auto-icon"><path d="M460.864 539.072H564.8L510.592 376l-49.728 163.072zM872 362.368V149.504H659.648L510.528 0l-149.12 149.504H149.12v212.928L0 511.872l149.12 149.504v212.928h212.352l149.12 149.504 149.12-149.504h212.352V661.376l149.12-149.504L872 362.368zM614.464 693.12l-31.616-90.624H438.272l-31.616 90.624h-85.888l144.576-407.68h90.368l144.576 407.68h-85.824zm0 0" fill="currentColor"></path></svg></div> <div class="item night"><svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" class="icon dark-icon"><path d="M935.539 630.402c-11.43-11.432-28.674-14.739-43.531-8.354-46.734 20.103-96.363 30.297-147.508 30.297-99.59 0-193.221-38.784-263.64-109.203-108.637-108.637-139.61-270.022-78.908-411.148a39.497 39.497 0 00-51.886-51.887c-52.637 22.64-100.017 54.81-140.826 95.616-85.346 85.346-132.346 198.821-132.346 319.52 0 120.7 47.001 234.172 132.347 319.519S408.063 947.11 528.76 947.11c120.7 0 234.172-47.003 319.52-132.351 40.809-40.81 72.978-88.19 95.616-140.826a39.497 39.497 0 00-8.356-43.532z" fill="currentColor"></path></svg></div></div> <!----></div></div></div></button> <div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/static-blog/category/" class="nav-link"><i class="iconfont icon-note"></i>
  分类
</a></div><div class="nav-item"><a href="/static-blog/timeline/" class="nav-link"><i class="iconfont icon-time"></i>
  时间线
</a></div><div class="nav-item"><a href="/static-blog/about/" class="nav-link"><i class="iconfont icon-info"></i>
  关于
</a></div><div class="nav-item"><a href="https://photos.lifeisgg.online/" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont icon-emoji"></i>
  相册
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <a rel="noopener noreferrer" href="https://github.com/LifeAlsoIsGG" target="_blank" class="repo-link">
    Github
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <nav class="nav-links"><div class="nav-item"><a href="/static-blog/category/" class="nav-link"><i class="iconfont icon-note"></i>
  分类
</a></div><div class="nav-item"><a href="/static-blog/timeline/" class="nav-link"><i class="iconfont icon-time"></i>
  时间线
</a></div><div class="nav-item"><a href="/static-blog/about/" class="nav-link"><i class="iconfont icon-info"></i>
  关于
</a></div><div class="nav-item"><a href="https://photos.lifeisgg.online/" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont icon-emoji"></i>
  相册
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <a rel="noopener noreferrer" href="https://github.com/LifeAlsoIsGG" target="_blank" class="repo-link">
    Github
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading clickable"><i class="iconfont icon-creative"></i> <span>My-Project</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading clickable"><i class="iconfont icon-creative"></i> <span>Java面试整理</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading clickable"><i class="iconfont icon-code"></i> <span>Java</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading clickable open"><i class="iconfont icon-creative"></i> <span>数据库</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/static-blog/database/" aria-current="page" class="sidebar-link">数据库学习目录</a></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading clickable"><i class="iconfont icon-creative"></i> <span>Mysql</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading clickable open"><i class="iconfont icon-creative"></i> <span>Redis</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/static-blog/database/redis/Redis_theory_note/" aria-current="page" class="active sidebar-link">Redis理论学习笔记</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/static-blog/database/redis/Redis_theory_note/#_1-参考" class="sidebar-link">1. 参考</a></li><li class="sidebar-sub-header"><a href="/static-blog/database/redis/Redis_theory_note/#_2-简介" class="sidebar-link">2. 简介</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/static-blog/database/redis/Redis_theory_note/#_2-1-优点" class="sidebar-link">2.1 优点</a></li><li class="sidebar-sub-header"><a href="/static-blog/database/redis/Redis_theory_note/#_2-2-缺点" class="sidebar-link">2.2 缺点</a></li></ul></li><li class="sidebar-sub-header"><a href="/static-blog/database/redis/Redis_theory_note/#_3-为什么要用-redis-为什么要用缓存" class="sidebar-link">3. 为什么要用 redis /为什么要用缓存</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/static-blog/database/redis/Redis_theory_note/#_3-1-高性能" class="sidebar-link">3.1 高性能</a></li><li class="sidebar-sub-header"><a href="/static-blog/database/redis/Redis_theory_note/#_3-2-高并发" class="sidebar-link">3.2 高并发</a></li><li class="sidebar-sub-header"><a href="/static-blog/database/redis/Redis_theory_note/#_3-3-为什么要用-redis-而不用-map-guava-做缓存" class="sidebar-link">3.3 为什么要⽤ redis ⽽不⽤ map/guava 做缓存?</a></li></ul></li><li class="sidebar-sub-header"><a href="/static-blog/database/redis/Redis_theory_note/#_4-redis-的线程模型" class="sidebar-link">4. redis 的线程模型</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/static-blog/database/redis/Redis_theory_note/#_4-1-redis单线程模型指的是什么" class="sidebar-link">4.1 redis单线程模型指的是什么</a></li><li class="sidebar-sub-header"><a href="/static-blog/database/redis/Redis_theory_note/#_4-2-redis是单线程模型为什么效率还这么高" class="sidebar-link">4.2 redis是单线程模型为什么效率还这么高？</a></li><li class="sidebar-sub-header"><a href="/static-blog/database/redis/Redis_theory_note/#_4-3-rector模式简介" class="sidebar-link">4.3 rector模式简介</a></li><li class="sidebar-sub-header"><a href="/static-blog/database/redis/Redis_theory_note/#_4-4-为什么网络处理要引入多线程" class="sidebar-link">4.4 为什么网络处理要引入多线程？</a></li></ul></li><li class="sidebar-sub-header"><a href="/static-blog/database/redis/Redis_theory_note/#_5-常⻅数据结构以及使用场景分析" class="sidebar-link">5.常⻅数据结构以及使⽤场景分析</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/static-blog/database/redis/Redis_theory_note/#_5-1-string" class="sidebar-link">5.1 String</a></li><li class="sidebar-sub-header"><a href="/static-blog/database/redis/Redis_theory_note/#_5-2-hash" class="sidebar-link">5.2 Hash</a></li><li class="sidebar-sub-header"><a href="/static-blog/database/redis/Redis_theory_note/#_5-3-list" class="sidebar-link">5.3 List</a></li><li class="sidebar-sub-header"><a href="/static-blog/database/redis/Redis_theory_note/#_5-4-set" class="sidebar-link">5.4 Set</a></li><li class="sidebar-sub-header"><a href="/static-blog/database/redis/Redis_theory_note/#_5-5-zset-sorted-set" class="sidebar-link">5.5 ZSet（Sorted Set）</a></li></ul></li><li class="sidebar-sub-header"><a href="/static-blog/database/redis/Redis_theory_note/#_6-redis过期时间" class="sidebar-link">6. Redis过期时间</a></li><li class="sidebar-sub-header"><a href="/static-blog/database/redis/Redis_theory_note/#_7-redis内存淘汰机制" class="sidebar-link">7. Redis内存淘汰机制</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/static-blog/database/redis/Redis_theory_note/#_7-1-内存置换策略" class="sidebar-link">7.1 内存置换策略</a></li><li class="sidebar-sub-header"><a href="/static-blog/database/redis/Redis_theory_note/#_7-2-淘汰机制的实现" class="sidebar-link">7.2 淘汰机制的实现</a></li></ul></li><li class="sidebar-sub-header"><a href="/static-blog/database/redis/Redis_theory_note/#_8-redis持久化机制" class="sidebar-link">8. Redis持久化机制</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/static-blog/database/redis/Redis_theory_note/#_8-1-rdb-redis-database-快照" class="sidebar-link">8.1 RDB（Redis DataBase 快照）</a></li><li class="sidebar-sub-header"><a href="/static-blog/database/redis/Redis_theory_note/#_8-2-aof-append-only-file" class="sidebar-link">8.2 AOF（Append Only File）</a></li><li class="sidebar-sub-header"><a href="/static-blog/database/redis/Redis_theory_note/#_8-3-redis-4-0-对于持久化机制的优化" class="sidebar-link">8.3 Redis 4.0 对于持久化机制的优化</a></li></ul></li><li class="sidebar-sub-header"><a href="/static-blog/database/redis/Redis_theory_note/#_9-redis事务" class="sidebar-link">9. Redis事务</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/static-blog/database/redis/Redis_theory_note/#_9-1-特点" class="sidebar-link">9.1 特点</a></li><li class="sidebar-sub-header"><a href="/static-blog/database/redis/Redis_theory_note/#_9-2-阶段" class="sidebar-link">9.2 阶段</a></li><li class="sidebar-sub-header"><a href="/static-blog/database/redis/Redis_theory_note/#_9-3-相关命令参考" class="sidebar-link">9.3 相关命令参考</a></li></ul></li><li class="sidebar-sub-header"><a href="/static-blog/database/redis/Redis_theory_note/#_10-缓存雪崩-缓存穿透-缓存击穿" class="sidebar-link">10. 缓存雪崩 | 缓存穿透 | 缓存击穿</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/static-blog/database/redis/Redis_theory_note/#_10-1-缓存穿透" class="sidebar-link">10.1 缓存穿透</a></li><li class="sidebar-sub-header"><a href="/static-blog/database/redis/Redis_theory_note/#_10-2-缓存击穿" class="sidebar-link">10.2 缓存击穿</a></li><li class="sidebar-sub-header"><a href="/static-blog/database/redis/Redis_theory_note/#_10-3-缓存雪崩" class="sidebar-link">10.3 缓存雪崩</a></li></ul></li><li class="sidebar-sub-header"><a href="/static-blog/database/redis/Redis_theory_note/#_11-如何解决-redis-的并发竞争-key-问题" class="sidebar-link">11. 如何解决 Redis 的并发竞争 Key 问题</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/static-blog/database/redis/Redis_theory_note/#_11-1-分布式锁-时间戳" class="sidebar-link">11.1 分布式锁+时间戳</a></li><li class="sidebar-sub-header"><a href="/static-blog/database/redis/Redis_theory_note/#_11-2-消息队列" class="sidebar-link">11.2 消息队列</a></li></ul></li><li class="sidebar-sub-header"><a href="/static-blog/database/redis/Redis_theory_note/#_12-区别" class="sidebar-link">12. 区别</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/static-blog/database/redis/Redis_theory_note/#_12-1-redis-和-memcached-的区别" class="sidebar-link">12.1 redis 和 memcached 的区别</a></li></ul></li></ul></li><li><a href="/static-blog/database/redis/Redis_deployment&amp;use/" class="sidebar-link">Redis部署与基本使用</a></li><li><a href="/static-blog/database/redis/Redis_single_signin/" class="sidebar-link">Redis实现单点登录</a></li><li><a href="/static-blog/database/redis/Redis_High_concurrency_spike_system/" class="sidebar-link">Redis实现高并发秒杀系统</a></li></ul></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading clickable"><i class="iconfont icon-creative"></i> <span>Hadoop</span> <span class="arrow right"></span></p> <!----></section></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading clickable"><i class="iconfont icon-creative"></i> <span>数据结构&amp;算法</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading clickable"><i class="iconfont icon-creative"></i> <span>Linux</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading clickable"><i class="iconfont icon-creative"></i> <span>Docker</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading clickable"><i class="iconfont icon-creative"></i> <span>前端</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading clickable"><i class="iconfont icon-creative"></i> <span>Guide</span> <span class="arrow right"></span></p> <!----></section></li><li><a href="/static-blog/about/" class="sidebar-link"><i class="iconfont icon-info" style="margin-right:0.2em;"></i>About</a></li></ul> </aside> <main class="page"><nav class="breadcrumb"><ul><li><a href="/static-blog/database/" class="router-link-active"><!---->
        数据库学习目录
      </a></li><li class="is-active"><a href="/static-blog/database/redis/Redis_theory_note/" aria-current="page" class="router-link-exact-active router-link-active"><!---->
        Redis理论学习笔记
      </a></li></ul></nav>  <div class="page-title"><h1><!---->
    Redis理论学习笔记
  </h1> <div class="page-info"><span class="origin">原创💡</span> <span aria-label="作者🖊" data-balloon-pos="down"><svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" class="icon author-icon"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z" fill="currentColor"></path></svg> <span>LifeAlsoIsGG</span></span><span aria-label="访问量🔢" data-balloon-pos="down" class="visitor-info"><svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" class="icon eye-icon"><path d="M992 512.096c0-5.76-.992-10.592-1.28-11.136-.192-2.88-1.152-8.064-2.08-10.816-.256-.672-.544-1.376-.832-2.08-.48-1.568-1.024-3.104-1.6-4.32C897.664 290.112 707.104 160 512 160c-195.072 0-385.632 130.016-473.76 322.592-1.056 2.112-1.792 4.096-2.272 5.856a55.512 55.512 0 00-.64 1.6c-1.76 5.088-1.792 8.64-1.632 7.744-.832 3.744-1.568 11.168-1.568 11.168-.224 2.272-.224 4.032.032 6.304 0 0 .736 6.464 1.088 7.808.128 1.824.576 4.512 1.12 6.976h-.032c.448 2.08 1.12 4.096 1.984 6.08.48 1.536.992 2.976 1.472 4.032C126.432 733.856 316.992 864 512 864c195.136 0 385.696-130.048 473.216-321.696 1.376-2.496 2.24-4.832 2.848-6.912.256-.608.48-1.184.672-1.728 1.536-4.48 1.856-8.32 1.728-8.32l-.032.032c.608-3.104 1.568-7.744 1.568-13.28zM512 672c-88.224 0-160-71.776-160-160s71.776-160 160-160 160 71.776 160 160-71.776 160-160 160z" fill="currentColor"></path></svg> <span id="/static-blog/database/redis/Redis_theory_note/" data-flag-title="Redis理论学习笔记" class="leancloud_visitors"><span class="leancloud-visitors-count">...</span></span></span><span aria-label="写作日期📅" data-balloon-pos="down" class="time-info"><svg viewBox="0 0 1030 1024" xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z" fill="currentColor"></path></svg> <span>2020-10-12 20:45:07</span></span><!----><span aria-label="标签🏷" data-balloon-pos="down"><svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" class="icon tag-icon"><path d="M939.902 458.563L910.17 144.567c-1.507-16.272-14.465-29.13-30.737-30.737L565.438 84.098h-.402c-3.215 0-5.726 1.005-7.634 2.913l-470.39 470.39a10.004 10.004 0 000 14.164l365.423 365.424c1.909 1.908 4.42 2.913 7.132 2.913s5.223-1.005 7.132-2.913l470.39-470.39c2.01-2.11 3.014-5.023 2.813-8.036zm-240.067-72.121c-35.458 0-64.286-28.828-64.286-64.286s28.828-64.285 64.286-64.285 64.286 28.828 64.286 64.285-28.829 64.286-64.286 64.286z" fill="currentColor"></path></svg> <ul class="tags-wrapper"><li class="tag clickable tag0"><span role="navigation">数据库</span></li><li class="tag clickable tag1"><span role="navigation">Redis</span></li></ul></span><span aria-label="阅读时间⌛" data-balloon-pos="down" class="read-time-info"><svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" class="icon time-icon"><path d="M511.997 70.568c-243.797 0-441.429 197.633-441.429 441.435 0 243.797 197.632 441.429 441.43 441.429S953.431 755.8 953.431 512.002c0-243.796-197.637-441.434-441.435-441.434zm150.158 609.093l-15.605 15.61c-8.621 8.615-22.596 8.615-31.215 0L472.197 552.126c-4.95-4.944-4.34-14.888-4.34-24.677V247.14c0-12.19 9.882-22.07 22.07-22.07h22.07c12.19 0 22.07 9.882 22.07 22.07v273.218l128.088 128.088c8.62 8.62 8.62 22.595 0 31.215zm0 0" fill="currentColor"></path></svg> <span>大约 28 分钟</span></span></div> <hr></div> <!----> <div class="anchor-place-holder"><aside id="anchor"><div class="anchor-wrapper"><ul class="anchor-list"><li class="anchor anchor2"><a href="/static-blog/database/redis/Redis_theory_note/#_1-参考" class="anchor-link"><div>1. 参考</div></a></li><li class="anchor anchor2"><a href="/static-blog/database/redis/Redis_theory_note/#_2-简介" class="anchor-link"><div>2. 简介</div></a><ul class="anchor-list"><li class="anchor anchor3"><a href="/static-blog/database/redis/Redis_theory_note/#_2-1-优点" class="anchor-link"><div>2.1 优点</div></a></li><li class="anchor anchor3"><a href="/static-blog/database/redis/Redis_theory_note/#_2-2-缺点" class="anchor-link"><div>2.2 缺点</div></a></li></ul></li><li class="anchor anchor2"><a href="/static-blog/database/redis/Redis_theory_note/#_3-为什么要用-redis-为什么要用缓存" class="anchor-link"><div>3. 为什么要用 redis /为什么要用缓存</div></a><ul class="anchor-list"><li class="anchor anchor3"><a href="/static-blog/database/redis/Redis_theory_note/#_3-1-高性能" class="anchor-link"><div>3.1 高性能</div></a></li><li class="anchor anchor3"><a href="/static-blog/database/redis/Redis_theory_note/#_3-2-高并发" class="anchor-link"><div>3.2 高并发</div></a></li><li class="anchor anchor3"><a href="/static-blog/database/redis/Redis_theory_note/#_3-3-为什么要用-redis-而不用-map-guava-做缓存" class="anchor-link"><div>3.3 为什么要⽤ redis ⽽不⽤ map/guava 做缓存?</div></a></li></ul></li><li class="anchor anchor2"><a href="/static-blog/database/redis/Redis_theory_note/#_4-redis-的线程模型" class="anchor-link"><div>4. redis 的线程模型</div></a><ul class="anchor-list"><li class="anchor anchor3"><a href="/static-blog/database/redis/Redis_theory_note/#_4-1-redis单线程模型指的是什么" class="anchor-link"><div>4.1 redis单线程模型指的是什么</div></a></li><li class="anchor anchor3"><a href="/static-blog/database/redis/Redis_theory_note/#_4-2-redis是单线程模型为什么效率还这么高" class="anchor-link"><div>4.2 redis是单线程模型为什么效率还这么高？</div></a></li><li class="anchor anchor3"><a href="/static-blog/database/redis/Redis_theory_note/#_4-3-rector模式简介" class="anchor-link"><div>4.3 rector模式简介</div></a></li><li class="anchor anchor3"><a href="/static-blog/database/redis/Redis_theory_note/#_4-4-为什么网络处理要引入多线程" class="anchor-link"><div>4.4 为什么网络处理要引入多线程？</div></a></li></ul></li><li class="anchor anchor2"><a href="/static-blog/database/redis/Redis_theory_note/#_5-常⻅数据结构以及使用场景分析" class="anchor-link"><div>5.常⻅数据结构以及使⽤场景分析</div></a><ul class="anchor-list"><li class="anchor anchor3"><a href="/static-blog/database/redis/Redis_theory_note/#_5-1-string" class="anchor-link"><div>5.1 String</div></a></li><li class="anchor anchor3"><a href="/static-blog/database/redis/Redis_theory_note/#_5-2-hash" class="anchor-link"><div>5.2 Hash</div></a></li><li class="anchor anchor3"><a href="/static-blog/database/redis/Redis_theory_note/#_5-3-list" class="anchor-link"><div>5.3 List</div></a></li><li class="anchor anchor3"><a href="/static-blog/database/redis/Redis_theory_note/#_5-4-set" class="anchor-link"><div>5.4 Set</div></a></li><li class="anchor anchor3"><a href="/static-blog/database/redis/Redis_theory_note/#_5-5-zset-sorted-set" class="anchor-link"><div>5.5 ZSet（Sorted Set）</div></a></li></ul></li><li class="anchor anchor2"><a href="/static-blog/database/redis/Redis_theory_note/#_6-redis过期时间" class="anchor-link"><div>6. Redis过期时间</div></a></li><li class="anchor anchor2"><a href="/static-blog/database/redis/Redis_theory_note/#_7-redis内存淘汰机制" class="anchor-link"><div>7. Redis内存淘汰机制</div></a><ul class="anchor-list"><li class="anchor anchor3"><a href="/static-blog/database/redis/Redis_theory_note/#_7-1-内存置换策略" class="anchor-link"><div>7.1 内存置换策略</div></a></li><li class="anchor anchor3"><a href="/static-blog/database/redis/Redis_theory_note/#_7-2-淘汰机制的实现" class="anchor-link"><div>7.2 淘汰机制的实现</div></a></li></ul></li><li class="anchor anchor2"><a href="/static-blog/database/redis/Redis_theory_note/#_8-redis持久化机制" class="anchor-link"><div>8. Redis持久化机制</div></a><ul class="anchor-list"><li class="anchor anchor3"><a href="/static-blog/database/redis/Redis_theory_note/#_8-1-rdb-redis-database-快照" class="anchor-link"><div>8.1 RDB（Redis DataBase 快照）</div></a></li><li class="anchor anchor3"><a href="/static-blog/database/redis/Redis_theory_note/#_8-2-aof-append-only-file" class="anchor-link"><div>8.2 AOF（Append Only File）</div></a></li><li class="anchor anchor3"><a href="/static-blog/database/redis/Redis_theory_note/#_8-3-redis-4-0-对于持久化机制的优化" class="anchor-link"><div>8.3 Redis 4.0 对于持久化机制的优化</div></a></li></ul></li><li class="anchor anchor2"><a href="/static-blog/database/redis/Redis_theory_note/#_9-redis事务" class="anchor-link"><div>9. Redis事务</div></a><ul class="anchor-list"><li class="anchor anchor3"><a href="/static-blog/database/redis/Redis_theory_note/#_9-1-特点" class="anchor-link"><div>9.1 特点</div></a></li><li class="anchor anchor3"><a href="/static-blog/database/redis/Redis_theory_note/#_9-2-阶段" class="anchor-link"><div>9.2 阶段</div></a></li><li class="anchor anchor3"><a href="/static-blog/database/redis/Redis_theory_note/#_9-3-相关命令参考" class="anchor-link"><div>9.3 相关命令参考</div></a></li></ul></li><li class="anchor anchor2"><a href="/static-blog/database/redis/Redis_theory_note/#_10-缓存雪崩-缓存穿透-缓存击穿" class="anchor-link"><div>10. 缓存雪崩 | 缓存穿透 | 缓存击穿</div></a><ul class="anchor-list"><li class="anchor anchor3"><a href="/static-blog/database/redis/Redis_theory_note/#_10-1-缓存穿透" class="anchor-link"><div>10.1 缓存穿透</div></a></li><li class="anchor anchor3"><a href="/static-blog/database/redis/Redis_theory_note/#_10-2-缓存击穿" class="anchor-link"><div>10.2 缓存击穿</div></a></li><li class="anchor anchor3"><a href="/static-blog/database/redis/Redis_theory_note/#_10-3-缓存雪崩" class="anchor-link"><div>10.3 缓存雪崩</div></a></li></ul></li><li class="anchor anchor2"><a href="/static-blog/database/redis/Redis_theory_note/#_11-如何解决-redis-的并发竞争-key-问题" class="anchor-link"><div>11. 如何解决 Redis 的并发竞争 Key 问题</div></a><ul class="anchor-list"><li class="anchor anchor3"><a href="/static-blog/database/redis/Redis_theory_note/#_11-1-分布式锁-时间戳" class="anchor-link"><div>11.1 分布式锁+时间戳</div></a></li><li class="anchor anchor3"><a href="/static-blog/database/redis/Redis_theory_note/#_11-2-消息队列" class="anchor-link"><div>11.2 消息队列</div></a></li></ul></li><li class="anchor anchor2"><a href="/static-blog/database/redis/Redis_theory_note/#_12-区别" class="anchor-link"><div>12. 区别</div></a><ul class="anchor-list"><li class="anchor anchor3"><a href="/static-blog/database/redis/Redis_theory_note/#_12-1-redis-和-memcached-的区别" class="anchor-link"><div>12.1 redis 和 memcached 的区别</div></a></li></ul></li></ul></div></aside></div> <div class="theme-default-content content__default"><h2 id="_1-参考"><a href="#_1-参考" class="header-anchor">#</a> 1. 参考</h2> <blockquote><ul><li><a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247484858&amp;idx=1&amp;sn=8e222ea6115e0b69cac91af14d2caf36&amp;chksm=cea24a71f9d5c367148dccec3d5ddecf5ecd8ea096b5c5ec32f22080e66ac3c343e99151c9e0&amp;token=1082669959&amp;lang=zh_CN&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">redis 总结——重构版<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li>https://www.cnblogs.com/jasontec/p/9699242.html</li> <li>https://github.com/Snailclimb/JavaGuide</li> <li><a href="http://redisdoc.com/" target="_blank" rel="noopener noreferrer">Redis中文文档<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://www.bilibili.com/video/BV1S54y1R7SB" target="_blank" rel="noopener noreferrer">【狂神说Java】Redis最新超详细版教程通俗易懂<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></blockquote> <h2 id="_2-简介"><a href="#_2-简介" class="header-anchor">#</a> 2. 简介</h2> <p>Redis的全称是<code>Remote Dictionary Server</code>，即<code>远程字典服务</code>。官方原话如下：</p> <p>Redis是一个开源(BSD许可)的,内存中的数据结构存储系统,它可以用作<code>数据库</code>、<code>缓存</code>和<code>消息中间件MQ</code>。它支持多种类型的数据结构,如字符串( strings),散列( hashes),列表( lists),集合(sets),有序集合( sorted sets)与范围查询,bitmaps, hyperloglogs和地理空间( geospatial)索引半径查询。 Redis内置了复制( replication),LUA脚本(Luascripting),LRU驱动事件( LRU eviction),事务( transactions)和不同级别的磁盘持久化( persistence),并通过Reds哨兵( Sentinel)和自动分区( Cluster)提供高可用性( high availability)。</p> <h3 id="_2-1-优点"><a href="#_2-1-优点" class="header-anchor">#</a> 2.1 优点</h3> <p>因为是<code>纯内存</code>操作, Redis的性能非常出色,每秒可以处理超过<code>10万次读写操作</code>是已知性能最快的<code>Key- Value DB</code>。Redis的出色之处不仅仅是性能, Redis最大的魅力是支持保存<code>多种数据结构</code>,此外<code>单个value</code>的最大限制是<code>1GB</code>,不像 <code>memcached</code>只能保存<code>1MB</code>的数据,因此 Redis可以用来实现很多有用的功能。比方说用他的<code>Lst</code>来做<code>FIFO双向链表</code>,实现一个轻量级的高性能消息队列服务用他的Set可以做高性能的tag系统等等另外 Redis也可以对存入的<code>Key-Vaue</code>设置<code>expire</code>时间,因此也可以被当作一个功能加强版的 memcached来用。</p> <h3 id="_2-2-缺点"><a href="#_2-2-缺点" class="header-anchor">#</a> 2.2 缺点</h3> <p>Redis的主要缺点是<code>数据库容量</code>受到<code>物理内存</code>的限制,不能用作<code>海量数据的高性能读写</code>,因此 Redis适合的场景主要局限在较小数据量的高性能操作和运算上。</p> <p>简单来说 redis 就是⼀个数据库，不过与传统数据库不同的是 redis 的数据是存在内存中的，所以读 写速度⾮常快，因此 redis 被⼴泛应⽤于缓存⽅向。另外，redis 也经常⽤来做<code>分布式锁</code>。redis 提 供了多种数据类型来⽀持不同的业务场景。除此之外，redis ⽀持事务 、持久化、LUA脚本、LRU驱动 事件、多种集群⽅案。</p> <h2 id="_3-为什么要用-redis-为什么要用缓存"><a href="#_3-为什么要用-redis-为什么要用缓存" class="header-anchor">#</a> 3. 为什么要用 redis /为什么要用缓存</h2> <p>主要从“<code>高性能</code>”和“<code>高并发</code>”这两点来看待这个问题。</p> <h3 id="_3-1-高性能"><a href="#_3-1-高性能" class="header-anchor">#</a> 3.1 高性能</h3> <p>假如用户第一次访问数据库中的某些数据。这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的数据存在数缓存中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可！</p> <p><img src="https://cdn.jsdelivr.net/gh/lifealsoisgg/static-blog@gh-pages/assets/img/Why_use_redis_high-performance.c1a0af65.jpg" alt="为什么使用redis-高性能"></p> <h3 id="_3-2-高并发"><a href="#_3-2-高并发" class="header-anchor">#</a> 3.2 高并发</h3> <p>直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。</p> <p><img src="https://cdn.jsdelivr.net/gh/lifealsoisgg/static-blog@gh-pages/assets/img/Why_use_redis_high-concurrency.992ae12b.jpg" alt="为什么使用redis-高并发"></p> <h3 id="_3-3-为什么要用-redis-而不用-map-guava-做缓存"><a href="#_3-3-为什么要用-redis-而不用-map-guava-做缓存" class="header-anchor">#</a> 3.3 为什么要⽤ redis ⽽不⽤ map/guava 做缓存?</h3> <p>缓存分为本地缓存和分布式缓存。以 Java 为例，使⽤⾃带的 map 或者 guava 实现的是本地缓存，最主要的特点是轻量以及快速，⽣命周期随着 jvm 的销毁⽽结束，并且在多实例的情况下，每个实例都 需要各⾃保存⼀份缓存，缓存不具有⼀致性。 使⽤ redis 或 memcached 之类的称为分布式缓存，在多实例的情况下，各实例共⽤⼀份缓存数据，缓 存具有⼀致性。缺点是需要保持 redis 或 memcached服务的⾼可⽤，整个程序架构上较为复杂。</p> <h2 id="_4-redis-的线程模型"><a href="#_4-redis-的线程模型" class="header-anchor">#</a> 4. redis 的线程模型</h2> <p>参考</p> <blockquote><ul><li>https://blog.csdn.net/m0_37524661/article/details/87086267</li> <li>https://baijiahao.baidu.com/s?id=1666100733546359034&amp;wfr=spider&amp;for=pc</li></ul></blockquote> <p><img src="https://cdn.jsdelivr.net/gh/lifealsoisgg/static-blog@gh-pages/assets/img/Redis_thread_model.67d63984.png" alt="Redis线程模型"></p> <h3 id="_4-1-redis单线程模型指的是什么"><a href="#_4-1-redis单线程模型指的是什么" class="header-anchor">#</a> 4.1 redis单线程模型指的是什么</h3> <p>Redis基于<code>Reactor</code>模式开发了网络事件处理器，这个处理器被称为<code>文件事件处理器</code>。它的组成结构为4部分：</p> <blockquote><ul><li><p>多个套接字</p></li> <li><p>IO多路复用程序</p></li> <li><p>文件事件分派器</p></li> <li><p>事件处理器</p></li></ul></blockquote> <p>redis 内部使⽤⽂件事件处理器 <code>file event handler</code> ，这个<code>⽂件事件处理器</code>是<code>单线程</code>的，所以 redis 才叫做<code>单线程模型</code>。它采⽤ <code>IO 多路复⽤机</code>制同时监听多个 <code>socket</code>，根据 <code>socket</code> 上的事件 来选择对应的事件处理器进⾏处理</p> <p>Redis客户端对服务端的每次调用都经历了<code>发送命令</code>，<code>执行命令</code>，<code>返回结果</code>三个过程。其中执行命令阶段，由于Redis是<code>单线程</code>来处理命令的，所有每一条到达服务端的命令不会立刻执行，所有的命令都会进入一个队列中，然后逐个被执行。并且多个客户端发送的命令的执行<code>顺序是不确定</code>的。但是可以确定的是不会有两条命令被同时执行，不会产生并发问题，这就是Redis的单线程基本模型。</p> <blockquote><p>目前redis的网络处理方面时多线程，但是核心模块方面还是单线程</p></blockquote> <h3 id="_4-2-redis是单线程模型为什么效率还这么高"><a href="#_4-2-redis是单线程模型为什么效率还这么高" class="header-anchor">#</a> 4.2 redis是单线程模型为什么效率还这么高？</h3> <blockquote><ol><li><strong>纯内存访问</strong>：数据存放在内存中，内存的响应时间大约是100纳秒，这是Redis每秒万亿级别访问的重要基础。</li> <li><strong>非阻塞I/O</strong>：Redis采用epoll做为I/O多路复用技术的实现，再加上Redis自身的事件处理模型将epoll中的连接，读写，关闭都转换为了时间，不在I/O上浪费过多的时间。</li> <li>单线程避免了线程切换和竞态产生的消耗。</li> <li>Redis采用单线程模型，每条命令执行如果占用大量时间，会造成其他线程阻塞，对于Redis这种高性能服务是致命的，所以Redis是面向高速执行的数据库</li></ol></blockquote> <h3 id="_4-3-rector模式简介"><a href="#_4-3-rector模式简介" class="header-anchor">#</a> 4.3 rector模式简介</h3> <p>参考</p> <blockquote><ul><li>https://www.cnblogs.com/crazymakercircle/p/9833847.html</li></ul></blockquote> <h3 id="_4-4-为什么网络处理要引入多线程"><a href="#_4-4-为什么网络处理要引入多线程" class="header-anchor">#</a> 4.4 为什么网络处理要引入多线程？</h3> <p>之前的段落说了，Redis 的瓶颈并不在 CPU，而在<code>内存</code>和<code>网络I/O</code>。</p> <p>内存不够的话，可以加内存或者做数据结构优化和其他优化等，但网络的性能优化才是大头，网络 IO 的读写在 Redis 整个执行期间占用了大部分的 CPU 时间，如果把网络处理这部分做成多线程处理方式，那对整个 Redis 的性能会有很大的提升。</p> <p><img src="https://cdn.jsdelivr.net/gh/lifealsoisgg/static-blog@gh-pages/assets/img/Redis_single_multi-threaded_GET_performance_comparison.b0d82d00.jpg" alt="redis单多线程GET性能对比"></p> <p><img src="https://cdn.jsdelivr.net/gh/lifealsoisgg/static-blog@gh-pages/assets/img/Redis_single_multi-threaded_SET_performance_comparison.5391ac78.jpg" alt="redis单多线程SET性能对比"></p> <h2 id="_5-常⻅数据结构以及使用场景分析"><a href="#_5-常⻅数据结构以及使用场景分析" class="header-anchor">#</a> 5.常⻅数据结构以及使⽤场景分析</h2> <table><thead><tr><th>数据结构</th> <th>常用命令</th></tr></thead> <tbody><tr><td>String</td> <td>set,get,decr,incr,mget</td></tr> <tr><td>Hash</td> <td>hget,hset,hgetall</td></tr> <tr><td>List</td> <td>lpush,rpush,lpop,rpop,lrange</td></tr> <tr><td>Set</td> <td>sadd,spop,smembers,sunion</td></tr> <tr><td>ZSet（Sorted Set）</td> <td>zadd,zrange,zrem,zcard</td></tr></tbody></table> <h3 id="_5-1-string"><a href="#_5-1-string" class="header-anchor">#</a> 5.1 String</h3> <blockquote><p>常⽤命令: set,get,decr,incr,mget 等。</p></blockquote> <p>String数据结构是简单的key-value类型，value其实不仅可以是String，也可以是数字。 常规keyvalue缓存应⽤； 常规计数：微博数，粉丝数等。</p> <p>string类型是二进制安全的。意思是redis的string可以包含任何数据。比如jpg图片或者序列化的对象 。</p> <h3 id="_5-2-hash"><a href="#_5-2-hash" class="header-anchor">#</a> 5.2 Hash</h3> <blockquote><p>常⽤命令： hget,hset,hgetall 等。</p></blockquote> <p>hash 是⼀个 string 类型的 <code>field</code> 和 <code>value</code> 的映射表，hash 特别适合⽤于存储对象，后续操作的时 候，你可以直接仅仅修改这个对象中的某个字段的值。 ⽐如我们可以 hash 数据结构来存储⽤户信 息，商品信息等等。⽐如下⾯我就⽤ hash 类型存放了我本⼈的⼀些信息：</p> <div class="language-json line-numbers-mode"><pre class="language-json"><code>key=JavaUser293847
value=<span class="token punctuation">{</span>
 “id”<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
 “name”<span class="token operator">:</span> “SnailClimb”<span class="token punctuation">,</span>
 “age”<span class="token operator">:</span> <span class="token number">22</span><span class="token punctuation">,</span>
 “location”<span class="token operator">:</span> “Wuhan<span class="token punctuation">,</span> Hubei”
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h3 id="_5-3-list"><a href="#_5-3-list" class="header-anchor">#</a> 5.3 List</h3> <blockquote><p>常⽤命令: lpush,rpush,lpop,rpop,lrange等</p></blockquote> <p>Redis list 的实现为⼀个<code>双向链表</code>。Redis list 的应⽤场景⾮常多，也是Redis最重要的数据结构之⼀，⽐如微博的关注 列表，粉丝列表，消息列表等功能都可以⽤Redis的 list 结构来实现。 Redis list 的实现为⼀个双向链表，即可以⽀持反向查找和遍历，更⽅便操作，不过带来了部分额外 的内存开销。 另外可以通过 lrange 命令，就是从某个元素开始读取多少个元素，可以基于 list 实现分⻚查询，这 个很棒的⼀个功能，基于 redis 实现简单的⾼性能分⻚，可以做类似微博那种下拉不断分⻚的东⻄ （⼀⻚⼀⻚的往下⾛），性能⾼。</p> <p>在 key 对应 list 的头部添加字符串元素</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>lpush name value
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>在 key 对应 list 的尾部添加字符串元素</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>rpush name value
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>key 对应 list 中删除 count 个和 value 相同的元素</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>lrem name index
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>返回 key 对应 list 的长度</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>llen name 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h3 id="_5-4-set"><a href="#_5-4-set" class="header-anchor">#</a> 5.4 Set</h3> <blockquote><p>常⽤命令： sadd,spop,smembers,sunion 等</p></blockquote> <p>set 对外提供的功能与list类似是⼀个列表的功能，特殊之处在于 set 是可以⾃动排重的。 当你需要存储⼀个列表数据，⼜不希望出现重复数据时，set是⼀个很好的选择，并且set提供了判断某 个成员是否在⼀个set集合内的重要接⼝，这个也是list所不能提供的。可以基于 set 轻易实现交集、 并集、差集的操作。 ⽐如：在微博应⽤中，可以将⼀个⽤户所有的关注⼈存在⼀个集合中，将其所有粉丝存在⼀个集合。 Redis可以⾮常⽅便的实现如共同关注、共同粉丝、共同喜好等功能。这个过程也就是求交集的过程， 具体命令如下：</p> <div class="language-json line-numbers-mode"><pre class="language-json"><code>sinterstore key1 key2 key3 将交集存在key1内
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h3 id="_5-5-zset-sorted-set"><a href="#_5-5-zset-sorted-set" class="header-anchor">#</a> 5.5 ZSet（Sorted Set）</h3> <blockquote><p>常⽤命令： zadd,zrange,zrem,zcard等</p></blockquote> <p>和set相⽐，sorted set增加了⼀个权重参数score，使得集合中的元素能够按score进⾏有序排列。 举例： 在直播系统中，实时排⾏信息包含直播间在线⽤户列表，各种礼物排⾏榜，弹幕消息（可以理 解为按消息维度的消息排⾏榜）等信息，适合使⽤ Redis 中的 Sorted Set 结构进⾏存储。</p> <h2 id="_6-redis过期时间"><a href="#_6-redis过期时间" class="header-anchor">#</a> 6. Redis过期时间</h2> <p>Redis中有个设置时间过期的功能，即对存储在 redis 数据库中的值可以设置⼀个过期时间。作为⼀个 缓存数据库，这是⾮常实⽤的。如我们⼀般项⽬中的 token 或者⼀些登录信息，尤其是短信验证码都 是有时间限制的，按照传统的数据库处理⽅式，⼀般都是⾃⼰判断过期，这样⽆疑会严重影响项⽬性 能。</p> <p>我们 set key 的时候，都可以给⼀个 <code>expire time</code>，就是过期时间，通过过期时间我们可以指定这个 key 可以存活的时间。 也可以在运行时给存在的键设置剩余的生存时间，不设置则默认为<code>-1</code>，设置为-1时表示<code>永久存储</code>。</p> <p>如果假设你创建一个 <code>Timer</code>，设置了⼀批 key 只能存活1个⼩时，那么接下来1⼩时后，redis是怎么对这批key进⾏删除 的？</p> <blockquote><ul><li><strong>定期删除</strong>：redis默认是每隔 <code>100ms</code> 就随机抽取⼀些设置了过期时间的key，检查其是否过期， 如果过期就删除。注意这⾥是随机抽取的。为什么要随机呢？你想⼀想假如 redis 存了⼏⼗万 个 key ，每隔100ms就遍历所有的设置过期时间的 key 的话，这时候需要的是Cpu处理能力，而不是内存，就会给 CPU 带来很⼤的负载！</li> <li><strong>惰性删除</strong> ：定期删除可能会导致很多过期 key 到了时间并没有被删除掉。所以就有了惰性删除。假如你的过期 key，靠定期删除没有被删除掉，还停留在内存⾥，除⾮你的系统去查⼀下那 个 key，才会被redis给删除掉。这就是所谓的惰性删除，也是够懒的哈！ 但是仅仅通过设置过期时间还是有问题的。</li></ul></blockquote> <p>但是仅仅通过设置过期时间还是有问题的。我们想⼀下：如果定期删除漏掉了很多过期 key，然后你也 没及时去查，也就没⾛惰性删除，此时会怎么样？如果⼤量过期key堆积在内存⾥，导致redis内存块耗 尽了。怎么解决这个问题呢？ redis 内存淘汰机制。</p> <h2 id="_7-redis内存淘汰机制"><a href="#_7-redis内存淘汰机制" class="header-anchor">#</a> 7. Redis内存淘汰机制</h2> <p>参考</p> <blockquote><ul><li>https://blog.csdn.net/weixin_43184769/article/details/90523923</li> <li>https://blog.csdn.net/qq_28018283/article/details/80764518</li> <li>配置文件： http://download.redis.io/redis-stable/redis.conf</li></ul></blockquote> <p>思考一下，如果定期删除漏掉了很多过期的key，而我们也没有再去访问它，如果不加处理，很可能导致内存耗尽。</p> <p>什么时候触发</p> <p>Redis配置文件中可以设置<code>maxmemory</code>，内存的最大使用量，到达限度时会执行<code>内存淘汰机制</code></p> <h3 id="_7-1-内存置换策略"><a href="#_7-1-内存置换策略" class="header-anchor">#</a> 7.1 内存置换策略</h3> <p>没有配置时，<code>默认为no-eviction</code></p> <table><thead><tr><th>名称</th> <th>描述</th></tr></thead> <tbody><tr><td>volatile-lru</td> <td>从<code>已设置过期时间的数据集</code>中挑选<code>最近最少使用</code>的数据淘汰</td></tr> <tr><td>volatile-lfu（4.0版本）</td> <td>从<code>已设置过期时间的数据集</code>中挑选<code>最不经常</code>使用的数据淘汰</td></tr> <tr><td>volatile-ttl</td> <td>从<code>已设置过期时间的数据集</code>中挑选<code>将要过期</code>的数据淘汰</td></tr> <tr><td>volatile-random</td> <td>从<code>已设置过期时间的数据集</code>中挑选<code>任意数据</code>淘汰</td></tr> <tr><td>allkeys-lru</td> <td>当<code>内存不足</code>写入新数据时淘汰<code>最近最少</code>使用的Key</td></tr> <tr><td>allkeys-random</td> <td>当<code>内存不足</code>写入新数据时<code>随机选择</code>key淘汰</td></tr> <tr><td>allkeys-lfu（4.0版本）</td> <td>当<code>内存不足</code>写入新数据时移除<code>最不经常使用</code>的Key</td></tr> <tr><td>no-eviction（禁止驱逐数据）</td> <td>当<code>内存不足</code>写入新数据时，写入操作会报错，同时不删除数据</td></tr></tbody></table> <blockquote><ul><li>volatile为前缀的策略都是从已过期的数据集中进行淘汰。</li> <li>allkeys为前缀的策略都是面向所有key进行淘汰。</li> <li>LRU（least recently used）最少最近用到的。</li> <li>LFU（Least Frequently Used）最不常用的。</li> <li>TTL（Time To Live）</li> <li>它们的触发条件都是Redis使用的内存达到阈值时。</li></ul></blockquote> <h3 id="_7-2-淘汰机制的实现"><a href="#_7-2-淘汰机制的实现" class="header-anchor">#</a> 7.2 淘汰机制的实现</h3> <p>既然是淘汰，那就需要把这些数据给删除，然后保存新的。Redis 删除失效主键的方法主要有两种：</p> <h4 id="消极方法-passive-way"><a href="#消极方法-passive-way" class="header-anchor">#</a> 消极方法( passive way)</h4> <p>在主键被访问时如果发现它已经失效,那么就删除它。 redis在实现<code>GET</code>、<code>MGET</code>、<code>HGET</code>、 LRANGE等所有涉及到读取数据的命令时都会调<code>expirelfNeeded</code>,它存在的意义就是在读取数据之前先检查一下它有没有失效,如果失效了就删除</p> <p><code>expirelfNeeded</code>函数中调用的另外一个函数 <code>propagateExpire</code>,这个函数用来在正式删除<code>失效主键</code>,并且<code>广播</code>告诉其他地方,目的地有俩</p> <blockquote><ul><li><code>AOF</code>文件,将删除失效主键的这一操作以 DEL Key的标准命令格式记录下来</li> <li>另一个就是发送到当前 Redis服务器的所有 <code>Slave</code>,同样将删除失效主键的这操作以 <code>DEL Key</code>的标准命令格式告知这些<code>Slave</code>删除各自的失效主键</li></ul></blockquote> <h4 id="积极方法-active-way"><a href="#积极方法-active-way" class="header-anchor">#</a> 积极方法( active way)</h4> <p>周期性地探测,发现失效就删除。消极方法的缺点是,如果keγ迟迟不被访问,就会占用很多内存空间,所以才有积极方式</p> <h4 id="主动删除"><a href="#主动删除" class="header-anchor">#</a> 主动删除</h4> <p>当內存超过 <code>maxmemoryl</code>限定时,触发主动清理策略,该策略由启动参数的配置决定</p> <h2 id="_8-redis持久化机制"><a href="#_8-redis持久化机制" class="header-anchor">#</a> 8. Redis持久化机制</h2> <blockquote><p>怎么保证 redis 挂掉之后再重启数据可以进⾏恢复</p></blockquote> <p>参考</p> <blockquote><ul><li>https://baijiahao.baidu.com/s?id=1654694618189745916&amp;wfr=spider&amp;for=pc</li></ul></blockquote> <p>很多时候我们需要持久化数据也就是将内存中的数据写⼊到硬盘⾥⾯，⼤部分原因是为了之后重⽤数据 （⽐如重启机器、机器故障之后恢复数据），或者是为了防⽌系统故障⽽将数据备份到⼀个远程位置。 Redis不同于Memcached的很重⼀点就是，Redis⽀持<code>持久化</code>，⽽且⽀持两种不同的持久化操作。</p> <blockquote><ul><li>RDB（Redis DataBase 快照）</li> <li>AOF（Append Only File）</li></ul></blockquote> <h3 id="_8-1-rdb-redis-database-快照"><a href="#_8-1-rdb-redis-database-快照" class="header-anchor">#</a> 8.1 RDB（Redis DataBase 快照）</h3> <p>Redis可以通过创建快照来获得存储在内存⾥⾯的数据在某个时间点上的副本。Redis创建快照之后，可 以对快照进⾏备份，可以将快照复制到其他服务器从⽽创建具有相同数据的服务器副本（Redis主从结 构，主要⽤来提⾼Redis性能），还可以将快照留在原地以便重启服务器的时候使⽤。</p> <p>优点</p> <blockquote><ul><li>RDB文件紧凑，全量备份，非常适合用于进行备份和灾难恢复。</li> <li>在使用bgsave生成RDB文件的时候，redis主进程会fork()一个子进程来处理所有保存工作，主进程不需要进行任何磁盘IO操作。</li> <li>RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。</li></ul></blockquote> <p>缺点</p> <blockquote><ul><li>RDB快照是一次<code>全量备份</code>，存储的是内存数据的<code>二进制序列化</code>形式，存储上非常紧凑。当进行快照持久化时，会开启一个子进程专门负责快照持久化，子进程会拥有父进程的<code>内存数据</code>，父进程修改内存子进程<code>不会反应</code>出来，所以在<code>快照持久化期间修改的数据不会被保存</code>，可能丢失数据。</li></ul></blockquote> <p>快照持久化是Redis<code>默认采⽤</code>的持久化⽅式,触发方式如下：</p> <blockquote><ul><li>save</li> <li>bgsave</li> <li>自动化</li></ul></blockquote> <h4 id="触发方式-save"><a href="#触发方式-save" class="header-anchor">#</a> 触发方式：save</h4> <p>该命令会阻塞当前Redis服务器，执行save命令期间，Redis不能处理其他命令，直到RDB过程完成为止。具体流程如下：</p> <p><img src="https://cdn.jsdelivr.net/gh/lifealsoisgg/static-blog@gh-pages/assets/img/save_trigger_mode.47130e98.jpg" alt="save触发方式"></p> <p>执行完成时候如果存在老的<code>RDB</code>文件，就把新的替代掉旧的。我们的客户端可能都是几万或者是几十万，这种方式显然不可取。</p> <h4 id="触发方式-bgsave"><a href="#触发方式-bgsave" class="header-anchor">#</a> 触发方式：bgsave</h4> <p>执行该命令时，Redis会在后台<code>异步</code>进行快照操作，快照同时还可以<code>响应客户端请求</code>。具体流程如下：</p> <p><img src="https://cdn.jsdelivr.net/gh/lifealsoisgg/static-blog@gh-pages/assets/img/bgsave_trigger_mode.85f4142f.jpg" alt="bgsave触发方式"></p> <p>具体操作是Redis进程执行<code>fork</code>操作<code>创建子进程</code>，RDB持久化过程由<code>子进程负责</code>，完成后自动结束。阻塞只发生在<code>fork</code>阶段，一般时间很短。基本上 Redis 内部所有的RDB操作都是采用 <code>bgsave</code> 命令。</p> <h4 id="触发方式-自动触发"><a href="#触发方式-自动触发" class="header-anchor">#</a> 触发方式：自动触发</h4> <p>自动触发是由我们的配置文件来完成的。在<code>redis.conf</code>配置文件中，里面有如下配置，我们可以去设置：</p> <p><strong>①save</strong></p> <p>这里是用来配置触发 Redis的 <code>RDB</code> 持久化条件，也就是什么时候将内存中的数据保存到硬盘。比如“save m n”。表示m秒内数据集存在n次修改时，自动触发<code>bgsave</code>。</p> <p>默认如下配置：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>save m n

#在<span class="token number">900</span>秒<span class="token punctuation">(</span><span class="token number">15</span>分钟<span class="token punctuation">)</span>之后，如果⾄少有<span class="token number">1</span>个key发⽣变化，<span class="token class-name">Redis</span>就会⾃动触发BGSAVE命令创建快照。
save <span class="token number">900</span> <span class="token number">1</span> 

#在<span class="token number">300</span>秒<span class="token punctuation">(</span><span class="token number">5</span>分钟<span class="token punctuation">)</span>之后，如果⾄少有<span class="token number">10</span>个key发⽣变化，<span class="token class-name">Redis</span>就会⾃动触发BGSAVE命令创建快照。
save <span class="token number">300</span> <span class="token number">10</span> 
  
#在<span class="token number">60</span>秒<span class="token punctuation">(</span><span class="token number">1</span>分钟<span class="token punctuation">)</span>之后，如果⾄少有<span class="token number">10000</span>个key发⽣变化，<span class="token class-name">Redis</span>就会⾃动触发BGSAVE命令创建快照。
save <span class="token number">60</span> <span class="token number">10000</span> 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>**②stop-writes-on-bgsave-error ：**默认值为yes。当启用了RDB且最后一次后台保存数据失败，Redis是否停止接收数据。这会让用户意识到数据没有正确持久化到磁盘上，否则没有人会注意到灾难（disaster）发生了。如果Redis重启了，那么又可以重新开始接收数据了</p> <p>**③rdbcompression ；**默认值是yes。对于存储到磁盘中的快照，可以设置是否进行压缩存储。</p> <p>**④rdbchecksum ：**默认值是yes。在存储快照后，我们还可以让redis使用CRC64算法来进行数据校验，但是这样做会增加大约10%的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能。</p> <p>**⑤dbfilename ：**设置快照的文件名，默认是 dump.rdb</p> <p>**⑥dir：**设置快照文件的存放路径，这个配置项一定是个目录，而不能是文件名。</p> <h4 id="save和bgsave的区别"><a href="#save和bgsave的区别" class="header-anchor">#</a> save和bgsave的区别</h4> <p><img src="https://cdn.jsdelivr.net/gh/lifealsoisgg/static-blog@gh-pages/assets/img/The_difference_between_save_and_bgsave.f4da06d6.jpg" alt="save和bgsave的区别"></p> <h3 id="_8-2-aof-append-only-file"><a href="#_8-2-aof-append-only-file" class="header-anchor">#</a> 8.2 AOF（Append Only File）</h3> <p>与<code>快照持久化</code>相⽐，<code>AOF持久化</code> 的<code>实时性</code>更好，因此已成为主流的持久化⽅案。默认情况下Redis没有 开启<code>AOF（append only file）</code>⽅式的持久化。</p> <p>可以通过<code>appendonly</code>参数开启：</p> <h4 id="持久化原理"><a href="#持久化原理" class="header-anchor">#</a> 持久化原理</h4> <p><img src="https://cdn.jsdelivr.net/gh/lifealsoisgg/static-blog@gh-pages/assets/img/AOF_running-principle&amp;creation.8678252c.jpg" alt="AOF运行原理-创建"></p> <p>每当有一个写命令过来时，就直接保存在我们的<code>AOF</code>文件中。</p> <h4 id="文件重写原理"><a href="#文件重写原理" class="header-anchor">#</a> 文件重写原理</h4> <p>AOF的方式也同时带来了另一个问题。持久化文件会变的越来越大。为了压缩<code>AOF</code>的持久化文件。redis提供了<code>bgrewriteaof</code>命令。将内存中的数据以命令的方式保存到临时文件中，同时会<code>fork</code>出一条<code>新进程</code>来将文件重写。</p> <p><img src="https://cdn.jsdelivr.net/gh/lifealsoisgg/static-blog@gh-pages/assets/img/Principle_of_bgrewriteaof_file_rewriting.c432c925.jpg" alt="bgrewriteaof文件重写原理"></p> <p>重写<code>AOF</code>文件的操作，并没有读取旧的<code>AOF</code>文件，而是将整个内存中的数据库内容用命令的方式重写了一个<code>新的AOF文件</code>，这点和<code>快照</code>有点类似。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>appendonly yes
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>开启AOF持久化后每执⾏⼀条会更改Redis中的数据的命令，Redis就会将该命令通过<code>write</code>写⼊硬盘中的<code>AOF</code>⽂件，通俗的理解就是<code>日志记录</code>。 <code>AOF</code>⽂件的保存位置和<code>RDB</code>⽂件的位置相同，都是通过<code>dir</code>参数设置的，默认的⽂件名是 <code>appendonly.aof</code>。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>appendfsync always #每次有数据修改发⽣时都会写⼊AOF⽂件<span class="token punctuation">,</span>这样会严重降低<span class="token class-name">Redis</span>的速度
  
appendfsync everysec #每秒钟同步⼀次，显示地将多个写命令同步到硬盘
  
appendfsync no #让操作系统决定何时进⾏同步
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>为了兼顾数据和写⼊性能，⽤户可以考虑 <code>appendfsync everysec</code>选项 ，让Redis每秒同步⼀次AOF⽂ 件，Redis性能⼏乎没受到任何影响。⽽且这样即使出现系统崩溃，⽤户最多只会丢失⼀秒之内产⽣的 数据。当硬盘忙于执⾏写⼊操作的时候，Redis还会优雅的放慢⾃⼰的速度以便适应硬盘的最⼤写⼊速度。</p> <h3 id="_8-3-redis-4-0-对于持久化机制的优化"><a href="#_8-3-redis-4-0-对于持久化机制的优化" class="header-anchor">#</a> 8.3 Redis 4.0 对于持久化机制的优化</h3> <p>Redis 4.0 开始⽀持 <code>RDB</code> 和 <code>AOF</code> 的<code>混合持久化</code>（默认关闭，可以通过配置项开启）</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>aof<span class="token operator">-</span>use<span class="token operator">-</span>rdbpreamble
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>如果把混合持久化打开，<code>AOF</code> 重写的时候就直接把 <code>RDB</code> 的内容写到 <code>AOF ⽂件开头</code>。这样做的好处是可 以结合 <code>RDB</code> 和 <code>AOF</code> 的优点, 快速加载同时避免丢失过多的数据。当然缺点也是有的， <code>AOF</code> ⾥⾯的 <code>RDB</code> 部分是压缩格式不再是 <code>AOF</code> 格式，可读性较差。</p> <h2 id="_9-redis事务"><a href="#_9-redis事务" class="header-anchor">#</a> 9. Redis事务</h2> <p>参考</p> <blockquote><ul><li>https://www.runoob.com/redis/redis-transactions.html</li></ul></blockquote> <p>Redis 通过 <code>MULTI</code>、<code>EXEC</code>、<code>WATCH</code> 等命令来实现<code>事务(transaction)</code>功能。Redis 事务的本质是一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。</p> <h3 id="_9-1-特点"><a href="#_9-1-特点" class="header-anchor">#</a> 9.1 特点</h3> <blockquote><ul><li>Redis事务没有隔离级别的概念：批量操作在发送 <code>EXEC</code> 命令前被放入队列缓存，并不会被实际执行，也就不存在事务内的查询要看到事务里的更新，事务外查询不能看到。</li> <li>Redis事务不保证原子性：Redis中，<code>单条命令是原子性执行的</code>，但事务不保证<code>原子性</code>，且没有回滚。事务中任意命令执行失败，其余的命令仍会被执行。</li> <li>在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中。</li></ul></blockquote> <h3 id="_9-2-阶段"><a href="#_9-2-阶段" class="header-anchor">#</a> 9.2 阶段</h3> <blockquote><ul><li>开始事务。</li> <li>命令入队。</li> <li>执行事务。</li></ul></blockquote> <h3 id="_9-3-相关命令参考"><a href="#_9-3-相关命令参考" class="header-anchor">#</a> 9.3 相关命令参考</h3> <blockquote><ul><li>https://www.runoob.com/redis/redis-transactions.html</li></ul></blockquote> <h2 id="_10-缓存雪崩-缓存穿透-缓存击穿"><a href="#_10-缓存雪崩-缓存穿透-缓存击穿" class="header-anchor">#</a> 10. 缓存雪崩 | 缓存穿透 | 缓存击穿</h2> <p>参考</p> <blockquote><ul><li>https://blog.csdn.net/fanrenxiang/article/details/80542580</li> <li>https://www.cnblogs.com/xichji/p/11286443.html</li></ul></blockquote> <blockquote><ul><li><strong>缓存穿透</strong>：key对应的数据在数据源并不存在，每次针对此key的请求从<code>缓存</code>获取不到，请求都会到<code>数据源</code>，从而可能<code>压垮数据源</code>。举个例⼦：某个⿊客故意制造我们缓存中不存在的 key 发起⼤量请求，导致⼤量请 求落到数据库，若黑客利用此漏洞进行攻击可能压垮数据库。</li> <li><strong>缓存击穿</strong>：是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个<code>key</code>在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，这个时候大并发的请求可能会瞬间把后端DB压垮，就像在一个屏障上凿开了一个洞。</li> <li><strong>缓存雪崩</strong>：当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，也会给后端系统(比如DB)带来很大压力，所以，后⾯的请求都会落到数据库上，造成数据库短时间内承受⼤量请求⽽崩掉。</li></ul></blockquote> <h3 id="_10-1-缓存穿透"><a href="#_10-1-缓存穿透" class="header-anchor">#</a> 10.1 缓存穿透</h3> <p>缓存穿透说简单点就是⼤量请求的 key 根本不存在于缓存中，导致请求直接到了数据库上，根本没有 经过缓存这⼀层。举个例⼦：某个⿊客故意制造我们缓存中不存在的 key 发起⼤量请求，导致⼤量请 求落到数据库。</p> <h4 id="原理"><a href="#原理" class="header-anchor">#</a> 原理</h4> <p>正常缓存处理流程</p> <p><img src="https://cdn.jsdelivr.net/gh/lifealsoisgg/static-blog@gh-pages/assets/img/Cache_processing_flow.30bd8a69.jpg" alt="缓存处理流程"></p> <p>缓存穿透处理流程</p> <p><img src="https://cdn.jsdelivr.net/gh/lifealsoisgg/static-blog@gh-pages/assets/img/Cache_penetration_processing_flow.933948da.jpg" alt="缓存穿透处理流程"></p> <h4 id="解决办法"><a href="#解决办法" class="header-anchor">#</a> 解决办法</h4> <p>一个一定不存在缓存及查询不到的数据，由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。</p> <p>最基本的就是⾸先做好<code>参数校验</code>，⼀些<code>不合法的参数</code>请求直接抛出异常信息返回给客户端。⽐如查询的 数据库 id 不能⼩于 0、传⼊的邮箱格式不对的时候直接返回错误消息给客户端等等。</p> <p>如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">getObjectInclNullById</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token comment">// 从缓存中获取数据</span>
 <span class="token class-name">Object</span> cacheValue <span class="token operator">=</span> cache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token comment">// 缓存为空</span>
 <span class="token keyword">if</span> <span class="token punctuation">(</span>cacheValue <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token comment">// 从数据库中获取</span>
 <span class="token class-name">Object</span> storageValue <span class="token operator">=</span> storage<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token comment">// 缓存空对象</span>
 cache<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> storageValue<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token comment">// 如果存储数据为空，需要设置⼀个过期时间(300秒)</span>
 <span class="token keyword">if</span> <span class="token punctuation">(</span>storageValue <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token comment">// 必须设置过期时间，否则有被攻击的⻛险</span>
 cache<span class="token punctuation">.</span><span class="token function">expire</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token number">60</span> <span class="token operator">*</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
 <span class="token keyword">return</span> storageValue<span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
 <span class="token keyword">return</span> cacheValue<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><h4 id="布隆过滤器-bloom-filter"><a href="#布隆过滤器-bloom-filter" class="header-anchor">#</a> 布隆过滤器（bloom filter）</h4> <p>参考</p> <blockquote><ul><li>https://github.com/Snailclimb/JavaGuide/blob/master/docs/dataStructures-algorithms/data-structure/bloom-filter.md</li></ul></blockquote> <p>布隆过滤器是⼀个⾮常神奇的数据结构，通过它我们可以⾮常⽅便地判断⼀个给定数 据是否存在与海量数据中。我们需要的就是判断 <code>key</code> 是否合法，有没有感觉布隆过滤器就是我们想要 找的那个“⼈”。具体是这样做的：把<code>所有可能存在的请求的值</code>都存放在布隆过滤器中，当⽤户请求过来，我会先判断⽤户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信 息给客户端，存在的话才会⾛下⾯的流程。</p> <p><img src="https://cdn.jsdelivr.net/gh/lifealsoisgg/static-blog@gh-pages/assets/img/bloom-filter.a91abb59.jpg" alt="布隆过滤器"></p> <h3 id="_10-2-缓存击穿"><a href="#_10-2-缓存击穿" class="header-anchor">#</a> 10.2 缓存击穿</h3> <p>参考</p> <blockquote><ul><li>https://www.cnblogs.com/chengege/p/11073166.html</li></ul></blockquote> <p>key可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。这个时候，需要考虑一个问题：缓存被“击穿”的问题。</p> <h4 id="互斥锁-mutex-key"><a href="#互斥锁-mutex-key" class="header-anchor">#</a> 互斥锁(mutex key)</h4> <p>业界比较常用的做法，是使用<code>mutex</code>。简单地来说，就是在缓存失效的时候（判断拿出来的值为空），不是立即去<code>load db</code>，而是先使用缓存工具的某些带成功操作返回值的操作（比如<code>Redis</code>的<code>SETNX</code>或者<code>Memcache</code>的<code>ADD</code>）去<code>set</code>一个<code>mutex key</code>，当操作返回成功时，再进行<code>load db</code>的操作并<code>回设缓存</code>；否则，就重试整个<code>get</code>缓存的方法。就是只让一个线程构建<code>缓存</code>，其他线程等待构建缓存的线程执行完，重新从缓存获取数据就可以了。</p> <p><img src="https://cdn.jsdelivr.net/gh/lifealsoisgg/static-blog@gh-pages/assets/img/Cache-breakdown_mutex_key.776ddda4.png" alt="缓存击穿-互斥锁mutex-key"></p> <h3 id="_10-3-缓存雪崩"><a href="#_10-3-缓存雪崩" class="header-anchor">#</a> 10.3 缓存雪崩</h3> <p>简介：缓存同⼀时间⼤⾯积的失效，所以，后⾯的请求都会落到数据库上，造成数据库短时间内承受⼤ 量请求⽽崩掉。</p> <blockquote><ul><li>事前：尽量保证整个 redis 集群的⾼可⽤性，发现机器宕机尽快补上。选择合适的内存淘汰策 略。</li> <li>事中：本地ehcache缓存 + hystrix限流&amp;降级，避免MySQL崩掉</li> <li>事后：利⽤ redis 持久化机制保存的数据尽快恢复缓存</li></ul></blockquote> <blockquote><ul><li>设置key永不失效（热点数据）；</li> <li>设置key缓存失效时候尽可能错开；</li> <li>使用多级缓存机制，比如同时使用redsi和memcache缓存，请求-&gt;redis-&gt;memcache-&gt;db；</li> <li>购买第三方可靠性高的Redis云服务器；</li></ul></blockquote> <p><img src="https://cdn.jsdelivr.net/gh/lifealsoisgg/static-blog@gh-pages/assets/img/Cache_avalanche_solution.4d09026c.jpg" alt="缓存雪崩解决方案"></p> <h2 id="_11-如何解决-redis-的并发竞争-key-问题"><a href="#_11-如何解决-redis-的并发竞争-key-问题" class="header-anchor">#</a> 11. 如何解决 Redis 的并发竞争 Key 问题</h2> <p>参考</p> <blockquote><ul><li>https://www.jianshu.com/p/41d3a673425d</li> <li>https://blog.csdn.net/qq_42253147/article/details/94446727</li></ul></blockquote> <p>这里的并发指的是多个redis的client同时set key引起的并发问题，也就是多个系统同时对⼀个 key 进⾏操作，但是最后执⾏的顺序 和我们期望的顺序不同，这样也就导致了结果的不同！</p> <p>方案</p> <blockquote><ul><li><strong>分布式锁+时间戳</strong></li> <li><strong>消息队列MQ</strong></li></ul></blockquote> <h3 id="_11-1-分布式锁-时间戳"><a href="#_11-1-分布式锁-时间戳" class="header-anchor">#</a> 11.1 分布式锁+时间戳</h3> <h4 id="如果对这个key操作-不要求顺序"><a href="#如果对这个key操作-不要求顺序" class="header-anchor">#</a> 如果对这个key操作，不要求顺序</h4> <p>这种情况下，准备一个分布式锁，大家去抢锁，抢到锁就做<code>set</code>操作即可，比较简单。加锁的目的实际上就是把<code>并行读写</code>改成<code>串行读写</code>的方式，从而来避免资源竞争。</p> <h4 id="如果对这个key操作-要求顺序"><a href="#如果对这个key操作-要求顺序" class="header-anchor">#</a> 如果对这个key操作，要求顺序</h4> <p>假设有一个<code>key1</code></p> <blockquote><ul><li>系统A需要将key1设置为valueA</li> <li>系统B需要将key1设置为valueB</li> <li>系统C需要将key1设置为valueC</li></ul></blockquote> <p>期望按照key1的value值按照 <code>valueA–&gt;valueB–&gt;valueC</code>的顺序变化。这种时候我们在数据写入数据库的时候，需要保存一个<code>时间戳</code>。假设<code>时间戳</code>如下</p> <blockquote><ul><li>系统A key 1 {valueA 3:00}</li> <li>系统B key 1 {valueB 3:05}</li> <li>系统C key 1 {valueC 3:10}</li></ul></blockquote> <p>那么，假设这会<code>系统B</code>先抢到锁，将<code>key1</code>设置为<code>{valueB 3:05}</code>。接下来系统A抢到锁，发现自己的valueA的时间戳早于缓存中的时间戳，那就不做<code>set</code>操作了。以此类推</p> <h4 id="什么是分布式锁"><a href="#什么是分布式锁" class="header-anchor">#</a> 什么是分布式锁</h4> <p>因为传统的加锁的做法（如java的synchronized和Lock）这里没用，只适合单点。因为这是分布式环境，需要的是分布式锁。</p> <p>当然，分布式锁可以基于很多种方式实现，比如zookeeper、redis等，</p> <p>不管哪种方式实现，基本原理是不变的：<strong>用一个状态值表示锁，对锁的占用和释放通过状态值来标识</strong>。</p> <h4 id="分布式锁的实现"><a href="#分布式锁的实现" class="header-anchor">#</a> 分布式锁的实现</h4> <p>主要用到的redis函数是<code>setnx()</code></p> <p>利用<code>SETNX</code>非常简单地实现<code>分布式锁</code>。例如：某客户端要获得一个名字<code>youzhi</code>的锁，客户端使用下面的命令进行获取：</p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code>SETNX lock.youzhi<span class="token operator">&lt;</span>current Unix <span class="token function">time</span> + lock <span class="token function">timeout</span> + <span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><blockquote><ul><li>如返回1，则该客户端获得锁，把<code>lock.youzhi</code>的键值设置为时间值表示该键已被锁定，该客户端最后可以通过<code>DEL lock.foo</code>来释放该锁。</li> <li>如返回0，表明该锁已被其他客户端取得，这时我们可以先返回或进行重试等对方完成或等待锁超时。</li></ul></blockquote> <h3 id="_11-2-消息队列"><a href="#_11-2-消息队列" class="header-anchor">#</a> 11.2 消息队列</h3> <p>在并发量过大的情况下,可以通过<code>消息中间件</code>进行处理,把<code>并行读写</code>进行<code>串行化</code>。</p> <p>把<code>Redis.set</code>操作放在队列中使其串行化,必须的一个一个执行。</p> <p>这种方式在一些高并发的场景中算是一种通用的解决方案。</p> <h2 id="_12-区别"><a href="#_12-区别" class="header-anchor">#</a> 12. 区别</h2> <h3 id="_12-1-redis-和-memcached-的区别"><a href="#_12-1-redis-和-memcached-的区别" class="header-anchor">#</a> 12.1 redis 和 memcached 的区别</h3> <blockquote><ol><li><strong>redis⽀持更丰富的数据类型（⽀持更复杂的应⽤场景）</strong>：Redis不仅仅⽀持简单的k/v类型的数 据，同时还提供list，set，zset，hash等数据结构的存储。memcache⽀持简单的数据类型， String。</li> <li><strong>Redis⽀持数据的持久化</strong>：可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进⾏使 ⽤,⽽Memecache把数据全部存在内存之中。</li> <li><strong>集群模式</strong>：memcached没有原⽣的集群模式，需要依靠客户端来实现往集群中分⽚写⼊数据；但 是 redis ⽬前是原⽣⽀持 cluster 模式的.</li> <li>Memcached是多线程，⾮阻塞IO复⽤的⽹络模型；Redis使⽤单线程的多路 IO 复⽤模型。</li></ol></blockquote> <p><img src="https://cdn.jsdelivr.net/gh/lifealsoisgg/static-blog@gh-pages/assets/img/difference_between_redis_and_memcached.f0d3d208.jpg" alt=""></p></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/LifeAlsoIsGG/edit/master/database/redis/Redis_theory_note.md" target="_blank" rel="noopener noreferrer">在 GitHub 上编辑此页</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <div class="last-updated"><span class="prefix">上次编辑于:</span> <span class="time">2020年12月4日 08:10</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev"><a href="/static-blog/database/Mysql/SQL_note/" class="prev"><svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" class="icon prev-icon"><path d="M906.783 588.79c-.02 8.499-6.882 15.36-15.38 15.37l-443.7-.01 75.704 191.682c2.52 6.42.482 13.763-5.038 17.91-5.52 4.168-13.138 4.147-18.616-.092L123.228 524.175a15.362 15.362 0 01-6-12.165c0-4.782 2.222-9.277 6-12.185L499.753 210.35a15.388 15.388 0 019.38-3.195c3.236 0 6.502 1.034 9.236 3.103 5.52 4.147 7.578 11.49 5.038 17.91L447.683 419.84l443.72-.01c8.498.01 15.36 6.881 15.36 15.36l.02 153.6z" fill="currentColor"></path></svg>
        SQL学习笔记
      </a></span> <span class="next"><a href="/static-blog/database/redis/Redis_deployment&amp;use/">
        Redis部署与基本使用
        <svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" class="icon next-icon"><path d="M906.772 512c0 4.772-2.211 9.267-5.99 12.175L524.257 813.66a15.37 15.37 0 01-18.616.092 15.368 15.368 0 01-5.038-17.91l75.714-191.672h-443.73c-8.488 0-15.36-6.881-15.36-15.36v-153.6c0-8.489 6.872-15.36 15.36-15.36h443.73l-75.714-191.682a15.358 15.358 0 015.048-17.91c5.51-4.158 13.128-4.137 18.606.092l376.525 289.485a15.323 15.323 0 015.99 12.165z" fill="currentColor"></path></svg></a></span></p></div> <div class="comments-wrapper"><div class="valine-wrapper"><div id="valine"></div></div></div> </main> <footer class="footer-wrapper"><div class="media-links-wrapper"><a href="https://github.com/LifeAlsoIsGG" rel="noopener noreferrer" target="_blank" aria-label="Github" data-balloon-pos="up" class="media-link"><span class="sr-only">Github</span> <svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" class="icon icon-github"><path d="M544.06 959.267h-64.95c-228.633 0-415.697-187.064-415.697-415.698V478.62c0-228.633 187.064-415.697 415.698-415.697h64.949c228.633 0 415.697 187.064 415.697 415.697v64.95c0 228.633-187.065 415.697-415.697 415.697z" fill="#171515"></path> <path d="M510.25 263.81c-136.001 0-246.287 110.273-246.287 246.317 0 108.81 70.566 201.128 168.45 233.701 12.315 2.259 16.81-5.345 16.81-11.872 0-5.847-.212-21.337-.332-41.891-68.514 14.884-82.97-33.017-82.97-33.017-11.199-28.454-27.347-36.029-27.347-36.029-22.362-15.282 1.692-14.972 1.692-14.972 24.717 1.742 37.727 25.382 37.727 25.382 21.971 37.64 57.646 26.77 71.681 20.465 2.238-15.917 8.6-26.77 15.638-32.927-54.693-6.216-112.191-27.347-112.191-121.73 0-26.889 9.597-48.876 25.352-66.093-2.533-6.232-10.985-31.274 2.414-65.184 0 0 20.68-6.622 67.731 25.25 19.647-5.464 40.716-8.196 61.663-8.291 20.916.095 41.987 2.828 61.662 8.29 47.023-31.872 67.665-25.249 67.665-25.249 13.437 33.91 4.983 58.952 2.451 65.184 15.785 17.217 25.318 39.203 25.318 66.093 0 94.62-57.588 115.44-112.458 121.538 8.845 7.604 16.721 22.637 16.721 45.612 0 32.927-.302 59.493-.302 67.568 0 6.587 4.437 14.25 16.936 11.843 97.788-32.634 168.295-124.89 168.295-233.672 0-136.043-110.287-246.316-246.319-246.316z" fill="#FFF"></path></svg></a><a href="https://twitter.com/LifeAlsoIsGG" rel="noopener noreferrer" target="_blank" aria-label="Twitter" data-balloon-pos="up" class="media-link"><span class="sr-only">Twitter</span> <svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" class="icon icon-twitter"><path d="M544.06 959.267h-64.95c-228.633 0-415.697-187.064-415.697-415.698V478.62c0-228.633 187.064-415.697 415.698-415.697h64.949c228.633 0 415.697 187.064 415.697 415.697v64.95c0 228.633-187.065 415.697-415.697 415.697z" fill="#5EAADE"></path> <path d="M749.737 364.631c-17.594 7.805-36.513 13.088-56.371 15.459 20.269-12.148 35.836-31.387 43.156-54.312A196.233 196.233 0 01674.2 349.6c-17.894-19.083-43.406-30.997-71.636-30.997-54.2 0-98.137 43.944-98.137 98.157 0 7.695.861 15.19 2.544 22.373-81.57-4.092-153.876-43.174-202.284-102.558-8.443 14.498-13.285 31.356-13.285 49.348 0 34.05 17.326 64.096 43.656 81.697a97.69 97.69 0 01-44.447-12.277c-.01.41-.01.82-.01 1.24 0 47.558 33.822 87.23 78.72 96.249a98.285 98.285 0 01-25.852 3.448 97.491 97.491 0 01-18.465-1.768c12.483 39.002 48.725 67.38 91.672 68.17-33.582 26.334-75.897 42.024-121.884 42.024-7.924 0-15.736-.46-23.408-1.37 43.434 27.844 95.014 44.104 150.443 44.104 180.505 0 279.221-149.576 279.221-279.294 0-4.263-.09-8.494-.278-12.708 19.178-13.835 35.813-31.115 48.967-50.807z" fill="#FFF"></path></svg></a><a href="http://localhost:8083/blog-vuepress/tencent:/AddContact/?fromId=50&amp;fromSubId=1&amp;subcmd=all&amp;uin=1138312802.html" rel="noopener noreferrer" target="_blank" aria-label="QQ" data-balloon-pos="up" class="media-link"><span class="sr-only">QQ</span> <svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" class="icon icon-qq"><path d="M544.06 959.267h-64.95c-228.633 0-415.697-187.064-415.697-415.698V478.62c0-228.633 187.064-415.697 415.698-415.697h64.949c228.633 0 415.697 187.064 415.697 415.697v64.95c0 228.633-187.065 415.697-415.697 415.697z" fill="#5EAADE"></path> <path d="M729.46 627.3c-3.157-39.628-24.045-83.747-32.624-105.91l-22.084-57.047c-.702-23.73 6.312-78.322-30.511-146.61s-110.82-74.446-124.497-75.147c-13.677-.701-99.248-1.403-141.331 72.945-42.084 74.347-30.745 148.812-30.745 148.812l-23.523 57.478c-.001.002-10.962 26.223-20.43 58.135-9.469 31.914-18.938 82.064-9.469 92.234 9.47 10.17 43.837-46.643 46.993-51.903 0 0 2.456 27.18 8.943 41.383l.81 1.776.33.723.38.826.3.652.444.96.203.436a281.465 281.465 0 001.917 4.025l.189.386c.231.473.468.953.711 1.442l.146.292c6.886 13.807 18.61 33.823 37.443 50.42l.018.016-1.184.387c-10.667 3.516-31.694 11.21-40.625 19.82-1.717 1.655-2.987 3.344-3.65 5.045-5.376 13.794 4.208 15.43 20.575 16.366 16.366.934 94.923 3.04 132.564-2.221.407-.056.787-.114 1.17-.171 2.711.094 5.324.142 7.83.16l.151.002c.836.005 1.663.008 2.475.008.496 0 1.015-.002 1.542-.006l.21-.001a222.593 222.593 0 005.462-.107c.26.038.508.076.778.114 37.642 5.26 116.198 3.156 132.564 2.22 16.366-.934 25.951-2.571 20.574-16.365-4.302-11.037-34.175-21.62-45.956-25.413a141.388 141.388 0 007.958-7.645l.237-.245a142.494 142.494 0 002.53-2.702c42.435-46.643 38.928-76.101 40.682-92.935 0 0 35.775 51.553 43.488 53.306 7.713 1.754 10.169-6.31 7.012-45.94z" fill="#FFF"></path></svg></a></div> <div class="footer">粤ICP备19126168号</div> <div class="copyright">Copyright © 2020 LifeAlsoIsGG</div></footer></div><div class="global-ui"><!----><!----><div id="pwa-install"><!----> <div id="install-modal-wrapper" style="display:none;"><div class="background"></div> <div class="install-modal"><div class="header"><button aria-label="Close" class="close-button"><svg width="23" height="22" xmlns="http://www.w3.org/2000/svg" class="icon close-icon"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.12.358a1.224 1.224 0 011.729 0l8.92 8.914L20.686.358a1.224 1.224 0 011.73 1.728L13.497 11l8.92 8.913a1.222 1.222 0 11-1.73 1.729l-8.919-8.913-8.92 8.913a1.224 1.224 0 01-1.729-1.729L10.04 11l-8.92-8.914a1.222 1.222 0 010-1.728z" fill="currentColor"></path></svg></button> <div class="logo"><!----> <div class="title"><h1></h1> <p class="desc">该应用可以安装在您的 PC 或移动设备上。这将使该 Web 应用程序外观和行为与其他应用程序相同。它将在出现在应用程序列表中，并可以固定到主屏幕，开始菜单或任务栏。此 Web 应用程序还将能够与其他应用程序和您的操作系统安全地进行交互。</p></div></div></div> <div class="content"><div class="highlight"><!----> <!----></div> <div class="description"><h3>详情</h3> <p></p></div></div> <div class="button-wrapper"><button class="install-button">
        安装 <span></span></button> <button class="cancel-button">
        取消
      </button></div></div></div></div><div tabindex="-1" role="dialog" aria-hidden="true" class="pswp"><div class="pswp__bg"></div> <div class="pswp__scroll-wrap"><div class="pswp__container"><div class="pswp__item"></div> <div class="pswp__item"></div> <div class="pswp__item"></div></div> <div class="pswp__ui pswp__ui--hidden"><div class="pswp__top-bar"><div class="pswp__counter"></div> <button title="Close (Esc)" class="pswp__button pswp__button--close"></button> <button title="Share" class="pswp__button pswp__button--share"></button> <button title="Toggle fullscreen" class="pswp__button pswp__button--fs"></button> <button title="Zoom in/out" class="pswp__button pswp__button--zoom"></button> <div class="pswp__preloader"><div class="pswp__preloader__icn"><div class="pswp__preloader__cut"><div class="pswp__preloader__donut"></div></div></div></div></div> <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class="pswp__share-tooltip"></div></div> <button title="Previous (arrow left)" class="pswp__button pswp__button--arrow--left"></button> <button title="Next (arrow right)" class="pswp__button pswp__button--arrow--right"></button> <div class="pswp__caption"><div class="pswp__caption__center"></div></div></div></div></div></div></div>
    <script src="https://cdn.jsdelivr.net/gh/lifealsoisgg/static-blog@gh-pages/assets/js/app.589166b9.js" defer></script><script src="https://cdn.jsdelivr.net/gh/lifealsoisgg/static-blog@gh-pages/assets/js/layout-Layout.db99e56e.js" defer></script><script src="https://cdn.jsdelivr.net/gh/lifealsoisgg/static-blog@gh-pages/assets/js/vendors~layout-Blog~layout-Layout~layout-NotFound.e9b6f9a1.js" defer></script><script src="https://cdn.jsdelivr.net/gh/lifealsoisgg/static-blog@gh-pages/assets/js/vendors~layout-Blog~layout-Layout~layout-NotFound~layout-Slide.8e109616.js" defer></script><script src="https://cdn.jsdelivr.net/gh/lifealsoisgg/static-blog@gh-pages/assets/js/vendors~layout-Blog~layout-Layout.2f613263.js" defer></script><script src="https://cdn.jsdelivr.net/gh/lifealsoisgg/static-blog@gh-pages/assets/js/page-Redis理论学习笔记--1a52f412.8ecda962.js" defer></script>
  </body>
</html>
